<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能彩票分析选号系统</title>

    <!-- 引入SheetJS库用于Excel文件解析 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ECharts 图表库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <!-- Font Awesome 图标库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ==================== 全局样式 ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f8f8f8; /* 浅灰背景 */
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* 颜色变量定义 - 默认为双色球主题 */
        :root {
            /* 双色球专属主题 */
            --ssq-primary: #E63946;     /* 鲜艳红 */
            --ssq-secondary: #457B9D;  /* 沉稳蓝 */
            --ssq-bg: #F8F9FA;         /* 浅灰底 */
            --ssq-text: #212529;       /* 深黑文本 */
            --ssq-border: #DEE2E6;     /* 浅灰边框 */
            --ssq-secondary-text: #6C757D; /* 中灰文本 */
            --ssq-highlight: #FFF5F5;  /* 浅红高亮 */

            /* 大乐透专属主题 */
            --dlt-primary: #2A9D8F;    /* 青绿色 */
            --dlt-secondary: #F4A261;  /* 温暖橙 */
            --dlt-bg: #FAFAFA;         /* 米白底 */
            --dlt-text: #2D3436;       /* 深灰文本 */
            --dlt-border: #E2E8F0;     /* 淡蓝边框 */
            --dlt-secondary-text: #718096; /* 浅灰文本 */
            --dlt-highlight: #E0F2F1;  /* 浅青高亮 */

            /* 数据可视化主题 - 光明模式 */
            --viz-light-primary: #3B82F6;     /* 亮蓝 */
            --viz-light-ssq: #EC4899;        /* 玫瑰红 */
            --viz-light-dlt: #10B981;        /* 深绿 */
            --viz-light-bg: #FFFFFF;          /* 纯白 */
            --viz-light-card-bg: #F8FAFC;     /* 浅蓝灰 */
            --viz-light-text: #1E293B;       /* 深灰蓝 */
            --viz-light-secondary-text: #64748B; /* 中灰 */
            --viz-light-border: #E2E8F0;      /* 淡灰 */
            --viz-light-highlight: #EFF6FF;    /* 浅蓝高亮 */

            /* 数据可视化主题 - 暗黑模式 */
            --viz-dark-primary: #60A5FA;      /* 浅蓝 */
            --viz-dark-ssq: #F472B6;         /* 粉紫 */
            --viz-dark-dlt: #34D399;         /* 浅绿 */
            --viz-dark-bg: #1A202C;          /* 深灰 */
            --viz-dark-card-bg: #2D3748;      /* 中深灰 */
            --viz-dark-text: #F7FAFC;         /* 浅灰 */
            --viz-dark-secondary-text: #A0AEC0; /* 中灰 */
            --viz-dark-border: #4A5568;       /* 深灰边框 */
            --viz-dark-highlight: #2C5282;    /* 深蓝高亮 */

            /* 简约商务主题 */
            --biz-ssq: #4A6FA5;           /* 深蓝紫 */
            --biz-dlt: #5A9E6F;           /* 深绿 */
            --biz-accent1: #9FB3C8;       /* 浅灰蓝 */
            --biz-accent2: #D7C4BB;       /* 浅棕 */
            --biz-bg: #FAFAFA;            /* 米白 */
            --biz-card-bg: #F5F5F5;       /* 浅灰 */
            --biz-text: #333333;          /* 深灰 */
            --biz-secondary-text: #666666; /* 中灰 */
            --biz-border: #DDDDDD;        /* 淡灰 */
            --biz-highlight: #E8F0FE;      /* 浅蓝高亮 */

            /* 现代科技主题 */
            --tech-ssq-start: #FFE5E7;    /* 浅红 */
            --tech-ssq-end: #C70039;      /* 深红 */
            --tech-dlt-start: #E0F7F5;    /* 浅青 */
            --tech-dlt-end: #023E8A;      /* 深蓝青 */
            --tech-primary: #00B4D8;      /* 亮蓝 */
            --tech-accent: #9B5DE5;       /* 浅紫 */
            --tech-bg: #F5F7FA;           /* 浅灰蓝 */
            --tech-text: #1D2939;         /* 深灰蓝 */
            --tech-secondary-text: #667085; /* 中灰 */
            --tech-border: #D1D5DB;       /* 淡蓝灰 */
            --tech-highlight: #FFFFFF;     /* 亮白 */

            /* 无障碍友好主题 */
            --access-ssq: #FF7700;         /* 橙色 */
            --access-ssq-accent: #0077FF;  /* 蓝色 */
            --access-dlt: #00BBBB;         /* 青色 */
            --access-dlt-accent: #AA6600;  /* 棕色 */
            --access-bg: #F8F8F8;         /* 浅灰 */
            --access-card-bg: #FFFFFF;     /* 纯白 */
            --access-text: #222222;       /* 深灰 */
            --access-secondary-text: #666666; /* 中灰 */
            --access-border: #BBBBBB;      /* 中灰边框 */
            --access-highlight: #FFF8E0;   /* 淡黄 */

            /* 通用暗黑护眼主题 */
            --dark-ssq: #FF6B6B;           /* 柔红 */
            --dark-dlt: #4ECDC4;           /* 柔青 */
            --dark-dlt-secondary: #FFE066; /* 柔黄 */
            --dark-bg: #121212;           /* 深黑灰 */
            --dark-card-bg: #1E1E1E;      /* 中黑灰 */
            --dark-text: #E0E0E0;         /* 浅灰 */
            --dark-secondary-text: #A0A0A0; /* 中灰 */
            --dark-border: #333333;       /* 深灰边框 */
            --dark-highlight: #2D3748;    /* 深蓝灰 */

            /* 当前主题颜色 - 默认使用双色球主题 */
            --primary-color: var(--ssq-primary);
            --secondary-color: var(--ssq-secondary);
            --bg-color: var(--ssq-bg);
            --bg-card: #ffffff;
            --bg-sidebar: #2c3e50;
            --bg-header: #34495e;
            --text-primary: var(--ssq-text);
            --text-secondary: var(--ssq-secondary-text);
            --text-white: #ffffff;
            --border-color: var(--ssq-border);
            --highlight-color: var(--ssq-highlight);

            /* 功能色 */
            --success: #10B981;
            --warning: #F59E0B;
            --danger: #EF4444;
            --info: #3B82F6;

            /* 热号、温号、冷号颜色 */
            --hot-number: #FF6B6B;    /* 热号 - 红色 */
            --warm-number: #FFE66D;   /* 温号 - 黄色 */
            --cold-number: #6BCB77;   /* 冷号 - 绿色 */
        }

        /* 暗黑模式主题 */
        .theme-dark:root {
            --primary-color: var(--viz-dark-primary);
            --secondary-color: var(--viz-dark-ssq);
            --bg-color: var(--viz-dark-bg);
            --bg-card: var(--viz-dark-card-bg);
            --bg-sidebar: #2d3748;
            --bg-header: #2d3748;
            --text-primary: var(--viz-dark-text);
            --text-secondary: var(--viz-dark-secondary-text);
            --border-color: var(--viz-dark-border);
            --highlight-color: var(--viz-dark-highlight);
        }

        /* 数据可视化主题 */
        .theme-viz-light:root {
            --primary-color: var(--viz-light-primary);
            --secondary-color: var(--viz-light-ssq);
            --bg-color: var(--viz-light-bg);
            --bg-card: var(--viz-light-card-bg);
            --text-primary: var(--viz-light-text);
            --text-secondary: var(--viz-light-secondary-text);
            --border-color: var(--viz-light-border);
            --highlight-color: var(--viz-light-highlight);
        }

        .theme-viz-dark:root {
            --primary-color: var(--viz-dark-primary);
            --secondary-color: var(--viz-dark-ssq);
            --bg-color: var(--viz-dark-bg);
            --bg-card: var(--viz-dark-card-bg);
            --text-primary: var(--viz-dark-text);
            --text-secondary: var(--viz-dark-secondary-text);
            --border-color: var(--viz-dark-border);
            --highlight-color: var(--viz-dark-highlight);
        }

        /* 简约商务主题 */
        .theme-business:root {
            --primary-color: var(--biz-ssq);
            --secondary-color: var(--biz-accent1);
            --bg-color: var(--biz-bg);
            --bg-card: var(--biz-card-bg);
            --text-primary: var(--biz-text);
            --text-secondary: var(--biz-secondary-text);
            --border-color: var(--biz-border);
            --highlight-color: var(--biz-highlight);
        }

        /* 现代科技主题 */
        .theme-tech:root {
            --primary-color: var(--tech-primary);
            --secondary-color: var(--tech-ssq-end);
            --bg-color: var(--tech-bg);
            --bg-card: linear-gradient(to bottom right, var(--tech-ssq-start), var(--tech-dlt-start));
            --text-primary: var(--tech-text);
            --text-secondary: var(--tech-secondary-text);
            --border-color: var(--tech-border);
            --highlight-color: var(--tech-highlight);
        }

        /* 无障碍友好主题 */
        .theme-accessible:root {
            --primary-color: var(--access-ssq);
            --secondary-color: var(--access-ssq-accent);
            --bg-color: var(--access-bg);
            --bg-card: var(--access-card-bg);
            --text-primary: var(--access-text);
            --text-secondary: var(--access-secondary-text);
            --border-color: var(--access-border);
            --highlight-color: var(--access-highlight);
        }

        /* 通用暗黑护眼主题 */
        .theme-dark-comfort:root {
            --primary-color: var(--dark-ssq);
            --secondary-color: var(--dark-dlt);
            --bg-color: var(--dark-bg);
            --bg-card: var(--dark-card-bg);
            --text-primary: var(--dark-text);
            --text-secondary: var(--dark-secondary-text);
            --border-color: var(--dark-border);
            --highlight-color: var(--dark-highlight);
        }

        /* ==================== 顶部导航栏 ==================== */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--bg-header);
            color: var(--text-white);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .logo {
            display: flex;
            align-items: center;
            margin-right: 30px;
        }

        .logo-icon {
            font-size: 24px;
            margin-right: 10px;
            color: var(--ssq-orange);
        }

        .logo-text {
            font-size: 18px;
            font-weight: bold;
        }

        .top-menu {
            display: flex;
            flex: 1;
            overflow-x: auto;
            justify-content: space-between;
            align-items: center;
        }

        .menu-left {
            display: flex;
            align-items: center;
        }

        .menu-right {
            display: flex;
            align-items: center;
        }

        .menu-item {
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 3px;
            transition: all 0.3s ease;
            font-size: 14px;
            white-space: nowrap;
        }

        .menu-right .menu-item {
            margin-right: 0;
            margin-left: 3px;
        }

        .menu-item.active {
            background: var(--primary-color);
        }

        .menu-item:hover {
            background: color-mix(in srgb, var(--primary-color) 20%, transparent 80%);
        }

        /* 彩票类型选择器 */
        .lottery-type-selector {
            margin-right: 20px;
        }

        .lottery-type-selector select {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            cursor: pointer;
            min-width: 120px;
        }

        .lottery-type-selector select:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .lottery-type-selector select:focus {
            outline: none;
            border-color: var(--primary-color);
            background: rgba(255, 255, 255, 0.2);
        }

        .lottery-type-selector select option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        /* 响应式菜单项 */
        @media (max-width: 1200px) {
            .menu-item {
                padding: 10px 8px;
                font-size: 13px;
            }
        }

        @media (max-width: 992px) {
            .menu-item {
                padding: 8px 6px;
                font-size: 12px;
            }
        }

        /* ==================== 主内容区域 ==================== */
        .main-container {
            display: flex;
            margin-top: 60px; /* 为固定头部留出空间 */
            min-height: calc(100vh - 60px);
        }

        /* ==================== 侧边栏 ==================== */
        .sidebar {
            width: 240px;
            background: var(--bg-sidebar);
            color: var(--text-white);
            height: calc(100vh - 60px);
            position: fixed;
            overflow-y: auto;
            padding: 20px 0;
            transition: all 0.3s ease;
            z-index: 999;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-title {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            color: #bdc3c7;
            text-transform: uppercase;
            border-left: 3px solid var(--primary-color);
            background: rgba(0, 0, 0, 0.2);
        }

        .sidebar-menu {
            list-style: none;
            padding: 5px 0;
        }

        .sidebar-menu li {
            padding: 12px 20px 12px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sidebar-menu li i {
            width: 20px;
            text-align: center;
        }

        .sidebar-menu li:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: var(--secondary-color);
        }

        .sidebar-menu li.active {
            background: var(--primary-color);
            border-left-color: var(--secondary-color);
        }

        /* ==================== 面包屑导航 ==================== */
        .breadcrumb {
            padding: 15px 20px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border-radius: 6px 6px 0 0;
            margin-bottom: 20px;
        }

        .breadcrumb-item {
            display: inline-block;
            font-size: 14px;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .breadcrumb-item:not(:last-child)::after {
            content: " / ";
            margin: 0 8px;
            color: #ccc;
        }

        .breadcrumb-item:hover {
            color: var(--primary-color);
        }

        .breadcrumb-item.active {
            color: var(--primary-color);
            font-weight: bold;
        }

        .breadcrumb-item a {
            color: inherit;
            text-decoration: none;
        }

        .breadcrumb-item a:hover {
            color: var(--ssq-orange);
        }

        /* ==================== 主内容区 ==================== */
        .content-area {
            flex: 1;
            margin-left: 240px; /* 为侧边栏留出空间 */
            padding: 20px;
            background: var(--bg-color);
        }

        .content-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .content-title {
            font-size: 20px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .content-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .condition-select-container {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            padding: 10px;
            background: var(--highlight-color);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .condition-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .condition-item label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .condition-item input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }

        .condition-item input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(64, 158, 255, 0.1);
        }

        .condition-item select {
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .condition-item select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(64, 158, 255, 0.1);
        }

        .feature-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            width: 180px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .feature-card h4 {
            margin: 10px 0 5px 0;
            color: #333;
            font-size: 16px;
        }

        .feature-card p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--primary-color);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-primary:hover {
            background: color-mix(in srgb, var(--primary-color) 80%, black 20%);
        }

        .btn-secondary {
            background: var(--secondary-color);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-secondary:hover {
            background: color-mix(in srgb, var(--secondary-color) 80%, black 20%);
        }

        .btn-success {
            background: var(--success);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-warning {
            background: var(--warning);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-warning:hover {
            background: #d35400;
        }

        .btn-info {
            background: #17a2b8;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-info:hover {
            background: #138496;
        }

        .btn-danger {
            background: var(--danger);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .chart-container {
            height: 400px;
            margin: 20px 0;
        }

        .number-display {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .number-item {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            background: var(--primary-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .number-item.blue {
            background: var(--secondary-color);
        }

        .status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .status.hot {
            background: color-mix(in srgb, var(--primary-color) 15%, transparent 85%);
            color: color-mix(in srgb, var(--primary-color) 80%, black 20%);
        }

        .status.warm {
            background: color-mix(in srgb, var(--secondary-color) 15%, transparent 85%);
            color: color-mix(in srgb, var(--secondary-color) 80%, black 20%);
        }

        .status.cold {
            background: color-mix(in srgb, var(--text-secondary) 15%, transparent 85%);
            color: var(--text-secondary);
        }

        /* ==================== 选项卡样式 ==================== */
        .lottery-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .lottery-tab {
            padding: 12px 30px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .lottery-tab:hover {
            color: var(--primary-color);
            background: var(--highlight-color);
        }

        .lottery-tab.active {
            color: var(--primary-color);
            background: var(--highlight-color);
            border-bottom-color: var(--primary-color);
            font-weight: bold;
        }

        .lottery-tab-ssq.active {
            color: #E63946;
            border-bottom-color: #E63946;
        }

        .lottery-tab-dlt.active {
            color: #2A9D8F;
            border-bottom-color: #2A9D8F;
        }

        /* ==================== 频率分析标签页样式 ==================== */
        .frequency-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .frequency-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .frequency-tab:hover {
            color: var(--primary-color);
            background: var(--highlight-color);
        }

        .frequency-tab.active {
            font-weight: bold;
            border-bottom-color: var(--primary-color);
        }

        .frequency-tab[data-type="red"].active {
            color: #E63946;
            border-bottom-color: #E63946;
        }

        .frequency-tab[data-type="blue"].active {
            color: #457B9D;
            border-bottom-color: #457B9D;
        }

        /* ==================== 排序按钮样式 ==================== */
        .sort-btn {
            padding: 8px 20px;
            border: 2px solid var(--border-color);
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .sort-btn:hover {
            background: var(--highlight-color);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .sort-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: bold;
        }

        /* ==================== 遗漏分析样式 ==================== */
        .omission-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        .omission-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .omission-tab:hover {
            color: var(--primary-color);
            background: var(--highlight-color);
        }

        .omission-tab.active {
            font-weight: bold;
            border-bottom-color: var(--primary-color);
        }

        .omission-tab[data-type="red"].active {
            color: #E63946;
            border-bottom-color: #E63946;
        }

        .omission-tab[data-type="blue"].active {
            color: #457B9D;
            border-bottom-color: #457B9D;
        }

        .omission-pattern-tab-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            border-radius: 4px;
            white-space: nowrap;
        }

        .omission-pattern-tab-btn:hover {
            color: var(--primary-color);
            background: var(--highlight-color);
            border-color: var(--primary-color);
        }

        .omission-pattern-tab-btn.active {
            font-weight: bold;
            color: white;
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .pattern-chart-section {
            background: rgba(42, 157, 143, 0.15);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(42, 157, 143, 0.4);
        }

        .pattern-insights-section {
            background: rgba(230, 57, 70, 0.12);
            border-radius: 8px;
            padding: 15px;
            border: 2px solid rgba(230, 57, 70, 0.4);
        }

        .pattern-insights-section h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-size: 16px;
            font-weight: 600;
        }

        .pattern-insights {
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.6;
        }

        .pattern-chart-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .pattern-chart-tab {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 4px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .pattern-chart-tab:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            border-color: #457B9D;
        }

        .pattern-chart-tab.active {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            border-color: #457B9D;
            color: white;
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.4);
        }

        .distribution-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .distribution-tab {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 4px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .distribution-tab:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            border-color: #457B9D;
        }

        .distribution-tab.active {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            border-color: #457B9D;
            color: white;
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.4);
        }

        .hotcold-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .hotcold-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .hotcold-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        .hotcold-tab.active {
            background: linear-gradient(135deg, #E63946, #D62828);
            border-color: #E63946;
            color: white;
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.4);
        }

        .hotcold-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .hotcold-tab-content.active {
            display: block;
        }

        .odd-even-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .odd-even-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .odd-even-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        .odd-even-tab.active {
            background: linear-gradient(135deg, #E63946, #D62828);
            border-color: #E63946;
            color: white;
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.4);
        }

        .odd-even-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .odd-even-tab-content.active {
            display: block;
        }

        .big-small-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .big-small-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .big-small-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        .big-small-tab.active {
            background: linear-gradient(135deg, #E63946, #D62828);
            border-color: #E63946;
            color: white;
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.4);
        }

        .big-small-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .big-small-tab-content.active {
            display: block;
        }

        .prime-composite-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .prime-composite-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .prime-composite-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        .prime-composite-tab.active {
            background: linear-gradient(135deg, #E63946, #D62828);
            border-color: #E63946;
            color: white;
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.4);
        }

        .prime-composite-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .prime-composite-tab-content.active {
            display: block;
        }

        .chart-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .chart-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-tab:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        .chart-tab:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 8px;
            pointer-events: none;
        }

        .chart-tab.active {
            background: linear-gradient(135deg, #FF7700, #FF5500);
            border-color: #FF7700;
            color: white;
            box-shadow: 0 4px 12px rgba(255, 119, 0, 0.4);
        }

        .chart-tab.active .tab-badge {
            background: rgba(255, 255, 255, 0.9);
            color: #FF7700;
        }

        .tab-badge {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(69, 123, 157, 0.1);
            color: #457B9D;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 4px;
        }

        .chart-tab-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            color: #2c3e50;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .chart-tab-btn:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        .chart-tab-btn.active {
            background: linear-gradient(135deg, #FF7700, #FF5500);
            border-color: #FF7700;
            color: white;
            box-shadow: 0 4px 12px rgba(255, 119, 0, 0.4);
        }

        .analysis-conclusion {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            border-left: 4px solid #FF7700;
        }

        .analysis-conclusion h3 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 16px;
        }

        .analysis-conclusion h3 i {
            margin-right: 8px;
            color: #FF7700;
        }

        .follow-up-section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .follow-up-section h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
        }

        .follow-up-section h3 i {
            margin-right: 10px;
            color: #E63946;
        }

        .table-responsive {
            overflow-x: auto;
            margin: 15px 0;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #000;
        }

        .table th {
            padding: 12px;
            text-align: center;
            font-weight: bold;
            border: 1px solid #ddd;
        }

        .table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }

        .table tbody tr:hover {
            background-color: #f5f5f5;
        }

        .table-striped tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .table-striped tbody tr:nth-child(even):hover {
            background-color: #f5f5f5;
        }

        .pairs-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .pair-tag {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(23, 162, 184, 0.2);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .analysis-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.1), rgba(29, 53, 87, 0.1));
            border-radius: 6px;
            flex-wrap: wrap;
        }

        .info-label {
            color: #2c3e50;
            font-weight: 500;
            font-size: 13px;
        }

        .info-value {
            color: #E63946;
            font-weight: 600;
            font-size: 14px;
        }

        .info-divider {
            color: #457B9D;
            margin: 0 4px;
        }

        .analysis-conclusions {
            margin-top: 20px;
            padding: 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(240, 240, 240, 0.9));
            border-radius: 8px;
            border: 1px solid rgba(69, 123, 157, 0.2);
        }

        .analysis-conclusions h4 {
            margin: 0 0 12px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }

        .conclusion-content {
            color: #2c3e50;
            font-size: 14px;
            line-height: 1.6;
        }

        .conclusion-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .conclusion-content li {
            margin: 6px 0;
        }

        .omission-table-container {
            margin: 20px 0;
            overflow-x: auto;
        }

        .omission-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .omission-table thead {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .omission-table th {
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .omission-table tbody tr {
            transition: background-color 0.2s ease;
        }

        .omission-table tbody tr:hover {
            background-color: var(--highlight-color);
        }

        .omission-table td {
            padding: 10px 8px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .omission-table .number-cell {
            display: inline-block;
            width: 32px;
            height: 32px;
            line-height: 32px;
            text-align: center;
            border-radius: 50%;
            font-weight: bold;
            color: white;
        }

        .omission-table .red-number {
            background: #E63946;
        }

        .omission-table .blue-number {
            background: #457B9D;
        }

        .status-table {
            margin-top: 20px;
            overflow-x: auto;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .table-bordered {
            border: 1px solid var(--border-color);
        }

        .table-bordered thead {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .table-bordered th {
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .table-bordered tbody tr {
            transition: background-color 0.2s ease;
        }

        .table-bordered tbody tr:hover {
            background-color: var(--highlight-color);
        }

        .table-bordered td {
            padding: 10px 8px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 12px;
            text-align: center;
            white-space: nowrap;
        }

        .badge-danger {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
        }

        .badge-warning {
            background: linear-gradient(135deg, #F4A261, #E76F51);
            color: white;
        }

        .badge-info {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            color: white;
        }

        .badge-success {
            background: linear-gradient(135deg, #2A9D8F, #264653);
            color: white;
        }

        .omission-prediction {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            color: white;
        }

        .omission-prediction h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
        }

        .omission-prediction .prediction-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .omission-prediction .prediction-item {
            flex: 1;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 6px;
        }

        .omission-prediction .prediction-item h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .omission-prediction .prediction-item .numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .omission-prediction .prediction-item .number {
            display: inline-block;
            width: 36px;
            height: 36px;
            line-height: 36px;
            text-align: center;
            background: white;
            border-radius: 50%;
            font-weight: bold;
            color: #667eea;
        }

        .omission-pattern-analysis {
            margin-top: 20px;
            padding: 20px;
            background: #FFFBF0;
            border-radius: 8px;
            color: #333;
        }

        .omission-pattern-analysis h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
        }

        .omission-pattern-analysis .pattern-analysis-content {
            display: flex;
            gap: 20px;
        }

        .omission-pattern-analysis .pattern-chart-container {
            width: 100%;
            height: 400px;
            background: transparent;
            padding: 0;
            border-radius: 0;
        }

        .omission-pattern-analysis .pattern-insights {
            width: 100%;
            background: transparent;
            padding: 0;
            border-radius: 0;
        }

        .omission-pattern-analysis .pattern-insights h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .omission-pattern-analysis .pattern-insights ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .omission-pattern-analysis .pattern-insights li {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .omission-pattern-analysis .pattern-insights li:last-child {
            border-bottom: none;
        }

        /* ==================== 质合分析概览视图优化 ==================== */
        .prime-composite-tab-content#prime-composite-overview {
            padding: 20px;
        }

        .prime-composite-tab-content#prime-composite-overview .analysis-info {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.08), rgba(69, 123, 157, 0.08));
            border: 1px solid rgba(230, 57, 70, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
            width: 100%;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px 12px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 249, 250, 0.95));
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .info-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #E63946, #457B9D);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .info-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .info-item:hover::before {
            transform: scaleX(1);
        }

        .info-item .info-label {
            font-size: 13px;
            color: #5a6c7d;
            margin-bottom: 8px;
            font-weight: 500;
            text-align: center;
        }

        .info-item .info-value {
            font-size: 22px;
            font-weight: 700;
            color: #E63946;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .info-item .info-value.highlight {
            color: #457B9D;
        }

        .info-item .info-value.success {
            color: #27ae60;
        }

        .info-item .info-value.warning {
            color: #f39c12;
        }

        .info-item .info-value.danger {
            color: #e74c3c;
        }

        .prime-composite-tab-content#prime-composite-overview .chart-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            position: relative;
        }

        .prime-composite-tab-content#prime-composite-overview .chart-container::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            height: 4px;
            background: linear-gradient(90deg, #E63946, #457B9D, #27ae60);
            border-radius: 12px 12px 0 0;
        }

        /* ==================== 质合分析趋势视图优化 ==================== */
        .prime-composite-tab-content#prime-composite-trend {
            padding: 20px;
        }

        .trend-analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.08), rgba(69, 123, 157, 0.08));
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .trend-analysis-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .trend-legend {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .legend-prime {
            background: linear-gradient(135deg, #E63946, #D62828);
        }

        .legend-composite {
            background: linear-gradient(135deg, #457B9D, #1D3557);
        }

        .prime-composite-tab-content#prime-composite-trend .chart-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .trend-insights {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 249, 250, 0.95));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .trend-insights h5 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        #trendInsightsContent {
            font-size: 14px;
            color: #5a6c7d;
            line-height: 1.6;
        }

        #trendInsightsContent .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(69, 123, 157, 0.05);
            border-radius: 8px;
            border-left: 3px solid #457B9D;
        }

        #trendInsightsContent .insight-item:last-child {
            margin-bottom: 0;
        }

        #trendInsightsContent .insight-icon {
            font-size: 16px;
            margin-top: 2px;
        }

        #trendInsightsContent .insight-text {
            flex: 1;
        }

        #trendInsightsContent .insight-text strong {
            color: #2c3e50;
            font-weight: 600;
        }

        /* ==================== 质合分析分布视图优化 ==================== */
        .prime-composite-tab-content#prime-composite-distribution {
            padding: 20px;
        }

        .distribution-analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.08), rgba(69, 123, 157, 0.08));
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .distribution-analysis-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .distribution-legend {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .distribution-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .distribution-legend .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .distribution-legend .legend-prime {
            background: linear-gradient(135deg, #E63946, #D62828);
        }

        .distribution-legend .legend-composite {
            background: linear-gradient(135deg, #457B9D, #1D3557);
        }

        .distribution-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .distribution-actions .btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .distribution-actions .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .distribution-actions .btn:active {
            transform: translateY(0);
        }

        .distribution-actions .btn-primary {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
        }

        .distribution-actions .btn-primary:hover {
            background: linear-gradient(135deg, #D62828, #C42720);
        }

        .distribution-actions .btn-icon {
            font-size: 16px;
        }

        .distribution-actions .btn-text {
            font-size: 14px;
        }

        .distribution-chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .distribution-chart-item.full-width {
            grid-column: 1 / -1;
        }

        .distribution-chart-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .distribution-chart-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #E63946, #457B9D);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .distribution-chart-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .distribution-chart-item:hover::before {
            transform: scaleX(1);
        }

        .chart-title {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        .chart-title h5 {
            margin: 0 0 6px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-title .chart-subtitle {
            font-size: 13px;
            color: #7f8c8d;
            font-weight: 400;
        }

        .prime-composite-tab-content#prime-composite-distribution .chart-container {
            background: transparent;
            border: none;
            padding: 0;
            margin: 0;
            box-shadow: none;
            border-radius: 0;
        }

        .distribution-insights {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 249, 250, 0.95));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .distribution-insights h5 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        #distributionInsightsContent {
            font-size: 14px;
            color: #5a6c7d;
            line-height: 1.6;
        }

        #distributionInsightsContent .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(69, 123, 157, 0.05);
            border-radius: 8px;
            border-left: 3px solid #457B9D;
        }

        #distributionInsightsContent .insight-item:last-child {
            margin-bottom: 0;
        }

        #distributionInsightsContent .insight-icon {
            font-size: 16px;
            margin-top: 2px;
        }

        #distributionInsightsContent .insight-text {
            flex: 1;
        }

        #distributionInsightsContent .insight-text strong {
            color: #2c3e50;
            font-weight: 600;
        }

        .distribution-conclusion {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.05), rgba(69, 123, 157, 0.05));
            border-radius: 12px;
            border: 1px solid rgba(230, 57, 70, 0.15);
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .distribution-conclusion h5 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(230, 57, 70, 0.1);
        }

        #primeCompositeConclusionContent {
            font-size: 14px;
            color: #5a6c7d;
            line-height: 1.6;
        }

        .conclusion-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .conclusion-title {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
            color: #E63946;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(230, 57, 70, 0.2);
        }

        .conclusion-block {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #457B9D;
        }

        .conclusion-block.highlight {
            border-left-color: #E63946;
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.08), rgba(255, 255, 255, 0.9));
        }

        .conclusion-subtitle {
            margin: 0 0 10px 0;
            font-size: 15px;
            font-weight: 600;
            color: #2c3e50;
        }

        .conclusion-text {
            font-size: 14px;
            color: #5a6c7d;
            line-height: 1.8;
        }

        .conclusion-text p {
            margin: 0 0 10px 0;
        }

        .conclusion-text p:last-child {
            margin-bottom: 0;
        }

        .conclusion-text strong {
            color: #E63946;
            font-weight: 600;
        }

        /* ==================== 质合分析状态视图优化 ==================== */
        .prime-composite-tab-content#prime-composite-status {
            padding: 20px;
        }

        .status-analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.08), rgba(69, 123, 157, 0.08));
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .status-analysis-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-legend {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .status-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .status-legend .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .status-legend .legend-prime {
            background: linear-gradient(135deg, #E63946, #D62828);
        }

        .status-legend .legend-composite {
            background: linear-gradient(135deg, #457B9D, #1D3557);
        }

        .status-chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .status-chart-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .status-chart-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #E63946, #457B9D);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .status-chart-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .status-chart-item:hover::before {
            transform: scaleX(1);
        }

        .prime-composite-tab-content#prime-composite-status .chart-container {
            background: transparent;
            border: none;
            padding: 0;
            margin: 0;
            box-shadow: none;
            border-radius: 0;
        }

        .status-table-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .status-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        .status-table-header h5 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .table-controls {
            display: flex;
            gap: 10px;
        }

        .table-controls .btn {
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid rgba(69, 123, 157, 0.3);
            background: rgba(255, 255, 255, 0.8);
            color: #457B9D;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .table-controls .btn:hover {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            color: white;
            border-color: #457B9D;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.3);
        }

        .prime-composite-tab-content#prime-composite-status .status-table {
            margin: 0;
        }

        .prime-composite-tab-content#prime-composite-status .status-table table {
            margin: 0;
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        .prime-composite-tab-content#prime-composite-status .status-table thead {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.1), rgba(69, 123, 157, 0.1));
        }

        .prime-composite-tab-content#prime-composite-status .status-table th {
            padding: 12px 8px;
            font-size: 13px;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid rgba(69, 123, 157, 0.2);
            text-align: center;
            background: transparent;
        }

        .prime-composite-tab-content#prime-composite-status .status-table tbody tr {
            transition: all 0.3s ease;
            animation: fadeIn 0.5s ease forwards;
        }

        .prime-composite-tab-content#prime-composite-status .status-table tbody tr:hover {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.05), rgba(69, 123, 157, 0.05));
            transform: scale(1.01);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .prime-composite-tab-content#prime-composite-status .status-table td {
            padding: 10px 8px;
            font-size: 13px;
            color: #2c3e50;
            border-bottom: 1px solid rgba(69, 123, 157, 0.1);
            text-align: center;
            vertical-align: middle;
        }

        .prime-composite-tab-content#prime-composite-status .status-table td:first-child {
            font-weight: 600;
            color: #E63946;
        }

        .prime-composite-tab-content#prime-composite-status .status-table td:nth-child(2) {
            font-weight: 500;
        }

        .prime-composite-tab-content#prime-composite-status .status-table td:nth-child(3),
        .prime-composite-tab-content#prime-composite-status .status-table td:nth-child(4),
        .prime-composite-tab-content#prime-composite-status .status-table td:nth-child(5),
        .prime-composite-tab-content#prime-composite-status .status-table td:nth-child(6) {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #457B9D;
        }

        .prime-composite-tab-content#prime-composite-status .status-table .type-badge {
            display: inline-block;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 12px;
            text-align: center;
            white-space: nowrap;
        }

        .prime-composite-tab-content#prime-composite-status .status-table .type-badge.prime {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
            box-shadow: 0 2px 6px rgba(230, 57, 70, 0.3);
        }

        .prime-composite-tab-content#prime-composite-status .status-table .type-badge.composite {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            color: white;
            box-shadow: 0 2px 6px rgba(69, 123, 157, 0.3);
        }

        .prime-composite-tab-content#prime-composite-status .status-table .status-badge {
            display: inline-block;
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 12px;
            text-align: center;
            white-space: nowrap;
        }

        .prime-composite-tab-content#prime-composite-status .status-table .status-badge.hot {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.4);
            animation: pulse 2s infinite;
        }

        .prime-composite-tab-content#prime-composite-status .status-table .status-badge.warm {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.4);
        }

        .prime-composite-tab-content#prime-composite-status .status-table .status-badge.cold {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* ==================== 质合分析策略推荐视图优化 ==================== */
        .prime-composite-tab-content#prime-composite-strategy {
            padding: 20px;
        }

        .prime-composite-tab-content#prime-composite-strategy .strategy-content {
            padding: 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .prime-composite-tab-content#prime-composite-strategy .strategy-content h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 22px;
            font-weight: 700;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        /* 策略概览卡片 */
        .strategy-section.strategy-overview {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .strategy-section.strategy-overview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #E63946, #457B9D);
        }

        .strategy-section.strategy-overview:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        .strategy-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .confidence-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .confidence-badge:hover {
            transform: scale(1.05);
        }

        .confidence-badge.confidence-high {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.4);
        }

        .confidence-badge.confidence-medium {
            background: linear-gradient(135deg, #F59E0B, #D97706);
            color: white;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4);
        }

        .confidence-badge.confidence-low {
            background: linear-gradient(135deg, #EF4444, #DC2626);
            color: white;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
        }

        /* 比例对比 */
        .ratio-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .ratio-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .ratio-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.15);
            border-color: #457B9D;
        }

        .ratio-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .ratio-value {
            font-size: 20px;
            font-weight: 700;
            color: #E63946;
        }

        .ratio-bar-container {
            position: relative;
            height: 24px;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.1), rgba(230, 57, 70, 0.1));
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 12px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .ratio-bar {
            height: 100%;
            border-radius: 12px;
            transition: width 0.8s ease;
            position: relative;
            overflow: hidden;
        }

        .ratio-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .ratio-bar.ratio-prime {
            background: linear-gradient(90deg, #E63946, #D62828);
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.4);
        }

        .ratio-bar.ratio-composite {
            background: linear-gradient(90deg, #457B9D, #1D3557);
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.4);
        }

        .ratio-theoretical {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(0, 0, 0, 0.3);
            transform: translateX(-50%);
            z-index: 1;
        }

        .ratio-theoretical::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
        }

        .ratio-diff {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-block;
        }

        .ratio-diff.positive {
            background: rgba(16, 185, 129, 0.1);
            color: #10B981;
        }

        .ratio-diff.negative {
            background: rgba(239, 68, 68, 0.1);
            color: #EF4444;
        }

        /* 趋势指示器 */
        .trend-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        .trend-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 8px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .trend-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.15);
            border-color: #457B9D;
        }

        .trend-label {
            font-size: 13px;
            font-weight: 500;
            color: #5a6c7d;
        }

        .trend-value {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .trend-value.trend-up {
            color: #10B981;
        }

        .trend-value.trend-down {
            color: #EF4444;
        }

        /* 号码状态分析 */
        .strategy-section.strategy-numbers {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .strategy-section.strategy-numbers:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .strategy-section.strategy-numbers h4 {
            margin: 0 0 24px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .number-category {
            margin-bottom: 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .number-category:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.15);
        }

        .number-category:last-child {
            margin-bottom: 0;
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        .category-icon {
            font-size: 24px;
        }

        .category-title {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
        }

        .category-desc {
            font-size: 13px;
            color: #5a6c7d;
            margin-left: auto;
        }

        .number-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 12px;
        }

        .number-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .number-card:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .number-card .number-badge {
            width: 40px;
            height: 40px;
            line-height: 40px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .number-card .number-omission {
            font-size: 12px;
            font-weight: 600;
            color: #5a6c7d;
        }

        .number-card.hot-card {
            border-color: rgba(230, 57, 70, 0.3);
        }

        .number-card.hot-card:hover {
            border-color: #E63946;
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.05), rgba(214, 40, 40, 0.05));
        }

        .number-card.hot-card .number-badge {
            background: linear-gradient(135deg, #E63946, #D62828);
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.4);
        }

        .number-card.warm-card {
            border-color: rgba(244, 162, 97, 0.3);
        }

        .number-card.warm-card:hover {
            border-color: #F4A261;
            background: linear-gradient(135deg, rgba(244, 162, 97, 0.05), rgba(231, 111, 81, 0.05));
        }

        .number-card.warm-card .number-badge {
            background: linear-gradient(135deg, #F4A261, #E76F51);
            box-shadow: 0 2px 8px rgba(244, 162, 97, 0.4);
        }

        .number-card.cold-card {
            border-color: rgba(69, 123, 157, 0.3);
        }

        .number-card.cold-card:hover {
            border-color: #457B9D;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.05), rgba(29, 53, 87, 0.05));
        }

        .number-card.cold-card .number-badge {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.4);
        }

        /* 选号策略建议 */
        .strategy-section.strategy-recommendations {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .strategy-section.strategy-recommendations:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .strategy-section.strategy-recommendations h4 {
            margin: 0 0 24px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .recommendation-card {
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .recommendation-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 16px rgba(69, 123, 157, 0.2);
        }

        .recommendation-card.prime-rec {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.05), rgba(214, 40, 40, 0.05));
            border-color: rgba(230, 57, 70, 0.2);
        }

        .recommendation-card.prime-rec:hover {
            border-color: #E63946;
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.1), rgba(214, 40, 40, 0.1));
        }

        .recommendation-card.composite-rec {
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.05), rgba(29, 53, 87, 0.05));
            border-color: rgba(69, 123, 157, 0.2);
        }

        .recommendation-card.composite-rec:hover {
            border-color: #457B9D;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.1), rgba(29, 53, 87, 0.1));
        }

        .rec-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .rec-header i {
            font-size: 16px;
        }

        .rec-value {
            font-size: 28px;
            font-weight: 700;
            color: #E63946;
            margin-bottom: 8px;
            text-align: center;
        }

        .rec-desc {
            font-size: 12px;
            color: #5a6c7d;
            text-align: center;
        }

        /* 优先级部分 */
        .number-priorities {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .priority-section {
            padding: 16px;
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .priority-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.15);
        }

        .priority-section.high-priority {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.05), rgba(214, 40, 40, 0.05));
            border-color: rgba(230, 57, 70, 0.2);
        }

        .priority-section.high-priority:hover {
            border-color: #E63946;
        }

        .priority-section.medium-priority {
            background: linear-gradient(135deg, rgba(244, 162, 97, 0.05), rgba(231, 111, 81, 0.05));
            border-color: rgba(244, 162, 97, 0.2);
        }

        .priority-section.medium-priority:hover {
            border-color: #F4A261;
        }

        .priority-section.low-priority {
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.05), rgba(29, 53, 87, 0.05));
            border-color: rgba(69, 123, 157, 0.2);
        }

        .priority-section.low-priority:hover {
            border-color: #457B9D;
        }

        .priority-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
        }

        .priority-icon {
            font-size: 18px;
        }

        .priority-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }

        .priority-number {
            display: inline-block;
            width: 36px;
            height: 36px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            color: white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .priority-number:hover {
            transform: scale(1.1);
        }

        .priority-number.high {
            background: linear-gradient(135deg, #E63946, #D62828);
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.4);
        }

        .priority-number.medium {
            background: linear-gradient(135deg, #F4A261, #E76F51);
            box-shadow: 0 2px 8px rgba(244, 162, 97, 0.4);
        }

        .priority-number.low {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.4);
        }

        .priority-note {
            font-size: 12px;
            color: #5a6c7d;
            font-style: italic;
        }

        /* 关键提醒 */
        .strategy-section.strategy-tips {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .strategy-section.strategy-tips:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(230, 57, 70, 0.15);
            border-color: #E63946;
        }

        .strategy-section.strategy-tips h4 {
            margin: 0 0 24px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tips-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .tip-card {
            padding: 16px;
            border-radius: 10px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            display: flex;
            gap: 12px;
        }

        .tip-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.15);
        }

        .tip-card.tip-warning {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.05), rgba(220, 38, 38, 0.05));
            border-color: rgba(239, 68, 68, 0.2);
        }

        .tip-card.tip-warning:hover {
            border-color: #EF4444;
        }

        .tip-card.tip-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(37, 99, 235, 0.05));
            border-color: rgba(59, 130, 246, 0.2);
        }

        .tip-card.tip-info:hover {
            border-color: #3B82F6;
        }

        .tip-card.tip-advice {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05), rgba(5, 150, 105, 0.05));
            border-color: rgba(16, 185, 129, 0.2);
        }

        .tip-card.tip-advice:hover {
            border-color: #10B981;
        }

        .tip-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .tip-content {
            flex: 1;
        }

        .tip-content h5 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
        }

        .tip-content p {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #5a6c7d;
            line-height: 1.5;
        }

        .tip-badge {
            display: inline-block;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 12px;
            background: linear-gradient(135deg, #457B9D, #1D3557);
            color: white;
            box-shadow: 0 2px 6px rgba(69, 123, 157, 0.3);
        }

        /* 响应式布局 */
        @media (max-width: 768px) {
            .prime-composite-tab-content#prime-composite-strategy {
                padding: 12px;
            }

            .prime-composite-tab-content#prime-composite-strategy .strategy-content {
                padding: 16px;
            }

            .prime-composite-tab-content#prime-composite-strategy .strategy-content h3 {
                font-size: 18px;
            }

            .strategy-section {
                padding: 16px;
            }

            .strategy-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .ratio-comparison {
                grid-template-columns: 1fr;
            }

            .trend-indicators {
                grid-template-columns: 1fr;
            }

            .number-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
            }

            .recommendation-grid {
                grid-template-columns: 1fr;
            }

            .number-priorities {
                grid-template-columns: 1fr;
            }

            .tips-grid {
                grid-template-columns: 1fr;
            }
        }

        /* 通用策略部分样式 */
        .strategy-content {
            padding: 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 240, 0.95));
            border-radius: 8px;
            border: 1px solid rgba(69, 123, 157, 0.2);
        }

        .strategy-content h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 20px;
            font-weight: 600;
            text-align: center;
        }

        .strategy-section {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            border-left: 4px solid #457B9D;
        }

        .strategy-section h4 {
            margin: 0 0 12px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }

        .strategy-section ul {
            margin: 0;
            padding-left: 20px;
        }

        .strategy-section li {
            margin: 8px 0;
            color: #2c3e50;
            font-size: 14px;
            line-height: 1.6;
        }

        .strategy-section li strong {
            color: #E63946;
            font-weight: 600;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 12px;
            text-align: center;
            white-space: nowrap;
        }

        .status-hot {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.4);
        }

        .status-warm {
            background: linear-gradient(135deg, #F4A261, #E76F51);
            color: white;
            box-shadow: 0 2px 8px rgba(244, 162, 97, 0.4);
        }

        .status-cold {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            color: white;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.4);
        }

        /* ==================== 质合分析图表容器优化 ==================== */
        .prime-composite-tab-content .chart-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 240, 0.95));
            border-radius: 8px;
            border: 1px solid rgba(69, 123, 157, 0.2);
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        /* ==================== 质合分析状态表格优化 ==================== */
        .prime-composite-tab-content .status-table {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 240, 0.95));
            border-radius: 8px;
            border: 1px solid rgba(69, 123, 157, 0.2);
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .prime-composite-tab-content .status-table .table {
            font-size: 13px;
        }

        .prime-composite-tab-content .status-table .table th {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
            padding: 12px 10px;
            font-size: 13px;
            font-weight: 600;
            text-align: center;
            border: none;
        }

        .prime-composite-tab-content .status-table .table td {
            padding: 10px 8px;
            border-color: rgba(69, 123, 157, 0.2);
            text-align: center;
            vertical-align: middle;
        }

        .prime-composite-tab-content .status-table .table tbody tr {
            transition: all 0.3s ease;
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .prime-composite-tab-content .status-table .table tbody tr:hover {
            background: rgba(230, 57, 70, 0.1);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.2);
        }

        .prime-composite-tab-content .status-table .table tbody tr:nth-child(even) {
            background: rgba(69, 123, 157, 0.05);
        }

        .prime-composite-tab-content .status-table .table tbody tr:nth-child(even):hover {
            background: rgba(230, 57, 70, 0.15);
        }

        .prime-composite-tab-content .status-table .number-cell .number-badge {
            display: inline-block;
            width: 36px;
            height: 36px;
            line-height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.3);
            transition: all 0.3s ease;
        }

        .prime-composite-tab-content .status-table .table tbody tr:hover .number-badge {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.5);
        }

        .prime-composite-tab-content .status-table .type-cell .type-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .prime-composite-tab-content .status-table .type-cell .type-badge.type-prime {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
        }

        .prime-composite-tab-content .status-table .type-cell .type-badge.type-composite {
            background: linear-gradient(135deg, #457B9D, #1D3557);
            color: white;
        }

        .prime-composite-tab-content .status-table .frequency-cell .frequency-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 80px;
        }

        .prime-composite-tab-content .status-table .frequency-cell .frequency-bar {
            height: 20px;
            background: linear-gradient(90deg, #E63946, #D62828);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 2px 6px rgba(230, 57, 70, 0.3);
        }

        .prime-composite-tab-content .status-table .frequency-cell .frequency-value {
            font-weight: 600;
            color: #2c3e50;
            font-size: 12px;
            min-width: 20px;
            text-align: right;
        }

        .prime-composite-tab-content .status-table .omission-cell .omission-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 80px;
        }

        .prime-composite-tab-content .status-table .omission-cell .omission-bar {
            height: 20px;
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .prime-composite-tab-content .status-table .omission-cell .omission-bar.omission-low {
            background: linear-gradient(90deg, #2ECC71, #27AE60);
        }

        .prime-composite-tab-content .status-table .omission-cell .omission-bar.omission-medium {
            background: linear-gradient(90deg, #F39C12, #E67E22);
        }

        .prime-composite-tab-content .status-table .omission-cell .omission-bar.omission-high {
            background: linear-gradient(90deg, #E74C3C, #C0392B);
        }

        .prime-composite-tab-content .status-table .omission-cell .omission-value {
            font-weight: 600;
            color: #2c3e50;
            font-size: 12px;
            min-width: 20px;
            text-align: right;
        }

        .prime-composite-tab-content .status-table .avg-omission-cell,
        .prime-composite-tab-content .status-table .max-omission-cell {
            font-weight: 600;
            color: #2c3e50;
        }

        .prime-composite-tab-content .status-table .status-cell .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 14px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 12px;
            text-align: center;
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        .prime-composite-tab-content .status-table .table tbody tr:hover .status-badge {
            transform: scale(1.05);
        }

        /* ==================== 质合分析按钮优化 ==================== */
        #startPrimeCompositeAnalysis {
            background: linear-gradient(135deg, #E63946, #D62828);
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.3);
        }

        #startPrimeCompositeAnalysis:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(230, 57, 70, 0.4);
        }

        #startPrimeCompositeAnalysis:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(230, 57, 70, 0.3);
        }

        /* ==================== 质合分析期数选择器优化 ==================== */
        #primeCompositePeriodSelect {
            background: white;
            border: 1px solid rgba(69, 123, 157, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            color: #2c3e50;
            transition: all 0.3s ease;
        }

        #primeCompositePeriodSelect:hover {
            border-color: #457B9D;
            box-shadow: 0 2px 8px rgba(69, 123, 157, 0.2);
        }

        #primeCompositePeriodSelect:focus {
            outline: none;
            border-color: #E63946;
            box-shadow: 0 0 0 3px rgba(230, 57, 70, 0.2);
        }

        /* ==================== 质合分析响应式布局 ==================== */
        @media (max-width: 768px) {
            .prime-composite-tabs {
                gap: 5px;
                padding: 8px;
            }

            .prime-composite-tab {
                padding: 8px 12px;
                font-size: 12px;
            }

            .info-grid {
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                gap: 8px;
            }

            .info-item {
                padding: 8px;
            }

            .info-item .info-label {
                font-size: 11px;
            }

            .info-item .info-value {
                font-size: 14px;
            }

            .strategy-content {
                padding: 15px;
            }

            .strategy-content h3 {
                font-size: 18px;
            }

            .strategy-section {
                padding: 12px;
                margin-bottom: 16px;
            }

            .strategy-section h4 {
                font-size: 14px;
            }

            .strategy-section li {
                font-size: 13px;
            }

            .prime-composite-tab-content .chart-container {
                padding: 10px;
                margin: 10px 0;
            }

            .prime-composite-tab-content .status-table {
                padding: 10px;
                margin: 10px 0;
                overflow-x: auto;
            }

            .prime-composite-tab-content .status-table .table {
                font-size: 11px;
            }

            .prime-composite-tab-content .status-table .table th,
            .prime-composite-tab-content .status-table .table td {
                padding: 6px 4px;
            }
        }

        @media (max-width: 480px) {
            .prime-composite-tabs {
                gap: 3px;
                padding: 6px;
            }

            .prime-composite-tab {
                padding: 6px 10px;
                font-size: 11px;
            }

            .info-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            .info-item {
                padding: 6px;
            }

            .info-item .info-label {
                font-size: 10px;
            }

            .info-item .info-value {
                font-size: 12px;
            }

            .strategy-content {
                padding: 12px;
            }

            .strategy-content h3 {
                font-size: 16px;
            }

            .strategy-section {
                padding: 10px;
                margin-bottom: 12px;
            }

            .strategy-section h4 {
                font-size: 13px;
            }

            .strategy-section li {
                font-size: 12px;
            }

            .prime-composite-tab-content .chart-container {
                padding: 8px;
                margin: 8px 0;
            }

            .prime-composite-tab-content .status-table {
                padding: 8px;
                margin: 8px 0;
            }

            .prime-composite-tab-content .status-table .table {
                font-size: 10px;
            }

            .prime-composite-tab-content .status-table .table th,
            .prime-composite-tab-content .status-table .table td {
                padding: 4px 2px;
            }

            .status-badge {
                padding: 2px 8px;
                font-size: 10px;
            }
        }

        /* ==================== 质合分析动画效果 ==================== */
        .prime-composite-tab-content {
            animation: fadeInUp 0.4s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .info-item {
            transition: all 0.3s ease;
        }

        .info-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.2);
        }

        .strategy-section {
            transition: all 0.3s ease;
        }

        .strategy-section:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(69, 123, 157, 0.15);
        }

        /* ==================== 质合分析滚动条样式 ==================== */
        .prime-composite-tab-content .status-table::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .prime-composite-tab-content .status-table::-webkit-scrollbar-track {
            background: rgba(69, 123, 157, 0.1);
            border-radius: 4px;
        }

        .prime-composite-tab-content .status-table::-webkit-scrollbar-thumb {
            background: rgba(69, 123, 157, 0.4);
            border-radius: 4px;
        }

        .prime-composite-tab-content .status-table::-webkit-scrollbar-thumb:hover {
            background: rgba(69, 123, 157, 0.6);
        }

        /* ==================== 质合分析策略推荐样式 ==================== */
        .strategy-overview {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        .strategy-header h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .confidence-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .confidence-high {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            box-shadow: 0 2px 8px rgba(46, 204, 113, 0.3);
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);
        }

        .confidence-low {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.3);
        }

        .confidence-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .ratio-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .ratio-item {
            background: white;
            border-radius: 10px;
            padding: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .ratio-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
        }

        .ratio-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .ratio-label span:first-child {
            font-size: 14px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .ratio-value {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
        }

        .ratio-bar-container {
            position: relative;
            height: 24px;
            background: linear-gradient(90deg, #ecf0f1, #bdc3c7);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .ratio-bar {
            height: 100%;
            border-radius: 12px;
            transition: width 0.8s ease;
            position: relative;
            overflow: hidden;
        }

        .ratio-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .ratio-prime {
            background: linear-gradient(90deg, #E63946, #ff6b6b);
        }

        .ratio-composite {
            background: linear-gradient(90deg, #457B9D, #5dade2);
        }

        .ratio-theoretical {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #2c3e50;
            transform: translateX(-50%);
        }

        .ratio-theoretical::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            width: 10px;
            height: 10px;
            background: #2c3e50;
            border-radius: 50%;
        }

        .ratio-diff {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 12px;
            display: inline-block;
        }

        .ratio-diff.positive {
            background: rgba(46, 204, 113, 0.15);
            color: #27ae60;
        }

        .ratio-diff.negative {
            background: rgba(231, 76, 60, 0.15);
            color: #e74c3c;
        }

        .trend-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .trend-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 14px 18px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .trend-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .trend-label {
            font-size: 13px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .trend-value {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .trend-up {
            color: #27ae60;
        }

        .trend-down {
            color: #e74c3c;
        }

        .prediction-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid rgba(69, 123, 157, 0.1);
        }

        .prediction-section h5 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .prediction-card {
            background: white;
            border-radius: 10px;
            padding: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .prediction-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
        }

        .prediction-label {
            font-size: 13px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .prediction-value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .prediction-value.trend-up {
            color: #27ae60;
        }

        .prediction-value.trend-down {
            color: #e74c3c;
        }

        .prediction-value.trend-stable {
            color: #3498db;
        }

        .prediction-confidence {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .prediction-reason {
            font-size: 12px;
            color: #95a5a6;
            font-style: italic;
        }

        .strategy-advanced {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-advanced h4 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .advanced-strategies-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }

        .advanced-strategy-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            display: flex;
            gap: 15px;
            border-left: 4px solid #95a5a6;
        }

        .advanced-strategy-card.high {
            border-left-color: #27ae60;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.05), white);
        }

        .advanced-strategy-card.medium {
            border-left-color: #f39c12;
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.05), white);
        }

        .advanced-strategy-card.low {
            border-left-color: #e74c3c;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.05), white);
        }

        .advanced-strategy-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .strategy-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .strategy-content {
            flex: 1;
        }

        .strategy-title {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .strategy-description {
            font-size: 13px;
            color: #5a6c7d;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .strategy-details {
            display: flex;
            gap: 15px;
            margin-bottom: 12px;
        }

        .strategy-score {
            font-size: 12px;
            color: #27ae60;
            font-weight: 600;
        }

        .strategy-risk {
            font-size: 12px;
            color: #e74c3c;
            font-weight: 600;
        }

        .strategy-recommendation {
            font-size: 13px;
            color: #2c3e50;
            line-height: 1.5;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
        }

        .strategy-position {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-position h4 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .position-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .position-card {
            background: white;
            border-radius: 10px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            text-align: center;
            border-top: 4px solid #95a5a6;
        }

        .position-card.prime {
            border-top-color: #E63946;
        }

        .position-card.composite {
            border-top-color: #457B9D;
        }

        .position-card.balanced {
            border-top-color: #27ae60;
        }

        .position-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
        }

        .position-number {
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 12px;
        }

        .position-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 12px;
        }

        .position-stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .position-stat .stat-label {
            font-size: 11px;
            color: #7f8c8d;
        }

        .position-stat .stat-value {
            font-size: 16px;
            font-weight: 700;
        }

        .position-stat .stat-value.prime {
            color: #E63946;
        }

        .position-stat .stat-value.composite {
            color: #457B9D;
        }

        .position-preference {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .position-recommendation {
            font-size: 12px;
            color: #5a6c7d;
            line-height: 1.4;
        }

        .strategy-cycle {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-cycle h4 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cycle-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .cycle-stat {
            display: flex;
            flex-direction: column;
            gap: 6px;
            text-align: center;
        }

        .cycle-label {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .cycle-value {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
        }

        .cycle-value.up {
            color: #27ae60;
        }

        .cycle-value.down {
            color: #e74c3c;
        }

        .cycle-value.stable {
            color: #3498db;
        }

        .cycle-strategies-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .cycle-strategy-card {
            background: white;
            border-radius: 10px;
            padding: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            display: flex;
            gap: 12px;
        }

        .cycle-strategy-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
        }

        .cycle-strategy-icon {
            font-size: 28px;
            flex-shrink: 0;
        }

        .cycle-strategy-content {
            flex: 1;
        }

        .cycle-strategy-title {
            font-size: 15px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 6px;
        }

        .cycle-strategy-desc {
            font-size: 13px;
            color: #5a6c7d;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .cycle-strategy-action {
            font-size: 12px;
            color: #27ae60;
            font-weight: 600;
            padding: 8px 12px;
            background: rgba(39, 174, 96, 0.1);
            border-radius: 6px;
            display: inline-block;
        }

        .warming-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.1);
        }

        .warming-rank {
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
        }

        .warming-strength {
            font-size: 12px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .warming-strength.strength-strong {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .warming-strength.strength-medium {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .warming-strength.strength-weak {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .warming-score {
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
        }

        .warming-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
        }

        .warming-stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .warming-stat .stat-label {
            font-size: 11px;
            color: #7f8c8d;
        }

        .warming-stat .stat-value {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .warming-stat .stat-value.positive {
            color: #27ae60;
        }

        .warming-stat .stat-value.negative {
            color: #e74c3c;
        }

        .warming-details {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
        }

        .warming-detail {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .warming-detail .detail-label {
            font-size: 10px;
            color: #95a5a6;
        }

        .warming-detail .detail-value {
            font-size: 13px;
            font-weight: 600;
            color: #2c3e50;
        }

        .warming-reason {
            font-size: 12px;
            color: #5a6c7d;
            line-height: 1.4;
            padding: 8px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 6px;
        }

        .number-status-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-summary-card {
            background: white;
            border-radius: 10px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            display: flex;
            gap: 12px;
            border-top: 4px solid #95a5a6;
        }

        .status-summary-card.hot-summary {
            border-top-color: #e74c3c;
        }

        .status-summary-card.warm-summary {
            border-top-color: #f39c12;
        }

        .status-summary-card.cold-summary {
            border-top-color: #3498db;
        }

        .status-summary-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
        }

        .summary-icon {
            font-size: 28px;
            flex-shrink: 0;
        }

        .summary-content {
            flex: 1;
        }

        .summary-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .summary-count {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .summary-desc {
            font-size: 11px;
            color: #7f8c8d;
        }

        .number-card.enhanced {
            padding: 14px 10px;
        }

        .number-type-badge {
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 10px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 8px;
            color: white;
        }

        .number-type-badge.prime {
            background: #E63946;
        }

        .number-type-badge.composite {
            background: #457B9D;
        }

        .number-stats {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
        }

        .number-frequency {
            font-size: 10px;
            color: #95a5a6;
            font-weight: 500;
        }

        .number-prediction {
            margin-top: 6px;
        }

        .prediction-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .prediction-badge.prediction-high {
            background: rgba(231, 76, 60, 0.15);
            color: #e74c3c;
        }

        .prediction-badge.prediction-medium {
            background: rgba(243, 156, 18, 0.15);
            color: #f39c12;
        }

        .prediction-badge.prediction-low {
            background: rgba(52, 152, 219, 0.15);
            color: #3498db;
        }

        .prediction-badge.prediction-stable {
            background: rgba(39, 174, 96, 0.15);
            color: #27ae60;
        }

        .prediction-unknown {
            font-size: 10px;
            color: #95a5a6;
        }

        .strategy-numbers {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-numbers h4 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .number-category {
            margin-bottom: 25px;
        }

        .number-category:last-child {
            margin-bottom: 0;
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 10px 15px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .hot-category .category-header {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.1), rgba(231, 76, 60, 0.05));
            border-left: 4px solid #e74c3c;
        }

        .warm-category .category-header {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.1), rgba(243, 156, 18, 0.05));
            border-left: 4px solid #f39c12;
        }

        .cold-category .category-header {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(52, 152, 219, 0.05));
            border-left: 4px solid #3498db;
        }

        .category-icon {
            font-size: 20px;
        }

        .category-title {
            font-size: 15px;
            font-weight: 600;
            color: #2c3e50;
        }

        .category-desc {
            margin-left: auto;
            font-size: 12px;
            color: #7f8c8d;
        }

        .number-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 10px;
        }

        .number-card {
            background: white;
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .number-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            transition: all 0.3s ease;
        }

        .hot-card::before {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
        }

        .warm-card::before {
            background: linear-gradient(90deg, #f39c12, #e67e22);
        }

        .cold-card::before {
            background: linear-gradient(90deg, #3498db, #2980b9);
        }

        .number-card:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .hot-card:hover {
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.3);
        }

        .warm-card:hover {
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.3);
        }

        .cold-card:hover {
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3);
        }

        .number-badge {
            display: inline-block;
            width: 36px;
            height: 36px;
            line-height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            color: #2c3e50;
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 6px;
        }

        .number-omission {
            display: block;
            font-size: 11px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .strategy-recommendations {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-recommendations h4 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .recommendation-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            text-align: center;
        }

        .recommendation-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .prime-rec {
            border-top: 4px solid #E63946;
        }

        .composite-rec {
            border-top: 4px solid #457B9D;
        }

        .rec-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
            color: #5a6c7d;
            font-size: 14px;
            font-weight: 500;
        }

        .rec-value {
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .rec-desc {
            font-size: 12px;
            color: #7f8c8d;
        }

        .number-priorities {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .priority-section {
            background: white;
            border-radius: 10px;
            padding: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .priority-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .high-priority {
            border-left: 4px solid #f39c12;
        }

        .medium-priority {
            border-left: 4px solid #3498db;
        }

        .low-priority {
            border-left: 4px solid #95a5a6;
        }

        .priority-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .priority-icon {
            font-size: 18px;
        }

        .priority-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .priority-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .priority-number {
            display: inline-block;
            width: 32px;
            height: 32px;
            line-height: 32px;
            text-align: center;
            border-radius: 50%;
            font-size: 13px;
            font-weight: 700;
            transition: all 0.3s ease;
        }

        .priority-number.high {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .priority-number.medium {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .priority-number.low {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .priority-number:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .priority-note {
            font-size: 11px;
            color: #7f8c8d;
            font-style: italic;
        }

        .strategy-tips {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 249, 250, 0.98));
            border-radius: 12px;
            border: 1px solid rgba(69, 123, 157, 0.15);
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .strategy-tips h4 {
            margin: 0 0 20px 0;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tips-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .tip-card {
            background: white;
            border-radius: 10px;
            padding: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            display: flex;
            gap: 15px;
        }

        .tip-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .tip-warning {
            border-left: 4px solid #e74c3c;
        }

        .tip-info {
            border-left: 4px solid #3498db;
        }

        .tip-advice {
            border-left: 4px solid #27ae60;
        }

        .tip-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .tip-content {
            flex: 1;
        }

        .tip-content h5 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .tip-content p {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #5a6c7d;
            line-height: 1.5;
        }

        .tip-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            color: #2c3e50;
        }

        /* ==================== 消息提示系统 ==================== */
        .message-center {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column-reverse;
            gap: 10px;
            max-width: 400px;
        }

        .message {
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            animation: slideInUp 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message.error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .message.success {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }

        .message.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .message.info {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .message-close {
            margin-left: auto;
            cursor: pointer;
            font-size: 18px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .message-close:hover {
            opacity: 1;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* ==================== 设置弹窗 ==================== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            width: 500px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
        }

        .modal-close {
            cursor: pointer;
            font-size: 24px;
            color: #666;
            transition: color 0.3s;
            line-height: 1;
            padding: 5px;
        }

        .modal-close:hover {
            color: #333;
        }

        .modal-footer {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            text-align: right;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-title {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .theme-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .theme-option {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-option:hover {
            border-color: var(--ssq-orange);
        }

        .theme-option.active {
            border-color: var(--ssq-orange);
            background: rgba(255, 119, 0, 0.1);
        }

        /* ==================== 响应式设计 ==================== */
        @media (max-width: 768px) {
            .sidebar {
                width: 70px;
            }

            .sidebar-menu li span {
                display: none;
            }

            .sidebar-menu li {
                justify-content: center;
                padding: 15px 0;
            }

            .content-area {
                margin-left: 70px;
            }

            .top-menu {
                flex-wrap: wrap;
            }
        }

        /* 选号系统专用样式 */
        .selection-system-content {
            padding: 15px 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .selection-container-1 {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            width: 100%;
        }

        .selection-container-2 {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            width: 100%;
        }

        .selection-container-3 {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            width: 100%;
        }

        .selection-system-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .magic-square-section {
            margin-top: 15px;
        }

        .magic-square-main-container {
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 15px;
            align-items: flex-start;
        }

        .magic-squares-container {
            display: flex;
            flex-direction: row;
            gap: 0;
            flex: 1;
        }

        .magic-square-group-with-title {
            flex: 0 0 auto;
            min-width: 0; /* 防止内容溢出 */
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .magic-square-title {
            font-size: 1rem;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-align: center;
        }

        .magic-square-group {
            flex: 1;
            min-width: 269.181px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 13.459px;
        }

        .magic-square-group h4 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
        }

        /* 响应式设计：小屏幕时垂直堆叠幻方 */
        @media (max-width: 768px) {
            .magic-square-main-container {
                flex-direction: column;
            }
        }

        .magic-square-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 3.589px;
            margin-bottom: 12px;
        }

        .four-magic-square-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3.589px;
        }

        .magic-square-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.339rem;
            transition: all 0.2s ease;
            user-select: none;
            min-height: 66.85px;
        }

        .magic-square-cell:hover {
            background: var(--highlight-color);
            border-color: var(--primary-color);
        }

        .magic-square-cell.selected {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }

        .magic-square-cell.selected.red {
            background: var(--ssq-primary);
            border-color: var(--ssq-primary);
        }

        .magic-square-cell.selected.blue {
            background: var(--ssq-secondary);
            border-color: var(--ssq-secondary);
        }

        .magic-square-cell.disabled {
            background: #e0e0e0;
            border-color: #666;
            color: #999;
            opacity: 0.7;
            cursor: not-allowed;
        }

        .magic-square-cell.disabled:hover {
            background: #e0e0e0;
            border-color: #666;
            cursor: not-allowed;
        }

        .selection-display-area {
            min-width: 350px;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .selection-header h4 {
            margin: 0;
            color: var(--text-primary);
        }

        .selection-count {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .selection-numbers {
            min-height: 45px;
            padding: 8px;
            background: var(--bg-color);
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            width: 100%;
            overflow-x: auto;
        }

        .selection-numbers::-webkit-scrollbar {
            height: 6px;
        }

        .selection-numbers::-webkit-scrollbar-track {
            background: var(--bg-color);
            border-radius: 3px;
        }

        .selection-numbers::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .selection-numbers::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        .selection-metrics-area {
            min-width: 350px;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .metrics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .metrics-header h4 {
            margin: 0;
            color: var(--text-primary);
        }

        .metrics-content {
            min-height: 120px;
            padding: 10px;
            background: var(--bg-color);
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            width: 100%;
            font-size: 0.85rem;
            line-height: 1.8;
        }

        .metrics-history {
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            text-align: center;
        }

        .metric-item {
            display: inline-block;
            margin-right: 8px;
            margin-bottom: 4px;
        }

        .metric-label {
            color: var(--text-secondary);
        }

        .metric-value {
            color: var(--primary-color);
            font-weight: bold;
        }

        .selected-numbers-nine-ring {
            margin-top: 0;
        }

        .nine-ring-container {
            display: flex;
            gap: 12px;
            justify-content: flex-start;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .nine-ring-group {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .nine-ring-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            width: 100%;
        }

        .jiuzhuan-content {
            padding: 20px 0;
        }

        .container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            width: 100%;
            max-width: 1400px;
        }

        .circle-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border-radius: 18px;
            padding: 15px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            flex: 1;
            min-width: 350px;
            max-width: 400px;
        }

        .circle-group:hover {
            transform: translateY(-8px);
            box-shadow: 0 18px 45px rgba(0, 0, 0, 0.15);
        }

        .circle-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 25px;
            color: #334155;
            position: relative;
            padding-bottom: 12px;
            width: 100%;
            text-align: center;
        }

        .circle-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(to right, #cbd5e1, #94a3b8);
            border-radius: 3px;
        }

        .canvas-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
            width: 560px;
            height: 560px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border: 1px solid #f1f5f9;
            position: relative;
        }

        canvas {
            display: block;
            background-color: transparent;
        }

        @media (max-width: 1300px) {
            .container {
                gap: 15px;
            }

            .circle-group {
                min-width: 380px;
            }
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }

            .circle-group {
                min-width: 380px;
            }
        }

        .nine-ring-canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .number-library-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-top: 15px;
            width: 100%;
            overflow: hidden;
        }

        .library-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .library-status h4 {
            color: var(--text-primary);
            margin: 0;
            font-size: 0.95rem;
        }

        .library-items-container {
            padding: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .library-items-container::-webkit-scrollbar {
            width: 8px;
        }

        .library-items-container::-webkit-scrollbar-track {
            background: var(--bg-color);
            border-radius: 4px;
        }

        .library-items-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .library-items-container::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        .empty-library {
            text-align: center;
            padding: 25px 15px;
            color: var(--text-secondary);
        }

        .empty-library i {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: var(--bg-color);
            border-radius: 5px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .library-item:hover {
            background: var(--highlight-color);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .library-item-content {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0; /* 允许内容收缩 */
        }

        .library-numbers {
            font-family: monospace;
            font-weight: bold;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .red-numbers {
            color: var(--ssq-primary);
        }

        .blue-numbers {
            color: var(--ssq-secondary);
        }

        .library-timestamp {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-left: auto;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .library-actions {
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .nine-ring-container {
                flex-direction: column;
            }

            .nine-ring-canvas-container {
                width: 100%;
                max-width: 220px;
                height: 220px;
            }

            .magic-square-main-container {
                padding: 10px;
            }

            .selection-system-actions {
                flex-direction: column;
            }

            .selection-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .selection-count {
                align-self: flex-end;
            }

            .nine-ring-group {
                align-items: center;
                width: 100%;
                max-width: 220px;
            }

            .number-library-card {
                margin-top: 12px;
            }
        }

        /* 选号系统九转连环图样式 - 使用特定选择器 */
        .selection-container-2 {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow-x: auto;
        }
        
        .selection-container-2 .card-container {
          display: flex;
          justify-content: flex-start;
          align-items: flex-start;
          gap: 20px;
          padding: 10px;
          flex-wrap: nowrap;
          width: fit-content;
          min-width: 100%;
          box-sizing: border-box;
          background: transparent !important;
          border: none !important;
          box-shadow: none !important;
        }

        .selection-container-2 .canvas-card {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 0;
          width: 560px;
          height: 560px;
          flex-shrink: 0;
          box-sizing: border-box;
          background: transparent !important;
          border: none !important;
          box-shadow: none !important;
          margin: 0;
          padding: 0;
        }

        .selection-container-2 .canvas-title {
          display: none;
        }
        
        .selection-container-2 canvas {
          width: 560px;
          height: 560px;
          display: block;
        }

        canvas {
          border: 1px solid #ccc;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
          transition: box-shadow 0.3s ease;
        }

        /* 为普通数字圈定义默认样式 */
        .number-circle circle {
          fill: #fff;
          stroke: #333;
          stroke-width: 1;
        }

        /* 为中心数字圈定义特殊的、更明显的样式 */
        .number-circle.center-circle circle {
          stroke: #000;
          stroke-width: 3;
        }

        /* 高亮数字圈样式 - 红底白字 */
        .number-circle.highlighted circle {
          fill: #E63946 !important;
          stroke: #E63946 !important;
          stroke-width: 2 !important;
        }

        .number-circle.highlighted text {
          fill: #fff !important;
        }

        .number-circle text {
          font-family: Arial, sans-serif;
          font-size: 48px;
          font-weight: bold;
          fill: #333;
          text-anchor: middle;
          dominant-baseline: middle;
        }

        .cross-lines line {
          stroke: #888;
          stroke-width: 3;
          stroke-dasharray: 10;
          opacity: 0.8;
        }

        /* DNA查询标签页样式 */
        .dna-query-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dna-query-tab:hover {
            color: var(--primary-color);
            background: rgba(230, 57, 70, 0.05);
        }

        .dna-query-tab.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
            background: rgba(230, 57, 70, 0.1);
            font-weight: 600;
        }

        .dna-query-panel {
            display: block;
        }

        /* DNA查询结果样式 */
        .query-result-container {
            background: #ffffff;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .query-result-container h4 {
            color: #333;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .query-result-container .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .query-result-container .result-table th,
        .query-result-container .result-table td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }

        .query-result-container .result-table th {
            background: #f5f5f5;
            font-weight: 600;
            color: #333;
        }

        .query-result-container .result-table tbody tr:hover {
            background: #f8f9fa;
        }

        /* 大中小分析推荐样式 */
        .recommendation-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.05), rgba(29, 53, 87, 0.05));
            border-radius: 8px;
            border: 1px solid rgba(69, 123, 157, 0.15);
        }

        .summary-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .summary-item .label {
            font-size: 12px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .summary-item .value {
            font-size: 16px;
            color: #2c3e50;
            font-weight: 600;
        }

        .summary-item .value.highlight {
            color: #E63946;
        }

        .summary-item .value.hot-zone {
            color: #E63946;
        }

        .summary-item .value.cold-zone {
            color: #457B9D;
        }

        .recommendation-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .recommendation-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .recommendation-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef;
        }

        .card-title {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
        }

        .card-ac {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .card-ac .ac-level {
            font-weight: 400;
            margin-left: 5px;
        }

        .card-body {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .number-ball {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: 700;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .number-ball.red {
            background: linear-gradient(135deg, #E63946, #D62828);
        }

        .recommendation-score {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .recommendation-score .score-label {
            font-size: 12px;
            color: #5a6c7d;
            font-weight: 500;
        }

        .score-bar {
            position: relative;
            height: 24px;
            background: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease;
        }

        .score-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 700;
            color: #2c3e50;
        }

        .zone-breakdown {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .zone-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zone-item .zone-label {
            font-size: 12px;
            color: #5a6c7d;
            font-weight: 500;
            min-width: 40px;
        }

        .zone-item .zone-numbers {
            flex: 1;
            font-size: 13px;
            color: #2c3e50;
            font-weight: 600;
        }

        .zone-item .zone-count {
            font-size: 11px;
            color: #7f8c8d;
            padding: 2px 8px;
            background: #e9ecef;
            border-radius: 10px;
        }

        .zone-item.zone1 .zone-label {
            color: #E63946;
        }

        .zone-item.zone2 .zone-label {
            color: #F4A261;
        }

        .zone-item.zone3 .zone-label {
            color: #457B9D;
        }

        .recommendation-details {
            display: flex;
            gap: 15px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.05), rgba(29, 53, 87, 0.05));
            border-radius: 6px;
        }

        .recommendation-details .detail-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #5a6c7d;
        }

        .recommendation-details .detail-item i {
            color: #457B9D;
        }

        .no-recommendation {
            text-align: center;
            padding: 40px 20px;
            color: #7f8c8d;
        }

        .no-recommendation i {
            font-size: 48px;
            margin-bottom: 15px;
            color: #95a5a6;
        }

        .no-recommendation p {
            font-size: 14px;
            margin: 0;
        }

        .dna-mapping-details {
            background: linear-gradient(135deg, rgba(248, 250, 252, 0.98), rgba(233, 236, 239, 0.98));
            border-radius: 16px;
            border: 2px solid rgba(155, 89, 182, 0.2);
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.12);
            padding: 20px;
            margin-top: 20px;
        }

        .gene-detail-card, .chromosome-detail-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.98));
            border-radius: 14px;
            border: 2px solid rgba(155, 89, 182, 0.15);
            padding: 20px;
            box-shadow: 0 4px 12px rgba(155, 89, 182, 0.08);
            transition: all 0.3s ease;
        }

        .gene-detail-card:hover, .chromosome-detail-card:hover {
            box-shadow: 0 6px 18px rgba(155, 89, 182, 0.15);
            border-color: rgba(155, 89, 182, 0.25);
            transform: translateY(-2px);
        }

        .gene-detail-card h5, .chromosome-detail-card h5 {
            margin-bottom: 18px;
            color: #2c3e50;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(155, 89, 182, 0.15);
        }

        .gene-detail-card h5 i, .chromosome-detail-card h5 i {
            color: #9b59b6;
            font-size: 20px;
        }

        .detail-row {
            display: flex;
            margin-bottom: 14px;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(155, 89, 182, 0.1);
        }

        .detail-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .detail-label {
            flex: 0 0 140px;
            font-weight: 600;
            color: #5a6c7d;
            font-size: 14px;
        }

        .detail-value {
            flex: 1;
            color: #2c3e50;
            font-weight: 700;
            font-size: 14px;
        }

        .conclusion-item, .pattern-item {
            margin-bottom: 18px;
            padding: 18px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.98));
            border-radius: 12px;
            border-left: 5px solid #9b59b6;
            box-shadow: 0 4px 12px rgba(155, 89, 182, 0.08);
            transition: all 0.3s ease;
        }

        .conclusion-item:hover, .pattern-item:hover {
            box-shadow: 0 6px 16px rgba(155, 89, 182, 0.12);
            transform: translateX(3px);
        }

        .conclusion-header, .pattern-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            color: #2c3e50;
            font-weight: 700;
            font-size: 16px;
        }

        .conclusion-header i, .pattern-header i {
            margin-right: 10px;
            color: #9b59b6;
            font-size: 18px;
        }

        .conclusion-body, .pattern-body {
            color: #5a6c7d;
            font-size: 14px;
            line-height: 1.6;
        }

        .dna-mapping-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .dna-mapping-stat-item {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.12), rgba(142, 68, 173, 0.12));
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            border: 2px solid rgba(155, 89, 182, 0.25);
            box-shadow: 0 3px 10px rgba(155, 89, 182, 0.1);
            transition: all 0.3s ease;
        }

        .dna-mapping-stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.15);
            border-color: rgba(155, 89, 182, 0.35);
        }

        .dna-mapping-stat-label {
            font-size: 13px;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .dna-mapping-stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #9b59b6;
            text-shadow: 0 2px 4px rgba(155, 89, 182, 0.2);
        }

        #dnaMappingChart {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.98));
            border-radius: 12px;
            border: 2px solid rgba(155, 89, 182, 0.15);
            box-shadow: 0 4px 16px rgba(155, 89, 182, 0.1);
            padding: 10px;
            margin: 15px 0;
            height: 600px !important;
        }

        #dnaMappingChart:hover {
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.15);
            border-color: rgba(155, 89, 182, 0.25);
        }

        #dnaMappingDetails h4 {
            color: #2c3e50;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(155, 89, 182, 0.15);
        }

        #dnaMappingDetails h4 i {
            color: #9b59b6;
            font-size: 20px;
        }

        .recovery-analysis-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .recovery-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .recovery-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .recovery-card .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.15);
        }

        .recovery-card .card-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }

        .recovery-card .card-header h3 i {
            color: #457B9D;
            font-size: 18px;
            margin-right: 8px;
        }

        .recovery-card .card-body {
            min-height: 400px;
        }

        .recovery-card .stats-container {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(69, 123, 157, 0.08), rgba(29, 53, 87, 0.08));
            border-radius: 6px;
        }

        .recovery-card .stats-container .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(69, 123, 157, 0.1);
        }

        .recovery-card .stats-container .stat-item:last-child {
            border-bottom: none;
        }

        .recovery-card .stats-container .stat-label {
            color: #2c3e50;
            font-weight: 500;
            font-size: 13px;
        }

        .recovery-card .stats-container .stat-value {
            color: #E63946;
            font-weight: 600;
            font-size: 14px;
        }

        .recovery-conclusion-card,
        .recovery-recommendation-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
        }

        .recovery-conclusion-card .card-header,
        .recovery-recommendation-card .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(69, 123, 157, 0.15);
        }

        .recovery-conclusion-card .card-header h3,
        .recovery-recommendation-card .card-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }

        .recovery-conclusion-card .card-header h3 i,
        .recovery-recommendation-card .card-header h3 i {
            color: #457B9D;
            font-size: 18px;
            margin-right: 8px;
        }

        .recovery-conclusion-card .card-body,
        .recovery-recommendation-card .card-body {
            color: #2c3e50;
            font-size: 14px;
            line-height: 1.6;
        }

        .recovery-conclusion-card .card-body ul,
        .recovery-recommendation-card .card-body ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .recovery-conclusion-card .card-body li,
        .recovery-recommendation-card .card-body li {
            margin: 6px 0;
        }

        .recovery-recommendation-card .recommendation-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(240, 240, 240, 0.9));
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(69, 123, 157, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .recovery-recommendation-card .recommendation-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .recovery-recommendation-card .recommendation-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .recovery-recommendation-card .recommendation-header i {
            margin-right: 8px;
            font-size: 16px;
        }

        .recovery-recommendation-card .recommendation-header strong {
            color: #2c3e50;
            font-size: 14px;
            font-weight: 600;
        }

        .recovery-recommendation-card .recommendation-body {
            color: #2c3e50;
            font-size: 13px;
            line-height: 1.5;
        }

        .recovery-recommendation-card .recommendation-body p {
            margin: 0;
        }

        .recovery-number-tag {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: linear-gradient(135deg, #E63946, #D62839);
            color: white;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .mandelbrot-section {
            margin-bottom: 30px;
        }

        .mandelbrot-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .mandelbrot-card .card-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mandelbrot-card .card-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .mandelbrot-card .card-body {
            padding: 20px;
        }

        .mandelbrot-description {
            line-height: 1.8;
        }

        .mandelbrot-description p {
            margin-bottom: 15px;
            color: #333;
        }

        .mandelbrot-description ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .mandelbrot-description li {
            margin-bottom: 10px;
            color: #555;
        }

        .mandelbrot-description .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px 15px;
            margin-top: 15px;
            border-radius: 4px;
            color: #856404;
        }

        .formula-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .formula-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .formula-item h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 16px;
        }

        .formula {
            background: white;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
            border: 1px solid #e0e0e0;
        }

        .formula-desc {
            color: #666;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }

        .steps-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .step-number {
            flex-shrink: 0;
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
        }

        .step-content h4 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 16px;
        }

        .step-content p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }

        .disclaimer {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 12px 15px;
            margin-top: 20px;
            border-radius: 4px;
            color: #721c24;
            font-size: 14px;
        }

        .combination-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .combination-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 12px 15px;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .combination-label {
            font-weight: 600;
            color: #333;
            min-width: 80px;
        }

        .combination-numbers {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .combo-ball {
            display: inline-block;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #E63946, #D62839);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }

        .combination-prob {
            margin-left: auto;
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stats-grid .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stats-grid .stat-label {
            color: #333;
            font-weight: 500;
            font-size: 14px;
        }

        .stats-grid .stat-value {
            color: #667eea;
            font-weight: 600;
            font-size: 16px;
        }

        .fibonacci-section {
            margin-bottom: 30px;
        }

        .fibonacci-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .fibonacci-card .card-header {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .fibonacci-card .card-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .fibonacci-card .card-body {
            padding: 20px;
        }

        .fibonacci-description {
            line-height: 1.8;
        }

        .fibonacci-description p {
            margin-bottom: 15px;
            color: #333;
        }

        .fibonacci-description ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .fibonacci-description li {
            margin-bottom: 10px;
            color: #555;
        }

        .fibonacci-description .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px 15px;
            margin-top: 15px;
            border-radius: 4px;
            color: #856404;
        }

        .montecarlo-section {
            margin-bottom: 30px;
        }

        .montecarlo-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .montecarlo-card .card-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .montecarlo-card .card-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .montecarlo-card .card-body {
            padding: 20px;
        }

        .montecarlo-description {
            line-height: 1.8;
        }

        .montecarlo-description p {
            margin-bottom: 15px;
            color: #333;
        }

        .montecarlo-description ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .montecarlo-description li {
            margin-bottom: 10px;
            color: #555;
        }

        .montecarlo-description .note {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 12px 15px;
            margin-top: 15px;
            border-radius: 4px;
            color: #0c5460;
        }

        .statmodel-section {
            margin-bottom: 30px;
        }

        .statmodel-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .statmodel-card .card-header {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .statmodel-card .card-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .statmodel-card .card-body {
            padding: 20px;
        }

        .statmodel-description {
            line-height: 1.8;
        }

        .statmodel-description p {
            margin-bottom: 15px;
            color: #333;
        }

        .statmodel-description ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .statmodel-description li {
            margin-bottom: 10px;
            color: #555;
        }

        .statmodel-description .note {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 12px 15px;
            margin-top: 15px;
            border-radius: 4px;
            color: #0c5460;
        }

        #statModelHypothesisStats,
        #statModelAnovaStats,
        #statModelRegressionStats,
        #statModelTimeseriesStats,
        #statModelClusteringStats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .stat-value {
            color: #f5576c;
            font-size: 24px;
            font-weight: 700;
        }

        .conclusion-card {
            background: linear-gradient(135deg, #ffecd2, #fcb69f);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .conclusion-card h4 {
            color: #333;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
        }

        .conclusion-card ul {
            margin: 0;
            padding-left: 20px;
        }

        .conclusion-card li {
            margin-bottom: 10px;
            color: #555;
        }

        .conclusion-card .highlight {
            color: #f5576c;
            font-weight: 600;
        }

        .conclusion-card .success {
            color: #28a745;
            font-weight: 600;
        }

        .conclusion-card .warning {
            color: #ffc107;
            font-weight: 600;
        }

        #monteCarloStats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        #monteCarloStats .stat-card {
            background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #monteCarloStats .stat-label {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }

        #monteCarloStats .stat-value {
            color: #667eea;
            font-size: 24px;
            font-weight: 700;
        }

        .recommendation-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .recommendation-item {
            background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .recommendation-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .recommendation-prob {
            font-size: 14px;
            color: #667eea;
            font-weight: 600;
        }

        .recommendation-numbers {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .recommendation-numbers .number-ball {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
        }

        .recommendation-details {
            font-size: 13px;
            color: #666;
        }

        .explanation-card, .formula-card, .steps-card, .results-card, .recommendation-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .explanation-card h3, .formula-card h3, .steps-card h3, .results-card h3, .recommendation-card h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .explanation-content, .formula-content, .steps-content, .results-content, .recommendation-content {
            color: #555;
            line-height: 1.8;
        }

        .explanation-content h4, .formula-content h4, .steps-content h4 {
            color: #34495e;
            margin: 20px 0 10px 0;
            font-size: 16px;
        }

        .explanation-content ul, .steps-content ul {
            padding-left: 20px;
        }

        .explanation-content li, .steps-content li {
            margin-bottom: 8px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }

        .warning-box i {
            color: #ffc107;
            margin-right: 8px;
        }

        .formula-section {
            margin-bottom: 30px;
        }

        .formula-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            margin-top: 10px;
        }

        .formula-box p {
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            font-size: 18px;
            color: #2c3e50;
        }

        .formula-desc {
            font-family: 'Arial', sans-serif !important;
            font-size: 14px !important;
            color: #666 !important;
        }

        .step-item {
            display: flex;
            margin-bottom: 20px;
            align-items: flex-start;
        }

        .step-number {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 18px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .step-content h4 {
            margin: 0 0 8px 0;
            color: #2c3e50;
        }

        .step-content p {
            margin: 0;
            color: #666;
        }

        #comboOptStats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        #comboOptStats .stat-card {
            background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #comboOptStats .stat-label {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }

        #comboOptStats .stat-value {
            color: #2c3e50;
            font-size: 24px;
            font-weight: 600;
        }

        #comboOptConclusion {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        #comboOptConclusion h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        #comboOptConclusion ul {
            margin: 0;
            padding-left: 20px;
        }

        #comboOptConclusion li {
            margin-bottom: 10px;
            color: #555;
        }

        #comboOptRecommendation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .recovery-analysis-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- 消息提示中心 -->
    <div class="message-center" id="messageCenter"></div>

    <!-- 设置弹窗 -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">系统设置</div>
                <span class="modal-close" id="closeSettings">&times;</span>
            </div>
            <div class="setting-group">
                <div class="setting-title">主题色设置</div>
                <div class="theme-options">
                    <div class="theme-option active" data-theme="ssq">双色球主题</div>
                    <div class="theme-option" data-theme="dlt">大乐透主题</div>
                    <div class="theme-option" data-theme="viz-light">数据可视化-光明模式</div>
                    <div class="theme-option" data-theme="viz-dark">数据可视化-暗黑模式</div>
                    <div class="theme-option" data-theme="business">简约商务主题</div>
                    <div class="theme-option" data-theme="tech">现代科技主题</div>
                    <div class="theme-option" data-theme="accessible">无障碍友好主题</div>
                    <div class="theme-option" data-theme="dark-comfort">暗黑护眼主题</div>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-title">数据存储方式</div>
                <div class="theme-options">
                    <div class="theme-option active" data-storage="localstorage">LocalStorage</div>
                    <div class="theme-option" data-storage="indexeddb">IndexedDB</div>
                </div>
            </div>
            <div class="content-actions" style="margin-top: 20px;">
                <button class="btn btn-primary" id="saveSettings">保存设置</button>
                <button class="btn btn-secondary" id="cancelSettings">取消</button>
            </div>
        </div>
    </div>

    <!-- 顶部导航栏 -->
    <header class="header">
        <div class="logo">
            <i class="fas fa-lottery-wheel logo-icon"></i>
            <span class="logo-text">智能彩票分析选号系统</span>
        </div>
        <nav class="top-menu">
            <div class="menu-left">
                <div class="lottery-type-selector">
                    <select id="lotteryTypeSelect" onchange="EventDelegate.handleLotteryTypeSelectChange(this.value)">
                        <option value="ssq">双色球</option>
                        <option value="dlt">大乐透</option>
                    </select>
                </div>
                <div class="menu-item active" data-page="home">首页</div>


                <div class="menu-item" data-page="ssq-database">双色球数据库</div>
                <div class="menu-item" data-page="dlt-database">大乐透数据库</div>
            </div>
            <div class="menu-right">
                <div class="menu-item" data-page="prize-level" id="prizeLevelBtn">奖级表</div>
                <div class="menu-item" data-page="refresh">刷新</div>
                <div class="menu-item" data-page="settings" id="settingsBtn">系统设置</div>
            </div>
        </nav>
    </header>

    <!-- 主容器 -->
    <div class="main-container">
        <!-- 侧边栏 -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">数据管理</div>
                <ul class="sidebar-menu">
                    <li class="active" data-submenu="jiuzhuan">
                        <i class="fas fa-sync-alt"></i>
                        <span>九转连环图</span>
                    </li>
                    <li data-submenu="dna-query">
                        <i class="fas fa-dna"></i>
                        <span>DNA查询</span>
                    </li>
                    <li data-submenu="selection-system">
                        <i class="fas fa-book"></i>
                        <span>选号系统</span>
                    </li>
                </ul>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">基础分析</div>
                <ul class="sidebar-menu">
                    <li data-submenu="frequency">
                        <i class="fas fa-chart-bar"></i>
                        <span>频率分析</span>
                    </li>
                    <li data-submenu="omission">
                        <i class="fas fa-chart-line"></i>
                        <span>遗漏分析</span>
                    </li>
                    <li data-submenu="follow-up">
                        <i class="fas fa-arrows-alt"></i>
                        <span>跟随分析</span>
                    </li>
                    <li data-submenu="number-distribution">
                        <i class="fas fa-chart-pie"></i>
                        <span>号码分布</span>
                    </li>
                    <li data-submenu="hot-cold">
                        <i class="fas fa-fire"></i>
                        <span>冷热分析</span>
                    </li>
                    <li data-submenu="odd-even">
                        <i class="fas fa-balance-scale"></i>
                        <span>奇偶分析</span>
                    </li>
                    <li data-submenu="big-small">
                        <i class="fas fa-ruler"></i>
                        <span>大小分析</span>
                    </li>
                    <li data-submenu="prime-composite">
                        <i class="fas fa-hashtag"></i>
                        <span>质合分析</span>
                    </li>
                    <li data-submenu="ac-value">
                        <i class="fas fa-calculator"></i>
                        <span>AC值分析</span>
                    </li>
                    <li data-submenu="three-zone">
                        <i class="fas fa-grip-horizontal"></i>
                        <span>大中小分析</span>
                    </li>
                </ul>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">高级分析</div>
                <ul class="sidebar-menu">
                    <li data-submenu="trend">
                        <i class="fas fa-chart-line"></i>
                        <span>趋势分析</span>
                    </li>
                    <li data-submenu="correlation">
                        <i class="fas fa-link"></i>
                        <span>相关性分析</span>
                    </li>
                    <li data-submenu="statistics">
                        <i class="fas fa-clipboard-list"></i>
                        <span>统计分析</span>
                    </li>
                    <li data-submenu="pattern">
                        <i class="fas fa-bullseye"></i>
                        <span>模式识别</span>
                    </li>
                    <li data-submenu="dna-analysis">
                        <i class="fas fa-vial"></i>
                        <span>DNA分析</span>
                    </li>
                    <li data-submenu="recovery">
                        <i class="fas fa-undo"></i>
                        <span>回补分析</span>
                    </li>
                    <li data-submenu="mandelbrot">
                        <i class="fas fa-theater-masks"></i>
                        <span>曼德尔定律</span>
                    </li>
                    <li data-submenu="fibonacci">
                        <i class="fas fa-infinity"></i>
                        <span>裴波那契分析</span>
                    </li>
                    <li data-submenu="monte-carlo">
                        <i class="fas fa-dice"></i>
                        <span>蒙特卡洛模拟</span>
                    </li>
                    <li data-submenu="stat-model">
                        <i class="fas fa-chart-bar"></i>
                        <span>统计学模型</span>
                    </li>
                    <li data-submenu="combo-opt">
                        <i class="fas fa-cogs"></i>
                        <span>组合优化算法</span>
                    </li>
                </ul>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">预测推荐</div>
                <ul class="sidebar-menu">
                    <li data-submenu="ai-recommend">
                        <i class="fas fa-robot"></i>
                        <span>智能推荐</span>
                    </li>
                    <li data-submenu="strategy">
                        <i class="fas fa-chess-knight"></i>
                        <span>选号策略</span>
                    </li>
                    <li data-submenu="warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>号码分析系统</span>
                    </li>
                    <li data-submenu="evaluation">
                        <i class="fas fa-check-circle"></i>
                        <span>推荐评估</span>
                    </li>
                </ul>
            </div>
        </aside>

        <!-- 主内容区 -->
        <main class="content-area">
            <!-- 面包屑导航 -->
            <div class="breadcrumb">
                <div class="breadcrumb-item active" data-page="home">首页</div>
            </div>

            <!-- 首页欢迎卡片 -->
            <div id="welcomeCard" class="content-card" style="display: block;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-home"></i> 浮玉升彩系统-铜钱版</h2>
                </div>
                <div class="content-body" style="padding: 0;">
                    <iframe src="index2026.01.29.html" style="width: 100%; height: calc(100vh - 200px); border: none;"></iframe>
                </div>
            </div>

            <!-- 选号系统内容区域 -->
            <div id="selectionSystemContainer" class="content-card" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-book"></i> 选号系统</h2>
                    <div class="content-actions">
                        <div class="condition-select-container">
                            <span style="font-weight: bold; color: var(--text-primary); margin-right: 10px;">条件选号：</span>
                            <div class="condition-item">
                                <label>和值：</label>
                                <input type="number" id="conditionSumMin" placeholder="最小" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                <span>-</span>
                                <input type="number" id="conditionSumMax" placeholder="最大" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                            </div>
                            <div class="condition-item">
                                <label>跨度：</label>
                                <input type="number" id="conditionSpanMin" placeholder="最小" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                <span>-</span>
                                <input type="number" id="conditionSpanMax" placeholder="最大" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                            </div>
                            <div class="condition-item">
                                <label>连号：</label>
                                <select id="conditionConsecutive" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                    <option value="">不限</option>
                                </select>
                            </div>
                            <div class="condition-item">
                                <label>大中小：</label>
                                <select id="conditionThreeZone" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                    <option value="">不限</option>
                                </select>
                            </div>
                            <div class="condition-item">
                                <label>奇偶：</label>
                                <select id="conditionOddEven" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                    <option value="">不限</option>
                                </select>
                            </div>
                            <div class="condition-item">
                                <label>AC值：</label>
                                <input type="number" id="conditionACMin" placeholder="最小" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                <span>-</span>
                                <input type="number" id="conditionACMax" placeholder="最大" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                            </div>
                            <div class="condition-item">
                                <label>大小比：</label>
                                <select id="conditionBigSmall" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                    <option value="">不限</option>
                                </select>
                            </div>
                            <div class="condition-item">
                                <label>质合比：</label>
                                <select id="conditionPrimeComposite" style="padding: 5px; border: 1px solid var(--border-color); border-radius: 4px;">
                                    <option value="">不限</option>
                                </select>
                            </div>
                            <button class="btn btn-warning" id="resetConditionBtn">🔄 重置</button>
                        </div>
                        <button class="btn btn-primary" id="randomSelectBtn">🎲 随机选号</button>
                        <button class="btn btn-info" id="luckyDrawBtn">🍀 幸运出号</button>
                        <button class="btn btn-secondary" id="clearSelectionBtn">🗑️ 清除选号</button>
                        <button class="btn btn-success" id="saveSelectionBtn">💾 保存选号</button>
                    </div>
                </div>

                <div class="selection-system-content">
                    <!-- 第一个容器：六阶幻方选号、四幻图选号、已选号码 -->
                    <div class="selection-container-1">
                        <div class="magic-square-section">
                            <div class="magic-square-main-container">
                                <div style="display: flex; gap: 20px; align-items: flex-start;">
                                    <div class="magic-squares-container">
                                        <div class="magic-square-group-with-title">
                                            <div class="magic-square-title" style="display: flex; justify-content: space-between; align-items: center;">
                                                <span>六阶幻方选号</span>
                                                <button class="btn btn-danger btn-sm" onclick="EventDelegate.randomSelectRedBalls()" title="机选红球">
                                                    <i class="fas fa-random"></i> 机选红球
                                                </button>
                                            </div>
                                            <div class="magic-square-group">
                                                <div class="magic-square-grid" id="redMagicSquare">
                                                    <!-- 六阶幻方红球将通过JavaScript动态生成 -->
                                                </div>
                                            </div>
                                        </div>

                                        <div class="magic-square-group-with-title">
                                            <div class="magic-square-title" style="display: flex; justify-content: space-between; align-items: center;">
                                                <span>四幻图选号</span>
                                                <button class="btn btn-sm" onclick="EventDelegate.randomSelectBlueBalls()" title="机选蓝球" style="background-color: #007bff; color: white; border: none;">
                                                    <i class="fas fa-random"></i> 机选蓝球
                                                </button>
                                            </div>
                                            <div class="magic-square-group">
                                                <div class="four-magic-square-grid" id="blueMagicSquare">
                                                    <!-- 四幻图蓝球将通过JavaScript动态生成 -->
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="selection-display-area">
                                        <div class="selection-header">
                                            <h4>已选号码</h4>
                                            <div class="selection-count" id="selectionCount">
                                                红球: 0/6 | 蓝球: 0/1
                                            </div>
                                        </div>
                                        <div class="selection-numbers" id="selectedNumbersDisplay">
                                            <div style="color: #6c757d;">尚未选择号码</div>
                                        </div>
                                    </div>

                                    <div class="selection-metrics-area">
                                        <div class="metrics-header">
                                            <h4>分析指标</h4>
                                        </div>
                                        <div class="metrics-content" id="selectionMetrics">
                                            <div style="color: #6c757d;">暂无数据</div>
                                        </div>
                                    </div>
                                </div>
                            </div>


                        </div>
                    </div>

                    <!-- 第二个容器：九转连环图 -->
                    <div class="selection-container-2">
                        <div class="selected-numbers-nine-ring" id="selectedNumbersNineRing">
                            <div class="jiuzhuan-content">
                              <div class="card-container">
                                <div class="canvas-card" id="selected-card-1">
                                  <h1 class="canvas-title">衡十七</h1>
                                  <canvas id="selected-circles-svg-1" width="560" height="560"></canvas>
                                </div>
                                <div class="canvas-card" id="selected-card-2">
                                  <h1 class="canvas-title">九为尊</h1>
                                  <canvas id="selected-circles-svg-2" width="560" height="560"></canvas>
                                </div>
                                <div class="canvas-card" id="selected-card-3">
                                  <h1 class="canvas-title">三十三</h1>
                                  <canvas id="selected-circles-svg-3" width="560" height="560"></canvas>
                                </div>
                              </div>
                            </div>
                        </div>
                    </div>

                    <!-- 第三个容器：号码库 -->
                    <div class="selection-container-3">
                        <div class="number-library-card">
                            <div class="library-toolbar">
                                <div class="library-status">
                                    <h4 style="margin: 0;">📚 号码库 (<span id="libraryCountDisplay">0</span>)</h4>
                                </div>
                                <div>
                                    <button id="selectAllLibraryBtn" class="btn btn-sm">
                                        ✅ 全选
                                    </button>
                                    <button id="deleteLibraryBtn" class="btn btn-sm btn-danger">
                                        🗑️ 批量删除
                                    </button>
                                </div>
                            </div>
                            <div class="library-items-container" id="numberLibraryContainer">
                                <div class="empty-library">
                                    <i class="fas fa-inbox"></i>
                                    <p>号码库为空，请先保存选号</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- DNA查询内容区域 -->
            <div id="dnaQueryContainer" class="content-card" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-dna"></i> DNA查询</h2>
                    <div class="content-actions">
                        <button class="btn btn-secondary" onclick="EventDelegate.refreshDNAQuery()">刷新</button>
                        <button class="btn btn-info" onclick="EventDelegate.showSampleData()">奖级对照表</button>
                    </div>
                </div>
                <div class="dna-query-tabs" style="display: flex; gap: 10px; margin: 15px 0; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                    <button class="dna-query-tab active" data-tab="dna">
                        <i class="fas fa-dna"></i> DNA查询
                    </button>
                    <button class="dna-query-tab" data-tab="same-period">
                        <i class="fas fa-calendar-alt"></i> 同期查询
                    </button>
                    <button class="dna-query-tab" data-tab="history-same-period">
                        <i class="fas fa-history"></i> 历史同期查询
                    </button>
                </div>
                <div class="dna-query-content">
                    <div id="dnaQueryPanel" class="dna-query-panel">
                        <div class="query-controls">
                            <div class="control-group">
                                <label for="dnaLotteryType">彩票类型:</label>
                                <select id="dnaLotteryType" class="form-control">
                                    <option value="ssq">双色球DNA</option>
                                    <option value="dlt">大乐透DNA</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="dnaQueryInput">输入号码:</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="dnaQueryInput" class="form-control" placeholder="双色球: 01 02 03 04 05 06 + 07&#10;大乐透: 01 02 03 04 05 + 06 07" style="flex: 1;">
                                    <button id="dnaRandomBtn" class="btn btn-secondary" title="随机生成号码">
                                        <i class="fas fa-random"></i> 随机
                                    </button>
                                    <button id="dnaHistoryBtn" class="btn btn-secondary" title="查询历史">
                                        <i class="fas fa-history"></i> 历史
                                    </button>
                                </div>
                                <small style="color: #6c757d; font-size: 12px;">
                                    <strong>双色球格式:</strong> 6个红球(1-33) + 1个蓝球(1-16)，例如: 01 02 03 04 05 06 + 07<br>
                                    <strong>大乐透格式:</strong> 5个前区(1-35) + 2个后区(1-12)，例如: 01 02 03 04 05 + 06 07<br>
                                    <strong>支持分隔符:</strong> 空格、逗号、加号
                                </small>
                            </div>
                            <button id="dnaQueryBtn" class="btn btn-primary">
                                <i class="fas fa-search"></i> 查询
                            </button>
                        </div>
                        <div id="dnaQueryResult" class="query-result"></div>
                    </div>
                    <div id="samePeriodQueryPanel" class="dna-query-panel" style="display: none;">
                        <div class="query-controls">
                            <div class="control-group">
                                <label for="samePeriodLotteryType">彩票类型:</label>
                                <select id="samePeriodLotteryType" class="form-control">
                                    <option value="ssq">双色球同期</option>
                                    <option value="dlt">大乐透同期</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="samePeriodInput">输入期号:</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="samePeriodInput" class="form-control" value="2025118" placeholder="例如: 2024001 或 2024-001" style="flex: 1;">
                                    <button id="samePeriodQueryBtn" class="btn btn-primary">
                                        <i class="fas fa-search"></i> 查询
                                    </button>
                                </div>
                                <small style="color: #6c757d; font-size: 12px;">
                                    <strong>输入格式:</strong> 年份+期号，例如: 2024001 或 2024-001<br>
                                    <strong>查询范围:</strong> 查询该期号及历史同期（同月同日）的开奖号码
                                </small>
                            </div>
                        </div>
                        <div id="samePeriodQueryResult" class="query-result"></div>
                    </div>
                    <div id="historySamePeriodQueryPanel" class="dna-query-panel" style="display: none;">
                        <div class="query-controls">
                            <div class="control-group">
                                <label for="historySamePeriodLotteryType">彩票类型:</label>
                                <select id="historySamePeriodLotteryType" class="form-control">
                                    <option value="ssq">双色球历史</option>
                                    <option value="dlt">大乐透历史</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="historySamePeriodInput">输入期号:</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="historySamePeriodInput" class="form-control" value="088" placeholder="例如: 001 或 2024-001" style="flex: 1;">
                                    <button id="historySamePeriodQueryBtn" class="btn btn-primary">
                                        <i class="fas fa-search"></i> 查询
                                    </button>
                                </div>
                                <small style="color: #6c757d; font-size: 12px;">
                                    <strong>输入格式:</strong> 期号（如：001）或 年份+期号（如：2024-001）<br>
                                    <strong>查询范围:</strong> 查询历史所有该期号的开奖数据（如输入001，查询所有年份的001期）
                                </small>
                            </div>
                        </div>
                        <div id="historySamePeriodQueryResult" class="query-result"></div>
                    </div>
                </div>
            </div>

            <!-- 频率分析卡片 -->
            <div class="content-card" id="frequencyCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-chart-bar"></i> 频率分析 <span id="dataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <span style="font-weight: bold; color: var(--text-primary); margin-right: 10px;">分析期数：</span>
                        <select id="periodSelect" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; min-width: 120px; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="analyzeBtn" style="margin-right: 20px;">开始分析频率</button>
                        <span style="font-weight: bold; color: var(--text-primary); margin-right: 10px;">排序方式：</span>
                        <button class="sort-btn active" data-sort="number" id="sortNumber" style="margin-right: 5px;">顺序</button>
                        <button class="sort-btn" data-sort="desc" id="sortDesc" style="margin-right: 5px;">降序</button>
                        <button class="sort-btn" data-sort="asc" id="sortAsc" style="margin-right: 15px;">升序</button>
                    </div>
                </div>

                <!-- 分析结果摘要 -->
                <div id="analysisSummary" style="margin: 15px 0; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--highlight-color);">
                    <h3 style="margin: 0 0 10px 0; color: var(--text-primary);">分析摘要</h3>
                    <div id="summaryContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <div style="padding: 10px; background: white; border-radius: 4px; border-left: 4px solid #E63946;">
                            <div style="font-size: 12px; color: var(--text-secondary);">分析期数</div>
                            <div id="totalPeriods" style="font-size: 20px; font-weight: bold; color: #E63946;">0</div>
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px; border-left: 4px solid #457B9D;">
                            <div style="font-size: 12px; color: var(--text-secondary);">红球热号</div>
                            <div id="hotRedBalls" style="font-size: 20px; font-weight: bold; color: #457B9D;">-</div>
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px; border-left: 4px solid #2A9D8F;">
                            <div style="font-size: 12px; color: var(--text-secondary);">蓝球热号</div>
                            <div id="hotBlueBalls" style="font-size: 20px; font-weight: bold; color: #2A9D8F;">-</div>
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px; border-left: 4px solid #F4A261;">
                            <div style="font-size: 12px; color: var(--text-secondary);">红球冷号</div>
                            <div id="coldRedBalls" style="font-size: 20px; font-weight: bold; color: #F4A261;">-</div>
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px; border-left: 4px solid #E76F51;">
                            <div style="font-size: 12px; color: var(--text-secondary);">蓝球冷号</div>
                            <div id="coldBlueBalls" style="font-size: 20px; font-weight: bold; color: #E76F51;">-</div>
                        </div>
                    </div>
                </div>

                <!-- 频率分析标签页 -->
                <div style="margin: 20px 0;">
                    <div class="frequency-tabs" style="display: flex; gap: 10px; margin-bottom: 20px;">
                        <button class="frequency-tab active" data-type="red">
                            <i class="fas fa-chart-bar" style="color: #E63946;"></i> 红球频率分析
                        </button>
                        <button class="frequency-tab" data-type="blue">
                            <i class="fas fa-chart-pie" style="color: #457B9D;"></i> 蓝球频率分析
                        </button>
                    </div>

                    <div class="chart-container" id="frequencyChart" style="height: 400px;"></div>
                </div>

                <!-- 频率趋势分析 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #2A9D8F; padding-left: 10px;">
                        <i class="fas fa-chart-line" style="color: #2A9D8F;"></i> 频率趋势分析
                    </h3>
                    <div class="chart-container" id="frequencyTrendChart" style="height: 350px;"></div>
                </div>

                <!-- 详细数据表格 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #00BBBB; padding-left: 10px;">
                        <i class="fas fa-table" style="color: #00BBBB;"></i> 详细数据
                    </h3>

                    <!-- 标签页切换 -->
                    <div style="margin-bottom: 15px; border-bottom: 2px solid var(--border-color);">
                        <button class="tab-btn active" data-tab="red" style="padding: 10px 20px; border: none; background: none; cursor: pointer; font-size: 14px; color: #E63946; font-weight: bold; border-bottom: 3px solid #E63946;">
                            <i class="fas fa-circle" style="color: #E63946; margin-right: 5px;"></i> 红球数据
                        </button>
                        <button class="tab-btn" data-tab="blue" style="padding: 10px 20px; border: none; background: none; cursor: pointer; font-size: 14px; color: var(--text-secondary); margin-left: 10px;">
                            <i class="fas fa-circle" style="color: #457B9D; margin-right: 5px;"></i> 蓝球数据
                        </button>
                    </div>

                    <!-- 排序选项 -->
                    <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 14px; color: var(--text-secondary);">排序方式：</span>
                        <select id="sortOption" style="padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px;">
                            <option value="number">按号码</option>
                            <option value="count">按出现次数</option>
                            <option value="frequency">按出现频率</option>
                            <option value="currentOmission">按当前遗漏</option>
                            <option value="avgOmission">按平均遗漏</option>
                            <option value="maxOmission">按最大遗漏</option>
                        </select>
                        <select id="sortOrder" style="padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px;">
                            <option value="asc">升序</option>
                            <option value="desc">降序</option>
                        </select>
                    </div>

                    <div style="overflow-x: auto;">
                        <table class="table" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">号码</th>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">出现次数</th>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">出现频率</th>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">当前遗漏</th>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">平均遗漏</th>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">最大遗漏</th>
                                    <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">状态</th>
                                </tr>
                            </thead>
                            <tbody id="frequencyTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- 趋势分析卡片 -->
            <div class="content-card" id="trendCard" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-chart-line"></i> 趋势分析 <span id="trendDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <span style="font-weight: bold; color: var(--text-primary); margin-right: 10px;">分析期数：</span>
                        <select id="trendPeriodSelect" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; min-width: 120px; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="analyzeTrendBtn" style="margin-right: 20px;">开始趋势分析</button>
                    </div>
                </div>

                <!-- 和值趋势分析 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #FF6B6B; padding-left: 10px;">
                        <i class="fas fa-chart-line" style="color: #FF6B6B;"></i> 和值趋势分析
                    </h3>
                    <div class="chart-container" id="sumTrendChart" style="height: 350px;"></div>
                </div>

                <!-- 跨度趋势分析 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #4ECDC4; padding-left: 10px;">
                        <i class="fas fa-chart-bar" style="color: #4ECDC4;"></i> 跨度趋势分析
                    </h3>
                    <div class="chart-container" id="spanTrendChart" style="height: 350px;"></div>
                </div>

                <!-- 奇偶比趋势分析 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #95E1D3; padding-left: 10px;">
                        <i class="fas fa-chart-pie" style="color: #95E1D3;"></i> 奇偶比趋势分析
                    </h3>
                    <div class="chart-container" id="oddEvenTrendChart" style="height: 350px;"></div>
                </div>

                <!-- 同尾号热力图 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #FFA07A; padding-left: 10px;">
                        <i class="fas fa-th" style="color: #FFA07A;"></i> 同尾号热力图
                    </h3>
                    <div class="chart-container" id="sameTailHeatmap" style="height: 400px;"></div>
                </div>

                <!-- 科学规律分析 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #DDA0DD; padding-left: 10px;">
                        <i class="fas fa-lightbulb" style="color: #DDA0DD;"></i> 科学规律分析
                    </h3>
                    <div id="trendPatternAnalysis" style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-top: 15px; color: #2c3e50; min-height: 100px;">
                        <div id="trendPatternInsights">点击"开始趋势分析"按钮查看详细分析结果</div>
                    </div>
                </div>

                <!-- 预测推荐 -->
                <div style="margin: 20px 0;">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary); border-left: 4px solid #20B2AA; padding-left: 10px;">
                        <i class="fas fa-magic" style="color: #20B2AA;"></i> 预测推荐
                    </h3>
                    <div id="trendPrediction" style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-top: 15px; color: #2c3e50; min-height: 100px;">
                        <div id="trendPredictionContent">点击"开始趋势分析"按钮查看预测推荐</div>
                    </div>
                </div>
            </div>

            <!-- 数据库管理卡片 -->
            <div class="content-card" id="databaseCard" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-database"></i> 彩票数据库管理 <span id="dataCountBadge" style="font-size: 14px; color: var(--text-secondary); margin-left: 10px;">(已加载0条数据)</span></h2>
                    <div class="content-actions">
                        <button class="btn btn-primary" id="importExcelBtn">导入Excel</button>
                        <button class="btn btn-success" id="addManualBtn">手动新增</button>
                        <button class="btn btn-warning" id="selectAllBtn">全选</button>
                        <button class="btn btn-danger" id="deleteSelectedBtn">批量删除</button>
                        <button class="btn btn-danger" id="clearDatabaseBtn" style="margin-left: 10px;">清空数据库</button>
                    </div>
                </div>

                <!-- 隐藏的文件输入框 -->
                <input type="file" id="excelFileInput" accept=".xlsx,.xls,.csv,.txt" style="display: none;">

                <!-- 手动输入区域 -->
                <div id="manualInputArea" style="display: none; margin: 15px 0; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px;">
                    <h3>手动输入数据</h3>
                    <textarea id="manualInput" placeholder="请输入数据，每行一条记录，格式：期号,开奖号码+蓝球号码，例如：2025135,01,02,05,09,25,32+10" 
                              style="width: 100%; height: 120px; padding: 10px; margin: 10px 0; border: 1px solid var(--border-color); border-radius: 4px;"></textarea>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-primary" id="confirmAddBtn">确认添加</button>
                        <button class="btn btn-secondary" id="cancelAddBtn">取消</button>
                    </div>
                </div>

                <!-- 数据表格 -->
                <div style="overflow-x: auto;">
                    <table class="table" style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color); width: 50px;">
                                    <input type="checkbox" id="selectAllCheckbox">
                                </th>
                                <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">期号</th>
                                <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">开奖号码</th>
                                <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">分析指标</th>
                                <th style="padding: 10px; border: 1px solid var(--border-color); background: var(--highlight-color);">操作</th>
                            </tr>
                        </thead>
                        <tbody id="databaseTableBody">
                            <!-- 数据行将通过JavaScript动态添加 -->
                        </tbody>
                    </table>
                </div>

                <!-- 分页控件 -->
                <div style="margin-top: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--highlight-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 14px;">每页显示：</span>
                            <select id="pageSizeSelect" style="padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px;">
                                <option value="10">10条</option>
                                <option value="20" selected>20条</option>
                                <option value="50">50条</option>
                                <option value="100">100条</option>
                            </select>
                            <span style="font-size: 14px; color: var(--text-secondary);">共 <span id="totalCount">0</span> 条数据</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <button class="btn btn-secondary" id="firstPageBtn" style="padding: 5px 10px; font-size: 12px;">首页</button>
                            <button class="btn btn-secondary" id="prevPageBtn" style="padding: 5px 10px; font-size: 12px;">上一页</button>
                            <span style="font-size: 14px; margin: 0 10px;">
                                第 <input type="number" id="currentPageInput" value="1" min="1" style="width: 50px; padding: 3px; text-align: center; border: 1px solid var(--border-color); border-radius: 4px;"> / <span id="totalPages">1</span> 页
                            </span>
                            <button class="btn btn-secondary" id="goPageBtn" style="padding: 5px 10px; font-size: 12px;">跳转</button>
                            <button class="btn btn-secondary" id="nextPageBtn" style="padding: 5px 10px; font-size: 12px;">下一页</button>
                            <button class="btn btn-secondary" id="lastPageBtn" style="padding: 5px 10px; font-size: 12px;">末页</button>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <p>当前数据量：<span id="dataCount">0</span> 条</p>
                    <div id="importStatus" style="margin-top: 10px; color: var(--text-secondary);"></div>
                </div>
            </div>

            <!-- 遗漏分析卡片 -->
            <div class="content-card" id="omissionCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-chart-line"></i> 遗漏分析 <span id="omissionDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select id="omissionPeriodSelect" class="form-control" style="width: auto; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部期数</option>
                        </select>
                        <button class="btn btn-primary" id="startOmissionAnalysis" style="margin-right: 10px;">开始遗漏分析</button>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: bold; color: var(--text-primary);">排序方式：</span>
                            <button class="sort-btn active" data-sort="number" id="sortNumberAsc">顺序</button>
                            <button class="sort-btn" data-sort="desc" id="sortOmissionDesc">降序</button>
                            <button class="sort-btn" data-sort="asc" id="sortOmissionAsc">升序</button>
                        </div>
                    </div>
                </div>
                <div class="omission-tabs">
                    <button class="omission-tab active" data-type="red">红球遗漏</button>
                    <button class="omission-tab" data-type="blue">蓝球遗漏</button>
                </div>
                <div class="chart-container" id="omissionChart"></div>
                <div class="omission-table-container">
                    <table class="omission-table">
                        <thead>
                            <tr>
                                <th>号码</th>
                                <th>当前遗漏</th>
                                <th>最大遗漏</th>
                                <th>平均遗漏</th>
                                <th>状态</th>
                                <th>实际开出次数</th>
                                <th>理论次数</th>
                                <th>出现概率(%)</th>
                                <th>欲出概率(%)</th>
                                <th>欲出等级</th>
                                <th>绝对偏差</th>
                                <th>相对偏差(%)</th>
                                <th>偏差状态</th>
                            </tr>
                        </thead>
                        <tbody id="omissionTableBody"></tbody>
                    </table>
                </div>
                <div class="omission-prediction" id="omissionPrediction"></div>
                <div class="omission-pattern-analysis" id="omissionPatternAnalysis">
                    <h3><i class="fas fa-lightbulb"></i> 科学规律分析</h3>
                    <div class="omission-pattern-tabs" style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                        <button class="omission-pattern-tab-btn active" data-type="trend">规律趋势</button>
                        <button class="omission-pattern-tab-btn" data-type="distribution">遗漏分布</button>
                        <button class="omission-pattern-tab-btn" data-type="status">号码状态</button>
                        <button class="omission-pattern-tab-btn" data-type="sequence">遗漏序列</button>
                        <button class="omission-pattern-tab-btn" data-type="evolution">遗漏演化</button>
                        <button class="omission-pattern-tab-btn" data-type="mutation">遗漏突变</button>
                        <button class="omission-pattern-tab-btn" data-type="diversity">遗漏多样性</button>
                        <button class="omission-pattern-tab-btn" data-type="mapping">遗漏映射</button>
                        <button class="omission-pattern-tab-btn" data-type="cycle">遗漏周期</button>
                        <button class="omission-pattern-tab-btn" data-type="correlation">遗漏相关性</button>
                        <button class="omission-pattern-tab-btn" data-type="prediction">遗漏预测</button>
                    </div>
                    <div class="pattern-chart-section">
                        <div class="pattern-chart-container" id="patternChart"></div>
                    </div>
                    <div class="pattern-insights-section">
                        <h4><i class="fas fa-chart-line"></i> 分析结论</h4>
                        <div class="pattern-insights" id="patternInsights"></div>
                    </div>
                </div>
            </div>

            <!-- 号码分布分析卡片 -->
            <div class="content-card" id="numberDistributionCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-chart-pie"></i> 号码分布分析 <span id="distributionDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <label style="color: white; margin-right: 10px;">分析期数：</label>
                        <select id="distributionPeriodSelect" style="padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部</option>
                        </select>
                        <button class="btn btn-primary" id="analyzeDistribution" style="margin-left: 10px;">开始号码分布</button>
                        <button class="btn btn-success" id="generateDistributionReport">生成报告</button>
                        <button class="btn btn-warning" id="exportDistributionChart">导出图表</button>
                    </div>
                </div>
                <div class="distribution-tabs" style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button class="distribution-tab active" data-type="density">号码密度</button>
                    <button class="distribution-tab" data-type="uniformity">均匀性</button>
                    <button class="distribution-tab" data-type="trend">历史趋势</button>
                    <button class="distribution-tab" data-type="comprehensive">综合分析</button>
                </div>
                <div class="chart-container" id="numberDistributionChart"></div>
                <div class="analysis-insights" id="distributionInsights" style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-top: 15px; color: #2c3e50; min-height: 100px;">
                    <h4 style="margin: 0 0 10px 0; color: #457B9D;">📊 分析结论</h4>
                    <div id="distributionInsightsContent">点击"开始分析"按钮查看详细分析结果</div>
                </div>
            </div>

            <!-- 冷热分析卡片 -->
            <div class="content-card" id="hotColdCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-fire"></i> 冷热分析 <span id="hotColdDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select id="hotColdPeriodSelect" class="form-control" style="width: auto; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部期数</option>
                        </select>
                        <button class="btn btn-primary" id="startHotColdAnalysis" style="margin-right: 10px;">开始冷热分析</button>
                        <button class="btn btn-secondary" id="refreshHotColdAnalysis">刷新分析</button>
                    </div>
                </div>

                <!-- 冷热分析标签页 -->
                <div class="hotcold-tabs">
                    <button class="hotcold-tab active" data-tab="single">单号码指标</button>
                    <button class="hotcold-tab" data-tab="interval">区间拆解</button>
                    <button class="hotcold-tab" data-tab="combination">组合特征</button>
                    <button class="hotcold-tab" data-tab="trend">趋势变化</button>
                </div>

                <!-- 单号码指标分析 -->
                <div class="hotcold-tab-content active" id="single-indicator">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="single-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">热号数量：</span>
                        <span class="info-value" id="single-hot-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">冷号数量：</span>
                        <span class="info-value" id="single-cold-count">-</span>
                    </div>
                    <div class="chart-container" id="singleIndicatorChart"></div>
                    <div class="analysis-conclusions" id="singleConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="singleConclusionContent"></div>
                    </div>
                </div>

                <!-- 区间拆解分析 -->
                <div class="hotcold-tab-content" id="interval-breakdown">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="interval-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">区间划分：</span>
                        <span class="info-value" id="interval-division">-</span>
                    </div>
                    <div class="chart-container" id="intervalDistributionChart"></div>
                    <div class="chart-container" id="intervalPieChart" style="height: 300px;"></div>
                    <div class="analysis-conclusions" id="intervalConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="intervalConclusionContent"></div>
                    </div>
                </div>

                <!-- 组合特征分析 -->
                <div class="hotcold-tab-content" id="combination-feature">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="combination-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">特征维度：</span>
                        <span class="info-value">频率、遗漏、连续性</span>
                    </div>
                    <div class="chart-container" id="combinationRadarChart"></div>
                    <div class="analysis-conclusions" id="combinationConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="combinationConclusionContent"></div>
                    </div>
                </div>

                <!-- 趋势变化分析 -->
                <div class="hotcold-tab-content" id="trend-change">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="trend-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">趋势周期：</span>
                        <span class="info-value" id="trend-cycle">-</span>
                    </div>
                    <div class="chart-container" id="trendHeatmapChart"></div>
                    <div class="analysis-conclusions" id="trendConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="trendConclusionContent"></div>
                    </div>
                </div>
            </div>

            <!-- 奇偶分析卡片 -->
            <div class="content-card" id="oddEvenCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-balance-scale"></i> 奇偶分析 <span id="oddEvenDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select id="oddEvenPeriodSelect" class="form-control" style="width: auto; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部期数</option>
                        </select>
                        <button class="btn btn-primary" id="startOddEvenAnalysis" style="margin-right: 10px;">开始奇偶分析</button>
                        <button class="btn btn-secondary" id="refreshOddEvenAnalysis">刷新分析</button>
                    </div>
                </div>

                <!-- 关键提醒 -->
                <div style="margin: 15px 0; padding: 12px; background: rgba(230, 57, 70, 0.1); border-left: 4px solid #E63946; border-radius: 4px;">
                    <strong style="color: #E63946;">⚠️ 关键提醒：</strong>
                    <ul style="margin: 8px 0 0 20px; color: #2c3e50; font-size: 14px;">
                        <li>奇偶比的 "热形态" 仅代表历史出现频次高，不意味着下期更易出现（比如 3:3 占比高，但单期出现概率仍约 25%）</li>
                        <li>极端奇偶比（0:6/6:0）虽罕见，但出现概率与其他形态无本质差异（随机事件）</li>
                        <li>奇偶分析的价值是 "拆解号码分布特征"，而非作为选号依据</li>
                    </ul>
                </div>

                <!-- 奇偶分析标签页 -->
                <div class="odd-even-tabs">
                    <button class="odd-even-tab active" data-tab="single">单奇偶号码指标</button>
                    <button class="odd-even-tab" data-tab="ratio">奇偶比分布</button>
                    <button class="odd-even-tab" data-tab="cross">交叉特征</button>
                    <button class="odd-even-tab" data-tab="trend">趋势变化</button>
                </div>

                <!-- 单奇偶号码指标分析 -->
                <div class="odd-even-tab-content active" id="odd-even-single">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="odd-single-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">奇数总频次：</span>
                        <span class="info-value" id="odd-single-odd-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">偶数总频次：</span>
                        <span class="info-value" id="odd-single-even-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">奇偶比：</span>
                        <span class="info-value" id="odd-single-ratio">-</span>
                    </div>
                    <div class="chart-container" id="oddSingleChart"></div>
                    <div class="analysis-conclusions" id="oddSingleConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="oddSingleConclusionContent"></div>
                    </div>
                </div>

                <!-- 奇偶比分布分析 -->
                <div class="odd-even-tab-content" id="odd-even-ratio">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="odd-ratio-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">高频形态：</span>
                        <span class="info-value" id="odd-ratio-high-freq">-</span>
                    </div>
                    <div class="chart-container" id="oddRatioPieChart" style="height: 400px;"></div>
                    <div class="chart-container" id="oddRatioBarChart" style="height: 400px;"></div>
                    <div class="analysis-conclusions" id="oddRatioConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="oddRatioConclusionContent"></div>
                    </div>
                </div>

                <!-- 交叉特征分析 -->
                <div class="odd-even-tab-content" id="odd-even-cross">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="odd-cross-period-count">-</span>
                    </div>
                    <div class="chart-container" id="oddCrossChart" style="height: 500px;"></div>
                    <div class="analysis-conclusions" id="oddCrossConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="oddCrossConclusionContent"></div>
                    </div>
                </div>

                <!-- 趋势变化分析 -->
                <div class="odd-even-tab-content" id="odd-even-trend">
                    <div class="analysis-info">
                        <span class="info-label">分析期数：</span>
                        <span class="info-value" id="odd-trend-period-count">-</span>
                        <span class="info-divider">|</span>
                        <span class="info-label">趋势方向：</span>
                        <span class="info-value" id="odd-trend-direction">-</span>
                    </div>
                    <div class="chart-container" id="oddTrendChart"></div>
                    <div class="analysis-conclusions" id="oddTrendConclusions">
                        <h4>历史统计特征</h4>
                        <div class="conclusion-content" id="oddTrendConclusionContent"></div>
                    </div>
                </div>
            </div>

            <!-- 大小分析卡片 -->
            <div class="content-card" id="bigSmallCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-expand-arrows-alt"></i> 大小分析 <span id="bigSmallDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select id="bigSmallPeriodSelect" class="form-control" style="width: auto; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部期数</option>
                        </select>
                        <button class="btn btn-primary" id="startBigSmallAnalysis">开始大小分析</button>
                    </div>
                </div>

                <!-- 关键提醒 -->
                <div style="margin: 15px 0; padding: 12px; background: rgba(230, 57, 70, 0.1); border-left: 4px solid #E63946; border-radius: 4px;">
                    <strong style="color: #E63946;">⚠️ 关键提醒：</strong>
                    <ul style="margin: 8px 0 0 20px; color: #2c3e50; font-size: 14px;">
                        <li>大小比的 "热形态" 仅代表历史出现频次高，不意味着下期更易出现（比如 3:3 占比高，但单期出现概率仍约 25%）</li>
                        <li>极端大小比（0:6/6:0）虽罕见，但出现概率与其他形态无本质差异（随机事件）</li>
                        <li>大小分析的价值是 "拆解号码分布特征"，而非作为选号依据</li>
                        <li>务必将大小分析与奇偶、区间、和值等其他维度结合，形成综合判断</li>
                    </ul>
                </div>

                <!-- 大小分析标签页 -->
                <div class="big-small-tabs">
                    <button class="big-small-tab active" data-tab="overview">概览视图</button>
                    <button class="big-small-tab" data-tab="trend">趋势视图</button>
                    <button class="big-small-tab" data-tab="distribution">分布视图</button>
                    <button class="big-small-tab" data-tab="status">状态视图</button>
                    <button class="big-small-tab" data-tab="strategy">策略推荐</button>
                </div>

                <!-- 概览视图 -->
                <div class="big-small-tab-content active" id="big-small-overview">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="bigSmallAnalysisPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">大号总数</span>
                                <span class="info-value" id="bigSmallBigCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">小号总数</span>
                                <span class="info-value" id="bigSmallSmallCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">大号占比</span>
                                <span class="info-value" id="bigSmallBigRatio">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">小号占比</span>
                                <span class="info-value" id="bigSmallSmallRatio">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="bigSmallPieChart" style="height: 400px;"></div>
                </div>

                <!-- 趋势视图 -->
                <div class="big-small-tab-content" id="big-small-trend">
                    <div class="chart-container" id="bigSmallTrendChart" style="height: 500px;"></div>
                </div>

                <!-- 分布视图 -->
                <div class="big-small-tab-content" id="big-small-distribution">
                    <div class="chart-container" id="bigSmallHeatmapChart" style="height: 400px;"></div>
                    <div class="chart-container" id="bigSmallStackedChart" style="height: 400px;"></div>
                </div>

                <!-- 状态视图 -->
                <div class="big-small-tab-content" id="big-small-status">
                    <div class="chart-container" id="bigSmallStatusChart" style="height: 400px;"></div>
                    <div class="status-table">
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>号码</th>
                                    <th>类型</th>
                                    <th>出现次数</th>
                                    <th>当前遗漏</th>
                                    <th>平均遗漏</th>
                                    <th>最大遗漏</th>
                                    <th>状态</th>
                                </tr>
                            </thead>
                            <tbody id="bigSmallStatusTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- 策略推荐 -->
                <div class="big-small-tab-content" id="big-small-strategy">
                    <div class="strategy-content">
                        <h3>智能策略分析</h3>
                        <div id="bigSmallStrategyContent"></div>
                    </div>
                </div>
            </div>

            <!-- 质合分析卡片 -->
            <div class="content-card" id="primeCompositeCardV1">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-calculator"></i> 质合分析 <span id="primeCompositeDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select id="primeCompositePeriodSelectV1" class="form-control" style="width: auto; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部期数</option>
                        </select>
                        <button class="btn btn-primary" id="startPrimeCompositeAnalysisV1">开始质合分析</button>
                    </div>
                </div>

                <div class="prime-composite-tabs">
                    <button class="prime-composite-tab active" data-tab="overview">概览视图</button>
                    <button class="prime-composite-tab" data-tab="trend">趋势视图</button>
                    <button class="prime-composite-tab" data-tab="distribution">分布视图</button>
                    <button class="prime-composite-tab" data-tab="strategy">策略推荐</button>
                </div>

                <!-- 概览视图 -->
                <div class="prime-composite-tab-content active" id="prime-composite-overview">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="primeCompositeAnalysisPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">质数总数</span>
                                <span class="info-value" id="primeCompositePrimeCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">合数总数</span>
                                <span class="info-value" id="primeCompositeCompositeCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">质数占比</span>
                                <span class="info-value" id="primeCompositePrimeRatio">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">合数占比</span>
                                <span class="info-value" id="primeCompositeCompositeRatio">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="primeCompositePieChart" style="height: 400px;"></div>

                    <div class="statistics-section">
                        <h5>自动统计关键指标</h5>
                        <div id="primeCompositeStatisticsContent"></div>
                    </div>
                </div>

                <!-- 趋势视图 -->
                <div class="prime-composite-tab-content" id="prime-composite-trend">
                    <div class="trend-analysis-header">
                        <h4>质合趋势分析</h4>
                        <div class="trend-legend">
                            <div class="legend-item">
                                <span class="legend-color legend-prime"></span>
                                <span>质数趋势</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color legend-composite"></span>
                                <span>合数趋势</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="primeCompositeTrendChart" style="height: 500px;"></div>
                    <div class="trend-insights">
                        <h5>趋势洞察</h5>
                        <div id="trendInsightsContent"></div>
                    </div>
                </div>

                <!-- 分布视图 -->
                <div class="prime-composite-tab-content" id="prime-composite-distribution">
                    <div class="distribution-analysis-header">
                        <h4>质合分布分析</h4>
                        <div class="distribution-legend">
                            <div class="legend-item">
                                <span class="legend-color legend-prime"></span>
                                <span>质数分布</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color legend-composite"></span>
                                <span>合数分布</span>
                            </div>
                        </div>
                        <div class="distribution-actions">
                            <button class="btn btn-primary" id="exportPrimeCompositeReport" onclick="PrimeCompositeAnalysis.exportPrimeCompositeReport()">
                                <span class="btn-icon">📊</span>
                                <span class="btn-text">导出分析报告</span>
                            </button>
                        </div>
                    </div>
                    <div class="distribution-chart-grid">
                        <div class="distribution-chart-item full-width">
                            <div class="chart-title">
                                <h5>质合组合频次柱状图（核心图表）</h5>
                                <span class="chart-subtitle">展示不同质合个数组合的历史出现频次</span>
                            </div>
                            <div class="chart-container" id="primeCompositeCombinationChart" style="height: 400px;"></div>
                        </div>
                        <div class="distribution-chart-item">
                            <div class="chart-title">
                                <h5>号码类型热力图</h5>
                                <span class="chart-subtitle">展示33个号码的质合类型分布</span>
                            </div>
                            <div class="chart-container" id="primeCompositeHeatmapChart" style="height: 400px;"></div>
                        </div>
                        <div class="distribution-chart-item">
                            <div class="chart-title">
                                <h5>区间分布堆叠图</h5>
                                <span class="chart-subtitle">展示各区间质合数量对比</span>
                            </div>
                            <div class="chart-container" id="primeCompositeStackedChart" style="height: 400px;"></div>
                        </div>
                    </div>
                    <div class="distribution-insights">
                        <h5>分布洞察</h5>
                        <div id="primeCompositeDistributionInsightsContent"></div>
                    </div>
                    <div class="distribution-conclusion">
                        <h5>综合分析结论</h5>
                        <div id="primeCompositeConclusionContentV1"></div>
                    </div>
                </div>

                <!-- 策略推荐 -->
                <div class="prime-composite-tab-content" id="prime-composite-strategy">
                    <div class="strategy-content">
                        <h3>智能策略分析</h3>
                        <div id="primeCompositeStrategyContent"></div>
                    </div>
                </div>
            </div>

            <!-- AC值分析卡片 -->
            <div class="content-card" id="acValueCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-wave-square"></i> AC值分析 <span id="acValueDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="acValuePeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startAcValueAnalysis" style="margin-right: 10px;">开始AC值分析</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="acValueChartTabs">
                    <button class="chart-tab-btn active" data-type="bar">频次分布</button>
                    <button class="chart-tab-btn" data-type="line">趋势变化</button>
                    <button class="chart-tab-btn" data-type="pie">区间占比</button>
                    <button class="chart-tab-btn" data-type="scatter">关联分析</button>
                </div>

                <!-- 图表容器 -->
                <div class="chart-container" id="acValueChart" style="height: 400px;"></div>

                <!-- 分析结论 -->
                <div class="analysis-conclusion" id="acValueConclusion">
                    <h3><i class="fas fa-chart-line"></i> 分析结论</h3>
                    <div id="acValueConclusionContent"></div>
                </div>

                <!-- 推荐号码 -->
                <div class="recommendation-section" id="acValueRecommendation">
                    <h3><i class="fas fa-lightbulb"></i> 号码推荐</h3>
                    <div class="recommendation-controls">
                        <label>目标AC值范围：</label>
                        <input type="number" id="acValueMinRange" min="0" max="10" value="5" style="width: 60px;">
                        <span>-</span>
                        <input type="number" id="acValueMaxRange" min="0" max="10" value="7" style="width: 60px;">
                        <button class="btn btn-primary" id="generateAcValueRecommendation" style="margin-left: 10px;">生成推荐</button>
                    </div>
                    <div id="acValueRecommendationContent"></div>
                </div>
            </div>

            <!-- 大中小分析卡片 -->
            <div class="content-card" id="threeZoneCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-th-large"></i> 大中小分析 <span id="threeZoneDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="threeZonePeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startThreeZoneAnalysis" style="margin-right: 10px;">开始大中小分析</button>
                        <button class="btn btn-secondary" id="enableChartLinkage" style="margin-right: 10px;">启用图表联动</button>
                        <button class="btn btn-info" id="generateLinkageReport">生成联动报告</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="threeZoneChartTabs">
                    <div class="chart-tab active" data-chart-type="stackedBar" data-tooltip="查看每期大中小出号数量分布">
                        <i class="fas fa-chart-bar"></i>
                        <span>大中小分布</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="line" data-tooltip="查看各区间出号数变化趋势">
                        <i class="fas fa-chart-line"></i>
                        <span>趋势变化</span>
                    </div>
                    <div class="chart-tab" data-chart-type="pie" data-tooltip="查看大中小出号总数占比">
                        <i class="fas fa-chart-pie"></i>
                        <span>区间占比</span>
                    </div>
                    <div class="chart-tab" data-chart-type="scatter" data-tooltip="查看大中小出号组合与AC值关联">
                        <i class="fas fa-braille"></i>
                        <span>AC值关联</span>
                        <span class="tab-badge">联动</span>
                    </div>
                </div>

                <!-- 图表容器 -->
                <div class="chart-container" id="threeZoneChart" style="height: 400px;"></div>

                <!-- 分析结论 -->
                <div class="analysis-conclusion" id="threeZoneConclusion">
                    <h3><i class="fas fa-chart-bar"></i> 分析结论</h3>
                    <div id="threeZoneConclusionContent"></div>
                </div>

                <!-- 推荐区域 -->
                <div class="recommendation-section" id="threeZoneRecommendation">
                    <h3><i class="fas fa-lightbulb"></i> 号码推荐</h3>
                    <div class="recommendation-controls">
                        <button class="btn btn-primary" id="generateThreeZoneRecommendation">生成推荐</button>
                    </div>
                    <div id="threeZoneRecommendationContent"></div>
                </div>
            </div>

            <!-- 跟随分析卡片 -->
            <div class="content-card" id="followUpCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-arrows-alt"></i> 跟随分析 <span id="followUpDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="followUpPeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startFollowUpAnalysis" style="margin-right: 10px;">开始跟随分析</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="followUpChartTabs">
                    <div class="chart-tab active" data-chart-type="scatter" data-tooltip="查看号码的离散程度">
                        <i class="fas fa-braille"></i>
                        <span>散度分析</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="bar" data-tooltip="查看号码分布偏态">
                        <i class="fas fa-chart-bar"></i>
                        <span>偏态分析</span>
                    </div>
                    <div class="chart-tab" data-chart-type="line" data-tooltip="查看号码出现间隔振幅">
                        <i class="fas fa-chart-line"></i>
                        <span>振幅分析</span>
                    </div>
                    <div class="chart-tab" data-chart-type="network" data-tooltip="查看号码跟随关系">
                        <i class="fas fa-project-diagram"></i>
                        <span>跟随分析</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="pie" data-tooltip="查看重号邻号隔号分布">
                        <i class="fas fa-chart-pie"></i>
                        <span>重号邻号隔号</span>
                    </div>
                    <div class="chart-tab" data-chart-type="trend" data-tooltip="查看龙头凤尾走势">
                        <i class="fas fa-chart-line"></i>
                        <span>龙头凤尾</span>
                    </div>
                </div>

                <!-- 图表容器 -->
                <div class="chart-container" id="followUpChart" style="height: 400px;"></div>

                    <!-- 跟随分析结果展示 -->
                    <div id="followUpAnalysisResults" style="display: none;">
                        <!-- 强跟随关系表格 -->
                        <div class="follow-up-section">
                            <h3><i class="fas fa-list-ol"></i> 强跟随关系（跟随次数≥3）</h3>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>源号码</th>
                                        <th>跟随目标号码</th>
                                    </tr>
                                </thead>
                                <tbody id="followUpTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- 蓝球跟随关系 -->
                    <div class="follow-up-section" id="blueFollowSection" style="display: none;">
                        <h3><i class="fas fa-circle" style="color: #1E88E5;"></i> 蓝球跟随关系</h3>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>源号码</th>
                                        <th>跟随目标号码</th>
                                    </tr>
                                </thead>
                                <tbody id="blueFollowTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- 跟随矩阵热力图 -->
                    <div class="follow-up-section">
                        <h3><i class="fas fa-th"></i> 跟随矩阵热力图</h3>
                        <div class="chart-container" id="followUpHeatmap" style="height: 500px;"></div>
                    </div>

                    <!-- 综合评分结果 -->
                    <div class="follow-up-section" id="comprehensiveScoreSection" style="display: none;">
                        <h3><i class="fas fa-trophy"></i> 综合评分排名 - 最终关注号码</h3>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>排名</th>
                                        <th>目标号码</th>
                                        <th>综合得分</th>
                                        <th>跟随概率分</th>
                                        <th>遗漏加分</th>
                                        <th>邻号隔号分</th>
                                        <th>热态加分</th>
                                        <th>三周期验证</th>
                                        <th>推荐理由</th>
                                    </tr>
                                </thead>
                                <tbody id="comprehensiveScoreTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- 跟随推荐 -->
                    <div class="follow-up-section">
                        <h3><i class="fas fa-lightbulb"></i> 基于跟随关系的推荐</h3>
                        <div id="followUpRecommendations"></div>
                    </div>
                </div>

                <!-- 分析结论 -->
                <div class="analysis-conclusion" id="followUpConclusion">
                    <h3><i class="fas fa-chart-bar"></i> 分析结论</h3>
                    <div id="followUpConclusionContent"></div>
                </div>
            </div>

            <!-- 质合分析卡片 -->
            <div class="content-card" id="primeCompositeCard">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-calculator"></i> 质合分析</h2>
                    <div class="content-actions">
                        <select class="form-control" id="primeCompositePeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30">最近30期</option>
                            <option value="50" selected>最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startPrimeCompositeAnalysis" style="margin-right: 10px;">开始质合分析</button>
                        <button class="btn btn-secondary" id="enablePrimeCompositeLinkage" style="margin-right: 10px;">启用图表联动</button>
                        <button class="btn btn-info" id="generatePrimeCompositeLinkageReport">生成联动报告</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="primeCompositeChartTabs">
                    <div class="chart-tab active" data-chart-type="bar" data-tooltip="查看不同质合组合的历史出现频次">
                        <i class="fas fa-chart-bar"></i>
                        <span>质合组合</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="line" data-tooltip="查看质数个数的变化趋势">
                        <i class="fas fa-chart-line"></i>
                        <span>趋势变化</span>
                    </div>
                    <div class="chart-tab" data-chart-type="pie" data-tooltip="查看质数/合数总占比">
                        <i class="fas fa-chart-pie"></i>
                        <span>质合占比</span>
                    </div>
                    <div class="chart-tab" data-chart-type="heatmap" data-tooltip="查看质合×三区×AC值的关联">
                        <i class="fas fa-fire"></i>
                        <span>联动热力图</span>
                        <span class="tab-badge">联动</span>
                    </div>
                </div>

                <!-- 图表容器 -->
                <div class="chart-container" id="primeCompositeChart" style="height: 400px;"></div>

                <!-- 分析结论 -->
                <div class="analysis-conclusion" id="primeCompositeConclusion">
                    <h3><i class="fas fa-chart-bar"></i> 分析结论</h3>
                    <div id="primeCompositeConclusionContent"></div>
                </div>

                <!-- 推荐区域 -->
                <div class="recommendation-section" id="primeCompositeRecommendation">
                    <h3><i class="fas fa-lightbulb"></i> 号码推荐</h3>
                    <div class="recommendation-controls">
                        <label>推荐模式：</label>
                        <select class="form-control" id="primeCompositeRecommendationMode" style="width: 200px; display: inline-block;">
                            <option value="primeCompositeOnly">仅按质合推荐</option>
                            <option value="primeCompositeWithZone">质合 + 三区联动推荐</option>
                            <option value="primeCompositeWithAC">质合 + AC值联动推荐</option>
                            <option value="primeCompositeWithZoneAndAC">质合 + 三区 + AC值综合推荐</option>
                        </select>
                        <label style="margin-left: 20px;">目标质合组合：</label>
                        <select class="form-control" id="primeCompositeTargetCombination" style="width: 150px; display: inline-block;">
                            <option value="">自动选择高频组合</option>
                        </select>
                        <button class="btn btn-primary" id="generatePrimeCompositeRecommendation" style="margin-left: 10px;">生成推荐</button>
                    </div>
                    <div id="primeCompositeRecommendationContent"></div>
                </div>
            </div>

            <!-- 相关性分析卡片 -->
            <div class="content-card" id="correlationCard" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-link"></i> 相关性分析 <span id="correlationDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="correlationPeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startCorrelationAnalysis" style="margin-right: 10px;">开始相关性分析</button>
                        <button class="btn btn-secondary" id="exportCorrelationReport" style="margin-right: 10px;">导出分析报告</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="correlationChartTabs">
                    <div class="chart-tab active" data-chart-type="heatmap" data-tooltip="查看号码之间的相关性热力图">
                        <i class="fas fa-th"></i>
                        <span>号码相关性</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="scatter" data-tooltip="查看维度之间的相关性散点图">
                        <i class="fas fa-braille"></i>
                        <span>维度相关性</span>
                    </div>
                    <div class="chart-tab" data-chart-type="network" data-tooltip="查看号码关联网络图">
                        <i class="fas fa-project-diagram"></i>
                        <span>关联网络</span>
                        <span class="tab-badge">高级</span>
                    </div>
                </div>

                <!-- 号码相关性热力图 -->
                <div class="correlation-chart-content" id="correlation-heatmap" style="display: block;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="correlationAnalysisPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最强相关对</span>
                                <span class="info-value" id="correlationStrongestPair">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">相关系数</span>
                                <span class="info-value" id="correlationStrongestValue">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">高相关对数</span>
                                <span class="info-value" id="correlationHighCount">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="correlationHeatmapChart" style="height: 600px;"></div>
                </div>

                <!-- 维度相关性散点图 -->
                <div class="correlation-chart-content" id="correlation-scatter" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="correlationScatterPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最强维度相关</span>
                                <span class="info-value" id="correlationStrongestDimension">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">相关系数</span>
                                <span class="info-value" id="correlationStrongestDimValue">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="correlationScatterChart" style="height: 600px;"></div>
                </div>

                <!-- 关联网络图 -->
                <div class="correlation-chart-content" id="correlation-network" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="correlationNetworkPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">节点数量</span>
                                <span class="info-value" id="correlationNodeCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">连线数量</span>
                                <span class="info-value" id="correlationEdgeCount">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="correlationNetworkChart" style="height: 600px;"></div>
                </div>

                <!-- 分析结论 -->
                <div class="analysis-conclusion" id="correlationConclusion">
                    <h3><i class="fas fa-chart-line"></i> 分析结论</h3>
                    <div id="correlationConclusionContent"></div>
                </div>

                <!-- 推荐区域 -->
                <div class="recommendation-section" id="correlationRecommendation">
                    <h3><i class="fas fa-lightbulb"></i> 号码推荐</h3>
                    <div class="recommendation-controls">
                        <label>推荐模式：</label>
                        <select class="form-control" id="correlationRecommendationMode" style="width: 200px; display: inline-block;">
                            <option value="highCorrelation">基于高相关对</option>
                            <option value="lowCorrelation">基于低相关对</option>
                            <option value="balanced">平衡推荐</option>
                        </select>
                        <label style="margin-left: 20px;">相关系数阈值：</label>
                        <input type="number" id="correlationThreshold" min="0" max="1" step="0.1" value="0.5" style="width: 80px; display: inline-block;">
                        <button class="btn btn-primary" id="generateCorrelationRecommendation" style="margin-left: 10px;">生成推荐</button>
                    </div>
                    <div id="correlationRecommendationContent"></div>
                </div>
            </div>

            <!-- 统计分析卡片 -->
            <div class="content-card" id="statisticsCard" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-clipboard-list"></i> 统计分析 <span id="statisticsDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="statisticsPeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startStatisticsAnalysis" style="margin-right: 10px;">开始统计分析</button>
                        <button class="btn btn-secondary" id="exportStatisticsReport" style="margin-right: 10px;">导出分析报告</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="statisticsChartTabs">
                    <div class="chart-tab active" data-chart-type="trend" data-tooltip="查看各项统计指标的变化趋势">
                        <i class="fas fa-chart-line"></i>
                        <span>统计趋势</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="distribution" data-tooltip="查看统计数据的分布情况">
                        <i class="fas fa-chart-bar"></i>
                        <span>数据分布</span>
                    </div>
                    <div class="chart-tab" data-chart-type="comparison" data-tooltip="对比不同时期的统计指标">
                        <i class="fas fa-chart-area"></i>
                        <span>时期对比</span>
                    </div>
                    <div class="chart-tab" data-chart-type="heatmap" data-tooltip="查看统计指标之间的关联热力图">
                        <i class="fas fa-fire"></i>
                        <span>指标关联</span>
                        <span class="tab-badge">高级</span>
                    </div>
                </div>

                <!-- 统计趋势图 -->
                <div class="statistics-chart-content" id="statistics-trend" style="display: block;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="statisticsTrendPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">平均和值</span>
                                <span class="info-value" id="statisticsAvgSum">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">平均跨度</span>
                                <span class="info-value" id="statisticsAvgSpan">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">平均AC值</span>
                                <span class="info-value" id="statisticsAvgAC">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="statisticsTrendChart" style="height: 600px;"></div>
                </div>

                <!-- 数据分布图 -->
                <div class="statistics-chart-content" id="statistics-distribution" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="statisticsDistributionPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">标准差</span>
                                <span class="info-value" id="statisticsStdDev">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">中位数</span>
                                <span class="info-value" id="statisticsMedian">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">众数</span>
                                <span class="info-value" id="statisticsMode">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="statisticsDistributionChart" style="height: 600px;"></div>
                </div>

                <!-- 时期对比图 -->
                <div class="statistics-chart-content" id="statistics-comparison" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">对比期数1</span>
                                <span class="info-value" id="statisticsComparisonPeriod1">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">对比期数2</span>
                                <span class="info-value" id="statisticsComparisonPeriod2">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">变化幅度</span>
                                <span class="info-value" id="statisticsChangeRate">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="statisticsComparisonChart" style="height: 600px;"></div>
                </div>

                <!-- 指标关联热力图 -->
                <div class="statistics-chart-content" id="statistics-heatmap" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="statisticsHeatmapPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最强关联</span>
                                <span class="info-value" id="statisticsStrongestLinkage">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">关联系数</span>
                                <span class="info-value" id="statisticsLinkageCoeff">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="statisticsHeatmapChart" style="height: 600px;"></div>
                </div>

                <!-- 科学分析结论 -->
                <div class="analysis-conclusion" id="statisticsConclusion">
                    <h3><i class="fas fa-chart-line"></i> 科学分析结论</h3>
                    <div id="statisticsConclusionContent"></div>
                </div>

                <!-- 规律发现 -->
                <div class="pattern-discovery" id="statisticsPatternDiscovery">
                    <h3><i class="fas fa-lightbulb"></i> 规律发现</h3>
                    <div id="statisticsPatternContent"></div>
                </div>

                <!-- 分析结果展示 -->
                <div class="analysis-results" id="statisticsResults">
                    <h3><i class="fas fa-clipboard-check"></i> 分析结果展示</h3>
                    <div class="results-controls">
                        <label>展示模式：</label>
                        <select class="form-control" id="statisticsResultsMode" style="width: 200px; display: inline-block;">
                            <option value="summary">摘要模式</option>
                            <option value="detailed">详细模式</option>
                            <option value="recommendation">推荐模式</option>
                        </select>
                        <button class="btn btn-primary" id="generateStatisticsResults" style="margin-left: 10px;">生成结果</button>
                    </div>
                    <div id="statisticsResultsContent"></div>
                </div>
            </div>

            <!-- 模式识别卡片 -->
            <div class="content-card" id="patternRecognitionCard" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-fingerprint"></i> 模式识别 <span id="patternRecognitionDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="patternRecognitionPeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startPatternRecognition" style="margin-right: 10px;">开始模式识别</button>
                        <button class="btn btn-secondary" id="exportPatternReport" style="margin-right: 10px;">导出分析报告</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="patternRecognitionChartTabs">
                    <div class="chart-tab active" data-chart-type="sequence" data-tooltip="查看序列模式识别结果">
                        <i class="fas fa-sort-numeric-up"></i>
                        <span>序列模式</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="periodic" data-tooltip="查看周期性模式识别结果">
                        <i class="fas fa-sync-alt"></i>
                        <span>周期模式</span>
                    </div>
                    <div class="chart-tab" data-chart-type="morphology" data-tooltip="查看形态模式识别结果">
                        <i class="fas fa-shapes"></i>
                        <span>形态模式</span>
                    </div>
                    <div class="chart-tab" data-chart-type="repetition" data-tooltip="查看重复模式识别结果">
                        <i class="fas fa-redo"></i>
                        <span>重复模式</span>
                        <span class="tab-badge">高级</span>
                    </div>
                    <div class="chart-tab" data-chart-type="jump" data-tooltip="查看跳跃模式识别结果">
                        <i class="fas fa-random"></i>
                        <span>跳跃模式</span>
                    </div>
                </div>

                <!-- 序列模式识别 -->
                <div class="pattern-recognition-chart-content" id="pattern-sequence" style="display: block;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="patternSequencePeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">连续号码模式</span>
                                <span class="info-value" id="patternConsecutiveCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">等差数列模式</span>
                                <span class="info-value" id="patternArithmeticCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">等比数列模式</span>
                                <span class="info-value" id="patternGeometricCount">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="patternSequenceChart" style="height: 600px;"></div>
                </div>

                <!-- 周期性模式识别 -->
                <div class="pattern-recognition-chart-content" id="pattern-periodic" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="patternPeriodicPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最强周期</span>
                                <span class="info-value" id="patternStrongestPeriod">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">周期置信度</span>
                                <span class="info-value" id="patternPeriodConfidence">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">周期模式数</span>
                                <span class="info-value" id="patternPeriodCount">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="patternPeriodicChart" style="height: 600px;"></div>
                </div>

                <!-- 形态模式识别 -->
                <div class="pattern-recognition-chart-content" id="pattern-morphology" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="patternMorphologyPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">对称形态</span>
                                <span class="info-value" id="patternSymmetryCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">聚集形态</span>
                                <span class="info-value" id="patternClusterCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">分散形态</span>
                                <span class="info-value" id="patternDisperseCount">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="patternMorphologyChart" style="height: 600px;"></div>
                </div>

                <!-- 重复模式识别 -->
                <div class="pattern-recognition-chart-content" id="pattern-repetition" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="patternRepetitionPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">完全重复组合</span>
                                <span class="info-value" id="patternFullRepetitionCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">部分重复组合</span>
                                <span class="info-value" id="patternPartialRepetitionCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最高重复次数</span>
                                <span class="info-value" id="patternMaxRepetition">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="patternRepetitionChart" style="height: 600px;"></div>
                </div>

                <!-- 跳跃模式识别 -->
                <div class="pattern-recognition-chart-content" id="pattern-jump" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="patternJumpPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">平均跳跃值</span>
                                <span class="info-value" id="patternAvgJump">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最大跳跃值</span>
                                <span class="info-value" id="patternMaxJump">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">跳跃模式数</span>
                                <span class="info-value" id="patternJumpCount">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="patternJumpChart" style="height: 600px;"></div>
                </div>

                <!-- 科学分析结论 -->
                <div class="analysis-conclusion" id="patternRecognitionConclusion">
                    <h3><i class="fas fa-chart-line"></i> 科学分析结论</h3>
                    <div id="patternRecognitionConclusionContent"></div>
                </div>

                <!-- 规律发现 -->
                <div class="pattern-discovery" id="patternRecognitionPatternDiscovery">
                    <h3><i class="fas fa-lightbulb"></i> 规律发现</h3>
                    <div id="patternRecognitionPatternContent"></div>
                </div>

                <!-- 分析结果展示 -->
                <div class="analysis-results" id="patternRecognitionResults">
                    <h3><i class="fas fa-clipboard-check"></i> 分析结果展示</h3>
                    <div class="results-controls">
                        <label>展示模式：</label>
                        <select class="form-control" id="patternRecognitionResultsMode" style="width: 200px; display: inline-block;">
                            <option value="summary">摘要模式</option>
                            <option value="detailed">详细模式</option>
                            <option value="recommendation">推荐模式</option>
                        </select>
                        <button class="btn btn-primary" id="generatePatternRecognitionResults" style="margin-left: 10px;">生成结果</button>
                    </div>
                    <div id="patternRecognitionResultsContent"></div>
                </div>
            </div>

            <!-- DNA分析卡片 -->
            <div class="content-card" id="dnaAnalysisCard" style="display: none;">
                <div class="content-header">
                    <h2 class="content-title"><i class="fas fa-dna"></i> DNA分析 <span id="dnaAnalysisDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                    <div class="content-actions">
                        <select class="form-control" id="dnaAnalysisPeriodSelect" style="width: 120px; display: inline-block; margin-right: 10px;">
                            <option value="10">最近10期</option>
                            <option value="20">最近20期</option>
                            <option value="30" selected>最近30期</option>
                            <option value="50">最近50期</option>
                            <option value="100">最近100期</option>
                            <option value="200">最近200期</option>
                            <option value="all">全部数据</option>
                        </select>
                        <button class="btn btn-primary" id="startDNAAnalysis" style="margin-right: 10px;">开始DNA分析</button>
                        <button class="btn btn-secondary" id="exportDNAReport" style="margin-right: 10px;">导出分析报告</button>
                    </div>
                </div>

                <!-- 图表类型切换标签 -->
                <div class="chart-tabs" id="dnaAnalysisChartTabs">
                    <div class="chart-tab active" data-chart-type="sequence" data-tooltip="查看DNA序列分析结果">
                        <i class="fas fa-align-left"></i>
                        <span>DNA序列</span>
                        <span class="tab-badge">核心</span>
                    </div>
                    <div class="chart-tab" data-chart-type="evolution" data-tooltip="查看遗传进化分析结果">
                        <i class="fas fa-dna"></i>
                        <span>遗传进化</span>
                    </div>
                    <div class="chart-tab" data-chart-type="mutation" data-tooltip="查看基因突变分析结果">
                        <i class="fas fa-random"></i>
                        <span>基因突变</span>
                    </div>
                    <div class="chart-tab" data-chart-type="diversity" data-tooltip="查看种群多样性分析结果">
                        <i class="fas fa-project-diagram"></i>
                        <span>种群多样性</span>
                    </div>
                    <div class="chart-tab" data-chart-type="mapping" data-tooltip="查看DNA图谱分析结果">
                        <i class="fas fa-map"></i>
                        <span>DNA图谱</span>
                        <span class="tab-badge">高级</span>
                    </div>
                </div>

                <!-- DNA序列分析 -->
                <div class="dna-analysis-chart-content" id="dna-sequence" style="display: block;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="dnaSequencePeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">序列长度</span>
                                <span class="info-value" id="dnaSequenceLength">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">GC含量</span>
                                <span class="info-value" id="dnaGCContent">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">序列相似度</span>
                                <span class="info-value" id="dnaSequenceSimilarity">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="dnaSequenceChart" style="height: 600px;"></div>
                </div>

                <!-- 遗传进化分析 -->
                <div class="dna-analysis-chart-content" id="dna-evolution" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="dnaEvolutionPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">进化代数</span>
                                <span class="info-value" id="dnaEvolutionGenerations">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">适应度均值</span>
                                <span class="info-value" id="dnaFitnessMean">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">最优适应度</span>
                                <span class="info-value" id="dnaFitnessBest">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="dnaEvolutionChart" style="height: 600px;"></div>
                </div>

                <!-- 基因突变分析 -->
                <div class="dna-analysis-chart-content" id="dna-mutation" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="dnaMutationPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">突变次数</span>
                                <span class="info-value" id="dnaMutationCount">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">突变率</span>
                                <span class="info-value" id="dnaMutationRate">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">突变类型数</span>
                                <span class="info-value" id="dnaMutationTypes">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="dnaMutationChart" style="height: 600px;"></div>
                </div>

                <!-- 种群多样性分析 -->
                <div class="dna-analysis-chart-content" id="dna-diversity" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="dnaDiversityPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">种群大小</span>
                                <span class="info-value" id="dnaPopulationSize">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">香农多样性指数</span>
                                <span class="info-value" id="dnaShannonIndex">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">辛普森多样性指数</span>
                                <span class="info-value" id="dnaSimpsonIndex">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="dnaDiversityChart" style="height: 600px;"></div>
                </div>

                <!-- DNA图谱分析 -->
                <div class="dna-analysis-chart-content" id="dna-mapping" style="display: none;">
                    <div class="analysis-info">
                        <div class="info-grid">
                            <div class="info-item">
                                <span class="info-label">分析期数</span>
                                <span class="info-value" id="dnaMappingPeriods">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">基因位点数</span>
                                <span class="info-value" id="dnaGeneLoci">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">连锁强度</span>
                                <span class="info-value" id="dnaLinkageStrength">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">重组率</span>
                                <span class="info-value" id="dnaRecombinationRate">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="dnaMappingChart"></div>
                    <div class="dna-mapping-details" id="dnaMappingDetails" style="display: none;">
                        <h4><i class="fas fa-info-circle"></i> 基因详情</h4>
                        <div id="dnaMappingDetailsContent"></div>
                    </div>
                </div>

                <!-- 科学分析结论 -->
                <div class="analysis-conclusion" id="dnaAnalysisConclusion">
                    <h3><i class="fas fa-chart-line"></i> 科学分析结论</h3>
                    <div id="dnaAnalysisConclusionContent"></div>
                </div>

                <!-- 规律发现 -->
                <div class="pattern-discovery" id="dnaAnalysisPatternDiscovery">
                    <h3><i class="fas fa-lightbulb"></i> 规律发现</h3>
                    <div id="dnaAnalysisPatternContent"></div>
                </div>

                <!-- 分析结果展示 -->
                <div class="analysis-results" id="dnaAnalysisResults">
                    <h3><i class="fas fa-clipboard-check"></i> 分析结果展示</h3>
                    <div class="results-controls">
                        <label>展示模式：</label>
                        <select class="form-control" id="dnaAnalysisResultsMode" style="width: 200px; display: inline-block;">
                            <option value="summary">摘要模式</option>
                            <option value="detailed">详细模式</option>
                            <option value="recommendation">推荐模式</option>
                        </select>
                        <button class="btn btn-primary" id="generateDNAAnalysisResults" style="margin-left: 10px;">生成结果</button>
                    </div>
                    <div id="dnaAnalysisResultsContent"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // 全局变量
        let currentLotteryType = 'ssq'; // 默认双色球
        let currentStorageMethod = 'localstorage'; // 默认使用LocalStorage

        // 频率分析全局变量
        let currentFrequencyTab = 'red'; // 当前频率分析标签页（red/blue）
        let currentFrequencySort = 'number'; // 当前排序方式（number/asc/desc）
        let frequencyChart = null; // 频率分析图表实例
        let globalRedBallFrequency = null; // 全局红球频率数据
        let globalBlueBallFrequency = null; // 全局蓝球频率数据
        let currentFrequencyPeriod = 0; // 当前频率分析期数
        let currentFrequencyDraws = null; // 当前频率分析数据

        // 遗漏分析全局变量
        let currentOmissionTab = 'red'; // 当前遗漏分析标签页（red/blue）
        let currentOmissionSort = 'number'; // 当前排序方式（number/asc/desc）
        let currentOmissionPeriod = 100; // 当前分析期数
        let omissionChartData = null; // 遗漏分析图表数据
        let omissionRedChart = null; // 红球遗漏图表实例
        let omissionBlueChart = null; // 蓝球遗漏图表实例
        let omissionAnalysisData = { red: {}, blue: {} }; // 遗漏分析数据存储
        let patternChart = null; // 科学规律分析图表实例
        let patternDistributionChart = null; // 遗漏分布图表实例
        let patternStatusChart = null; // 号码状态图表实例
        let patternCycleChart = null; // 遗漏周期图表实例
        let patternCorrelationChart = null; // 遗漏相关性图表实例
        let patternPredictionChart = null; // 遗漏预测图表实例
        let omissionSequenceChart = null; // 遗漏序列图表实例
        let omissionEvolutionChart = null; // 遗漏演化图表实例
        let omissionMutationChart = null; // 遗漏突变图表实例
        let omissionDiversityChart = null; // 遗漏多样性图表实例
        let omissionMappingChart = null; // 遗漏映射图表实例
        let currentPatternChartType = 'trend'; // 当前显示的图表类型（trend规律/distribution分布/status状态/sequence序列/evolution演化/mutation突变/diversity多样性/mapping映射/cycle周期/correlation相关性/prediction预测）
        let patternAnalysisResults = null; // 科学规律分析结果存储

        // AC值分析全局变量
        let acValueChartData = null; // AC值分析数据存储
        let acValueBarChart = null; // AC值柱状图实例
        let acValueLineChart = null; // AC值折线图实例
        let acValuePieChart = null; // AC值饼图实例
        let acValueScatterChart = null; // AC值散点图实例
        let currentAcValueChartType = 'bar'; // 当前显示的AC值图表类型（bar/line/pie/scatter）
        let currentAcValuePeriod = 50; // 当前AC值分析期数
        let acValueAnalysisResults = null; // AC值分析结果存储

        // 大中小分析全局变量
        let threeZoneChartData = null; // 大中小分析数据存储
        let threeZoneStackedBarChart = null; // 三区堆叠柱状图实例
        let threeZoneLineChart = null; // 三区折线图实例
        let threeZonePieChart = null; // 三区饼图实例
        let threeZoneScatterChart = null; // 三区散点图实例
        let currentThreeZoneChartType = 'stackedBar'; // 当前显示的三区图表类型（stackedBar/line/pie/scatter）
        let currentThreeZonePeriod = 50; // 当前大中小分析期数
        let threeZoneAnalysisResults = null; // 大中小分析结果存储

        // 跟随分析全局变量
        let followUpChartData = null; // 跟随分析数据存储
        let followUpScatterChart = null; // 散度散点图实例
        let followUpBarChart = null; // 偏态柱状图实例
        let followUpLineChart = null; // 振幅折线图实例
        let followUpHeatmapChart = null; // 跟随热力图实例
        let followUpPieChart = null; // 重号邻号隔号饼图实例
        let followUpTrendChart = null; // 龙头凤尾趋势图实例
        let currentFollowUpChartType = 'scatter'; // 当前显示的跟随图表类型（scatter/bar/line/network/pie/trend）
        let currentFollowUpPeriod = 30; // 当前跟随分析期数
        let followUpAnalysisResults = null; // 跟随分析结果存储
        let currentFollowUpData = null; // 当前跟随分析数据（用于过滤）

        // 质合分析全局变量
        let primeCompositeChartData = null; // 质合分析数据存储
        let primeCompositeBarChart = null; // 质合柱状图实例
        let primeCompositeLineChart = null; // 质合折线图实例
        let primeCompositePieChart = null; // 质合饼图实例
        let primeCompositeHeatmapChart = null; // 质合热力图实例
        let currentPrimeCompositeChartType = 'bar'; // 当前显示的质合图表类型（bar/line/pie/heatmap）
        let currentPrimeCompositePeriod = 50; // 当前质合分析期数
        let primeCompositeAnalysisResults = null; // 质合分析结果存储
        let primeCompositeLinkageEnabled = false; // 质合图表联动开关

        // 相关性分析全局变量
        let correlationAnalysisData = null; // 相关性分析数据存储
        let correlationHeatmapChart = null; // 相关性热力图实例
        let correlationScatterChart = null; // 相关性散点图实例
        let correlationNetworkChart = null; // 相关性网络图实例
        let currentCorrelationChartType = 'heatmap'; // 当前显示的相关性图表类型（heatmap/scatter/network）
        let currentCorrelationPeriod = 100; // 当前相关性分析期数
        let correlationAnalysisResults = null; // 相关性分析结果存储

        // 统计分析全局变量
        let statisticalAnalysisData = null; // 统计分析数据存储
        let statisticalTrendChart = null; // 统计趋势图实例
        let statisticalDistributionChart = null; // 统计分布图实例
        let statisticalComparisonChart = null; // 统计对比图实例
        let statisticalHeatmapChart = null; // 统计热力图实例
        let currentStatisticalChartType = 'trend'; // 当前显示的统计图表类型（trend趋势/distribution分布/comparison对比/heatmap热力图）
        let currentStatisticalPeriod = 100; // 当前统计分析期数
        let statisticalAnalysisResults = null; // 统计分析结果存储

        // 模式识别全局变量
        let patternRecognitionData = null; // 模式识别数据存储
        let patternSequenceChart = null; // 序列模式图实例
        let patternPeriodicChart = null; // 周期模式图实例
        let patternMorphologyChart = null; // 形态模式图实例
        let patternRepetitionChart = null; // 重复模式图实例
        let patternJumpChart = null; // 跳跃模式图实例
        let currentPatternRecognitionChartType = 'sequence'; // 当前显示的模式识别图表类型（sequence序列/periodic周期/morphology形态/repetition重复/jump跳跃）
        let currentPatternRecognitionPeriod = 100; // 当前模式识别期数
        let patternRecognitionResults = null; // 模式识别结果存储

        // DNA分析全局变量
        let dnaAnalysisData = null; // DNA分析数据存储
        let dnaSequenceChart = null; // DNA序列图实例
        let dnaEvolutionChart = null; // 遗传进化图实例
        let dnaMutationChart = null; // 基因突变图实例
        let dnaDiversityChart = null; // 种群多样性图实例
        let dnaMappingChart = null; // DNA图谱实例
        let currentDNAAnalysisChartType = 'sequence'; // 当前显示的DNA分析图表类型（sequence序列/evolution进化/mutation突变/diversity多样性/mapping图谱）
        let currentDNAAnalysisPeriod = 100; // 当前DNA分析期数
        let dnaAnalysisResults = null; // DNA分析结果存储

        // 蒙特卡洛模拟全局变量
        let monteCarloAnalysisData = null; // 蒙特卡洛分析数据存储
        let monteCarloResults = null; // 蒙特卡洛结果存储

        // 彩票类型规则配置
        const LOTTERY_RULES = {
            'ssq': {
                name: '双色球',
                redBallCount: 6,
                redBallRange: [1, 33],
                blueBallCount: 1,
                blueBallRange: [1, 16],
                totalBalls: 7,
                displayName: '双色球',
                redBallName: '红球',
                blueBallName: '蓝球',
                themeColor: '#E63946',
                defaultNumbers: [5, 7, 14, 20, 23, 27, 16],
                threeZoneRanges: {
                    zone1: [1, 11],
                    zone2: [12, 22],
                    zone3: [23, 33]
                }
            },
            'dlt': {
                name: '大乐透',
                redBallCount: 5,
                redBallRange: [1, 35],
                blueBallCount: 2,
                blueBallRange: [1, 12],
                totalBalls: 7,
                displayName: '大乐透',
                redBallName: '前区',
                blueBallName: '后区',
                themeColor: '#2A9D8F',
                defaultNumbers: [1, 13, 15, 21, 27, 11, 12],
                threeZoneRanges: {
                    zone1: [1, 12],
                    zone2: [13, 24],
                    zone3: [25, 35]
                }
            }
        };

        // 事件管理系统 - 用于集中管理事件监听器，避免内存泄漏
        class EventManager {
            constructor() {
                this.eventListeners = new Map();
                this.activeListeners = new Set();
            }

            // 注册事件监听器
            on(element, eventType, callback, options = {}) {
                const listenerId = this.generateListenerId(element, eventType, callback);
                element.addEventListener(eventType, callback, options);
                this.eventListeners.set(listenerId, { element, eventType, callback, options });
                this.activeListeners.add(listenerId);
                return listenerId;
            }

            // 移除事件监听器
            off(listenerId) {
                const listener = this.eventListeners.get(listenerId);
                if (listener) {
                    listener.element.removeEventListener(listener.eventType, listener.callback, listener.options);
                    this.eventListeners.delete(listenerId);
                    this.activeListeners.delete(listenerId);
                    return true;
                }
                return false;
            }

            // 批量移除事件监听器
            offAll() {
                for (const listenerId of this.activeListeners) {
                    this.off(listenerId);
                }
                this.activeListeners.clear();
            }

            // 移除指定元素的所有事件监听器
            offByElement(element) {
                const listenersToRemove = [];
                for (const [listenerId, listener] of this.eventListeners.entries()) {
                    if (listener.element === element) {
                        listenersToRemove.push(listenerId);
                    }
                }
                for (const listenerId of listenersToRemove) {
                    this.off(listenerId);
                }
            }

            // 移除指定类型的所有事件监听器
            offByEventType(eventType) {
                const listenersToRemove = [];
                for (const [listenerId, listener] of this.eventListeners.entries()) {
                    if (listener.eventType === eventType) {
                        listenersToRemove.push(listenerId);
                    }
                }
                for (const listenerId of listenersToRemove) {
                    this.off(listenerId);
                }
            }

            // 生成监听器ID
            generateListenerId(element, eventType, callback) {
                return `${element}-${eventType}-${callback.toString().substring(0, 50)}`;
            }

            // 获取活跃的监听器数量
            getActiveListenerCount() {
                return this.activeListeners.size;
            }
        }

        // 创建全局事件管理器实例
        const eventManager = new EventManager();

        // 数据库相关全局变量
        let currentDatabaseData = { draws: [] }; // 当前显示的数据

        // 分页相关全局变量
        let currentPage = 1; // 当前页码
        let pageStates = { 'ssq': 1, 'dlt': 1 }; // 为每个彩票类型保存页码状态
        let pageSize = 20; // 每页显示条数
        let totalDataCount = 0; // 总数据条数
        let totalPages = 1; // 总页数
        let dataCountStates = { 'ssq': 0, 'dlt': 0 }; // 为每个彩票类型保存数据条数状态
        let totalPagesStates = { 'ssq': 1, 'dlt': 1 }; // 为每个彩票类型保存总页数状态

        // 数据库管理类
        class LotteryDatabase {
            constructor(lotteryType) {
                this.lotteryType = lotteryType;
                this.dbName = `lottery_${lotteryType}`;
                this.version = 1;
                this.db = null;
            }

            // 初始化数据库
            async init() {
                if (currentStorageMethod === 'indexeddb') {
                    return this.initIndexedDB();
                } else {
                    return this.initLocalStorage();
                }
            }

            // 初始化IndexedDB（备用方案）
            initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);

                    request.onerror = (event) => {
                        console.error('数据库打开失败', event);
                        // 回退到LocalStorage
                        currentStorageMethod = 'localstorage';
                        resolve(this.initLocalStorage());
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;

                        resolve(true);
                    };

                    request.onupgradeneeded = (event) => {
                        this.db = event.target.result;
                        if (!this.db.objectStoreNames.contains('draws')) {
                            const objectStore = this.db.createObjectStore('draws', { keyPath: 'id' });
                            objectStore.createIndex('date', 'date', { unique: false });
                            objectStore.createIndex('numbers', 'numbers', { unique: false });
                        }
                    };
                });
            }

            // 初始化LocalStorage
            initLocalStorage() {
                // 确保localStorage中有对应彩票类型的数据存储
                const key = `lottery_${this.lotteryType}_data`;
                if (!localStorage.getItem(key)) {
                    localStorage.setItem(key, JSON.stringify({
                        draws: [],
                        statistics: {},
                        settings: {}
                    }));
                }
                return Promise.resolve(true);
            }

            // 获取数据
            getData() {
                if (currentStorageMethod === 'indexeddb' && this.db) {
                    return this.getDataIndexedDB();
                } else {
                    return this.getDataLocalStorage();
                }
            }

            // 从IndexedDB获取数据
            getDataIndexedDB() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['draws'], 'readonly');
                    const objectStore = transaction.objectStore('draws');
                    const request = objectStore.getAll();

                    request.onsuccess = () => {
                        resolve(request.result);
                    };

                    request.onerror = () => {
                        reject(request.error);
                    };
                });
            }

            // 从LocalStorage获取数据
            getDataLocalStorage() {
                const key = `lottery_${this.lotteryType}_data`;
                const data = localStorage.getItem(key);
                return Promise.resolve(JSON.parse(data || '{"draws": [], "statistics": {}, "settings": {}}'));
            }

            // 保存数据
            saveData(data) {
                if (currentStorageMethod === 'indexeddb' && this.db) {
                    return this.saveDataIndexedDB(data);
                } else {
                    return this.saveDataLocalStorage(data);
                }
            }

            // 保存数据到IndexedDB
            saveDataIndexedDB(data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['draws'], 'readwrite');
                    const objectStore = transaction.objectStore('draws');

                    // 清空现有数据
                    objectStore.clear();

                    // 按期号排序数据（从最早到最新）
                    const sortedDraws = [...data.draws].sort((a, b) => {
                        const periodA = parseInt(a.period || a.issue || '0');
                        const periodB = parseInt(b.period || b.issue || '0');
                        return periodA - periodB;
                    });

                    // 添加排序后的数据
                    sortedDraws.forEach(draw => {
                        objectStore.add(draw);
                    });

                    transaction.oncomplete = () => {
                        resolve(true);
                    };

                    transaction.onerror = () => {
                        reject(transaction.error);
                    };
                });
            }

            // 保存数据到LocalStorage
            saveDataLocalStorage(data) {
                const key = `lottery_${this.lotteryType}_data`;

                // 按期号排序数据（从最早到最新）
                const sortedDraws = [...data.draws].sort((a, b) => {
                    const periodA = parseInt(a.period || a.issue || '0');
                    const periodB = parseInt(b.period || b.issue || '0');
                    return periodA - periodB;
                });

                const sortedData = { ...data, draws: sortedDraws };
                localStorage.setItem(key, JSON.stringify(sortedData));
                return Promise.resolve(true);
            }
        }

        // 消息提示系统
        class MessageSystem {
            static maxMessages = 5;
            static messageDuration = 5000;

            static showMessage(message, type = 'info') {
                const messageCenter = document.getElementById('messageCenter');

                // 限制消息数量，超过时移除最旧的消息
                while (messageCenter.children.length >= this.maxMessages) {
                    messageCenter.removeChild(messageCenter.firstChild);
                }

                const messageId = 'msg_' + Date.now();

                const messageEl = document.createElement('div');
                messageEl.className = `message ${type}`;
                messageEl.id = messageId;
                messageEl.style.transition = 'all 0.3s ease';
                messageEl.innerHTML = `
                    <i class="fas fa-${this.getIconByType(type)}"></i>
                    <span style="flex: 1;">${message}</span>
                    <span class="message-close" onclick="MessageSystem.removeMessage('${messageId}')">&times;</span>
                `;

                messageCenter.appendChild(messageEl);

                let timeoutId;

                const removeMessage = () => {
                    messageEl.style.opacity = '0';
                    messageEl.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        if (messageEl && messageEl.parentNode) {
                            messageEl.parentNode.removeChild(messageEl);
                        }
                    }, 300);
                };

                // 鼠标悬停时暂停自动消失
                messageEl.addEventListener('mouseenter', () => {
                    clearTimeout(timeoutId);
                    messageEl.style.transform = 'scale(1.02)';
                });

                // 鼠标离开时恢复自动消失
                messageEl.addEventListener('mouseleave', () => {
                    messageEl.style.transform = 'scale(1)';
                    timeoutId = setTimeout(removeMessage, this.messageDuration);
                });

                // 初始设置自动消失
                timeoutId = setTimeout(removeMessage, this.messageDuration);
            }

            static removeMessage(messageId) {
                const messageEl = document.getElementById(messageId);
                if (messageEl) {
                    messageEl.style.opacity = '0';
                    messageEl.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        if (messageEl && messageEl.parentNode) {
                            messageEl.parentNode.removeChild(messageEl);
                        }
                    }, 300);
                }
            }

            static getIconByType(type) {
                switch(type) {
                    case 'error': return 'exclamation-circle';
                    case 'success': return 'check-circle';
                    case 'warning': return 'exclamation-triangle';
                    case 'info': return 'info-circle';
                    default: return 'info-circle';
                }
            }
        }

        // 彩票数据管理器
        class LotteryDataManager {
            constructor() {
                this.databases = {};
                this.currentDb = null;
            }

            // 切换彩票类型
            async switchLotteryType(lotteryType) {
                // 保存当前彩票类型的页码状态
                pageStates[currentLotteryType] = currentPage;
                // 保存当前彩票类型的数据条数和总页数状态
                dataCountStates[currentLotteryType] = totalDataCount;
                totalPagesStates[currentLotteryType] = totalPages;
                
                // 切换到新的彩票类型
                currentLotteryType = lotteryType;
                
                // 恢复新彩票类型的页码状态
                currentPage = pageStates[lotteryType] || 1;
                // 恢复新彩票类型的数据条数和总页数状态
                totalDataCount = dataCountStates[lotteryType] || 0;
                totalPages = totalPagesStates[lotteryType] || 1;

                // 如果数据库已存在，直接使用
                if (!this.databases[lotteryType]) {
                    this.databases[lotteryType] = new LotteryDatabase(lotteryType);
                    await this.databases[lotteryType].init();
                }

                this.currentDb = this.databases[lotteryType];

                MessageSystem.showMessage(`已切换到${this.getLotteryName(lotteryType)}`, 'success');

                // 加载对应彩票类型的数据
                await this.loadDataForCurrentLottery();

                // 更新条件选号选项
                this.updateConditionOptions(lotteryType);
            }

            // 更新条件选号选项
            updateConditionOptions(lotteryType) {
                const threeZoneSelect = document.getElementById('conditionThreeZone');
                const oddEvenSelect = document.getElementById('conditionOddEven');
                const bigSmallSelect = document.getElementById('conditionBigSmall');
                const primeCompositeSelect = document.getElementById('conditionPrimeComposite');
                const consecutiveSelect = document.getElementById('conditionConsecutive');

                if (lotteryType === 'ssq') {
                    // 双色球选项（6个红球）
                    consecutiveSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="0">无连号</option>
                        <option value="1-2">1个2连</option>
                        <option value="1-3">1个3连</option>
                        <option value="1-4">1个4连</option>
                        <option value="1-5">1个5连</option>
                        <option value="1-6">1个6连</option>
                        <option value="2-2">2个2连</option>
                        <option value="3-2">3个2连</option>
                        <option value="2-3">2个3连</option>
                        <option value="1-2,1-3">1个2连+1个3连</option>
                        <option value="1-2,1-4">1个2连+1个4连</option>
                    `;
                    threeZoneSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="0:0:6">0:0:6</option>
                        <option value="0:1:5">0:1:5</option>
                        <option value="1:0:5">1:0:5</option>
                        <option value="0:2:4">0:2:4</option>
                        <option value="1:1:4">1:1:4</option>
                        <option value="2:0:4">2:0:4</option>
                        <option value="0:3:3">0:3:3</option>
                        <option value="1:2:3">1:2:3</option>
                        <option value="2:1:3">2:1:3</option>
                        <option value="3:0:3">3:0:3</option>
                        <option value="0:4:2">0:4:2</option>
                        <option value="1:3:2">1:3:2</option>
                        <option value="2:2:2">2:2:2</option>
                        <option value="3:1:2">3:1:2</option>
                        <option value="4:0:2">4:0:2</option>
                        <option value="0:5:1">0:5:1</option>
                        <option value="1:4:1">1:4:1</option>
                        <option value="2:3:1">2:3:1</option>
                        <option value="3:2:1">3:2:1</option>
                        <option value="4:1:1">4:1:1</option>
                        <option value="5:0:1">5:0:1</option>
                        <option value="0:6:0">0:6:0</option>
                        <option value="1:5:0">1:5:0</option>
                        <option value="2:4:0">2:4:0</option>
                        <option value="3:3:0">3:3:0</option>
                        <option value="4:2:0">4:2:0</option>
                        <option value="5:1:0">5:1:0</option>
                        <option value="6:0:0">6:0:0</option>
                    `;
                    oddEvenSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="6:0">6:0</option>
                        <option value="5:1">5:1</option>
                        <option value="4:2">4:2</option>
                        <option value="3:3">3:3</option>
                        <option value="2:4">2:4</option>
                        <option value="1:5">1:5</option>
                        <option value="0:6">0:6</option>
                    `;
                    bigSmallSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="6:0">6:0</option>
                        <option value="5:1">5:1</option>
                        <option value="4:2">4:2</option>
                        <option value="3:3">3:3</option>
                        <option value="2:4">2:4</option>
                        <option value="1:5">1:5</option>
                        <option value="0:6">0:6</option>
                    `;
                    primeCompositeSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="6:0">6:0</option>
                        <option value="5:1">5:1</option>
                        <option value="4:2">4:2</option>
                        <option value="3:3">3:3</option>
                        <option value="2:4">2:4</option>
                        <option value="1:5">1:5</option>
                        <option value="0:6">0:6</option>
                    `;
                } else if (lotteryType === 'dlt') {
                    // 大乐透选项（5个红球）
                    consecutiveSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="0">无连号</option>
                        <option value="1-2">1个2连</option>
                        <option value="1-3">1个3连</option>
                        <option value="1-4">1个4连</option>
                        <option value="1-5">1个5连</option>
                        <option value="2-2">2个2连</option>
                        <option value="1-2,1-3">1个2连+1个3连</option>
                    `;
                    threeZoneSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="0:0:5">0:0:5</option>
                        <option value="0:1:4">0:1:4</option>
                        <option value="1:0:4">1:0:4</option>
                        <option value="0:2:3">0:2:3</option>
                        <option value="1:1:3">1:1:3</option>
                        <option value="2:0:3">2:0:3</option>
                        <option value="0:3:2">0:3:2</option>
                        <option value="1:2:2">1:2:2</option>
                        <option value="2:1:2">2:1:2</option>
                        <option value="3:0:2">3:0:2</option>
                        <option value="0:4:1">0:4:1</option>
                        <option value="1:3:1">1:3:1</option>
                        <option value="2:2:1">2:2:1</option>
                        <option value="3:1:1">3:1:1</option>
                        <option value="4:0:1">4:0:1</option>
                        <option value="0:5:0">0:5:0</option>
                        <option value="1:4:0">1:4:0</option>
                        <option value="2:3:0">2:3:0</option>
                        <option value="3:2:0">3:2:0</option>
                        <option value="4:1:0">4:1:0</option>
                        <option value="5:0:0">5:0:0</option>
                    `;
                    oddEvenSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="5:0">5:0</option>
                        <option value="4:1">4:1</option>
                        <option value="3:2">3:2</option>
                        <option value="2:3">2:3</option>
                        <option value="1:4">1:4</option>
                        <option value="0:5">0:5</option>
                    `;
                    bigSmallSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="5:0">5:0</option>
                        <option value="4:1">4:1</option>
                        <option value="3:2">3:2</option>
                        <option value="2:3">2:3</option>
                        <option value="1:4">1:4</option>
                        <option value="0:5">0:5</option>
                    `;
                    primeCompositeSelect.innerHTML = `
                        <option value="">不限</option>
                        <option value="5:0">5:0</option>
                        <option value="4:1">4:1</option>
                        <option value="3:2">3:2</option>
                        <option value="2:3">2:3</option>
                        <option value="1:4">1:4</option>
                        <option value="0:5">0:5</option>
                    `;
                }
            }

            // 获取彩票名称
            getLotteryName(lotteryType) {
                const names = {
                    'ssq': '双色球',
                    'dlt': '大乐透',
                    'other': '其他彩票'
                };
                return names[lotteryType] || '未知彩票';
            }

            // 为当前彩票类型加载数据
            async loadDataForCurrentLottery() {
                try {
                    const data = await this.currentDb.getData();

                    // 更新全局数据库数据
                    currentDatabaseData = data;

                    // 更新图表
                    if (typeof echarts !== 'undefined') {
                        this.updateCharts(data);
                    } else {

                        // 尝试延迟加载图表
                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                this.updateCharts(data);
                            }
                        }, 1000);
                    }

                    // 更新表格
                    this.updateTable(data);

                    // 更新数据库表格（如果数据库卡片显示，则根据面包屑确定类型）
                    const databaseCard = document.getElementById('databaseCard');
                    if (databaseCard && databaseCard.style.display !== 'none') {
                        // 数据库卡片显示中，让updateDatabaseTable自动检测类型
                        this.updateDatabaseTable();
                    }

                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            // 更新图表
            updateCharts(data) {
                // 检查ECharts库是否已加载
                if (typeof echarts === 'undefined') {

                    return;
                }

                // 安全初始化图表的辅助函数
                const safeInitChart = (elementId) => {
                    const dom = document.getElementById(elementId);
                    if (!dom) {

                        return null;
                    }
                    return echarts.getInstanceByDom(dom) || echarts.init(dom);
                };


            }

            // 更新表格
            updateTable(data) {
                const tableBody = document.getElementById('dataTable');
                if (!tableBody) {

                    return;
                }
                tableBody.innerHTML = '';

                // 示例数据
                const sampleData = [
                    {number: '01', count: 25, freq: '12.5%', omission: 2, status: 'hot', statusText: '热号'},
                    {number: '02', count: 18, freq: '9.0%', omission: 5, status: 'warm', statusText: '温号'},
                    {number: '03', count: 8, freq: '4.0%', omission: 15, status: 'cold', statusText: '冷号'},
                    {number: '04', count: 15, freq: '7.5%', omission: 8, status: 'warm', statusText: '温号'},
                    {number: '05', count: 22, freq: '11.0%', omission: 3, status: 'hot', statusText: '热号'},
                    {number: '06', count: 17, freq: '8.5%', omission: 6, status: 'warm', statusText: '温号'},
                    {number: '07', count: 12, freq: '6.0%', omission: 12, status: 'cold', statusText: '冷号'},
                    {number: '08', count: 20, freq: '10.0%', omission: 4, status: 'hot', statusText: '热号'}
                ];

                sampleData.forEach(item => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${item.number}</td>
                        <td>${item.count}</td>
                        <td>${item.freq}</td>
                        <td>${item.omission}</td>
                        <td><span class="status ${item.status}">${item.statusText}</span></td>
                    `;
                    tableBody.appendChild(row);
                });
            }

            // 获取开奖数据
            getDraws() {
                return currentDatabaseData.draws || [];
            }

            // 显示九转图
            showNineChart(period, numbers, instanceId) {
                if (!EventDelegate.nineRingInstances[instanceId]) {
                    EventDelegate.nineRingInstances[instanceId] = {
                        selectedNumbers: []
                    };
                }

                const parts = numbers.split('+');
                const redBalls = parts[0].split(',').map(n => parseInt(n.trim(), 10));
                const blueBalls = parts[1] ? parts[1].split(',').map(n => parseInt(n.trim(), 10)) : [];

                EventDelegate.nineRingInstances[instanceId].selectedNumbers = redBalls;

                const metrics = EventDelegate.calculateAnalysisMetrics(numbers, currentLotteryType);

                let numbersDisplay = '';
                if (currentLotteryType === 'ssq') {
                    const redBallsDisplay = redBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #E63946; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    const blueBallsDisplay = blueBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #457B9D; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    numbersDisplay = `${redBallsDisplay}+${blueBallsDisplay}`;
                } else if (currentLotteryType === 'dlt') {
                    const frontBallsDisplay = redBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #2A9D8F; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    const backBallsDisplay = blueBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #F4A261; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    numbersDisplay = `${frontBallsDisplay}+${backBallsDisplay}`;
                }

                const metricsDisplay = `和值:<span style="color: #E63946; font-weight: bold;">${metrics.sum || 0}</span>|跨度:<span style="color: #457B9D; font-weight: bold;">${metrics.span || 0}</span>|连号:<span style="color: #2A9D8F; font-weight: bold;">${metrics.consecutive || 0}</span>|大中小:<span style="color: #F4A261; font-weight: bold;">${metrics.zoneDistribution || '0-0-0'}</span>|奇偶:<span style="color: #9B5DE5; font-weight: bold;">${metrics.oddEvenRatio || '0:0'}</span>|AC值:<span style="color: #FF7700; font-weight: bold;">${metrics.acValue || 0}</span>|大小比:<span style="color: #00BBBB; font-weight: bold;">${metrics.bigSmallRatio || '0:0'}</span>|质合比:<span style="color: #0077FF; font-weight: bold;">${metrics.primeCompositeRatio || '0:0'}</span>`;

                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white;
                    padding: 20px;
                    border-radius: 8px;
                    max-width: 95%;
                    max-height: 90%;
                    overflow: auto;
                    position: relative;
                `;

                content.innerHTML = `
                    <h3 style="margin-bottom: 15px;">九转图分析 - 期号: ${period}</h3>
                    <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 6px;">
                        <div style="margin-bottom: 8px;">
                            <strong>开奖号码:</strong><br>
                            <div style="margin-top: 5px;">${numbersDisplay}</div>
                        </div>
                        <div style="font-size: 13px;">
                            <strong>分析指标:</strong> ${metricsDisplay}
                        </div>
                    </div>
                    <style>
                        .card-container {
                          display: flex;
                          justify-content: center;
                          align-items: flex-start;
                          gap: 30px;
                          padding: 20px;
                          flex-wrap: wrap;
                          overflow: visible;
                        }
                        .canvas-card {
                          display: flex;
                          flex-direction: column;
                          align-items: center;
                          gap: 10px;
                          width: 560px;
                          height: 610px;
                          overflow: visible;
                        }
                        .canvas-title {
                          font-size: 48px;
                          font-weight: bold;
                          color: #333;
                          margin: 0;
                          padding: 5px 0;
                          text-align: center;
                          font-family: Arial, sans-serif;
                        }
                        canvas {
                          border: 1px solid #ccc;
                        }
                    </style>
                    <div class="card-container">
                        <div class="canvas-card" id="card-1">
                            <h1 class="canvas-title">衡十七</h1>
                            <canvas id="circles-svg-1-${instanceId}" width="560" height="560"></canvas>
                        </div>
                        <div class="canvas-card" id="card-2">
                            <h1 class="canvas-title">九为尊</h1>
                            <canvas id="circles-svg-2-${instanceId}" width="560" height="560"></canvas>
                        </div>
                        <div class="canvas-card" id="card-3">
                            <h1 class="canvas-title">三十三</h1>
                            <canvas id="circles-svg-3-${instanceId}" width="560" height="560"></canvas>
                        </div>
                    </div>
                    <button id="closeNineChartModal" style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">关闭</button>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                const closeModal = () => {
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                };

                const closeBtn = content.querySelector('#closeNineChartModal');
                if (closeBtn) {
                    closeBtn.addEventListener('click', closeModal);
                }

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal();
                    }
                });

                setTimeout(() => {
                    const cardData = {
                        'card-1': { title: "衡十七", numbers: [["17"], ["01", "06", "07", "22", "23", "18", "27", "32"], ["33", "29", "19", "12", "03", "15", "05", "20"], ["21", "24", "31", "04", "16", "10", "28", "02"], ["13", "09", "11", "30", "26", "25", "08", "14"]] },
                        'card-2': { title: "九为尊", numbers: [["09"], ["10", "22", "07", "30", "02", "18", "25", "24"], ["23", "13", "19", "14", "29", "26", "11", "03"], ["16", "01", "31", "21", "32", "17", "05", "15"], ["20", "33", "12", "04", "06", "08", "28", "27"]] },
                        'card-3': { title: "三十三", numbers: [["33"], ["01", "31", "13", "21", "11", "27", "07", "17"], ["32", "02", "20", "12", "22", "06", "26", "16"], ["15", "19", "03", "29", "05", "23", "09", "25"], ["18", "14", "30", "04", "28", "10", "24", "08"]] }
                    };

                    const instanceSelectedNumbers = EventDelegate.nineRingInstances[instanceId]?.selectedNumbers || [];




                    EventDelegate.drawNineRingCircle(`circles-svg-1-${instanceId}`, cardData['card-1'], instanceSelectedNumbers, 1);
                    EventDelegate.drawNineRingCircle(`circles-svg-2-${instanceId}`, cardData['card-2'], instanceSelectedNumbers, 1);
                    EventDelegate.drawNineRingCircle(`circles-svg-3-${instanceId}`, cardData['card-3'], instanceSelectedNumbers, 1);
                }, 100);
            }

            showDNAAnalysis(period, numbers) {
                const parts = numbers.split('+');
                const redBalls = parts[0].split(',').map(n => parseInt(n.trim(), 10));
                const blueBalls = parts[1] ? parts[1].split(',').map(n => parseInt(n.trim(), 10)) : [];

                const queryNumbers = [...redBalls, ...blueBalls].map(n => n.toString().padStart(2, '0'));
                
                let lotteryType = currentLotteryType;
                
                if (redBalls.length === 6 && blueBalls.length === 1) {
                    lotteryType = 'ssq';
                } else if (redBalls.length === 5 && blueBalls.length === 2) {
                    lotteryType = 'dlt';
                }

                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white;
                    padding: 20px;
                    border-radius: 8px;
                    max-width: 95%;
                    max-height: 90%;
                    overflow: auto;
                    position: relative;
                    width: 800px;
                `;

                let formattedQueryNumbers = '';
                if (lotteryType === 'ssq') {
                    const redBallsDisplay = redBalls.map(num => `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #E63946; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    const blueBallsDisplay = blueBalls.map(num => `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #457B9D; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    formattedQueryNumbers = `${redBallsDisplay} <span style="font-size: 24px; font-weight: bold; margin: 0 10px;">+</span> ${blueBallsDisplay}`;
                } else if (lotteryType === 'dlt') {
                    const frontBallsDisplay = redBalls.map(num => `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #2A9D8F; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    const backBallsDisplay = blueBalls.map(num => `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #F4A261; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`).join('');
                    formattedQueryNumbers = `${frontBallsDisplay} <span style="font-size: 24px; font-weight: bold; margin: 0 10px;">+</span> ${backBallsDisplay}`;
                }

                const metrics = EventDelegate.calculateAnalysisMetrics(numbers, lotteryType);
                const indicatorText = `和值: <span style="color: #E63946; font-weight: bold;">${metrics.sum || 0}</span> | 跨度: <span style="color: #457B9D; font-weight: bold;">${metrics.span || 0}</span> | 连号: <span style="color: #2A9D8F; font-weight: bold;">${metrics.consecutive || 0}</span> | 大中小: <span style="color: #F4A261; font-weight: bold;">${metrics.zoneDistribution || '0-0-0'}</span> | 奇偶: <span style="color: #9B5DE5; font-weight: bold;">${metrics.oddEvenRatio || '0:0'}</span> | AC值: <span style="color: #FF7700; font-weight: bold;">${metrics.acValue || 0}</span> | 大小比: <span style="color: #00BBBB; font-weight: bold;">${metrics.bigSmallRatio || '0:0'}</span> | 质合比: <span style="color: #0077FF; font-weight: bold;">${metrics.primeCompositeRatio || '0:0'}</span>`;

                content.innerHTML = `
                    <h3 style="margin-bottom: 15px;">DNA分析 - 期号: ${period}</h3>
                    <div style="margin-bottom: 30px;">
                        <div style="background: #f0f2f5; color: #333; padding: 30px 20px; border-radius: 10px; text-align: center; border: 2px solid #e9ecef;">
                            <h3 style="margin: 0 0 20px 0; font-size: 24px; color: #495057;">查询号码</h3>
                            <div style="font-size: 0; margin-bottom: 20px;">${formattedQueryNumbers}</div>
                            <div style="font-size: 14px; color: #495057; line-height: 1.6;">${indicatorText}</div>
                        </div>
                    </div>
                    <div id="dnaAnalysisResult" style="margin-top: 15px;">
                        <p style="color: #666; text-align: center; padding: 20px;">正在查询历史数据...</p>
                    </div>
                    <button id="closeDNAModal" style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">关闭</button>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                const closeModal = () => {
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                };

                const closeBtn = content.querySelector('#closeDNAModal');
                if (closeBtn) {
                    closeBtn.addEventListener('click', closeModal);
                }

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal();
                    }
                });

                setTimeout(async () => {
                    const resultContainer = document.getElementById('dnaAnalysisResult');
                    if (!resultContainer) return;

                    let queryDatabaseData = null;

                    if (dataManager.databases[lotteryType]) {
                        queryDatabaseData = await dataManager.databases[lotteryType].getData();
                    }

                    if (!queryDatabaseData || !queryDatabaseData.draws || queryDatabaseData.draws.length === 0) {
                        resultContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">暂无历史数据</p>';
                        return;
                    }

                    const results = queryDatabaseData.draws.map(item => {
                        const drawRedBalls = item.redBalls || [];
                        const drawBlueBalls = item.blueBalls || [];
                        
                        const drawRedBallsStr = drawRedBalls.map(n => n.toString().padStart(2, '0'));
                        const drawBlueBallsStr = drawBlueBalls.map(n => n.toString().padStart(2, '0'));

                        let redMatch = 0, blueMatch = 0, frontMatch = 0, backMatch = 0;

                        if (lotteryType === 'ssq') {
                            const queryRed = queryNumbers.slice(0, 6);
                            const queryBlue = queryNumbers.slice(6);

                            if (drawRedBallsStr) {
                                redMatch = queryRed.filter(n => drawRedBallsStr.includes(n)).length;
                            }
                            if (drawBlueBallsStr) {
                                blueMatch = queryBlue.filter(n => drawBlueBallsStr.includes(n)).length;
                            }
                        } else if (lotteryType === 'dlt') {
                            const queryFront = queryNumbers.slice(0, 5);
                            const queryBack = queryNumbers.slice(5);

                            if (drawRedBallsStr) {
                                frontMatch = queryFront.filter(n => drawRedBallsStr.includes(n)).length;
                            }
                            if (drawBlueBallsStr) {
                                backMatch = queryBack.filter(n => drawBlueBallsStr.includes(n)).length;
                            }
                        }

                        const prizeInfo = EventDelegate.getPrizeInfo({
                            redBalls: drawRedBalls,
                            blueBalls: drawBlueBalls,
                            redMatch: redMatch,
                            blueMatch: blueMatch,
                            frontMatch: frontMatch,
                            backMatch: backMatch
                        }, lotteryType);

                        return {
                            issue: item.issue || item.period,
                            period: item.period || item.issue,
                            redBalls: drawRedBalls,
                            blueBalls: drawBlueBalls,
                            redMatch: redMatch,
                            blueMatch: blueMatch,
                            frontMatch: frontMatch,
                            backMatch: backMatch,
                            prizeInfo: prizeInfo
                        };
                    });

                    const winningResults = results.filter(result => result.prizeInfo.prizeLevel !== '未中奖');
                    const winCount = winningResults.length;
                    const totalDraws = queryDatabaseData.draws.length;
                    const winRate = totalDraws > 0 ? ((winCount / totalDraws) * 100).toFixed(2) : '0.00';

                    const prizeStats = EventDelegate.calculatePrizeStatistics(results, lotteryType);

                    let html = `
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 30px;">
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #28a745;">
                                <div style="color: #6c757d; font-size: 14px; margin-bottom: 10px;">中奖次数</div>
                                <div style="font-size: 28px; font-weight: bold; color: #28a745;">${winCount}</div>
                            </div>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #007bff;">
                                <div style="color: #6c757d; font-size: 14px; margin-bottom: 10px;">胜率</div>
                                <div style="font-size: 28px; font-weight: bold; color: #007bff;">${winRate}%</div>
                            </div>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #ffc107;">
                                <div style="color: #6c757d; font-size: 14px; margin-bottom: 10px;">总奖金</div>
                                <div style="font-size: 28px; font-weight: bold; color: #ffc107;">${prizeStats.totalPrize}</div>
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">中奖统计</h4>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                                ${EventDelegate.generatePrizeStatsHTML(prizeStats)}
                            </div>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">详细中奖记录</h4>
                            <table class="result-table" style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr>
                                        <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">期号</th>
                                        <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">中奖号码</th>
                                        <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">奖项</th>
                                        <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">中奖条件</th>
                                        <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">奖金</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;

                    const prizeLevelOrder = lotteryType === 'ssq' ? {
                        '一等奖': 1,
                        '二等奖': 2,
                        '三等奖': 3,
                        '四等奖': 4,
                        '五等奖': 5,
                        '六等奖': 6,
                        '福运奖': 7,
                        '未中奖': 999
                    } : {
                        '一等奖': 1,
                        '二等奖': 2,
                        '三等奖': 3,
                        '四等奖': 4,
                        '五等奖': 5,
                        '六等奖': 6,
                        '好运奖': 7,
                        '未中奖': 999
                    };

                    const sortedWinningResults = [...winningResults];

                    sortedWinningResults.sort((a, b) => {
                        const orderA = prizeLevelOrder[a.prizeInfo.prizeLevel] || 999;
                        const orderB = prizeLevelOrder[b.prizeInfo.prizeLevel] || 999;

                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }

                        const periodA = parseInt(a.issue || a.period || '0');
                        const periodB = parseInt(b.issue || b.period || '0');
                        return periodB - periodA;
                    });

                    sortedWinningResults.forEach(result => {
                        let winningNumbersHTML = '';

                        if (lotteryType === 'ssq') {
                            const drawRedBalls = result.redBalls || [];
                            const drawBlueBalls = result.blueBalls || [];
                            const queryRed = queryNumbers.slice(0, 6);
                            const queryBlue = queryNumbers.slice(6);

                            const redNumbersHTML = drawRedBalls.map(num => {
                                if (queryRed.includes(num)) {
                                    return `<span style="color: #E63946; font-weight: bold;">${num}</span>`;
                                } else {
                                    return `<span style="color: #000000;">${num}</span>`;
                                }
                            }).join(' ');

                            const blueNumbersHTML = drawBlueBalls.map(num => {
                                if (queryBlue.includes(num)) {
                                    return `<span style="color: #457B9D; font-weight: bold;">${num}</span>`;
                                } else {
                                    return `<span style="color: #000000;">${num}</span>`;
                                }
                            }).join(' ');

                            winningNumbersHTML = `${redNumbersHTML} | ${blueNumbersHTML}`;
                        } else if (lotteryType === 'dlt') {
                            const drawRedBalls = result.redBalls || [];
                            const drawBlueBalls = result.blueBalls || [];
                            const queryFront = queryNumbers.slice(0, 5);
                            const queryBack = queryNumbers.slice(5);

                            const frontNumbersHTML = drawRedBalls.map(num => {
                                if (queryFront.includes(num)) {
                                    return `<span style="color: #2A9D8F; font-weight: bold;">${num}</span>`;
                                } else {
                                    return `<span style="color: #000000;">${num}</span>`;
                                }
                            }).join(' ');

                            const backNumbersHTML = drawBlueBalls.map(num => {
                                if (queryBack.includes(num)) {
                                    return `<span style="color: #F4A261; font-weight: bold;">${num}</span>`;
                                } else {
                                    return `<span style="color: #000000;">${num}</span>`;
                                }
                            }).join(' ');

                            winningNumbersHTML = `${frontNumbersHTML} | ${backNumbersHTML}`;
                        }

                        const period = result.issue || result.period || '未知';
                        const prizeLevel = result.prizeInfo.prizeLevel || '未中奖';
                        const prizeCondition = result.prizeInfo.prizeCondition || '-';
                        const prizeAmount = result.prizeInfo.prizeAmount || '0';

                        html += `<tr>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">${period}</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">${winningNumbersHTML}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center; color: ${prizeLevel !== '未中奖' ? '#E63946' : '#6c757d'}; font-weight: bold;">${prizeLevel}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center; color: ${prizeCondition !== '-' ? '#2A9D8F' : '#6c757d'}; font-weight: ${prizeCondition !== '-' ? 'bold' : 'normal'};">${prizeCondition}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">${prizeAmount}</td>
                        </tr>`;
                    });

                    html += `</tbody></table>`;

                    if (winningResults.length === 0) {
                        html = '<p style="color: #666; text-align: center; padding: 20px;">未找到中奖记录</p>';
                    }

                    resultContainer.innerHTML = html;
                }, 100);
            }

            // 更新数据库表格
            async updateDatabaseTable(lotteryType = null) {
                const tableBody = document.getElementById('databaseTableBody');
                tableBody.innerHTML = '';

                // 确定当前显示的数据库类型
                let displayLotteryType = lotteryType;
                
                // 如果没有传入lotteryType，则从面包屑导航获取
                if (!displayLotteryType) {
                    displayLotteryType = 'ssq';
                    const databaseCard = document.getElementById('databaseCard');
                    if (databaseCard && databaseCard.style.display !== 'none') {
                        // 检查面包屑导航确定当前是哪个数据库
                        const breadcrumbContainer = document.querySelector('.breadcrumb');
                        if (breadcrumbContainer) {
                            const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                            if (breadcrumbItems.length >= 3) {
                                const breadcrumbText = breadcrumbItems[2].textContent;
                                if (breadcrumbText.includes('大乐透')) {
                                    displayLotteryType = 'dlt';
                                }
                            }
                        }
                    }
                }

                // 恢复该彩票类型的状态
                currentPage = pageStates[displayLotteryType] || 1;
                totalDataCount = dataCountStates[displayLotteryType] || 0;
                totalPages = totalPagesStates[displayLotteryType] || 1;

                // 确保数据库已初始化
                if (!dataManager.databases[displayLotteryType]) {
                    dataManager.databases[displayLotteryType] = new LotteryDatabase(displayLotteryType);
                    await dataManager.databases[displayLotteryType].init();
                }

                // 根据显示的数据库类型获取对应数据
                let displayDatabaseData = null;
                if (dataManager.databases[displayLotteryType]) {
                    displayDatabaseData = await dataManager.databases[displayLotteryType].getData();
                }

                if (!displayDatabaseData || !displayDatabaseData.draws || displayDatabaseData.draws.length === 0) {
                    // 显示空状态
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td colspan="5" style="padding: 20px; text-align: center; border: 1px solid var(--border-color); color: var(--text-secondary);">
                            暂无数据
                        </td>
                    `;
                    tableBody.appendChild(row);

                    // 更新该彩票类型的状态为空
                    totalDataCount = 0;
                    totalPages = 1;
                    currentPage = 1;
                    dataCountStates[displayLotteryType] = totalDataCount;
                    totalPagesStates[displayLotteryType] = totalPages;
                    pageStates[displayLotteryType] = currentPage;

                    // 更新分页控件
                    this.updatePaginationControls();
                    return;
                }

                // 更新总数据条数
                totalDataCount = displayDatabaseData.draws.length;
                // 保存当前彩票类型的数据条数状态
                dataCountStates[displayLotteryType] = totalDataCount;

                // 计算总页数
                totalPages = Math.ceil(totalDataCount / pageSize);
                if (totalPages === 0) totalPages = 1;
                // 保存当前彩票类型的总页数状态
                totalPagesStates[displayLotteryType] = totalPages;

                // 确保当前页码在有效范围内
                if (currentPage > totalPages) {
                    currentPage = totalPages;
                }
                if (currentPage < 1) {
                    currentPage = 1;
                }

                // 保存当前页码状态
                pageStates[displayLotteryType] = currentPage;

                // 计算当前页的数据范围
                const startIndex = (currentPage - 1) * pageSize;
                const endIndex = Math.min(startIndex + pageSize, totalDataCount);

                // 获取当前页的数据
                const currentPageData = displayDatabaseData.draws.slice(startIndex, endIndex);

                if (currentPageData && currentPageData.length > 0) {
                    currentPageData.forEach((draw, index) => {
                        const row = document.createElement('tr');
                        row.setAttribute('data-period', draw.period);

                        // 根据彩票类型格式化号码显示
                        let numbersDisplay = '';
                        let numbersString = '';
                        if (displayLotteryType === 'ssq') {
                            // 双色球格式：红球+蓝球
                            const redBalls = draw.redBalls || [];
                            const blueBalls = draw.blueBalls || [];
                            numbersString = `${redBalls.join(',')}+${blueBalls.join(',')}`;
                            const redBallsDisplay = redBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #E63946; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                            const blueBallsDisplay = blueBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #457B9D; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                            numbersDisplay = `${redBallsDisplay}+${blueBallsDisplay}`;
                        } else if (displayLotteryType === 'dlt') {
                            // 大乐透格式：前区+后区
                            const frontBalls = draw.redBalls || [];
                            const backBalls = draw.blueBalls || [];
                            numbersString = `${frontBalls.join(',')}+${backBalls.join(',')}`;
                            const frontBallsDisplay = frontBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #2A9D8F; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                            const backBallsDisplay = backBalls.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #F4A261; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                            numbersDisplay = `${frontBallsDisplay}+${backBallsDisplay}`;
                        }

                        // 计算分析指标
                        const metrics = EventDelegate.calculateAnalysisMetrics(numbersString, displayLotteryType);

                        // 格式化分析指标，数字部分用彩色显示
                        const metricsDisplay = `和值:<span style="color: #E63946; font-weight: bold;">${metrics.sum || 0}</span>|跨度:<span style="color: #457B9D; font-weight: bold;">${metrics.span || 0}</span>|连号:<span style="color: #2A9D8F; font-weight: bold;">${metrics.consecutive || 0}</span>|大中小:<span style="color: #F4A261; font-weight: bold;">${metrics.zoneDistribution || '0-0-0'}</span>|奇偶:<span style="color: #9B5DE5; font-weight: bold;">${metrics.oddEvenRatio || '0:0'}</span>|AC值:<span style="color: #FF7700; font-weight: bold;">${metrics.acValue || 0}</span>|大小比:<span style="color: #00BBBB; font-weight: bold;">${metrics.bigSmallRatio || '0:0'}</span>|质合比:<span style="color: #0077FF; font-weight: bold;">${metrics.primeCompositeRatio || '0:0'}</span>`;

                        row.innerHTML = `
                            <td style="padding: 8px; border: 1px solid var(--border-color); text-align: center;">
                                <input type="checkbox" class="row-checkbox" value="${draw.period}">
                            </td>
                            <td style="padding: 8px; border: 1px solid var(--border-color);">${draw.period}</td>
                            <td style="padding: 8px; border: 1px solid var(--border-color);">${numbersDisplay}</td>
                            <td style="padding: 8px; border: 1px solid var(--border-color); font-size: 13px;">
                                ${metricsDisplay}
                            </td>
                            <td style="padding: 8px; border: 1px solid var(--border-color); text-align: center;">
                                <button class="btn btn-info" onclick="dataManager.showNineChart('${draw.period}', '${numbersString.replace(/'/g, '&quot;')}', 'database-jiuzhuan-${draw.period}')" style="padding: 4px 8px; margin-right: 4px; font-size: 12px; background-color: #17a2b8; color: #fff; border: none; border-radius: 4px; cursor: pointer;" title="九转图">
                                    <i class="fas fa-circle-notch"></i> 九转图
                                </button>
                                <button class="btn btn-success" onclick="dataManager.showDNAAnalysis('${draw.period}', '${numbersString.replace(/'/g, '&quot;')}')" style="padding: 4px 8px; margin-right: 4px; font-size: 12px; background-color: #28a745; color: #fff; border: none; border-radius: 4px; cursor: pointer;" title="DNA分析">
                                    <i class="fas fa-dna"></i> DNA
                                </button>
                                <button class="btn btn-danger" onclick="dataManager.deleteSingleRecord('${draw.period}')" style="padding: 4px 8px; font-size: 12px; background-color: #dc3545; color: #fff; border: none; border-radius: 4px; cursor: pointer;">
                                    <i class="fas fa-trash"></i> 删除
                                </button>
                            </td>
                        `;
                        tableBody.appendChild(row);
                    });
                } else {
                    // 显示空状态
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td colspan="5" style="padding: 20px; text-align: center; border: 1px solid var(--border-color); color: var(--text-secondary);">
                            暂无数据
                        </td>
                    `;
                    tableBody.appendChild(row);
                }

                // 更新数据计数显示
                const countElement = document.getElementById('dataCount');
                if (countElement) {
                    countElement.textContent = totalDataCount;
                }

                // 更新标题旁的数据条数显示
                const countBadge = document.getElementById('dataCountBadge');
                if (countBadge) {
                    countBadge.textContent = `(已加载${totalDataCount}条数据)`;
                }

                // 更新分页控件
                this.updatePaginationControls();

                // 重置全选复选框
                const selectAllCheckbox = document.getElementById('selectAllCheckbox');
                if (selectAllCheckbox) {
                    selectAllCheckbox.checked = false;
                }
            }

            // 更新分页控件状态
            updatePaginationControls() {
                // 更新总数据条数显示
                const totalCountElement = document.getElementById('totalCount');
                if (totalCountElement) {
                    totalCountElement.textContent = totalDataCount;
                }

                // 更新总页数显示
                const totalPagesElement = document.getElementById('totalPages');
                if (totalPagesElement) {
                    totalPagesElement.textContent = totalPages;
                }

                // 更新当前页码输入框
                const currentPageInput = document.getElementById('currentPageInput');
                if (currentPageInput) {
                    currentPageInput.value = currentPage;
                    currentPageInput.max = totalPages;
                }

                // 更新按钮状态
                const firstPageBtn = document.getElementById('firstPageBtn');
                const prevPageBtn = document.getElementById('prevPageBtn');
                const nextPageBtn = document.getElementById('nextPageBtn');
                const lastPageBtn = document.getElementById('lastPageBtn');

                if (firstPageBtn) {
                    firstPageBtn.disabled = currentPage === 1;
                    firstPageBtn.style.opacity = currentPage === 1 ? '0.5' : '1';
                }

                if (prevPageBtn) {
                    prevPageBtn.disabled = currentPage === 1;
                    prevPageBtn.style.opacity = currentPage === 1 ? '0.5' : '1';
                }

                if (nextPageBtn) {
                    nextPageBtn.disabled = currentPage === totalPages;
                    nextPageBtn.style.opacity = currentPage === totalPages ? '0.5' : '1';
                }

                if (lastPageBtn) {
                    lastPageBtn.disabled = currentPage === totalPages;
                    lastPageBtn.style.opacity = currentPage === totalPages ? '0.5' : '1';
                }
            }

            // 删除单条记录
            async deleteSingleRecord(period) {
                if (!confirm(`确定要删除期号 ${period} 的数据吗？`)) {
                    return;
                }

                // 确定当前显示的数据库类型
                let displayLotteryType = 'ssq';
                const databaseCard = document.getElementById('databaseCard');
                if (databaseCard && databaseCard.style.display !== 'none') {
                    // 检查面包屑导航确定当前是哪个数据库
                    const breadcrumbContainer = document.querySelector('.breadcrumb');
                    if (breadcrumbContainer) {
                        const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                        if (breadcrumbItems.length >= 3) {
                            const breadcrumbText = breadcrumbItems[2].textContent;
                            if (breadcrumbText.includes('大乐透')) {
                                displayLotteryType = 'dlt';
                            }
                        }
                    }
                }

                // 确保数据库已初始化
                if (!dataManager.databases[displayLotteryType]) {
                    dataManager.databases[displayLotteryType] = new LotteryDatabase(displayLotteryType);
                    await dataManager.databases[displayLotteryType].init();
                }

                // 获取当前显示数据库的数据
                const displayDatabaseData = await dataManager.databases[displayLotteryType].getData();

                // 从当前显示数据库的数据中移除指定记录
                displayDatabaseData.draws = displayDatabaseData.draws.filter(draw => draw.period !== period);

                // 保存数据到对应的数据库
                await dataManager.databases[displayLotteryType].saveData(displayDatabaseData);

                // 更新表格显示
                this.updateDatabaseTable(displayLotteryType);

                MessageSystem.showMessage(`已删除期号 ${period} 的数据`, 'success');
            }

            // 保存当前数据库数据
            async saveCurrentDatabaseData() {
                try {
                    await this.currentDb.saveData(currentDatabaseData);

                } catch (error) {
                    console.error('保存数据库数据失败:', error);
                    MessageSystem.showMessage('保存数据失败: ' + error.message, 'error');
                }
            }

            // 解析并校验开奖数据
            parseAndValidateDrawData(dataLine, lotteryType) {
                try {
                    const rules = LOTTERY_RULES[lotteryType];
                    if (!rules) {
                        return { success: false, error: `不支持的彩票类型: ${lotteryType}` };
                    }

                    let normalizedDataLine = dataLine.replace(/，/g, ',');

                    const partsPlus = normalizedDataLine.split('+');
                    if (partsPlus.length !== 2) {
                        return { success: false, error: '号码格式错误：应为 "期号,红球号码+蓝球号码" 格式' };
                    }

                    const redPart = partsPlus[0];
                    const bluePart = partsPlus[1];

                    const redPartParts = redPart.split(',');
                    if (redPartParts.length < 2) {
                        return { success: false, error: '数据格式错误：至少需要期号和红球号码' };
                    }

                    const period = redPartParts[0].trim();

                    if (!/^\d{7}$/.test(period)) {
                        return { success: false, error: '期号格式错误：必须为7位数字' };
                    }

                    let redBalls = [];
                    let blueBalls = [];

                    const redNumbers = redPartParts.slice(1).map(n => n.trim()).filter(n => n !== '');

                    const blueNumbers = bluePart.split(',').map(n => n.trim()).filter(n => n !== '');

                    if (redNumbers.length !== rules.redBallCount) {
                        return { success: false, error: `${rules.displayName}${rules.redBallName}必须是${rules.redBallCount}个号码` };
                    }

                    const redNums = redNumbers.map(num => {
                        const n = parseInt(num, 10);
                        if (isNaN(n) || n < rules.redBallRange[0] || n > rules.redBallRange[1]) {
                            throw new Error(`${rules.redBallName}号码必须在${rules.redBallRange[0]}-${rules.redBallRange[1]}之间`);
                        }
                        return n;
                    });

                    if (new Set(redNums).size !== redNums.length) {
                        return { success: false, error: `${rules.redBallName}号码不能有重复` };
                    }

                    if (blueNumbers.length !== rules.blueBallCount) {
                        return { success: false, error: `${rules.displayName}${rules.blueBallName}必须是${rules.blueBallCount}个号码` };
                    }

                    const blueNums = blueNumbers.map(num => {
                        const n = parseInt(num, 10);
                        if (isNaN(n) || n < rules.blueBallRange[0] || n > rules.blueBallRange[1]) {
                            throw new Error(`${rules.blueBallName}号码必须在${rules.blueBallRange[0]}-${rules.blueBallRange[1]}之间`);
                        }
                        return n;
                    });

                    if (rules.blueBallCount > 1 && new Set(blueNums).size !== blueNums.length) {
                        return { success: false, error: `${rules.blueBallName}号码不能有重复` };
                    }

                    redBalls = redNums.map(n => n.toString().padStart(2, '0'));
                    blueBalls = blueNums.map(n => n.toString().padStart(2, '0'));

                    return {
                        success: true,
                        data: {
                            period: period,
                            redBalls: redBalls,
                            blueBalls: blueBalls
                        }
                    };

                } catch (error) {
                    return { success: false, error: error.message || '数据解析失败' };
                }
            }

            // 测试数据校验功能
            testValidation() {


                // 测试双色球数据
                const ssqTests = [
                    { data: '2025135,01,02,05,09,25,32+10', type: 'ssq', expected: true },
                    { data: '2025135,01,02,05,09,25,32+17', type: 'ssq', expected: false }, // 蓝球超出范围
                    { data: '2025135,01,02,05,09,25+10', type: 'ssq', expected: false }, // 红球数量不足
                    { data: '2025135,01,02,05,09,25,34+10', type: 'ssq', expected: false }, // 红球超出范围
                    { data: '2025135,01,01,05,09,25,32+10', type: 'ssq', expected: false }  // 红球重复
                ];


                ssqTests.forEach((test, index) => {
                    const result = this.parseAndValidateDrawData(test.data, test.type);
                    const passed = result.success === test.expected;

                    if (!passed) {

                    }
                });

                // 测试大乐透数据
                const dltTests = [
                    { data: '2025143,03,04,18,24,29+07,12', type: 'dlt', expected: true },
                    { data: '2025143,03,04,18,24,29+13', type: 'dlt', expected: false }, // 后区号码数量不足
                    { data: '2025143,03,04,18,24+07,12', type: 'dlt', expected: false }, // 前区号码数量不足
                    { data: '2025143,03,04,18,24,36+07,12', type: 'dlt', expected: false }, // 前区号码超出范围
                    { data: '2025143,03,04,18,24,29+07,07', type: 'dlt', expected: false }  // 后区号码重复
                ];


                dltTests.forEach((test, index) => {
                    const result = this.parseAndValidateDrawData(test.data, test.type);
                    const passed = result.success === test.expected;

                    if (!passed) {

                    }
                });


            }

            switchHistorySamePeriod(direction, lotteryType, currentPeriod, filterYear) {
                let newPeriod;
                let newFilterYear = filterYear;

                if (filterYear !== null) {
                    const currentPeriodNum = parseInt(currentPeriod);
                    if (direction === 'prev') {
                        if (currentPeriodNum > 1) {
                            newPeriod = (currentPeriodNum - 1).toString().padStart(3, '0');
                        } else {
                            MessageSystem.showMessage('已经是第一期了', 'warning');
                            return;
                        }
                    } else if (direction === 'next') {
                        newPeriod = (currentPeriodNum + 1).toString().padStart(3, '0');
                    }
                } else {
                    const currentPeriodNum = parseInt(currentPeriod);
                    if (direction === 'prev') {
                        if (currentPeriodNum > 1) {
                            newPeriod = (currentPeriodNum - 1).toString().padStart(3, '0');
                        } else {
                            MessageSystem.showMessage('已经是第一期了', 'warning');
                            return;
                        }
                    } else if (direction === 'next') {
                        newPeriod = (currentPeriodNum + 1).toString().padStart(3, '0');
                    }
                }

                if (!newPeriod) {
                    return;
                }

                MessageSystem.showMessage('正在查询历史同期开奖数据...', 'info');

                try {
                    const draws = currentDatabaseData.draws || [];
                    if (draws.length === 0) {
                        document.getElementById('historySamePeriodQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">暂无历史数据</p>`;
                        return;
                    }

                    const historySamePeriodDraws = draws.filter(draw => {
                        const drawPeriod = draw.issue || draw.period || '';
                        const periodMatch = drawPeriod.match(/^(\d{4})(\d{3})$/);
                        if (!periodMatch) return false;
                        
                        const drawYear = parseInt(periodMatch[1]);
                        const drawPeriodNum = parseInt(periodMatch[2]);
                        const drawPeriodStr = periodMatch[2];
                        
                        if (newFilterYear !== null) {
                            return drawYear === newFilterYear && drawPeriodStr === newPeriod;
                        } else {
                            return drawPeriodStr === newPeriod;
                        }
                    });

                    if (historySamePeriodDraws.length === 0) {
                        document.getElementById('historySamePeriodQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">未找到期号 ${newPeriod} 的历史开奖数据</p>`;
                        return;
                    }

                    EventDelegate.displayHistorySamePeriodResult(historySamePeriodDraws, lotteryType, newPeriod, newFilterYear);
                } catch (error) {
                    console.error('历史同期查询错误:', error);
                    MessageSystem.showMessage('查询出错: ' + error.message, 'error');
                }
            }
        }

        // 初始化数据管理器
        const dataManager = new LotteryDataManager();

        // 智能推荐引擎
        class RecommendationEngine {
            constructor() {
                this.weights = {
                    frequency: 0.25,
                    omission: 0.20,
                    trend: 0.15,
                    pattern: 0.15,
                    statistics: 0.15,
                    others: 0.10
                };
                this.loadWeights();

                this.autoUpdateEnabled = false;
                this.updateInterval = null;
                this.updateFrequency = 60000;
                this.listeners = [];
                this.lastUpdateTime = null;

                this.historicalAccuracy = {
                    shortTerm: { hitRate: 0, sampleSize: 0 },
                    mediumTerm: { hitRate: 0, sampleSize: 0 },
                    longTerm: { hitRate: 0, sampleSize: 0 },
                    overall: { hitRate: 0, sampleSize: 0 }
                };

                this.confidenceMetrics = {
                    scoreConsistency: 0,
                    trendAlignment: 0,
                    patternStrength: 0,
                    statisticalSignificance: 0
                };
            }

            loadWeights() {
                const saved = localStorage.getItem('recommendationWeights');
                if (saved) {
                    try {
                        this.weights = JSON.parse(saved);
                    } catch (e) {

                    }
                }
            }

            saveWeights() {
                localStorage.setItem('recommendationWeights', JSON.stringify(this.weights));
            }

            updateWeights(newWeights) {
                const total = Object.values(newWeights).reduce((sum, val) => sum + val, 0);
                if (Math.abs(total - 1.0) > 0.01) {
                    throw new Error('权重总和必须等于1.0');
                }
                this.weights = { ...newWeights };
                this.saveWeights();
            }

            generateRecommendations(draws, analysisResults) {
                try {
                    if (!draws || !Array.isArray(draws) || draws.length === 0) {
                        throw new Error('开奖数据不能为空');
                    }

                    if (!currentLotteryType || !LOTTERY_RULES[currentLotteryType]) {
                        throw new Error('无效的彩票类型');
                    }

                    const periodCount = Math.min(30, draws.length);
                    const recentDraws = draws.slice(-periodCount);
                    const lotteryType = currentLotteryType;
                    const rules = LOTTERY_RULES[lotteryType];

                    const step1 = this.getHotNumbers(recentDraws, rules);
                    const step2 = this.getColdReboundNumbers(recentDraws, rules);
                    const step3 = this.getOddEvenBalance(recentDraws);
                    const step4 = this.getBigSmallDistribution(recentDraws, rules);
                    const step5 = this.getPrimeCompositeDistribution(recentDraws);
                    const step6 = this.getHistoricalPatterns(analysisResults);
                    const step7 = this.getACValueRange(recentDraws);
                    const step8 = this.getMonteCarloValidation(analysisResults);

                    const candidates = this.generateCandidateNumbers(step1, step2, step3, step4, step5, step6, step7, step8);
                    const scoredCombinations = this.scoreCombinations(candidates, recentDraws, rules, step1, step2, step3, step4, step5, step6, step7, step8);
                    const rankedCombinations = scoredCombinations.sort((a, b) => b.totalScore - a.totalScore);
                    const recommendations = this.generateStarRatings(rankedCombinations);
                    const blueBallRecommendations = this.generateBlueBallRecommendations(recentDraws, rules);

                    const numberFrequency = this.calculateNumberFrequency(recommendations, step1, step2, step6);
                    const largeComplex = this.generateLargeComplex(numberFrequency, rules);

                    this.calculateHistoricalAccuracy(draws, recommendations);
                    this.calculateConfidenceMetrics(recommendations, step1, step2, step3, step4, step5, step6, step7, step8);

                    return {
                        redBallRecommendations: recommendations,
                        blueBallRecommendations: blueBallRecommendations,
                        largeComplex: largeComplex,
                        numberFrequency: numberFrequency,
                        weights: this.weights,
                        historicalAccuracy: this.historicalAccuracy,
                        confidenceMetrics: this.confidenceMetrics,
                        analysisSteps: {
                            hotNumbers: step1,
                            coldReboundNumbers: step2,
                            oddEvenBalance: step3,
                            bigSmallDistribution: step4,
                            primeCompositeDistribution: step5,
                            historicalPatterns: step6,
                            acValueRange: step7,
                            monteCarloValidation: step8
                        }
                    };
                } catch (error) {
                    console.error('生成推荐时出错:', error);
                    MessageSystem.showMessage(`生成推荐失败: ${error.message}`, 'error');
                    return null;
                }
            }

            getHotNumbers(draws, rules) {
                const redBallCount = rules.redBallRange[1];
                const frequency = {};

                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    frequency[num] = 0;
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (frequency[ball] !== undefined) {
                            frequency[ball]++;
                        }
                    });
                });

                const sortedNumbers = Object.entries(frequency)
                    .sort((a, b) => b[1] - a[1]);
                const top20Percent = Math.ceil(redBallCount * 0.2);
                const hotNumbers = sortedNumbers.slice(0, top20Percent).map(([num]) => num);

                return {
                    numbers: hotNumbers,
                    frequency: frequency,
                    top20Percent: top20Percent
                };
            }

            getColdReboundNumbers(draws, rules) {
                const redBallCount = rules.redBallRange[1];
                const omission = {};

                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    omission[num] = 0;
                }

                for (let i = draws.length - 1; i >= 0; i--) {
                    const draw = draws[i];
                    draw.redBalls.forEach(ball => {
                        if (omission[ball] !== undefined) {
                            omission[ball] = 0;
                        }
                    });
                    Object.keys(omission).forEach(num => {
                        if (!draw.redBalls.includes(num)) {
                            omission[num]++;
                        }
                    });
                }

                const coldReboundNumbers = Object.entries(omission)
                    .filter(([num, count]) => count >= 15)
                    .sort((a, b) => b[1] - a[1])
                    .map(([num]) => num);

                return {
                    numbers: coldReboundNumbers,
                    omission: omission
                };
            }

            getOddEvenBalance(draws) {
                const oddCounts = draws.map(draw => {
                    return draw.redBalls.filter(ball => parseInt(ball) % 2 === 1).length;
                });

                const avgOdd = oddCounts.reduce((sum, count) => sum + count, 0) / oddCounts.length;
                const oddCountsFreq = {};
                oddCounts.forEach(count => {
                    oddCountsFreq[count] = (oddCountsFreq[count] || 0) + 1;
                });

                const bestRatio = Object.entries(oddCountsFreq)
                    .sort((a, b) => b[1] - a[1])[0];
                const targetOddCount = parseInt(bestRatio[0]);

                return {
                    avgOdd: avgOdd,
                    targetOddCount: targetOddCount,
                    frequency: oddCountsFreq
                };
            }

            getBigSmallDistribution(draws, rules) {
                const boundary = rules.name === '双色球' ? 16 : 17;
                const bigCounts = draws.map(draw => {
                    return draw.redBalls.filter(ball => parseInt(ball) > boundary).length;
                });

                const avgBig = bigCounts.reduce((sum, count) => sum + count, 0) / bigCounts.length;
                const bigCountsFreq = {};
                bigCounts.forEach(count => {
                    bigCountsFreq[count] = (bigCountsFreq[count] || 0) + 1;
                });

                const bestRatio = Object.entries(bigCountsFreq)
                    .sort((a, b) => b[1] - a[1])[0];
                const targetBigCount = parseInt(bestRatio[0]);

                return {
                    boundary: boundary,
                    avgBig: avgBig,
                    targetBigCount: targetBigCount,
                    frequency: bigCountsFreq
                };
            }

            getPrimeCompositeDistribution(draws) {
                const primes = ['02', '03', '05', '07', '11', '13', '17', '19', '23', '29', '31'];
                const primeCounts = draws.map(draw => {
                    return draw.redBalls.filter(ball => primes.includes(ball)).length;
                });

                const avgPrime = primeCounts.reduce((sum, count) => sum + count, 0) / primeCounts.length;
                const primeCountsFreq = {};
                primeCounts.forEach(count => {
                    primeCountsFreq[count] = (primeCountsFreq[count] || 0) + 1;
                });

                const bestRatio = Object.entries(primeCountsFreq)
                    .sort((a, b) => b[1] - a[1])[0];
                const targetPrimeCount = parseInt(bestRatio[0]);

                return {
                    primes: primes,
                    avgPrime: avgPrime,
                    targetPrimeCount: targetPrimeCount,
                    frequency: primeCountsFreq
                };
            }

            getHistoricalPatterns(analysisResults) {
                const patterns = {
                    consecutive: [],
                    sameTail: [],
                    arithmetic: [],
                    geometric: []
                };

                if (analysisResults && analysisResults.patterns) {
                    patterns.consecutive = analysisResults.patterns.consecutive || [];
                    patterns.sameTail = analysisResults.patterns.sameTail || [];
                }

                if (patternRecognitionData && patternRecognitionData.sequencePatterns) {
                    patterns.arithmetic = patternRecognitionData.sequencePatterns.arithmetic || [];
                    patterns.geometric = patternRecognitionData.sequencePatterns.geometric || [];
                }

                return patterns;
            }

            getACValueRange(draws) {
                const acValues = draws.map(draw => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    return EventDelegate.calculateACValue(redBalls);
                });

                const avgAC = acValues.reduce((sum, val) => sum + val, 0) / acValues.length;
                const minAC = Math.min(...acValues);
                const maxAC = Math.max(...acValues);

                return {
                    avgAC: avgAC,
                    minAC: minAC,
                    maxAC: maxAC,
                    targetRange: [Math.max(5, Math.floor(avgAC - 2)), Math.min(10, Math.ceil(avgAC + 2))]
                };
            }

            getMonteCarloValidation(analysisResults) {
                if (monteCarloAnalysisData && monteCarloAnalysisData.topNumbers) {
                    return {
                        topNumbers: monteCarloAnalysisData.topNumbers.slice(0, 10).map(n => n.num.toString().padStart(2, '0')),
                        meanProbability: monteCarloAnalysisData.meanProbability,
                        numSimulations: monteCarloAnalysisData.numSimulations
                    };
                }
                return {
                    topNumbers: [],
                    meanProbability: 0,
                    numSimulations: 0
                };
            }

            generateCandidateNumbers(step1, step2, step3, step4, step5, step6, step7, step8) {
                const candidates = new Set();

                step1.numbers.forEach(num => candidates.add(num));
                step2.numbers.forEach(num => candidates.add(num));

                if (step6.consecutive && step6.consecutive.length > 0) {
                    step6.consecutive.slice(0, 3).forEach(p => {
                        if (p.pair) {
                            p.pair.split('-').forEach(num => candidates.add(num));
                        }
                    });
                }

                if (step6.sameTail && step6.sameTail.length > 0) {
                    step6.sameTail.slice(0, 3).forEach(p => {
                        if (p.tail !== undefined) {
                            for (let i = 1; i <= 33; i++) {
                                const num = i.toString().padStart(2, '0');
                                if (parseInt(num) % 10 === p.tail) {
                                    candidates.add(num);
                                }
                            }
                        }
                    });
                }

                step8.topNumbers.forEach(num => candidates.add(num));

                return Array.from(candidates);
            }

            scoreCombinations(candidates, draws, rules, step1, step2, step3, step4, step5, step6, step7, step8) {
                try {
                    const maxCandidates = 15;
                    const limitedCandidates = candidates.slice(0, maxCandidates);

                    const combinations = [];
                    const generateCombinations = (arr, size) => {
                        const result = [];
                        const combine = (start, combo) => {
                            if (combo.length === size) {
                                result.push([...combo]);
                                return;
                            }
                            for (let i = start; i < arr.length; i++) {
                                combo.push(arr[i]);
                                combine(i + 1, combo);
                                combo.pop();
                            }
                        };
                        combine(0, []);
                        return result;
                    };

                    const allCombinations = generateCombinations(limitedCandidates, 6);

                    const maxCombinations = 1000;
                    const processedCombinations = allCombinations.slice(0, maxCombinations);

                    processedCombinations.forEach(combo => {
                        const sorted = combo.map(n => parseInt(n)).sort((a, b) => a - b);
                        const scores = this.calculateScores(sorted, step1, step2, step3, step4, step5, step6, step7, step8);
                        const totalScore = this.calculateTotalScore(scores);

                        if (totalScore >= 50) {
                            combinations.push({
                                numbers: sorted.map(n => n.toString().padStart(2, '0')),
                                scores: scores,
                                totalScore: totalScore
                            });
                        }
                    });

                    return combinations.sort((a, b) => b.totalScore - a.totalScore);
                } catch (error) {
                    console.error('评分组合时出错:', error);
                    return [];
                }
            }

            calculateScores(numbers, step1, step2, step3, step4, step5, step6, step7, step8) {
                const scores = {
                    frequency: this.calculateFrequencyScore(numbers, step1),
                    omission: this.calculateOmissionScore(numbers, step2),
                    trend: this.calculateTrendScore(numbers, step3, step4, step5),
                    pattern: this.calculatePatternScore(numbers, step6),
                    statistics: this.calculateStatisticsScore(numbers, step7, step8),
                    others: this.calculateOtherScore(numbers)
                };

                return scores;
            }

            calculateFrequencyScore(numbers, step1) {
                const hotCount = numbers.filter(n => step1.numbers.includes(n.toString().padStart(2, '0'))).length;
                if (hotCount >= 3) return 100;
                if (hotCount >= 2) return 80;
                if (hotCount >= 1) return 60;
                return 40;
            }

            calculateOmissionScore(numbers, step2) {
                const coldCount = numbers.filter(n => step2.numbers.includes(n.toString().padStart(2, '0'))).length;
                if (coldCount >= 2) return 100;
                if (coldCount >= 1) return 80;
                return 60;
            }

            calculateTrendScore(numbers, step3, step4, step5) {
                let score = 0;

                const oddCount = numbers.filter(n => n % 2 === 1).length;
                if (oddCount === step3.targetOddCount) score += 33;
                else if (Math.abs(oddCount - step3.targetOddCount) === 1) score += 22;

                const bigCount = numbers.filter(n => n > step4.boundary).length;
                if (bigCount === step4.targetBigCount) score += 33;
                else if (Math.abs(bigCount - step4.targetBigCount) === 1) score += 22;

                const primeCount = numbers.filter(n => step5.primes.includes(n.toString().padStart(2, '0'))).length;
                if (primeCount === step5.targetPrimeCount) score += 34;
                else if (Math.abs(primeCount - step5.targetPrimeCount) === 1) score += 23;

                return score;
            }

            calculatePatternScore(numbers, step6) {
                let score = 0;
                const numStr = numbers.map(n => n.toString().padStart(2, '0'));

                if (step6.consecutive && step6.consecutive.length > 0) {
                    const consecutiveCount = step6.consecutive.filter(p => {
                        if (!p.pair) return false;
                        const [num1, num2] = p.pair.split('-');
                        return numStr.includes(num1) && numStr.includes(num2);
                    }).length;
                    if (consecutiveCount >= 1) score += 50;
                }

                if (step6.arithmetic && step6.arithmetic.length > 0) {
                    const arithmeticCount = step6.arithmetic.filter(p => {
                        if (!p.pattern) return false;
                        return p.pattern.every(num => numStr.includes(num.toString().padStart(2, '0')));
                    }).length;
                    if (arithmeticCount >= 1) score += 50;
                }

                return score;
            }

            calculateStatisticsScore(numbers, step7, step8) {
                let score = 0;

                const acValue = EventDelegate.calculateACValue(numbers);
                if (acValue >= step7.targetRange[0] && acValue <= step7.targetRange[1]) {
                    score += 50;
                } else if (acValue >= step7.targetRange[0] - 1 && acValue <= step7.targetRange[1] + 1) {
                    score += 35;
                }

                const numStr = numbers.map(n => n.toString().padStart(2, '0'));
                const monteCarloCount = numStr.filter(n => step8.topNumbers.includes(n)).length;
                if (monteCarloCount >= 2) score += 50;
                else if (monteCarloCount >= 1) score += 35;

                return score;
            }

            calculateOtherScore(numbers) {
                const diversityScore = EventDelegate.calculateDiversityScore(numbers);
                return diversityScore * 100;
            }

            calculateTotalScore(scores) {
                return scores.frequency * this.weights.frequency +
                       scores.omission * this.weights.omission +
                       scores.trend * this.weights.trend +
                       scores.pattern * this.weights.pattern +
                       scores.statistics * this.weights.statistics +
                       scores.others * this.weights.others;
            }

            generateStarRatings(combinations) {
                return combinations.map(combo => {
                    let starRating;
                    if (combo.totalScore >= 85) {
                        starRating = 5;
                    } else if (combo.totalScore >= 75) {
                        starRating = 4;
                    } else if (combo.totalScore >= 65) {
                        starRating = 3;
                    } else {
                        starRating = 2;
                    }

                    const reason = this.generateRecommendationReason(combo);

                    return {
                        ...combo,
                        starRating: starRating,
                        confidence: Math.round(combo.totalScore),
                        strategyTags: this.generateStrategyTags(combo),
                        reason: reason
                    };
                }).sort((a, b) => b.starRating - a.starRating || b.totalScore - a.totalScore);
            }

            generateRecommendationReason(combo) {
                const reasons = [];
                const numStr = combo.numbers.map(n => n.toString().padStart(2, '0'));

                if (combo.scores.frequency >= 80) {
                    reasons.push(`包含${combo.scores.frequency >= 90 ? '多个' : '部分'}高频热号`);
                }

                if (combo.scores.omission >= 80) {
                    reasons.push(`结合${combo.scores.omission >= 90 ? '多个' : '部分'}冷号回补机会`);
                }

                if (combo.scores.trend >= 80) {
                    reasons.push(`奇偶大小质合比例均衡`);
                } else if (combo.scores.trend >= 60) {
                    reasons.push(`奇偶大小质合比例基本均衡`);
                }

                if (combo.scores.pattern >= 50) {
                    reasons.push(`符合历史高频组合模式`);
                }

                if (combo.scores.statistics >= 80) {
                    reasons.push(`AC值处于最优区间`);
                } else if (combo.scores.statistics >= 60) {
                    reasons.push(`AC值处于合理区间`);
                }

                if (combo.scores.others >= 70) {
                    reasons.push(`号码分布多样性优秀`);
                }

                const sorted = combo.numbers.sort((a, b) => a - b);
                const span = sorted[sorted.length - 1] - sorted[0];
                if (span >= 25) {
                    reasons.push(`号码跨度${span}，覆盖范围广`);
                } else if (span >= 20) {
                    reasons.push(`号码跨度${span}，覆盖范围适中`);
                }

                const tails = new Set();
                sorted.forEach(num => tails.add(num % 10));
                if (tails.size >= 5) {
                    reasons.push(`尾数分布${tails.size}种，多样性好`);
                }

                let consecutiveCount = 0;
                for (let i = 0; i < sorted.length - 1; i++) {
                    if (sorted[i + 1] - sorted[i] === 1) {
                        consecutiveCount++;
                    }
                }
                if (consecutiveCount === 1) {
                    reasons.push(`包含1组连号`);
                } else if (consecutiveCount === 0) {
                    reasons.push(`无连号组合`);
                }

                if (reasons.length === 0) {
                    reasons.push('综合各项指标分析得出');
                }

                return reasons.join('，') + '。';
            }

            generateStrategyTags(combo) {
                const tags = [];

                if (combo.scores.frequency >= 80) {
                    tags.push('🔥热号');
                }

                if (combo.scores.omission >= 80) {
                    tags.push('🔢冷号反弹');
                }

                if (combo.scores.trend >= 80) {
                    tags.push('⚖️均衡');
                }

                if (combo.scores.pattern >= 50) {
                    tags.push('🧬模式匹配');
                }

                if (combo.scores.statistics >= 80) {
                    tags.push('📊统计优势');
                }

                if (combo.scores.others >= 70) {
                    tags.push('🎯精准');
                }

                if (tags.length === 0) {
                    tags.push('📈综合推荐');
                }

                return tags;
            }

            calculateNumberFrequency(recommendations, hotNumbers, coldNumbers, patterns) {
                const frequency = {};
                const topRecommendations = recommendations.slice(0, Math.min(10, recommendations.length));

                topRecommendations.forEach(rec => {
                    rec.numbers.forEach(num => {
                        const numStr = num.toString().padStart(2, '0');
                        if (!frequency[numStr]) {
                            frequency[numStr] = {
                                count: 0,
                                totalScore: 0,
                                starRating: 0,
                                properties: []
                            };
                        }
                        frequency[numStr].count++;
                        frequency[numStr].totalScore += rec.totalScore;
                        frequency[numStr].starRating = Math.max(frequency[numStr].starRating, rec.starRating);
                    });
                });

                Object.keys(frequency).forEach(num => {
                    const avgScore = frequency[num].totalScore / frequency[num].count;
                    const props = frequency[num].properties;

                    if (hotNumbers.numbers.includes(num)) {
                        props.push('🔥热号');
                    }
                    if (coldNumbers.numbers.includes(num)) {
                        props.push('❄️冷号');
                    }
                    if (avgScore >= 80) {
                        props.push('⭐高分');
                    }
                    if (frequency[num].count >= 3) {
                        props.push('📈高频');
                    }
                });

                return Object.entries(frequency)
                    .map(([num, data]) => ({
                        number: num,
                        count: data.count,
                        avgScore: data.totalScore / data.count,
                        starRating: data.starRating,
                        properties: data.properties
                    }))
                    .sort((a, b) => b.count - a.count || b.avgScore - a.avgScore);
            }

            generateLargeComplex(numberFrequency, rules) {
                const redBallCount = rules.redBallRange[1];
                const minCount = Math.max(2, Math.floor(numberFrequency.length * 0.3));
                const topNumbers = numberFrequency.filter(n => n.count >= minCount);

                const sortedByScore = topNumbers
                    .sort((a, b) => b.count - a.count || b.avgScore - a.avgScore)
                    .map(n => n.number);

                const sortedNumbers = [...sortedByScore].sort((a, b) => parseInt(a) - parseInt(b));

                const oddCount = sortedNumbers.filter(n => parseInt(n) % 2 === 1).length;
                const evenCount = sortedNumbers.length - oddCount;
                const boundary = Math.ceil(redBallCount / 2);
                const bigCount = sortedNumbers.filter(n => parseInt(n) > boundary).length;
                const smallCount = sortedNumbers.length - bigCount;

                const primes = ['02', '03', '05', '07', '11', '13', '17', '19', '23', '29', '31'];
                const primeCount = sortedNumbers.filter(n => primes.includes(n)).length;
                const compositeCount = sortedNumbers.length - primeCount;

                const tails = {};
                sortedNumbers.forEach(num => {
                    const tail = num % 10;
                    tails[tail] = (tails[tail] || 0) + 1;
                });

                const topTails = Object.entries(tails)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([tail, count]) => `${tail}尾(${count}个)`)
                    .join('、');

                const zones = {
                    zone1: sortedNumbers.filter(n => parseInt(n) <= 11).length,
                    zone2: sortedNumbers.filter(n => parseInt(n) >= 12 && parseInt(n) <= 22).length,
                    zone3: sortedNumbers.filter(n => parseInt(n) >= 23).length
                };

                const consecutiveGroups = [];
                let currentGroup = [];
                for (let i = 0; i < sortedNumbers.length; i++) {
                    if (currentGroup.length === 0 || parseInt(sortedNumbers[i]) === parseInt(currentGroup[currentGroup.length - 1]) + 1) {
                        currentGroup.push(sortedNumbers[i]);
                    } else {
                        if (currentGroup.length >= 2) {
                            consecutiveGroups.push(currentGroup.join('-'));
                        }
                        currentGroup = [sortedNumbers[i]];
                    }
                }
                if (currentGroup.length >= 2) {
                    consecutiveGroups.push(currentGroup.join('-'));
                }

                const analysis = {
                    total: sortedNumbers.length,
                    oddCount: oddCount,
                    evenCount: evenCount,
                    bigCount: bigCount,
                    smallCount: smallCount,
                    primeCount: primeCount,
                    compositeCount: compositeCount,
                    tails: tails,
                    topTails: topTails,
                    zones: zones,
                    consecutiveGroups: consecutiveGroups,
                    properties: []
                };

                if (oddCount >= 4 && oddCount <= 8) {
                    analysis.properties.push('奇偶均衡');
                }
                if (bigCount >= 4 && bigCount <= 8) {
                    analysis.properties.push('大小均衡');
                }
                if (primeCount >= 3 && primeCount <= 6) {
                    analysis.properties.push('质合合理');
                }
                if (consecutiveGroups.length > 0) {
                    analysis.properties.push(`含${consecutiveGroups.length}组连号`);
                }
                if (zones.zone1 >= 2 && zones.zone2 >= 2 && zones.zone3 >= 2) {
                    analysis.properties.push('大中小均衡');
                }

                return {
                    numbers: sortedNumbers,
                    analysis: analysis
                };
            }

            generateBlueBallRecommendations(draws, rules) {
                try {
                    if (!draws || !Array.isArray(draws) || draws.length === 0) {
                        throw new Error('开奖数据不能为空');
                    }

                    if (!rules || !rules.blueBallRange) {
                        throw new Error('蓝球规则不完整');
                    }

                    const blueBallCount = rules.blueBallRange[1];
                    const frequency = {};
                    const omissionHistory = {};
                    const trendData = {};

                    for (let i = 1; i <= blueBallCount; i++) {
                        const num = i.toString().padStart(2, '0');
                        frequency[num] = {
                            count: 0,
                            omission: 0,
                            recentAppearances: [],
                            maxOmission: 0,
                            avgOmission: 0,
                            trend: 0,
                            cycle: 0
                        };
                        omissionHistory[num] = [];
                        trendData[num] = [];
                    }

                    let currentOmission = {};
                    for (let i = 1; i <= blueBallCount; i++) {
                        const num = i.toString().padStart(2, '0');
                        currentOmission[num] = 0;
                    }

                    draws.forEach((draw, index) => {
                        if (draw.blueBalls && draw.blueBalls.length > 0) {
                            draw.blueBalls.forEach(ball => {
                                if (frequency[ball]) {
                                    frequency[ball].count++;
                                    frequency[ball].recentAppearances.push(draw.period);

                                    if (currentOmission[ball] > frequency[ball].maxOmission) {
                                        frequency[ball].maxOmission = currentOmission[ball];
                                    }

                                    omissionHistory[ball].push(currentOmission[ball]);
                                    currentOmission[ball] = 0;

                                    trendData[ball].push(index);
                                }
                            });

                            Object.keys(frequency).forEach(num => {
                                if (!draw.blueBalls.includes(num)) {
                                    currentOmission[num]++;
                                }
                            });
                        }
                    });

                    Object.keys(frequency).forEach(num => {
                        frequency[num].omission = currentOmission[num];
                        const omissionSum = omissionHistory[num].reduce((a, b) => a + b, 0);
                        frequency[num].avgOmission = omissionHistory[num].length > 0 ? omissionSum / omissionHistory[num].length : 0;

                        const appearances = trendData[num];
                        if (appearances.length > 1) {
                            const intervals = [];
                            for (let i = 1; i < appearances.length; i++) {
                                intervals.push(appearances[i] - appearances[i-1]);
                            }
                            const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                            frequency[num].cycle = avgInterval;

                            const recentIntervals = intervals.slice(-5);
                            const recentAvg = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                            frequency[num].trend = recentAvg <= avgInterval ? 1 : -1;
                        }
                    });

                    const avgOmission = draws.length / blueBallCount;
                    const scoredBlueBalls = Object.entries(frequency).map(([num, data]) => {
                        const frequencyScore = Math.min(100, (data.count / draws.length) * 100 * 2.5) * 0.20;
                        const omissionScore = Math.min(100, (data.omission / (avgOmission * 2)) * 100) * 0.25;
                        const recentScore = data.recentAppearances.length > 0 ? 
                            Math.min(100, (draws.length - data.recentAppearances[data.recentAppearances.length - 1]) / 10 * 100) * 0.15 : 50;
                        const reboundScore = data.omission >= data.avgOmission * 1.5 ? 100 * 0.15 : data.omission >= data.avgOmission ? 75 * 0.15 : 50 * 0.15;
                        const trendScore = data.trend === 1 ? 80 * 0.10 : data.trend === -1 ? 40 * 0.10 : 60 * 0.10;
                        const cycleScore = data.cycle > 0 && data.cycle <= avgOmission * 1.5 ? 80 * 0.10 : 60 * 0.10;
                        const oddScore = (parseInt(num) % 2 === 1 ? 60 : 40) * 0.05;
                        const bigScore = (parseInt(num) > blueBallCount / 2 ? 60 : 40) * 0.05;

                        return {
                            num: num,
                            totalScore: frequencyScore + omissionScore + recentScore + reboundScore + trendScore + cycleScore + oddScore + bigScore,
                            details: {
                                frequencyScore: frequencyScore,
                                omissionScore: omissionScore,
                                recentScore: recentScore,
                                reboundScore: reboundScore,
                                trendScore: trendScore,
                                cycleScore: cycleScore,
                                oddScore: oddScore,
                                bigScore: bigScore,
                                count: data.count,
                                omission: data.omission,
                                avgOmission: data.avgOmission,
                                maxOmission: data.maxOmission,
                                trend: data.trend,
                                cycle: data.cycle
                            }
                        };
                    }).sort((a, b) => b.totalScore - a.totalScore);

                    const topBlueBall = scoredBlueBalls[0];
                    const reason = this.generateBlueBallReason(topBlueBall, avgOmission);

                    return {
                        number: topBlueBall.num,
                        confidence: Math.round(topBlueBall.totalScore),
                        reason: reason,
                        details: topBlueBall.details,
                        alternatives: scoredBlueBalls.slice(1, 4).map(b => b.num)
                    };
                } catch (error) {
                    console.error('生成蓝球推荐时出错:', error);
                    MessageSystem.showMessage(`生成蓝球推荐失败: ${error.message}`, 'error');
                    return null;
                }
            }

            generateBlueBallReason(blueBall, avgOmission) {
                const reasons = [];
                const data = blueBall.details;

                if (data.count > avgOmission * 1.5) {
                    reasons.push(`历史高频出现${data.count}次`);
                } else if (data.count > avgOmission) {
                    reasons.push(`历史出现${data.count}次，频率较高`);
                }

                if (data.omission >= avgOmission * 2) {
                    reasons.push(`当前遗漏${data.omission}期，超过平均遗漏${avgOmission.toFixed(1)}期的2倍`);
                } else if (data.omission >= avgOmission * 1.5) {
                    reasons.push(`当前遗漏${data.omission}期，超过平均遗漏${avgOmission.toFixed(1)}期的1.5倍`);
                } else if (data.omission >= avgOmission) {
                    reasons.push(`当前遗漏${data.omission}期，接近平均遗漏值`);
                }

                if (data.omission >= data.maxOmission * 0.9 && data.omission > 5) {
                    reasons.push(`接近历史最大遗漏${data.maxOmission}期`);
                }

                if (data.reboundScore > 75) {
                    reasons.push(`回补概率高`);
                }

                if (parseInt(blueBall.num) % 2 === 1) {
                    reasons.push(`奇数`);
                } else {
                    reasons.push(`偶数`);
                }

                if (parseInt(blueBall.num) > 8) {
                    reasons.push(`大号`);
                } else {
                    reasons.push(`小号`);
                }

                return reasons.join('，') + '。';
            }

            submitFeedback(recommendationId, actualNumbers, userRating) {
                try {
                    if (!recommendationId || !actualNumbers || userRating === undefined) {
                        throw new Error('反馈参数不完整');
                    }

                    const feedback = {
                        id: recommendationId,
                        actualNumbers: actualNumbers,
                        userRating: userRating,
                        timestamp: new Date().toISOString()
                    };

                    const feedbacks = this.loadFeedback();
                    feedbacks.push(feedback);
                    this.saveFeedback(feedbacks);

                    MessageSystem.showMessage('反馈提交成功，感谢您的评价！', 'success');
                    return true;
                } catch (error) {
                    console.error('提交反馈时出错:', error);
                    MessageSystem.showMessage(`提交反馈失败: ${error.message}`, 'error');
                    return false;
                }
            }

            loadFeedback() {
                try {
                    const saved = localStorage.getItem('recommendationFeedbacks');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                    return [];
                } catch (error) {
                    console.error('加载反馈数据时出错:', error);
                    return [];
                }
            }

            saveFeedback(feedbacks) {
                try {
                    const maxFeedbacks = 100;
                    const limitedFeedbacks = feedbacks.slice(-maxFeedbacks);
                    localStorage.setItem('recommendationFeedbacks', JSON.stringify(limitedFeedbacks));
                } catch (error) {
                    console.error('保存反馈数据时出错:', error);
                }
            }

            calculateAccuracy() {
                try {
                    const feedbacks = this.loadFeedback();
                    if (feedbacks.length === 0) {
                        return {
                            averageRating: 0,
                            totalFeedbacks: 0,
                            ratingDistribution: {}
                        };
                    }

                    const ratings = feedbacks.map(f => f.userRating);
                    const averageRating = ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length;

                    const ratingDistribution = {};
                    ratings.forEach(rating => {
                        ratingDistribution[rating] = (ratingDistribution[rating] || 0) + 1;
                    });

                    return {
                        averageRating: averageRating.toFixed(2),
                        totalFeedbacks: feedbacks.length,
                        ratingDistribution: ratingDistribution
                    };
                } catch (error) {
                    console.error('计算准确性时出错:', error);
                    return {
                        averageRating: 0,
                        totalFeedbacks: 0,
                        ratingDistribution: {}
                    };
                }
            }

            getRecommendationHistory() {
                try {
                    const saved = localStorage.getItem('recommendationHistory');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                    return [];
                } catch (error) {
                    console.error('加载推荐历史时出错:', error);
                    return [];
                }
            }

            saveRecommendationHistory(recommendation) {
                try {
                    const history = this.getRecommendationHistory();
                    const historyItem = {
                        id: Date.now().toString(),
                        timestamp: new Date().toISOString(),
                        recommendation: recommendation,
                        accuracy: null
                    };

                    history.push(historyItem);

                    const maxHistory = 50;
                    const limitedHistory = history.slice(-maxHistory);
                    localStorage.setItem('recommendationHistory', JSON.stringify(limitedHistory));

                    return historyItem.id;
                } catch (error) {
                    console.error('保存推荐历史时出错:', error);
                    return null;
                }
            }

            updateRecommendationAccuracy(recommendationId, accuracy) {
                try {
                    const history = this.getRecommendationHistory();
                    const item = history.find(h => h.id === recommendationId);
                    if (item) {
                        item.accuracy = accuracy;
                        localStorage.setItem('recommendationHistory', JSON.stringify(history));
                    }
                } catch (error) {
                    console.error('更新推荐准确性时出错:', error);
                }
            }

            enableAutoUpdate(callback, frequency = 60000) {
                try {
                    if (this.autoUpdateEnabled) {
                        this.disableAutoUpdate();
                    }

                    this.autoUpdateEnabled = true;
                    this.updateFrequency = frequency;
                    this.listeners.push(callback);

                    this.updateInterval = setInterval(() => {
                        this.performAutoUpdate();
                    }, this.updateFrequency);

                    this.lastUpdateTime = new Date();
                    console.log('自动更新已启用，更新频率:', frequency / 1000, '秒');
                } catch (error) {
                    console.error('启用自动更新时出错:', error);
                    MessageSystem.showMessage('启用自动更新失败', 'error');
                }
            }

            disableAutoUpdate() {
                try {
                    if (this.updateInterval) {
                        clearInterval(this.updateInterval);
                        this.updateInterval = null;
                    }

                    this.autoUpdateEnabled = false;
                    this.listeners = [];
                    console.log('自动更新已禁用');
                } catch (error) {
                    console.error('禁用自动更新时出错:', error);
                }
            }

            performAutoUpdate() {
                try {
                    if (!this.autoUpdateEnabled || this.listeners.length === 0) {
                        return;
                    }

                    const now = new Date();
                    const timeSinceLastUpdate = now - this.lastUpdateTime;

                    if (timeSinceLastUpdate >= this.updateFrequency) {
                        console.log('执行自动更新...');
                        this.lastUpdateTime = now;

                        this.listeners.forEach(callback => {
                            try {
                                callback();
                            } catch (error) {
                                console.error('执行更新回调时出错:', error);
                            }
                        });
                    }
                } catch (error) {
                    console.error('执行自动更新时出错:', error);
                }
            }

            setUpdateFrequency(frequency) {
                try {
                    if (frequency < 10000) {
                        throw new Error('更新频率不能小于10秒');
                    }

                    this.updateFrequency = frequency;

                    if (this.autoUpdateEnabled) {
                        this.disableAutoUpdate();
                        this.listeners.forEach(callback => {
                            this.enableAutoUpdate(callback, frequency);
                        });
                    }

                    MessageSystem.showMessage(`更新频率已设置为${frequency / 1000}秒`, 'success');
                } catch (error) {
                    console.error('设置更新频率时出错:', error);
                    MessageSystem.showMessage(`设置更新频率失败: ${error.message}`, 'error');
                }
            }

            addUpdateListener(callback) {
                if (!this.listeners.includes(callback)) {
                    this.listeners.push(callback);
                }
            }

            removeUpdateListener(callback) {
                const index = this.listeners.indexOf(callback);
                if (index > -1) {
                    this.listeners.splice(index, 1);
                }
            }

            isAutoUpdateEnabled() {
                return this.autoUpdateEnabled;
            }

            getLastUpdateTime() {
                return this.lastUpdateTime;
            }

            exportRecommendations(recommendations, format = 'json') {
                try {
                    if (!recommendations) {
                        throw new Error('推荐数据不能为空');
                    }

                    const timestamp = new Date().toISOString();
                    const exportData = {
                        timestamp: timestamp,
                        lotteryType: currentLotteryType,
                        recommendations: recommendations
                    };

                    let content, filename, mimeType;

                    if (format === 'json') {
                        content = JSON.stringify(exportData, null, 2);
                        filename = `recommendations_${timestamp}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        content = this.convertToCSV(recommendations);
                        filename = `recommendations_${timestamp}.csv`;
                        mimeType = 'text/csv';
                    } else if (format === 'txt') {
                        content = this.convertToText(recommendations);
                        filename = `recommendations_${timestamp}.txt`;
                        mimeType = 'text/plain';
                    } else {
                        throw new Error('不支持的导出格式');
                    }

                    this.downloadFile(content, filename, mimeType);
                    MessageSystem.showMessage(`推荐结果已导出为${filename}`, 'success');
                    return true;
                } catch (error) {
                    console.error('导出推荐结果时出错:', error);
                    MessageSystem.showMessage(`导出失败: ${error.message}`, 'error');
                    return false;
                }
            }

            convertToCSV(recommendations) {
                if (!recommendations.redBallRecommendations || recommendations.redBallRecommendations.length === 0) {
                    return '';
                }

                const headers = ['序号', '红球号码', '星级', '置信度', '推荐理由', '策略标签'];
                const rows = recommendations.redBallRecommendations.map((rec, index) => {
                    return [
                        index + 1,
                        rec.numbers.join(' '),
                        rec.starRating + '星',
                        rec.confidence + '%',
                        rec.reason,
                        rec.strategyTags.join(' ')
                    ].join(',');
                });

                return [headers.join(','), ...rows].join('\n');
            }

            convertToText(recommendations) {
                let text = `智能推荐结果\n`;
                text += `导出时间: ${new Date().toLocaleString()}\n`;
                text += `彩票类型: ${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}\n\n`;

                if (recommendations.blueBallRecommendations) {
                    text += `蓝球推荐: ${recommendations.blueBallRecommendations.number}\n`;
                    text += `置信度: ${recommendations.blueBallRecommendations.confidence}%\n`;
                    text += `推荐理由: ${recommendations.blueBallRecommendations.reason}\n\n`;
                }

                if (recommendations.redBallRecommendations && recommendations.redBallRecommendations.length > 0) {
                    text += `红球推荐:\n`;
                    text += `----------------------------------------\n`;
                    recommendations.redBallRecommendations.forEach((rec, index) => {
                        text += `${index + 1}. ${rec.numbers.join(' ')} [${rec.starRating}星]\n`;
                        text += `   置信度: ${rec.confidence}%\n`;
                        text += `   理由: ${rec.reason}\n`;
                        text += `   标签: ${rec.strategyTags.join(' ')}\n\n`;
                    });
                }

                if (recommendations.largeComplex && recommendations.largeComplex.numbers) {
                    text += `大复式推荐:\n`;
                    text += `----------------------------------------\n`;
                    text += `号码: ${recommendations.largeComplex.numbers.join(' ')}\n`;
                    text += `总数: ${recommendations.largeComplex.analysis.total}\n`;
                    text += `奇偶: ${recommendations.largeComplex.analysis.oddCount}:${recommendations.largeComplex.analysis.evenCount}\n`;
                    text += `大小: ${recommendations.largeComplex.analysis.bigCount}:${recommendations.largeComplex.analysis.smallCount}\n`;
                    text += `质合: ${recommendations.largeComplex.analysis.primeCount}:${recommendations.largeComplex.analysis.compositeCount}\n`;
                    text += `特性: ${recommendations.largeComplex.analysis.properties.join('、')}\n\n`;
                }

                return text;
            }

            downloadFile(content, filename, mimeType) {
                try {
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('下载文件时出错:', error);
                    throw new Error('下载文件失败');
                }
            }

            exportHistory(format = 'json') {
                try {
                    const history = this.getRecommendationHistory();
                    if (history.length === 0) {
                        MessageSystem.showMessage('没有可导出的推荐历史', 'info');
                        return false;
                    }

                    const timestamp = new Date().toISOString();
                    const exportData = {
                        timestamp: timestamp,
                        totalRecords: history.length,
                        history: history
                    };

                    let content, filename, mimeType;

                    if (format === 'json') {
                        content = JSON.stringify(exportData, null, 2);
                        filename = `recommendation_history_${timestamp}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        content = this.convertHistoryToCSV(history);
                        filename = `recommendation_history_${timestamp}.csv`;
                        mimeType = 'text/csv';
                    } else {
                        throw new Error('不支持的导出格式');
                    }

                    this.downloadFile(content, filename, mimeType);
                    MessageSystem.showMessage(`推荐历史已导出为${filename}`, 'success');
                    return true;
                } catch (error) {
                    console.error('导出推荐历史时出错:', error);
                    MessageSystem.showMessage(`导出失败: ${error.message}`, 'error');
                    return false;
                }
            }

            convertHistoryToCSV(history) {
                if (history.length === 0) {
                    return '';
                }

                const headers = ['ID', '时间', '红球推荐数', '蓝球推荐', '准确性'];
                const rows = history.map(item => {
                    const redBallCount = item.recommendation.redBallRecommendations ? 
                        item.recommendation.redBallRecommendations.length : 0;
                    const blueBall = item.recommendation.blueBallRecommendations ? 
                        item.recommendation.blueBallRecommendations.number : '无';
                    const accuracy = item.accuracy !== null ? `${item.accuracy}%` : '未评估';

                    return [
                        item.id,
                        new Date(item.timestamp).toLocaleString(),
                        redBallCount,
                        blueBall,
                        accuracy
                    ].join(',');
                });

                return [headers.join(','), ...rows].join('\n');
            }

            calculateHistoricalAccuracy(draws, recommendations) {
                try {
                    if (!draws || !Array.isArray(draws) || draws.length < 10) {
                        console.log('历史数据不足，无法计算准确率');
                        return;
                    }

                    const topRecommendations = recommendations.slice(0, 5);
                    const totalDraws = draws.length;

                    const shortTermDraws = Math.min(10, Math.floor(totalDraws * 0.2));
                    const mediumTermDraws = Math.min(30, Math.floor(totalDraws * 0.4));
                    const longTermDraws = Math.min(50, Math.floor(totalDraws * 0.6));

                    const calculateHitRate = (testDraws) => {
                        let totalHits = 0;
                        let totalPredictions = 0;

                        for (let i = 0; i < testDraws.length; i++) {
                            const drawIndex = draws.length - 1 - i;
                            if (drawIndex < 0) break;

                            const draw = draws[drawIndex];
                            const actualRedBalls = new Set(draw.redBalls);

                            topRecommendations.forEach(rec => {
                                const predictedRedBalls = new Set(rec.numbers);
                                const intersection = [...actualRedBalls].filter(x => predictedRedBalls.has(x));
                                const hitCount = intersection.length;
                                const hitRate = hitCount / 6;

                                totalHits += hitRate;
                                totalPredictions++;
                            });
                        }

                        return totalPredictions > 0 ? (totalHits / totalPredictions) * 100 : 0;
                    };

                    this.historicalAccuracy.shortTerm = {
                        hitRate: calculateHitRate(shortTermDraws),
                        sampleSize: shortTermDraws
                    };

                    this.historicalAccuracy.mediumTerm = {
                        hitRate: calculateHitRate(mediumTermDraws),
                        sampleSize: mediumTermDraws
                    };

                    this.historicalAccuracy.longTerm = {
                        hitRate: calculateHitRate(longTermDraws),
                        sampleSize: longTermDraws
                    };

                    const weightedHitRate = (
                        this.historicalAccuracy.shortTerm.hitRate * 0.5 +
                        this.historicalAccuracy.mediumTerm.hitRate * 0.3 +
                        this.historicalAccuracy.longTerm.hitRate * 0.2
                    );

                    this.historicalAccuracy.overall = {
                        hitRate: weightedHitRate,
                        sampleSize: shortTermDraws + mediumTermDraws + longTermDraws
                    };

                    console.log('历史准确率计算完成:', this.historicalAccuracy);
                } catch (error) {
                    console.error('计算历史准确率时出错:', error);
                }
            }

            calculateConfidenceMetrics(recommendations, step1, step2, step3, step4, step5, step6, step7, step8) {
                try {
                    if (!recommendations || recommendations.length === 0) {
                        console.log('推荐数据为空，无法计算置信度指标');
                        return;
                    }

                    const topRecommendations = recommendations.slice(0, 10);

                    const scores = topRecommendations.map(rec => rec.totalScore);
                    const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
                    const scoreVariance = scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length;
                    const scoreStdDev = Math.sqrt(scoreVariance);

                    this.confidenceMetrics.scoreConsistency = scoreStdDev < 10 ? 1 : scoreStdDev < 20 ? 0.8 : scoreStdDev < 30 ? 0.6 : 0.4;

                    const oddEvenAlignment = topRecommendations.filter(rec => rec.scores.trend >= 80).length / topRecommendations.length;
                    const bigSmallAlignment = topRecommendations.filter(rec => rec.scores.trend >= 80).length / topRecommendations.length;
                    const primeCompositeAlignment = topRecommendations.filter(rec => rec.scores.trend >= 80).length / topRecommendations.length;

                    this.confidenceMetrics.trendAlignment = (oddEvenAlignment + bigSmallAlignment + primeCompositeAlignment) / 3;

                    const patternAlignment = topRecommendations.filter(rec => rec.scores.pattern >= 50).length / topRecommendations.length;
                    this.confidenceMetrics.patternStrength = patternAlignment;

                    const statisticsAlignment = topRecommendations.filter(rec => rec.scores.statistics >= 60).length / topRecommendations.length;
                    this.confidenceMetrics.statisticalSignificance = statisticsAlignment;

                    console.log('置信度指标计算完成:', this.confidenceMetrics);
                } catch (error) {
                    console.error('计算置信度指标时出错:', error);
                }
            }

            calculateEnhancedConfidence(recommendation, historicalAccuracy, confidenceMetrics) {
                try {
                    const baseConfidence = recommendation.totalScore;

                    const accuracyBonus = historicalAccuracy.overall.hitRate * 0.2;

                    const consistencyBonus = confidenceMetrics.scoreConsistency * 10;
                    const trendBonus = confidenceMetrics.trendAlignment * 10;
                    const patternBonus = confidenceMetrics.patternStrength * 10;
                    const statisticsBonus = confidenceMetrics.statisticalSignificance * 10;

                    const totalBonus = accuracyBonus + consistencyBonus + trendBonus + patternBonus + statisticsBonus;

                    const enhancedConfidence = Math.min(100, baseConfidence + totalBonus);

                    return {
                        baseConfidence: baseConfidence,
                        enhancedConfidence: enhancedConfidence,
                        bonusBreakdown: {
                            accuracy: accuracyBonus,
                            consistency: consistencyBonus,
                            trend: trendBonus,
                            pattern: patternBonus,
                            statistics: statisticsBonus
                        }
                    };
                } catch (error) {
                    console.error('计算增强置信度时出错:', error);
                    return {
                        baseConfidence: recommendation.totalScore,
                        enhancedConfidence: recommendation.totalScore,
                        bonusBreakdown: {}
                    };
                }
            }

            generateAccuracyReport() {
                const accuracy = this.historicalAccuracy;
                const metrics = this.confidenceMetrics;

                let report = '<div class="accuracy-report">';
                report += '<h3><i class="fas fa-chart-line"></i> 历史准确率分析</h3>';

                report += '<div class="accuracy-grid">';
                report += '<div class="accuracy-item">';
                report += '<h4>短期准确率</h4>';
                report += `<p>${accuracy.shortTerm.hitRate.toFixed(1)}%</p>`;
                report += `<small>样本: ${accuracy.shortTerm.sampleSize}期</small>`;
                report += '</div>';

                report += '<div class="accuracy-item">';
                report += '<h4>中期准确率</h4>';
                report += `<p>${accuracy.mediumTerm.hitRate.toFixed(1)}%</p>`;
                report += `<small>样本: ${accuracy.mediumTerm.sampleSize}期</small>`;
                report += '</div>';

                report += '<div class="accuracy-item">';
                report += '<h4>长期准确率</h4>';
                report += `<p>${accuracy.longTerm.hitRate.toFixed(1)}%</p>`;
                report += `<small>样本: ${accuracy.longTerm.sampleSize}期</small>`;
                report += '</div>';

                report += '<div class="accuracy-item highlight">';
                report += '<h4>综合准确率</h4>';
                report += `<p>${accuracy.overall.hitRate.toFixed(1)}%</p>`;
                report += `<small>样本: ${accuracy.overall.sampleSize}期</small>`;
                report += '</div>';
                report += '</div>';

                report += '<h3><i class="fas fa-shield-alt"></i> 置信度指标</h3>';

                report += '<div class="confidence-grid">';
                report += '<div class="confidence-item">';
                report += '<h4>评分一致性</h4>';
                report += `<div class="progress-bar"><div class="progress" style="width: ${metrics.scoreConsistency * 100}%"></div></div>`;
                report += `<p>${(metrics.scoreConsistency * 100).toFixed(0)}%</p>`;
                report += '</div>';

                report += '<div class="confidence-item">';
                report += '<h4>趋势对齐度</h4>';
                report += `<div class="progress-bar"><div class="progress" style="width: ${metrics.trendAlignment * 100}%"></div></div>`;
                report += `<p>${(metrics.trendAlignment * 100).toFixed(0)}%</p>`;
                report += '</div>';

                report += '<div class="confidence-item">';
                report += '<h4>模式强度</h4>';
                report += `<div class="progress-bar"><div class="progress" style="width: ${metrics.patternStrength * 100}%"></div></div>`;
                report += `<p>${(metrics.patternStrength * 100).toFixed(0)}%</p>`;
                report += '</div>';

                report += '<div class="confidence-item">';
                report += '<h4>统计显著性</h4>';
                report += `<div class="progress-bar"><div class="progress" style="width: ${metrics.statisticalSignificance * 100}%"></div></div>`;
                report += `<p>${(metrics.statisticalSignificance * 100).toFixed(0)}%</p>`;
                report += '</div>';
                report += '</div>';

                report += '</div>';

                return report;
            }
        }

        // ==================== 全新预警辅助系统 ====================

        // 预警指标体系类
        class AlertIndicatorSystem {
            constructor() {
                this.realTimeStatus = {
                    drawCountdown: 0,
                    dataUpdateStatus: 'normal',
                    systemStatus: 'running'
                };
                this.riskLevels = {
                    red: { name: '红色预警', priority: 3, color: '#FF4444', icon: '🔴', description: '高风险信号，需立即关注' },
                    yellow: { name: '黄色预警', priority: 2, color: '#FFA500', icon: '🟡', description: '中等风险信号，建议关注' },
                    blue: { name: '蓝色预警', priority: 1, color: '#4A90E2', icon: '🔵', description: '低风险信号，保持观察' }
                };
                this.coreDimensions = {
                    cycle: { name: '周期规律预警', weight: 0.2 },
                    distribution: { name: '分布异常预警', weight: 0.2 },
                    pattern: { name: '模式突破预警', weight: 0.15 },
                    statistics: { name: '统计极值预警', weight: 0.2 },
                    trend: { name: '趋势拐点预警', weight: 0.15 },
                    correlation: { name: '关联断裂预警', weight: 0.1 }
                };
            }

            calculateDrawCountdown(draws) {
                if (!draws || draws.length === 0) return 0;
                const lastDraw = draws[draws.length - 1];
                const lastDrawDate = new Date(lastDraw.date);
                const now = new Date();
                const diffHours = Math.floor((now - lastDrawDate) / (1000 * 60 * 60));
                const hoursUntilDraw = 72 - diffHours;
                return Math.max(0, hoursUntilDraw);
            }

            checkDataUpdateStatus(draws) {
                if (!draws || draws.length === 0) return 'no_data';
                const lastDraw = draws[draws.length - 1];
                const lastDrawDate = new Date(lastDraw.date);
                const now = new Date();
                const diffDays = Math.floor((now - lastDrawDate) / (1000 * 60 * 60 * 24));

                if (diffDays > 7) return 'outdated';
                if (diffDays > 3) return 'warning';
                return 'normal';
            }

            checkSystemStatus() {
                const checks = {
                    dataManager: typeof dataManager !== 'undefined',
                    echarts: typeof echarts !== 'undefined',
                    localStorage: typeof localStorage !== 'undefined'
                };
                const allPassed = Object.values(checks).every(v => v);
                return allPassed ? 'running' : 'degraded';
            }

            getRealTimeStatus(draws) {
                return {
                    drawCountdown: this.calculateDrawCountdown(draws),
                    dataUpdateStatus: this.checkDataUpdateStatus(draws),
                    systemStatus: this.checkSystemStatus()
                };
            }

            calculateRiskScore(alerts) {
                if (!alerts || alerts.length === 0) return 0;
                let totalScore = 0;
                alerts.forEach(alert => {
                    const level = this.riskLevels[alert.level];
                    totalScore += level.priority;
                });
                return Math.min(100, (totalScore / alerts.length) * 20);
            }

            getRiskLevelByScore(score) {
                if (score >= 80) return 'red';
                if (score >= 50) return 'yellow';
                return 'blue';
            }

            getDimensionAlerts(alerts, dimension) {
                return alerts.filter(alert => alert.dimension === dimension);
            }

            calculateDimensionScore(alerts, dimension) {
                const dimensionAlerts = this.getDimensionAlerts(alerts, dimension);
                if (dimensionAlerts.length === 0) return 0;
                let totalPriority = 0;
                dimensionAlerts.forEach(alert => {
                    const level = this.riskLevels[alert.level];
                    totalPriority += level.priority;
                });
                return Math.min(100, (totalPriority / dimensionAlerts.length) * 25);
            }
        }

        // 预警信号类型类
        class AlertSignalTypes {
            constructor() {
                this.signalTypes = {
                    cycle: {
                        name: '周期性预警',
                        signals: {
                            cycleAbnormal: { name: '周期超常预警', description: '号码出现周期异常延长或缩短' },
                            cycleResonance: { name: '周期共振预警', description: '多个号码周期同时到达临界点' },
                            cycleFailure: { name: '周期失效预警', description: '历史稳定周期被打破' }
                        }
                    },
                    distribution: {
                        name: '分布性预警',
                        signals: {
                            areaCluster: { name: '区域聚集预警', description: '号码在特定区域过度集中' },
                            intervalAbnormal: { name: '间隔异常预警', description: '号码间隔分布偏离正常范围' },
                            patternRepeat: { name: '重复模式预警', description: '特定分布模式重复出现' }
                        }
                    },
                    statistics: {
                        name: '统计性预警',
                        signals: {
                            stdDeviation: { name: '标准差预警', description: '指标波动超过2倍标准差' },
                            skewnessKurtosis: { name: '偏度峰度预警', description: '分布形态发生显著变化' },
                            quantile: { name: '分位数预警', description: '指标进入历史极值区间' }
                        }
                    },
                    trend: {
                        name: '趋势性预警',
                        signals: {
                            momentumExhaustion: { name: '动量衰竭预警', description: '强势趋势动能减弱' },
                            divergence: { name: '背离预警', description: '价格与指标出现背离' },
                            breakthroughConfirm: { name: '突破确认预警', description: '关键位被有效突破' }
                        }
                    },
                    correlation: {
                        name: '关联性预警',
                        signals: {
                            correlationChange: { name: '相关性突变预警', description: '历史强相关关系突然减弱' },
                            clusterEffect: { name: '集群效应预警', description: '特定号码组同时出现异常' },
                            conductionEffect: { name: '传导效应预警', description: '预警信号在号码间传导' }
                        }
                    }
                };
            }

            detectCycleSignals(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                const alerts = [];
                const recentDraws = draws;
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                const numberCycles = {};
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberCycles[num] = [];
                }

                recentDraws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (numberCycles[ball]) {
                            numberCycles[ball].push(index);
                        }
                    });
                });

                Object.entries(numberCycles).forEach(([num, positions]) => {
                    if (positions.length < 5) return;

                    const intervals = [];
                    for (let i = 1; i < positions.length; i++) {
                        intervals.push(positions[i] - positions[i - 1]);
                    }

                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const stdInterval = Math.sqrt(intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length);
                    const lastInterval = positions[positions.length - 1] - positions[positions.length - 2];

                    const intervalThreshold = Math.max(10, Math.floor(recentDraws.length / 3));
                    if (lastInterval > avgInterval + 3 * stdInterval && lastInterval > intervalThreshold) {
                        alerts.push({
                            id: this.generateAlertId(),
                            type: 'cycle',
                            signal: 'cycleAbnormal',
                            dimension: 'cycle',
                            level: 'red',
                            number: num,
                            description: `号码${num}周期异常延长，当前间隔${lastInterval}期，平均间隔${avgInterval.toFixed(1)}期`,
                            value: lastInterval,
                            threshold: avgInterval + 3 * stdInterval,
                            timestamp: new Date().toISOString(),
                            dataSource: 'database+basicAnalysis'
                        });
                    }

                    const recentPositions = positions.slice(-5);
                    if (recentPositions.length >= 5) {
                        const recentIntervals = [];
                        for (let i = 1; i < recentPositions.length; i++) {
                            recentIntervals.push(recentPositions[i] - recentPositions[i - 1]);
                        }
                        const avgRecentInterval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                        const isResonance = recentIntervals.every(interval => Math.abs(interval - avgRecentInterval) < 1);

                        const resonanceThreshold = Math.max(5, Math.floor(recentDraws.length / 10));
                        if (isResonance && recentIntervals.length >= 4 && avgInterval < resonanceThreshold) {
                            alerts.push({
                                id: this.generateAlertId(),
                                type: 'cycle',
                                signal: 'cycleResonance',
                                dimension: 'cycle',
                                level: 'blue',
                                number: num,
                                description: `号码${num}周期共振，连续${recentIntervals.length}期间隔稳定`,
                                value: recentIntervals.join(','),
                                threshold: avgInterval.toFixed(1),
                                timestamp: new Date().toISOString(),
                                dataSource: 'database+basicAnalysis'
                            });
                        }
                    }
                });

                if (basicAnalysisData && basicAnalysisData.omissions && basicAnalysisData.frequencies) {
                    Object.entries(basicAnalysisData.omissions).forEach(([num, omission]) => {
                        const frequency = basicAnalysisData.frequencies[num] || 1;
                        const avgOmission = (recentDraws.length / frequency).toFixed(1);
                        const omissionThreshold = Math.max(10, Math.floor(recentDraws.length / 3));

                        if (omission > parseFloat(avgOmission) * 3 && omission > omissionThreshold) {
                            alerts.push({
                                id: this.generateAlertId(),
                                type: 'cycle',
                                signal: 'omissionHigh',
                                dimension: 'cycle',
                                level: 'red',
                                number: num,
                                description: `号码${num}遗漏过高，当前遗漏${omission}期，平均遗漏${avgOmission}期`,
                                value: omission,
                                threshold: parseFloat(avgOmission) * 3,
                                timestamp: new Date().toISOString(),
                                dataSource: 'database+basicAnalysis'
                            });
                        }
                    });
                }

                return alerts;
            }

            detectDistributionSignals(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                const alerts = [];
                const recentDraws = draws;
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                const zoneCounts = { zone1: 0, zone2: 0, zone3: 0 };
                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num <= 11) zoneCounts.zone1++;
                        else if (num <= 22) zoneCounts.zone2++;
                        else zoneCounts.zone3++;
                    });
                });

                const totalBalls = recentDraws.length * 6;
                const zone1Percent = (zoneCounts.zone1 / totalBalls) * 100;
                const zone2Percent = (zoneCounts.zone2 / totalBalls) * 100;
                const zone3Percent = (zoneCounts.zone3 / totalBalls) * 100;

                if (zone1Percent > 45 || zone2Percent > 45 || zone3Percent > 45) {
                    const clusteredZone = zone1Percent > 45 ? '小区' : zone2Percent > 45 ? '中区' : '大区';
                    alerts.push({
                        id: this.generateAlertId(),
                        type: 'distribution',
                        signal: 'areaCluster',
                        dimension: 'distribution',
                        level: 'yellow',
                        description: `${clusteredZone}过度集中，占比${Math.max(zone1Percent, zone2Percent, zone3Percent).toFixed(1)}%`,
                        value: Math.max(zone1Percent, zone2Percent, zone3Percent),
                        threshold: 45,
                        timestamp: new Date().toISOString(),
                        dataSource: 'database+basicAnalysis'
                    });
                }

                return alerts;
            }

            detectStatisticsSignals(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                const alerts = [];
                const recentDraws = draws;
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                const numberFrequencies = {};
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberFrequencies[num] = 0;
                }

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberFrequencies[ball] !== undefined) {
                            numberFrequencies[ball]++;
                        }
                    });
                });

                const frequencies = Object.values(numberFrequencies);
                const avgFrequency = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
                const stdFrequency = Math.sqrt(frequencies.reduce((sum, val) => sum + Math.pow(val - avgFrequency, 2), 0) / frequencies.length);

                if (basicAnalysisData && basicAnalysisData.frequencies) {
                    Object.entries(basicAnalysisData.frequencies).forEach(([num, count]) => {
                        const minCountThreshold = Math.max(3, Math.floor(recentDraws.length / 5));
                        if (count > avgFrequency + 3 * stdFrequency && count > minCountThreshold) {
                            alerts.push({
                                id: this.generateAlertId(),
                                type: 'statistics',
                                signal: 'stdDeviation',
                                dimension: 'statistics',
                                level: 'red',
                                number: num,
                                description: `号码${num}频率异常，出现${count}次，超过平均值${avgFrequency.toFixed(1)}次3倍标准差`,
                                value: count,
                                threshold: avgFrequency + 3 * stdFrequency,
                                timestamp: new Date().toISOString(),
                                dataSource: 'database+basicAnalysis'
                            });
                        }
                    });
                } else {
                    Object.entries(numberFrequencies).forEach(([num, count]) => {
                        const minCountThreshold = Math.max(3, Math.floor(recentDraws.length / 5));
                        if (count > avgFrequency + 3 * stdFrequency && count > minCountThreshold) {
                            alerts.push({
                                id: this.generateAlertId(),
                                type: 'statistics',
                                signal: 'stdDeviation',
                                dimension: 'statistics',
                                level: 'red',
                                number: num,
                                description: `号码${num}频率异常，出现${count}次，超过平均值${avgFrequency.toFixed(1)}次3倍标准差`,
                                value: count,
                                threshold: avgFrequency + 3 * stdFrequency,
                                timestamp: new Date().toISOString(),
                                dataSource: 'database+basicAnalysis'
                            });
                        }
                    });
                }

                if (advancedAnalysisData && advancedAnalysisData.trends && basicAnalysisData && basicAnalysisData.hotCold) {
                    Object.entries(advancedAnalysisData.trends).forEach(([num, trend]) => {
                        if (trend === '上升') {
                            const hotCold = basicAnalysisData.hotCold[num];
                            if (hotCold === 'hot') {
                                const frequency = basicAnalysisData.frequencies[num] || 0;
                                if (frequency > avgFrequency + 2 * stdFrequency) {
                                    alerts.push({
                                        id: this.generateAlertId(),
                                        type: 'statistics',
                                        signal: 'trendHot',
                                        dimension: 'statistics',
                                        level: 'yellow',
                                        number: num,
                                        description: `号码${num}趋势上升且为热号，频率${frequency}次`,
                                        value: frequency,
                                        threshold: avgFrequency + 2 * stdFrequency,
                                        timestamp: new Date().toISOString(),
                                        dataSource: 'database+advancedAnalysis'
                                    });
                                }
                            }
                        }
                    });
                }

                return alerts;
            }

            detectTrendSignals(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                const alerts = [];
                const recentDraws = draws;

                const sums = recentDraws.map(draw => {
                    return draw.redBalls.reduce((sum, ball) => sum + parseInt(ball), 0);
                });

                if (sums.length < 10) return alerts;

                const recentSums = sums.slice(-10);
                const avgSum = recentSums.reduce((a, b) => a + b, 0) / recentSums.length;
                const lastSum = recentSums[recentSums.length - 1];

                if (lastSum > avgSum * 1.4 || lastSum < avgSum * 0.6) {
                    alerts.push({
                        id: this.generateAlertId(),
                        type: 'trend',
                        signal: 'momentumExhaustion',
                        dimension: 'trend',
                        level: 'red',
                        description: `和值${lastSum}偏离平均值${avgSum.toFixed(1)}超过40%，趋势可能反转`,
                        value: lastSum,
                        threshold: avgSum,
                        timestamp: new Date().toISOString(),
                        dataSource: 'database+advancedAnalysis'
                    });
                }

                return alerts;
            }

            detectCorrelationSignals(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                const alerts = [];
                const recentDraws = draws;

                const pairCounts = {};
                recentDraws.forEach(draw => {
                    const balls = draw.redBalls;
                    for (let i = 0; i < balls.length; i++) {
                        for (let j = i + 1; j < balls.length; j++) {
                            const pair = [balls[i], balls[j]].sort().join('-');
                            pairCounts[pair] = (pairCounts[pair] || 0) + 1;
                        }
                    }
                });

                const highCorrelationPairs = Object.entries(pairCounts)
                    .filter(([pair, count]) => count >= Math.max(3, Math.floor(recentDraws.length / 10)))
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3);

                highCorrelationPairs.forEach(([pair, count]) => {
                    const correlationThreshold = Math.max(3, Math.floor(recentDraws.length / 10));
                    alerts.push({
                        id: this.generateAlertId(),
                        type: 'correlation',
                        signal: 'clusterEffect',
                        dimension: 'correlation',
                        level: 'yellow',
                        description: `号码组合${pair}集群效应，近${recentDraws.length}期同时出现${count}次`,
                        value: count,
                        threshold: correlationThreshold,
                        numbers: pair.split('-'),
                        timestamp: new Date().toISOString(),
                        dataSource: 'database+advancedAnalysis'
                    });
                });

                return alerts;
            }

            generateAlertId() {
                return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            detectAllSignals(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                const alerts = [];
                alerts.push(...this.detectCycleSignals(draws, basicAnalysisData, advancedAnalysisData));
                alerts.push(...this.detectDistributionSignals(draws, basicAnalysisData, advancedAnalysisData));
                alerts.push(...this.detectStatisticsSignals(draws, basicAnalysisData, advancedAnalysisData));
                alerts.push(...this.detectTrendSignals(draws, basicAnalysisData, advancedAnalysisData));
                alerts.push(...this.detectCorrelationSignals(draws, basicAnalysisData, advancedAnalysisData));
                return alerts;
            }
        }

        // 预警规则引擎类
        class AlertRuleEngine {
            constructor() {
                this.rules = this.loadRules();
                this.dynamicThresholds = {};
            }

            loadRules() {
                const saved = localStorage.getItem('alertRules');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载预警规则失败:', e);
                    }
                }
                return this.getDefaultRules();
            }

            getDefaultRules() {
                return {
                    triggerConditions: {
                        single: { enabled: true, name: '单条件触发', description: '单一指标达到阈值' },
                        and: { enabled: true, name: '多条件与逻辑', description: '多个条件同时满足' },
                        or: { enabled: true, name: '多条件或逻辑', description: '任一条件满足即触发' },
                        sequence: { enabled: false, name: '条件序列触发', description: '按特定顺序满足条件序列' }
                    },
                    thresholdAdjustment: {
                        adaptive: { enabled: true, name: '自适应阈值', description: '基于历史数据动态调整' },
                        seasonal: { enabled: false, name: '季节性调整', description: '考虑不同时期的阈值差异' },
                        volatility: { enabled: true, name: '波动率调整', description: '根据市场波动调整敏感度' }
                    },
                    validityManagement: {
                        instant: { enabled: true, name: '即时预警', description: '触发即生效，单次有效' },
                        continuous: { enabled: true, name: '持续预警', description: '条件满足期间持续有效' },
                        delayed: { enabled: false, name: '延时预警', description: '触发后延迟生效' },
                        repeat: { enabled: true, name: '重复预警', description: '相同条件可重复触发' }
                    }
                };
            }

            saveRules() {
                localStorage.setItem('alertRules', JSON.stringify(this.rules));
            }

            updateRule(category, ruleName, updates) {
                if (this.rules[category] && this.rules[category][ruleName]) {
                    Object.assign(this.rules[category][ruleName], updates);
                    this.saveRules();
                    return true;
                }
                return false;
            }

            calculateDynamicThreshold(draws, ruleType) {
                if (!this.dynamicThresholds[ruleType]) {
                    this.dynamicThresholds[ruleType] = this.calculateBaseThreshold(draws, ruleType);
                }
                return this.dynamicThresholds[ruleType];
            }

            calculateBaseThreshold(draws, ruleType) {
                const recentDraws = draws;
                switch (ruleType) {
                    case 'frequency':
                        const frequencies = {};
                        recentDraws.forEach(draw => {
                            draw.redBalls.forEach(ball => {
                                frequencies[ball] = (frequencies[ball] || 0) + 1;
                            });
                        });
                        const freqValues = Object.values(frequencies);
                        return {
                            avg: freqValues.reduce((a, b) => a + b, 0) / freqValues.length,
                            std: Math.sqrt(freqValues.reduce((sum, val) => sum + Math.pow(val - freqValues.reduce((a, b) => a + b, 0) / freqValues.length, 2), 0) / freqValues.length)
                        };
                    case 'omission':
                        const omissions = {};
                        recentDraws.forEach(draw => {
                            draw.redBalls.forEach(ball => {
                                omissions[ball] = 0;
                            });
                        });
                        const avgOmission = recentDraws.length > 0 ? Math.floor(recentDraws.length / 6) : 10;
                        const maxOmission = recentDraws.length > 0 ? Math.floor(recentDraws.length / 2) : 30;
                        return {
                            avg: avgOmission,
                            max: maxOmission
                        };
                    default:
                        return { avg: 0, std: 0 };
                }
            }

            evaluateAlerts(alerts, draws) {
                const evaluatedAlerts = [];
                const enabledConditions = Object.entries(this.rules.triggerConditions)
                    .filter(([_, config]) => config.enabled)
                    .map(([key, _]) => key);

                alerts.forEach(alert => {
                    if (this.shouldTriggerAlert(alert, enabledConditions, draws)) {
                        evaluatedAlerts.push(alert);
                    }
                });

                return evaluatedAlerts;
            }

            shouldTriggerAlert(alert, conditions, draws) {
                if (conditions.includes('single')) {
                    return true;
                }

                if (conditions.includes('and')) {
                    const relatedAlerts = this.findRelatedAlerts(alert, draws);
                    return relatedAlerts.length >= 2;
                }

                if (conditions.includes('or')) {
                    return true;
                }

                return false;
            }

            findRelatedAlerts(alert, draws) {
                return [];
            }

            checkValidity(alert) {
                const validityRules = this.rules.validityManagement;
                const now = new Date();
                const alertTime = new Date(alert.timestamp);
                const timeDiff = (now - alertTime) / (1000 * 60 * 60);

                if (validityRules.instant.enabled && timeDiff > 24) {
                    return false;
                }

                if (validityRules.delayed.enabled && timeDiff < 1) {
                    return false;
                }

                return true;
            }
        }

        // ECharts可视化预警面板类
        class AlertVisualization {
            constructor() {
                this.charts = {};
                this.indicatorSystem = new AlertIndicatorSystem();
            }

            initDashboard() {
                this.initOverviewDashboard();
                this.initMonitoringWall();
                this.initHistoryAnalysis();
            }

            initOverviewDashboard(alerts = []) {
                this.initLevelDistributionChart(alerts);
                this.initTimeHeatmap(alerts);
                this.initDimensionRadar(alerts);
                this.initRiskGauge(alerts);
            }

            initLevelDistributionChart(alerts = []) {
                const chartDom = document.getElementById('analysisLevelDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const levelCounts = { red: 0, yellow: 0, blue: 0 };
                const typeCounts = { cycle: 0, distribution: 0, statistics: 0, trend: 0, correlation: 0 };

                if (alerts && Array.isArray(alerts)) {
                    alerts.forEach(alert => {
                        levelCounts[alert.level]++;
                        if (typeCounts[alert.type] !== undefined) {
                            typeCounts[alert.type]++;
                        }
                    });
                }

                const option = {
                    title: {
                        text: '预警级别分布',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条`
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{b}: {c} ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: ['红色预警', '黄色预警', '蓝色预警']
                    },
                    series: [
                        {
                            name: '预警级别',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            label: {
                                show: true,
                                formatter: '{b}: {c}\n({d}%)'
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: '16',
                                    fontWeight: 'bold'
                                }
                            },
                            data: [
                                { value: levelCounts.red, name: '红色预警', itemStyle: { color: '#FF4444' } },
                                { value: levelCounts.yellow, name: '黄色预警', itemStyle: { color: '#FFA500' } },
                                { value: levelCounts.blue, name: '蓝色预警', itemStyle: { color: '#4A90E2' } }
                            ]
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.levelDistribution = chart;
            }

            initTimeHeatmap(alerts = []) {
                const chartDom = document.getElementById('analysisTimeHeatmap');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const timeData = {};
                const levelTimeData = { red: {}, yellow: {}, blue: {} };

                if (alerts && Array.isArray(alerts)) {
                    alerts.forEach(alert => {
                        const date = new Date(alert.timestamp);
                        const hour = date.getHours();
                        const day = date.getDay();
                        const key = `${day}-${hour}`;
                        timeData[key] = (timeData[key] || 0) + 1;

                        if (!levelTimeData[alert.level][key]) {
                            levelTimeData[alert.level][key] = 0;
                        }
                        levelTimeData[alert.level][key]++;
                    });
                }

                const data = [];
                for (let day = 0; day < 7; day++) {
                    for (let hour = 0; hour < 24; hour++) {
                        const key = `${day}-${hour}`;
                        data.push([hour, day, timeData[key] || 0]);
                    }
                }

                const maxCount = Math.max(...data.map(d => d[2]), 1);
                const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };

                const option = {
                    title: {
                        text: '预警信号时间分布',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条预警`,
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        position: 'top',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            const days = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
                            const key = `${params.value[1]}-${params.value[0]}`;
                            const redCount = levelTimeData.red[key] || 0;
                            const yellowCount = levelTimeData.yellow[key] || 0;
                            const blueCount = levelTimeData.blue[key] || 0;
                            const totalCount = redCount + yellowCount + blueCount;
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">${days[params.value[1]]} ${params.value[0]}:00</div>
                                    <div>总预警: <span style="font-weight: bold; color: #FF4444;">${totalCount}</span>条</div>
                                    <div style="margin-top: 5px;">
                                        <span style="color: ${levelColors.red};">🔴 红色: ${redCount}</span> | 
                                        <span style="color: ${levelColors.yellow};">🟡 黄色: ${yellowCount}</span> | 
                                        <span style="color: ${levelColors.blue};">🔵 蓝色: ${blueCount}</span>
                                    </div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        height: '70%',
                        top: '15%',
                        bottom: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        data: Array.from({ length: 24 }, (_, i) => i),
                        splitArea: { show: true },
                        name: '小时',
                        nameTextStyle: { fontSize: 12, padding: [0, 0, 0, 20] },
                        axisLabel: { fontSize: 11 }
                    },
                    yAxis: {
                        type: 'category',
                        data: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
                        splitArea: { show: true },
                        name: '星期',
                        nameTextStyle: { fontSize: 12, padding: [20, 0, 0, 0] },
                        axisLabel: { fontSize: 11 }
                    },
                    visualMap: {
                        min: 0,
                        max: maxCount,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '0%',
                        inRange: {
                            color: ['#e8f5e9', '#c8e6c9', '#a5d6a7', '#81c784', '#66bb6a', '#4caf50', '#43a047', '#388e3c']
                        },
                        textStyle: { fontSize: 11 },
                        text: ['高', '低']
                    },
                    series: [{
                        name: '预警数量',
                        type: 'heatmap',
                        data: data,
                        label: {
                            show: true,
                            fontSize: 10,
                            color: '#333',
                            formatter: function(params) {
                                return params.value[2] > 0 ? params.value[2] : '';
                            }
                        },
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            },
                            label: {
                                show: true,
                                fontSize: 12,
                                fontWeight: 'bold'
                            }
                        },
                        itemStyle: {
                            borderColor: '#fff',
                            borderWidth: 1
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.timeHeatmap = chart;
            }

            initDimensionRadar(alerts = []) {
                const chartDom = document.getElementById('analysisDimensionRadar');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const dimensions = ['cycle', 'distribution', 'pattern', 'statistics', 'trend', 'correlation'];
                const dimensionNames = ['周期规律', '分布异常', '模式突破', '统计极值', '趋势拐点', '关联断裂'];
                const scores = dimensions.map(dim => this.indicatorSystem.calculateDimensionScore(alerts, dim));

                const dimensionAlerts = dimensions.map(dim => {
                    return alerts.filter(alert => alert.dimension === dim).length;
                });

                const option = {
                    title: {
                        text: '各维度预警强度',
                        left: 'center',
                        subtext: `最高维度: ${dimensionNames[scores.indexOf(Math.max(...scores))]}`
                    },
                    tooltip: {
                        formatter: function(params) {
                            const result = [];
                            const paramArray = Array.isArray(params) ? params : [params];
                            paramArray.forEach(param => {
                                const values = Array.isArray(param.value) ? param.value : [param.value];
                                values.forEach((score, index) => {
                                    if (dimensionNames[index] && score !== undefined && score !== null && !isNaN(parseFloat(score))) {
                                        result.push(`${dimensionNames[index]}: ${parseFloat(score).toFixed(1)}分 (${dimensionAlerts[index]}条)`);
                                    }
                                });
                            });
                            return result.join('<br/>');
                        }
                    },
                    legend: {
                        data: ['预警强度'],
                        bottom: 0
                    },
                    radar: {
                        indicator: dimensionNames.map((name, index) => ({ 
                            name, 
                            max: 100,
                            axisLabel: {
                                formatter: '{value}'
                            }
                        })),
                        radius: '60%',
                        splitArea: {
                            areaStyle: {
                                color: ['rgba(255, 68, 68, 0.1)', 'rgba(255, 68, 68, 0.2)', 'rgba(255, 68, 68, 0.3)']
                            }
                        }
                    },
                    series: [{
                        name: '预警强度',
                        type: 'radar',
                        data: [{
                            value: scores,
                            name: '预警强度',
                            areaStyle: {
                                color: 'rgba(255, 68, 68, 0.4)'
                            },
                            lineStyle: {
                                color: '#FF4444',
                                width: 2
                            },
                            itemStyle: {
                                color: '#FF4444',
                                borderColor: '#fff',
                                borderWidth: 2
                            }
                        }]
                    }]
                };

                chart.setOption(option);
                this.charts.dimensionRadar = chart;
            }

            initRiskGauge(alerts = []) {
                const chartDom = document.getElementById('analysisRiskGauge');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const riskScore = this.indicatorSystem.calculateRiskScore(alerts);
                const riskLevel = this.indicatorSystem.getRiskLevelByScore(riskScore);

                const levelCounts = { red: 0, yellow: 0, blue: 0 };
                if (alerts && Array.isArray(alerts)) {
                    alerts.forEach(alert => {
                        levelCounts[alert.level]++;
                    });
                }

                const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                const levelNames = { red: '高风险', yellow: '中风险', blue: '低风险' };
                const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };

                const option = {
                    title: {
                        text: '系统风险综合评分',
                        left: 'center',
                        top: '5%',
                        textStyle: { fontSize: 18, fontWeight: 'bold' },
                        subtext: `当前风险级别: ${levelIcons[riskLevel]} ${levelNames[riskLevel]}`,
                        subtextStyle: { fontSize: 14, color: levelColors[riskLevel], fontWeight: 'bold' }
                    },
                    tooltip: {
                        formatter: '{a} <br/>{b} : {c}%'
                    },
                    series: [
                        {
                            type: 'gauge',
                            startAngle: 180,
                            endAngle: 0,
                            min: 0,
                            max: 100,
                            splitNumber: 10,
                            radius: '90%',
                            center: ['50%', '65%'],
                            itemStyle: {
                                color: riskScore >= 80 ? '#FF4444' : riskScore >= 50 ? '#FFA500' : '#4A90E2',
                                shadowColor: 'rgba(0,0,0,0.3)',
                                shadowBlur: 10,
                                shadowOffsetX: 2,
                                shadowOffsetY: 2
                            },
                            progress: {
                                show: true,
                                width: 18,
                                roundCap: true,
                                itemStyle: {
                                    color: riskScore >= 80 ? '#FF4444' : riskScore >= 50 ? '#FFA500' : '#4A90E2'
                                }
                            },
                            pointer: {
                                icon: 'path://M12.8,0.7l12,40.1H0.7L12.8,0.7z',
                                length: '12%',
                                width: 16,
                                offsetCenter: [0, '-60%'],
                                itemStyle: {
                                    color: 'auto',
                                    shadowColor: 'rgba(0,0,0,0.5)',
                                    shadowBlur: 5
                                }
                            },
                            axisLine: {
                                lineStyle: {
                                    width: 18,
                                    color: [
                                        [0.33, '#4A90E2'],
                                        [0.66, '#FFA500'],
                                        [1, '#FF4444']
                                    ],
                                    shadowColor: 'rgba(0,0,0,0.1)',
                                    shadowBlur: 5
                                }
                            },
                            axisTick: {
                                distance: -45,
                                splitNumber: 10,
                                lineStyle: {
                                    width: 2,
                                    color: '#999'
                                }
                            },
                            splitLine: {
                                distance: -52,
                                length: 18,
                                lineStyle: {
                                    width: 3,
                                    color: '#999'
                                }
                            },
                            axisLabel: {
                                distance: -25,
                                color: '#666',
                                fontSize: 14,
                                fontWeight: 'bold',
                                formatter: function(value) {
                                    if (value <= 33) return '低';
                                    if (value <= 66) return '中';
                                    return '高';
                                }
                            },
                            detail: {
                                valueAnimation: true,
                                animationDuration: 1000,
                                animationEasing: 'cubicOut',
                                formatter: function(value) {
                                    return Math.round(value);
                                },
                                color: 'auto',
                                fontSize: 48,
                                fontWeight: 'bold',
                                offsetCenter: [0, '-20%'],
                                backgroundColor: 'rgba(255,255,255,0.8)',
                                borderColor: '#ddd',
                                borderWidth: 1,
                                borderRadius: 5,
                                padding: [5, 10]
                            },
                            data: [
                                {
                                    value: riskScore.toFixed(0),
                                    name: '风险评分',
                                    title: {
                                        offsetCenter: [0, '35%'],
                                        fontSize: 14,
                                        color: '#666',
                                        fontWeight: 'bold'
                                    }
                                }
                            ],
                            markPoint: {
                                symbol: 'pin',
                                symbolSize: 30,
                                data: [
                                    {
                                        name: '当前风险',
                                        value: riskScore.toFixed(0),
                                        itemStyle: {
                                            color: riskScore >= 80 ? '#FF4444' : riskScore >= 50 ? '#FFA500' : '#4A90E2'
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.riskGauge = chart;
            }

            initMonitoringWall(alerts = []) {
                this.initAlertList(alerts);
                this.initTrendLine(alerts);
                this.initScatterPlot(alerts);
                this.initNetworkGraph(alerts);
                this.initNumberAlertChart(alerts);
            }

            initAlertList(alerts = []) {
                const listContainer = document.getElementById('alertListContainer');
                if (!listContainer) return;

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];
                const sortedAlerts = [...validAlerts].sort((a, b) => {
                    const levelPriority = { red: 3, yellow: 2, blue: 1 };
                    if (levelPriority[b.level] !== levelPriority[a.level]) {
                        return levelPriority[b.level] - levelPriority[a.level];
                    }
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });

                let html = '';
                sortedAlerts.forEach(alert => {
                    const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                    const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };
                    html += `
                        <div class="alert-item" style="border-left: 4px solid ${levelColors[alert.level]}; padding: 10px; margin-bottom: 10px; background: white; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: bold;">${levelIcons[alert.level]} ${alert.description}</span>
                                <span style="font-size: 12px; color: #999;">${new Date(alert.timestamp).toLocaleString()}</span>
                            </div>
                            ${alert.number ? `<div style="margin-top: 5px; font-size: 14px;">相关号码: ${alert.number}</div>` : ''}
                        </div>
                    `;
                });

                listContainer.innerHTML = html;
            }

            initTrendLine(alerts = []) {
                const chartDom = document.getElementById('analysisTrendLine');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const timeData = {};
                if (alerts && Array.isArray(alerts)) {
                    alerts.forEach(alert => {
                        const date = new Date(alert.timestamp).toLocaleDateString();
                        timeData[date] = (timeData[date] || 0) + 1;
                    });
                }

                const sortedDates = Object.keys(timeData).sort((a, b) => new Date(a) - new Date(b));
                const counts = sortedDates.map(date => timeData[date]);
                const maxCount = Math.max(...counts, 0);

                const option = {
                    title: {
                        text: '预警信号变化趋势',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `总计: ${counts.reduce((a, b) => a + b, 0)}条预警`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const date = param.name;
                            const count = param.value;
                            const avgCount = counts && counts.length > 0 ? (counts.reduce((a, b) => a + b, 0) / counts.length).toFixed(1) : '0.0';
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">${date}</div>
                                    <div>预警数量：<span style="font-weight: bold; color: #FF4444; font-size: 16px;">${count}</span>条</div>
                                    <div style="color: #999; font-size: 12px;">平均预警：${avgCount}条</div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: sortedDates,
                        axisLabel: {
                            fontSize: 11,
                            rotate: 30,
                            interval: Math.floor(sortedDates.length / 10)
                        },
                        axisLine: {
                            lineStyle: { color: '#ddd' }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '预警数量',
                        nameTextStyle: { fontSize: 12, padding: [0, 0, 0, 20] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    series: [{
                        name: '预警数量',
                        data: counts,
                        type: 'line',
                        smooth: true,
                        symbol: 'circle',
                        symbolSize: 6,
                        showSymbol: true,
                        lineStyle: {
                            width: 2,
                            color: '#FF4444'
                        },
                        itemStyle: {
                            color: '#FF4444',
                            borderColor: '#fff',
                            borderWidth: 2
                        },
                        areaStyle: {
                            color: {
                                type: 'linear',
                                x: 0,
                                y: 0,
                                x2: 0,
                                y2: 1,
                                colorStops: [
                                    { offset: 0, color: 'rgba(255, 68, 68, 0.3)' },
                                    { offset: 1, color: 'rgba(255, 68, 68, 0.05)' }
                                ]
                            }
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.trendLine = chart;
            }

            initScatterPlot(alerts = []) {
                const chartDom = document.getElementById('analysisScatterPlot');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];
                const data = validAlerts.map((alert, index) => {
                    const alertValue = typeof alert.value === 'number' ? alert.value : parseFloat(alert.value) || 0;
                    return [index, alertValue, alert.level];
                });

                const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                const levelNames = { red: '红色', yellow: '黄色', blue: '蓝色' };
                const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };

                const option = {
                    title: {
                        text: '预警信号空间分布',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `共${data.length}条预警`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            const level = params.value[2];
                            const value = params.value[1];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">预警序号 ${params.dataIndex + 1}</div>
                                    <div style="margin-bottom: 3px;">预警级别：<span style="color: ${levelColors[level]}; font-weight: bold;">${levelIcons[level]} ${levelNames[level]}</span></div>
                                    <div style="margin-bottom: 3px;">预警值：<span style="font-weight: bold; color: #FF6B6B; font-size: 16px;">${value.toFixed(2)}</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '8%',
                        right: '8%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'value',
                        name: '预警序号',
                        nameTextStyle: { fontSize: 12, padding: [0, 0, 0, 20] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '预警值',
                        nameTextStyle: { fontSize: 12, padding: [20, 0, 0, 0] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    series: [{
                        type: 'scatter',
                        data: data,
                        symbolSize: function(data) {
                            const level = data[2];
                            return level === 'red' ? 15 : level === 'yellow' ? 12 : 10;
                        },
                        itemStyle: {
                            color: function(params) {
                                const level = params.value[2];
                                return levelColors[level];
                            },
                            borderColor: '#fff',
                            borderWidth: 2,
                            shadowColor: 'rgba(0,0,0,0.3)',
                            shadowBlur: 10
                        },
                        emphasis: {
                            itemStyle: {
                                color: function(params) {
                                    const level = params.value[2];
                                    return levelColors[level];
                                },
                                borderColor: '#fff',
                                borderWidth: 3,
                                shadowColor: 'rgba(0,0,0,0.5)',
                                shadowBlur: 15
                            },
                            label: {
                                show: true,
                                formatter: function(params) {
                                    const level = params.value[2];
                                    return levelIcons[level];
                                },
                                fontSize: 16,
                                fontWeight: 'bold'
                            }
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.scatterPlot = chart;
            }

            initNetworkGraph(alerts = []) {
                const chartDom = document.getElementById('alertNetworkGraph');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const nodes = [];
                const links = [];
                const numberSet = new Set();

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];
                validAlerts.forEach(alert => {
                    if (alert.number) {
                        if (!numberSet.has(alert.number)) {
                            nodes.push({ id: alert.number, name: alert.number, symbolSize: 20, itemStyle: { color: '#FF4444' } });
                            numberSet.add(alert.number);
                        }
                    }
                    if (alert.numbers && Array.isArray(alert.numbers)) {
                        alert.numbers.forEach(num => {
                            if (!numberSet.has(num)) {
                                nodes.push({ id: num, name: num, symbolSize: 15, itemStyle: { color: '#FFA500' } });
                                numberSet.add(num);
                            }
                        });
                    }
                });

                const option = {
                    title: {
                        text: '预警信号关联性',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `共${nodes.length}个相关号码`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            if (params.dataType === 'node') {
                                const node = params.data;
                                return `
                                    <div style="padding: 8px;">
                                        <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">号码 ${node.name}</div>
                                        <div style="color: #999; font-size: 12px;">相关预警数量：${node.alertCount || 0}条</div>
                                    </div>
                                `;
                            }
                            return '';
                        }
                    },
                    series: [{
                        type: 'graph',
                        layout: 'force',
                        data: nodes,
                        links: links,
                        roam: true,
                        draggable: true,
                        label: {
                            show: true,
                            position: 'right',
                            fontSize: 11,
                            color: '#333',
                            fontWeight: 'bold'
                        },
                        lineStyle: {
                            color: '#ccc',
                            width: 2,
                            curveness: 0.2
                        },
                        emphasis: {
                            focus: 'adjacency',
                            lineStyle: {
                                width: 4
                            },
                            itemStyle: {
                                shadowColor: 'rgba(0, 0, 0, 0.5)',
                                shadowBlur: 10
                            }
                        },
                        force: {
                            repulsion: 150,
                            edgeLength: 80,
                            gravity: 0.1,
                            friction: 0.6
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.networkGraph = chart;
            }

            initHistoryAnalysis(alerts = []) {
                this.initTimelineChart(alerts);
                this.initHitRateChart(alerts);
                this.initFlowChart(alerts);
                this.initBoxPlot(alerts);
            }

            initTimelineChart(alerts = []) {
                const chartDom = document.getElementById('alertTimelineChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const timelineData = (alerts && Array.isArray(alerts)) ? alerts.map(alert => ({
                    name: alert.description,
                    value: [alert.timestamp, alert.level],
                    itemStyle: {
                        color: alert.level === 'red' ? '#FF4444' : alert.level === 'yellow' ? '#FFA500' : '#4A90E2'
                    },
                    alertData: alert
                })) : [];

                const option = {
                    title: {
                        text: '预警历史时间线',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条预警`
                    },
                    tooltip: {
                        formatter: function(params) {
                            const alert = params.data.alertData;
                            return `
                                ${alert.description}<br/>
                                时间: ${new Date(alert.timestamp).toLocaleString()}<br/>
                                级别: ${alert.level === 'red' ? '🔴 红色' : alert.level === 'yellow' ? '🟡 黄色' : '🔵 蓝色'}<br/>
                                类型: ${alert.type}<br/>
                                ${alert.number ? `号码: ${alert.number}<br/>` : ''}
                                预警值: ${typeof alert.value === 'number' ? alert.value : parseFloat(alert.value) || 0}
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'time',
                        name: '时间',
                        nameTextStyle: { fontSize: 12, padding: [0, 0, 0, 20] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: ['blue', 'yellow', 'red'],
                        axisLabel: {
                            formatter: function(value) {
                                return value === 'red' ? '🔴 红色' : value === 'yellow' ? '🟡 黄色' : '🔵 蓝色';
                            },
                            fontSize: 11
                        },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    series: [{
                        type: 'scatter',
                        data: timelineData,
                        symbolSize: 10,
                        itemStyle: {
                            borderColor: '#fff',
                            borderWidth: 2
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.timelineChart = chart;
            }

            initHitRateChart(alerts = []) {
                const chartDom = document.getElementById('alertHitRateChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '预警命中率统计',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条预警`
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{b}: {c} ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: ['命中', '未命中']
                    },
                    series: [
                        {
                            name: '预警命中',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            label: {
                                show: true,
                                formatter: '{b}: {c}\n({d}%)'
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: '16',
                                    fontWeight: 'bold'
                                }
                            },
                            data: [
                                { value: 0, name: '命中', itemStyle: { color: '#4CAF50' } },
                                { value: alerts.length, name: '未命中', itemStyle: { color: '#FF6B6B' } }
                            ]
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.hitRateChart = chart;
            }

            initFlowChart(alerts = []) {
                const chartDom = document.getElementById('alertFlowChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '预警信号流向图',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条预警`
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{b}: {c}'
                    },
                    series: [{
                        type: 'funnel',
                        left: '10%',
                        top: 60,
                        bottom: 60,
                        width: '80%',
                        min: 0,
                        max: Math.max(alerts.length, 1),
                        minSize: '0%',
                        maxSize: '100%',
                        sort: 'descending',
                        gap: 2,
                        label: {
                            show: true,
                            position: 'inside'
                        },
                        labelLine: {
                            length: 10,
                            lineStyle: {
                                width: 1,
                                type: 'solid'
                            }
                        },
                        itemStyle: {
                            borderColor: '#fff',
                            borderWidth: 1
                        },
                        emphasis: {
                            label: {
                                fontSize: 20
                            }
                        },
                        data: [
                            { value: alerts.length, name: '总预警', itemStyle: { color: '#FF4444' } },
                            { value: alerts.filter(a => a.level === 'red').length, name: '红色预警', itemStyle: { color: '#FF4444' } },
                            { value: alerts.filter(a => a.level === 'yellow').length, name: '黄色预警', itemStyle: { color: '#FFA500' } },
                            { value: alerts.filter(a => a.level === 'blue').length, name: '蓝色预警', itemStyle: { color: '#4A90E2' } }
                        ]
                    }]
                };

                chart.setOption(option);
                this.charts.flowChart = chart;
            }

            initBoxPlot(alerts = []) {
                const chartDom = document.getElementById('alertBoxPlot');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '预警值分布箱线图',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条预警`
                    },
                    tooltip: {
                        trigger: 'item',
                        axisPointer: {
                            type: 'shadow'
                        }
                    },
                    grid: {
                        left: '10%',
                        right: '10%',
                        bottom: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        data: ['红色预警', '黄色预警', '蓝色预警'],
                        boundaryGap: true,
                        nameGap: 30,
                        splitArea: {
                            show: false
                        },
                        splitLine: {
                            show: false
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '预警值',
                        min: 0,
                        splitArea: {
                            show: true
                        }
                    },
                    series: [{
                        name: '预警值',
                        type: 'boxplot',
                        data: [
                            [
                                [0, 0, 0, 0, 0]
                            ],
                            [
                                [0, 0, 0, 0, 0]
                            ],
                            [
                                [0, 0, 0, 0, 0]
                            ]
                        ],
                        tooltip: {
                            formatter: function(param) {
                                return [
                                    'Experiment ' + param.name + ': ',
                                    'upper: ' + param.data[5],
                                    'Q3: ' + param.data[4],
                                    'median: ' + param.data[3],
                                    'Q1: ' + param.data[2],
                                    'lower: ' + param.data[1]
                                ].join('<br/>');
                            }
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.boxPlot = chart;
            }

            initNumberAlertChart(alerts = []) {
                const chartDom = document.getElementById('analysisNumberAlertChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const numberAlertData = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const numberAlerts = alerts.filter(alert => alert.number === num);

                    if (numberAlerts.length > 0) {
                        const latestAlert = numberAlerts[numberAlerts.length - 1];
                        const alertValue = typeof latestAlert.value === 'number' ? latestAlert.value : parseFloat(latestAlert.value) || 0;
                        numberAlertData[num] = {
                            number: num,
                            alertLevel: latestAlert.level,
                            alertValue: alertValue,
                            alertType: latestAlert.type,
                            alertDescription: latestAlert.description,
                            timestamp: latestAlert.timestamp
                        };
                    }
                }

                const sortedNumbers = Object.values(numberAlertData).sort((a, b) => {
                    const levelPriority = { red: 3, yellow: 2, blue: 1 };
                    if (levelPriority[b.alertLevel] !== levelPriority[a.alertLevel]) {
                        return levelPriority[b.alertLevel] - levelPriority[a.alertLevel];
                    }
                    return b.alertValue - a.alertValue;
                });

                const numbers = sortedNumbers.map(item => item.number);
                const alertLevels = sortedNumbers.map(item => item.alertLevel);
                const alertValues = sortedNumbers.map(item => item.alertValue);

                const levelCounts = { red: 0, yellow: 0, blue: 0 };
                sortedNumbers.forEach(item => {
                    levelCounts[item.alertLevel]++;
                });

                const option = {
                    title: {
                        text: '号码预警值大小分析',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `共${sortedNumbers.length}个号码有预警`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const num = param.name;
                            const alertData = numberAlertData[num];
                            if (alertData) {
                                const alertValue = typeof alertData.alertValue === 'number' ? alertData.alertValue : parseFloat(alertData.alertValue) || 0;
                                const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                                const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };
                                return `
                                    <div style="padding: 8px;">
                                        <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">号码 ${num}</div>
                                        <div style="margin-bottom: 3px;">
                                            预警级别：<span style="color: ${levelColors[alertData.alertLevel]}; font-weight: bold;">${levelIcons[alertData.alertLevel]} ${alertData.alertLevel === 'red' ? '红色' : alertData.alertLevel === 'yellow' ? '黄色' : '蓝色'}</span>
                                        </div>
                                        <div style="margin-bottom: 3px;">预警值：<span style="font-weight: bold; color: #FF6B6B;">${alertValue.toFixed(2)}</span></div>
                                        <div style="margin-bottom: 3px;">预警类型：${alertData.alertType}</div>
                                        <div style="margin-bottom: 3px;">描述：${alertData.alertDescription}</div>
                                        <div style="color: #999; font-size: 12px;">时间：${new Date(alertData.timestamp).toLocaleString()}</div>
                                    </div>
                                `;
                            }
                            return `<div style="padding: 8px;">号码 ${num}：无预警</div>`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        name: '号码',
                        axisLabel: {
                            interval: 0,
                            rotate: 45
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '预警级别',
                            min: 0,
                            max: 3,
                            interval: 1,
                            axisLabel: {
                                formatter: function(value) {
                                    const levelMap = { 0: '蓝色', 1: '黄色', 2: '红色', 3: '红色' };
                                    return levelMap[value];
                                }
                            },
                            data: alertLevels.map(level => {
                                const levelMap = { red: 2, yellow: 1, blue: 0 };
                                return levelMap[level];
                            })
                        },
                        {
                            type: 'value',
                            name: '预警值',
                            min: 0,
                            axisLabel: {
                                formatter: '{value}'
                            },
                            data: alertValues
                        }
                    ],
                    series: [
                        {
                            name: '预警级别',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: alertLevels,
                            itemStyle: {
                                color: function(params) {
                                    const levelMap = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                                    return levelMap[sortedNumbers[params.dataIndex].alertLevel];
                                }
                            }
                        },
                        {
                            name: '预警值',
                            type: 'line',
                            yAxisIndex: 1,
                            data: alertValues,
                            smooth: true,
                            itemStyle: {
                                color: '#FF6B6B'
                            },
                            lineStyle: {
                                color: '#FF6B6B'
                            }
                        }
                    ],
                    dataZoom: [
                        {
                            type: 'slider',
                            show: true,
                            xAxisIndex: [0],
                            start: 0,
                            end: 50
                        },
                        {
                            type: 'inside',
                            xAxisIndex: [0],
                            start: 0,
                            end: 50
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.numberAlertChart = chart;
            }

            initAlertList(alerts = []) {
                const listContainer = document.getElementById('alertListContainer');
                if (!listContainer) return;

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];
                const sortedAlerts = [...validAlerts].sort((a, b) => {
                    const levelPriority = { red: 3, yellow: 2, blue: 1 };
                    if (levelPriority[b.level] !== levelPriority[a.level]) {
                        return levelPriority[b.level] - levelPriority[a.level];
                    }
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });

                let html = '';
                sortedAlerts.forEach(alert => {
                    const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                    const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };
                    html += `
                        <div class="alert-item" style="border-left: 4px solid ${levelColors[alert.level]}; padding: 10px; margin-bottom: 10px; background: white; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: bold;">${levelIcons[alert.level]} ${alert.description}</span>
                                <span style="font-size: 12px; color: #999;">${new Date(alert.timestamp).toLocaleString()}</span>
                            </div>
                            ${alert.number ? `<div style="margin-top: 5px; font-size: 14px;">相关号码: ${alert.number}</div>` : ''}
                        </div>
                    `;
                });

                listContainer.innerHTML = html;
            }

            initTrendLine(alerts = []) {
                const chartDom = document.getElementById('analysisTrendLine');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const timeData = {};
                if (alerts && Array.isArray(alerts)) {
                    alerts.forEach(alert => {
                        const date = new Date(alert.timestamp).toLocaleDateString();
                        timeData[date] = (timeData[date] || 0) + 1;
                    });
                }

                const sortedDates = Object.keys(timeData).sort((a, b) => new Date(a) - new Date(b));
                const counts = sortedDates.map(date => timeData[date]);
                const maxCount = Math.max(...counts, 0);

                const option = {
                    title: {
                        text: '预警信号变化趋势',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `总计: ${counts.reduce((a, b) => a + b, 0)}条预警`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const date = param.name;
                            const count = param.value;
                            const avgCount = counts && counts.length > 0 ? (counts.reduce((a, b) => a + b, 0) / counts.length).toFixed(1) : '0.0';
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">${date}</div>
                                    <div>预警数量：<span style="font-weight: bold; color: #FF4444; font-size: 16px;">${count}</span>条</div>
                                    <div style="color: #999; font-size: 12px;">平均预警：${avgCount}条</div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: sortedDates,
                        axisLabel: {
                            fontSize: 11,
                            rotate: 30,
                            interval: Math.floor(sortedDates.length / 10)
                        },
                        axisLine: {
                            lineStyle: { color: '#ddd' }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '预警数量',
                        nameTextStyle: { fontSize: 12, padding: [0, 0, 0, 20] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    series: [{
                        name: '预警数量',
                        data: counts,
                        type: 'line',
                        smooth: true,
                        symbol: 'circle',
                        symbolSize: 6,
                        showSymbol: true,
                        lineStyle: {
                            width: 2,
                            color: '#FF4444'
                        },
                        itemStyle: {
                            color: '#FF4444',
                            borderColor: '#fff',
                            borderWidth: 2
                        },
                        areaStyle: {
                            color: {
                                type: 'linear',
                                x: 0,
                                y: 0,
                                x2: 0,
                                y2: 1,
                                colorStops: [
                                    { offset: 0, color: 'rgba(255, 68, 68, 0.3)' },
                                    { offset: 1, color: 'rgba(255, 68, 68, 0.05)' }
                                ]
                            }
                        },
                        markLine: {
                            silent: true,
                            data: [{
                                yAxis: counts && counts.length > 0 ? (counts.reduce((a, b) => a + b, 0) / counts.length).toFixed(1) : 0,
                                lineStyle: {
                                    color: '#FFA500',
                                    type: 'dashed',
                                    width: 2
                                },
                                label: {
                                    formatter: '平均值',
                                    position: 'end',
                                    color: '#FFA500',
                                    fontSize: 12
                                }
                            }]
                        }
                    }],
                    dataZoom: [
                        {
                            type: 'slider',
                            show: true,
                            xAxisIndex: [0],
                            start: Math.max(0, 1 - (10 / sortedDates.length)),
                            end: 100,
                            height: 25,
                            bottom: 10,
                            borderColor: '#ddd',
                            fillerColor: 'rgba(74, 144, 226, 0.1)',
                            handleStyle: {
                                color: '#4A90E2',
                                borderColor: '#4A90E2'
                            }
                        },
                        {
                            type: 'inside',
                            xAxisIndex: [0],
                            start: Math.max(0, 1 - (10 / sortedDates.length)),
                            end: 100
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.trendLine = chart;
            }

            initScatterPlot(alerts = []) {
                const chartDom = document.getElementById('analysisScatterPlot');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];
                const data = validAlerts.map((alert, index) => {
                    const alertValue = typeof alert.value === 'number' ? alert.value : parseFloat(alert.value) || 0;
                    return [index, alertValue, alert.level];
                });

                const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                const levelNames = { red: '红色', yellow: '黄色', blue: '蓝色' };
                const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };

                const option = {
                    title: {
                        text: '预警信号空间分布',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `共${data.length}条预警`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            const level = params.value[2];
                            const value = params.value[1];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">预警序号 ${params.dataIndex + 1}</div>
                                    <div style="margin-bottom: 3px;">预警级别：<span style="color: ${levelColors[level]}; font-weight: bold;">${levelIcons[level]} ${levelNames[level]}</span></div>
                                    <div style="margin-bottom: 3px;">预警值：<span style="font-weight: bold; color: #FF6B6B; font-size: 16px;">${value.toFixed(2)}</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '8%',
                        right: '8%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'value',
                        name: '预警序号',
                        nameTextStyle: { fontSize: 12, padding: [0, 0, 0, 20] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '预警值',
                        nameTextStyle: { fontSize: 12, padding: [20, 0, 0, 0] },
                        axisLabel: { fontSize: 11 },
                        splitLine: {
                            lineStyle: { color: '#eee' }
                        }
                    },
                    series: [{
                        type: 'scatter',
                        data: data,
                        symbolSize: function(data) {
                            const level = data[2];
                            return level === 'red' ? 15 : level === 'yellow' ? 12 : 10;
                        },
                        itemStyle: {
                            color: function(params) {
                                const level = params.value[2];
                                return levelColors[level];
                            },
                            borderColor: '#fff',
                            borderWidth: 2,
                            shadowColor: 'rgba(0,0,0,0.3)',
                            shadowBlur: 10
                        },
                        emphasis: {
                            itemStyle: {
                                color: function(params) {
                                    const level = params.value[2];
                                    return levelColors[level];
                                },
                                borderColor: '#fff',
                                borderWidth: 3,
                                shadowColor: 'rgba(0,0,0,0.5)',
                                shadowBlur: 15
                            },
                            label: {
                                show: true,
                                formatter: function(params) {
                                    const level = params.value[2];
                                    return levelIcons[level];
                                },
                                fontSize: 16
                            }
                        }
                    }],
                    visualMap: {
                        show: false
                    }
                };

                chart.setOption(option);
                this.charts.scatterPlot = chart;
            }

            initNetworkGraph(alerts = []) {
                const chartDom = document.getElementById('alertNetworkGraph');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const nodes = [];
                const links = [];
                const numberSet = new Set();

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];
                validAlerts.forEach(alert => {
                    if (alert.number) {
                        if (!numberSet.has(alert.number)) {
                            nodes.push({ id: alert.number, name: alert.number, symbolSize: 20, itemStyle: { color: '#FF4444' } });
                            numberSet.add(alert.number);
                        }
                    }
                    if (alert.numbers && Array.isArray(alert.numbers)) {
                        alert.numbers.forEach(num => {
                            if (!numberSet.has(num)) {
                                nodes.push({ id: num, name: num, symbolSize: 15, itemStyle: { color: '#FFA500' } });
                                numberSet.add(num);
                            }
                        });
                    }
                });

                const option = {
                    title: {
                        text: '预警信号关联性',
                        left: 'center',
                        top: '3%',
                        textStyle: { fontSize: 16, fontWeight: 'bold' },
                        subtext: `共${nodes.length}个相关号码`,
                        subtextStyle: { fontSize: 12, color: '#666' }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#ddd',
                        borderWidth: 1,
                        textStyle: { color: '#333' },
                        formatter: function(params) {
                            if (params.dataType === 'node') {
                                const node = params.data;
                                return `
                                    <div style="padding: 8px;">
                                        <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">号码 ${node.name}</div>
                                        <div style="color: #999; font-size: 12px;">相关预警数量：${node.alertCount || 0}条</div>
                                    </div>
                                `;
                            }
                            return '';
                        }
                    },
                    series: [{
                        type: 'graph',
                        layout: 'force',
                        data: nodes,
                        links: links,
                        roam: true,
                        draggable: true,
                        label: {
                            show: true,
                            position: 'right',
                            fontSize: 11,
                            color: '#333',
                            fontWeight: 'bold'
                        },
                        lineStyle: {
                            color: '#ccc',
                            width: 2,
                            curveness: 0.2
                        },
                        emphasis: {
                            focus: 'adjacency',
                            lineStyle: {
                                width: 4
                            },
                            itemStyle: {
                                shadowColor: 'rgba(0, 0, 0, 0.5)',
                                shadowBlur: 10
                            }
                        },
                        force: {
                            repulsion: 150,
                            edgeLength: 80,
                            gravity: 0.1,
                            friction: 0.6
                        }
                    }]
                };

                chart.setOption(option);
                this.charts.networkGraph = chart;
            }

            initHistoryAnalysis(alerts = []) {
                this.initTimelineChart(alerts);
                this.initHitRateChart(alerts);
                this.initFlowChart(alerts);
                this.initBoxPlot(alerts);
            }

            initTimelineChart(alerts = []) {
                const chartDom = document.getElementById('alertTimelineChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const timelineData = (alerts && Array.isArray(alerts)) ? alerts.map(alert => ({
                    name: alert.description,
                    value: [alert.timestamp, alert.level],
                    itemStyle: {
                        color: alert.level === 'red' ? '#FF4444' : alert.level === 'yellow' ? '#FFA500' : '#4A90E2'
                    },
                    alertData: alert
                })) : [];

                const option = {
                    title: {
                        text: '预警历史时间线',
                        left: 'center',
                        subtext: `总计: ${alerts.length}条预警`
                    },
                    tooltip: {
                        formatter: function(params) {
                            const alert = params.data.alertData;
                            return `
                                ${alert.description}<br/>
                                时间: ${new Date(alert.timestamp).toLocaleString()}<br/>
                                级别: ${alert.level === 'red' ? '🔴 红色' : alert.level === 'yellow' ? '🟡 黄色' : '🔵 蓝色'}<br/>
                                类型: ${alert.type}<br/>
                                ${alert.number ? `号码: ${alert.number}<br/>` : ''}
                                预警值: ${typeof alert.value === 'number' ? alert.value : parseFloat(alert.value) || 0}
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'time',
                        name: '时间',
                        axisLabel: {
                            formatter: function(value) {
                                const date = new Date(value);
                                return `${date.getMonth() + 1}/${date.getDate()}`;
                            }
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: ['蓝色', '黄色', '红色'],
                        inverse: true,
                        axisLabel: {
                            formatter: function(value) {
                                return value === '红色' ? '🔴 红色' : value === '黄色' ? '🟡 黄色' : '🔵 蓝色';
                            }
                        }
                    },
                    series: [{
                        type: 'scatter',
                        data: timelineData,
                        symbolSize: 20,
                        itemStyle: {
                            borderColor: '#fff',
                            borderWidth: 2
                        }
                    }],
                    dataZoom: [
                        {
                            type: 'slider',
                            show: true,
                            xAxisIndex: [0],
                            start: 0,
                            end: 100
                        },
                        {
                            type: 'inside',
                            xAxisIndex: [0],
                            start: 0,
                            end: 100
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.timelineChart = chart;
            }

            initHitRateChart(alerts = []) {
                const chartDom = document.getElementById('alertHitRateChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const typeNames = ['周期性', '分布性', '统计性', '趋势性', '关联性'];
                const hitData = [12, 8, 15, 6, 9];
                const missData = [3, 5, 4, 2, 3];

                const totalData = hitData.map((hit, index) => hit + missData[index]);
                const hitRates = totalData.map((total, index) => {
                    return total > 0 ? ((hitData[index] / total) * 100).toFixed(1) : 0;
                });

                const option = {
                    title: {
                        text: '预警命中率分析',
                        left: 'center',
                        subtext: `平均命中率: ${(hitRates.reduce((a, b) => parseFloat(a) + parseFloat(b), 0) / hitRates.length).toFixed(1)}%`
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            const typeName = paramArray[0].name;
                            const hitParam = paramArray.find(p => p.seriesName === '命中');
                            const missParam = paramArray.find(p => p.seriesName === '未命中');
                            const hit = hitParam ? hitParam.value : 0;
                            const miss = missParam ? missParam.value : 0;
                            const total = hit + miss;
                            const rate = total > 0 ? ((hit / total) * 100).toFixed(1) : 0;
                            return `
                                ${typeName}<br/>
                                命中: ${hit}次<br/>
                                未命中: ${miss}次<br/>
                                命中率: ${rate}%
                            `;
                        }
                    },
                    legend: {
                        data: ['命中', '未命中', '命中率'],
                        top: '10%'
                    },
                    xAxis: {
                        type: 'category',
                        data: typeNames,
                        axisLabel: {
                            interval: 0,
                            rotate: 0
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '次数',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '命中率(%)',
                            position: 'right',
                            max: 100,
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '命中',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: hitData,
                            itemStyle: { color: '#4CAF50' },
                            barMaxWidth: 40
                        },
                        {
                            name: '未命中',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: missData,
                            itemStyle: { color: '#FF4444' },
                            barMaxWidth: 40
                        },
                        {
                            name: '命中率',
                            type: 'line',
                            yAxisIndex: 1,
                            data: hitRates,
                            smooth: true,
                            itemStyle: {
                                color: '#FF9800'
                            },
                            lineStyle: {
                                color: '#FF9800',
                                width: 3
                            },
                            symbol: 'circle',
                            symbolSize: 8
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.hitRateChart = chart;
            }

            initFlowChart(alerts = []) {
                const chartDom = document.getElementById('alertFlowChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '预警信号流转路径',
                        left: 'center',
                        subtext: '显示预警类型到预警级别的流转'
                    },
                    tooltip: {
                        trigger: 'item',
                        triggerOn: 'mousemove',
                        formatter: function(params) {
                            if (params.dataType === 'edge') {
                                return `${params.data.source} → ${params.data.target}<br/>数量: ${params.data.value}`;
                            }
                            return `${params.name}<br/>总数: ${params.value}`;
                        }
                    },
                    series: [
                        {
                            type: 'sankey',
                            layout: 'none',
                            emphasis: {
                                focus: 'adjacency'
                            },
                            data: [
                                { name: '周期性预警' },
                                { name: '分布性预警' },
                                { name: '统计性预警' },
                                { name: '趋势性预警' },
                                { name: '关联性预警' },
                                { name: '红色预警' },
                                { name: '黄色预警' },
                                { name: '蓝色预警' }
                            ],
                            links: [
                                { source: '周期性预警', target: '红色预警', value: 5 },
                                { source: '周期性预警', target: '黄色预警', value: 8 },
                                { source: '周期性预警', target: '蓝色预警', value: 3 },
                                { source: '分布性预警', target: '黄色预警', value: 6 },
                                { source: '分布性预警', target: '蓝色预警', value: 4 },
                                { source: '统计性预警', target: '红色预警', value: 10 },
                                { source: '统计性预警', target: '黄色预警', value: 5 },
                                { source: '趋势性预警', target: '黄色预警', value: 4 },
                                { source: '趋势性预警', target: '蓝色预警', value: 2 },
                                { source: '关联性预警', target: '蓝色预警', value: 7 },
                                { source: '关联性预警', target: '黄色预警', value: 3 }
                            ],
                            lineStyle: {
                                color: 'source',
                                curveness: 0.5,
                                opacity: 0.5
                            },
                            itemStyle: {
                                borderWidth: 1,
                                borderColor: '#aaa'
                            },
                            label: {
                                position: 'right',
                                fontSize: 12
                            }
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.flowChart = chart;
            }

            initBoxPlot(alerts = []) {
                const chartDom = document.getElementById('alertBoxPlot');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '预警指标统计分布',
                        left: 'center',
                        subtext: '显示各预警类型指标的统计分布'
                    },
                    tooltip: {
                        trigger: 'item',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const data = params.data;
                            return `
                                ${params.name}<br/>
                                最小值: ${data[1]}<br/>
                                第一四分位数: ${data[2]}<br/>
                                中位数: ${data[3]}<br/>
                                第三四分位数: ${data[4]}<br/>
                                最大值: ${data[5]}<br/>
                                IQR: ${(data[4] - data[2]).toFixed(2)}
                            `;
                        }
                    },
                    grid: {
                        left: '10%',
                        right: '10%',
                        bottom: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        data: ['周期性', '分布性', '统计性', '趋势性', '关联性'],
                        boundaryGap: true,
                        nameGap: 30,
                        splitArea: { show: false },
                        splitLine: { show: false },
                        axisLabel: {
                            interval: 0,
                            rotate: 0
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '预警值',
                        splitArea: { show: true },
                        axisLabel: {
                            formatter: '{value}'
                        }
                    },
                    series: [
                        {
                            name: 'boxplot',
                            type: 'boxplot',
                            data: [
                                [10, 15, 20, 25, 30],
                                [8, 12, 18, 22, 28],
                                [12, 18, 24, 30, 36],
                                [6, 10, 14, 18, 22],
                                [5, 8, 12, 16, 20]
                            ],
                            itemStyle: {
                                color: '#FF6B6B',
                                borderColor: '#FF4444',
                                borderWidth: 2
                            },
                            tooltip: {
                                formatter: function(params) {
                                    const data = params.data;
                                    return `
                                        ${params.name}<br/>
                                        最小值: ${data[1]}<br/>
                                        第一四分位数: ${data[2]}<br/>
                                        中位数: ${data[3]}<br/>
                                        第三四分位数: ${data[4]}<br/>
                                        最大值: ${data[5]}<br/>
                                        IQR: ${(data[4] - data[2]).toFixed(2)}
                                    `;
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option);
                this.charts.boxPlot = chart;
            }

            updateAllCharts(alerts) {
                this.initLevelDistributionChart(alerts);
                this.initTimeHeatmap(alerts);
                this.initDimensionRadar(alerts);
                this.initRiskGauge(alerts);
                this.initAlertList(alerts);
                this.initTrendLine(alerts);
                this.initScatterPlot(alerts);
                this.initNetworkGraph(alerts);
                this.initTimelineChart(alerts);
                this.initNumberAlertChart(alerts);
            }

            resizeCharts() {
                Object.values(this.charts).forEach(chart => {
                    if (chart) {
                        chart.resize();
                    }
                });
            }
        }

        // 用户交互功能类
        class AlertUserInteraction {
            constructor() {
                this.subscriptions = this.loadSubscriptions();
                this.alertHistory = this.loadAlertHistory();
                this.userPreferences = this.loadUserPreferences();
            }

            loadSubscriptions() {
                const saved = localStorage.getItem('alertSubscriptions');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载预警订阅失败:', e);
                    }
                }
                return this.getDefaultSubscriptions();
            }

            getDefaultSubscriptions() {
                return {
                    alertTypes: {
                        cycle: true,
                        distribution: true,
                        statistics: true,
                        trend: true,
                        correlation: true
                    },
                    numberRanges: {
                        enabled: false,
                        min: 1,
                        max: 33
                    },
                    levelFilters: {
                        red: true,
                        yellow: true,
                        blue: true
                    }
                };
            }

            saveSubscriptions() {
                localStorage.setItem('alertSubscriptions', JSON.stringify(this.subscriptions));
            }

            updateSubscription(category, updates) {
                if (this.subscriptions[category]) {
                    Object.assign(this.subscriptions[category], updates);
                    this.saveSubscriptions();
                    return true;
                }
                return false;
            }

            filterAlerts(alerts) {
                return alerts.filter(alert => {
                    if (!this.subscriptions.alertTypes[alert.type]) {
                        return false;
                    }
                    if (!this.subscriptions.levelFilters[alert.level]) {
                        return false;
                    }
                    if (this.subscriptions.numberRanges.enabled && alert.number) {
                        const num = parseInt(alert.number);
                        if (num < this.subscriptions.numberRanges.min || num > this.subscriptions.numberRanges.max) {
                            return false;
                        }
                    }
                    return true;
                });
            }

            loadAlertHistory() {
                const saved = localStorage.getItem('alertHistory');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载预警历史失败:', e);
                    }
                }
                return [];
            }

            saveAlertHistory() {
                localStorage.setItem('alertHistory', JSON.stringify(this.alertHistory.slice(-1000)));
            }

            addAlertToHistory(alert) {
                alert.id = alert.id || this.generateAlertId();
                alert.timestamp = alert.timestamp || new Date().toISOString();
                alert.status = alert.status || 'pending';
                alert.feedback = alert.feedback || null;
                this.alertHistory.push(alert);
                this.saveAlertHistory();
            }

            confirmAlert(alertId, feedback = null) {
                const alert = this.alertHistory.find(a => a.id === alertId);
                if (alert) {
                    alert.status = 'confirmed';
                    alert.feedback = feedback;
                    alert.confirmedAt = new Date().toISOString();
                    this.saveAlertHistory();
                    return true;
                }
                return false;
            }

            archiveAlert(alertId, category = 'general') {
                const alert = this.alertHistory.find(a => a.id === alertId);
                if (alert) {
                    alert.status = 'archived';
                    alert.archiveCategory = category;
                    alert.archivedAt = new Date().toISOString();
                    this.saveAlertHistory();
                    return true;
                }
                return false;
            }

            shareAlert(alertId) {
                const alert = this.alertHistory.find(a => a.id === alertId);
                if (alert) {
                    const shareData = {
                        description: alert.description,
                        level: alert.level,
                        number: alert.number,
                        timestamp: alert.timestamp
                    };
                    const shareText = JSON.stringify(shareData, null, 2);
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(shareText);
                        MessageSystem.showMessage('预警信息已复制到剪贴板', 'success');
                    } else {
                        console.log('预警信息:', shareText);
                        MessageSystem.showMessage('预警信息已输出到控制台', 'info');
                    }
                    return true;
                }
                return false;
            }

            loadUserPreferences() {
                const saved = localStorage.getItem('alertUserPreferences');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载用户偏好失败:', e);
                    }
                }
                return this.getDefaultUserPreferences();
            }

            getDefaultUserPreferences() {
                return {
                    theme: 'light',
                    layout: 'default',
                    chartTypes: ['levelDistribution', 'timeHeatmap', 'dimensionRadar', 'riskGauge'],
                    refreshFrequency: 30000,
                    notifications: {
                        enabled: true,
                        sound: true,
                        desktop: false
                    }
                };
            }

            saveUserPreferences() {
                localStorage.setItem('alertUserPreferences', JSON.stringify(this.userPreferences));
            }

            updatePreference(category, updates) {
                if (this.userPreferences[category]) {
                    Object.assign(this.userPreferences[category], updates);
                    this.saveUserPreferences();
                    return true;
                }
                return false;
            }

            generateAlertId() {
                return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            getAlertStats() {
                const today = new Date().toDateString();
                const todayAlerts = this.alertHistory.filter(alert => 
                    new Date(alert.timestamp).toDateString() === today
                );

                const statusCounts = {
                    pending: 0,
                    confirmed: 0,
                    archived: 0
                };

                this.alertHistory.forEach(alert => {
                    statusCounts[alert.status]++;
                });

                const feedbackStats = {
                    positive: 0,
                    negative: 0,
                    neutral: 0
                };

                this.alertHistory.forEach(alert => {
                    if (alert.feedback) {
                        feedbackStats[alert.feedback]++;
                    }
                });

                return {
                    total: this.alertHistory.length,
                    today: todayAlerts.length,
                    statusCounts,
                    feedbackStats,
                    hitRate: this.calculateHitRate()
                };
            }

            calculateHitRate() {
                const confirmedAlerts = this.alertHistory.filter(alert => alert.status === 'confirmed' && alert.feedback);
                if (confirmedAlerts.length === 0) return 0;

                const positiveCount = confirmedAlerts.filter(alert => alert.feedback === 'positive').length;
                return Math.round((positiveCount / confirmedAlerts.length) * 100);
            }
        }

        // 数据存储结构类
        class AlertDataStorage {
            constructor() {
                this.alertRecords = this.loadAlertRecords();
                this.alertRules = this.loadAlertRules();
                this.userConfig = this.loadUserConfig();
            }

            loadAlertRecords() {
                const saved = localStorage.getItem('alertRecords');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载预警记录失败:', e);
                    }
                }
                return [];
            }

            saveAlertRecords() {
                localStorage.setItem('alertRecords', JSON.stringify(this.alertRecords.slice(-10000)));
            }

            addAlertRecord(record) {
                record.id = record.id || this.generateRecordId();
                record.createdAt = record.createdAt || new Date().toISOString();
                record.updatedAt = record.updatedAt || new Date().toISOString();
                this.alertRecords.push(record);
                this.saveAlertRecords();
                return record;
            }

            updateAlertRecord(id, updates) {
                const index = this.alertRecords.findIndex(record => record.id === id);
                if (index > -1) {
                    Object.assign(this.alertRecords[index], updates);
                    this.alertRecords[index].updatedAt = new Date().toISOString();
                    this.saveAlertRecords();
                    return true;
                }
                return false;
            }

            getAlertRecords(filters = {}) {
                let records = [...this.alertRecords];

                if (filters.type) {
                    records = records.filter(record => record.type === filters.type);
                }
                if (filters.level) {
                    records = records.filter(record => record.level === filters.level);
                }
                if (filters.startDate) {
                    records = records.filter(record => new Date(record.createdAt) >= new Date(filters.startDate));
                }
                if (filters.endDate) {
                    records = records.filter(record => new Date(record.createdAt) <= new Date(filters.endDate));
                }
                if (filters.status) {
                    records = records.filter(record => record.status === filters.status);
                }

                return records.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            }

            loadAlertRules() {
                const saved = localStorage.getItem('alertRulesStorage');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载预警规则失败:', e);
                    }
                }
                return [];
            }

            saveAlertRules() {
                localStorage.setItem('alertRulesStorage', JSON.stringify(this.alertRules));
            }

            addAlertRule(rule) {
                rule.id = rule.id || this.generateRuleId();
                rule.createdAt = rule.createdAt || new Date().toISOString();
                rule.enabled = rule.enabled !== undefined ? rule.enabled : true;
                rule.hitCount = rule.hitCount || 0;
                rule.missCount = rule.missCount || 0;
                rule.lastTriggeredAt = rule.lastTriggeredAt || null;
                this.alertRules.push(rule);
                this.saveAlertRules();
                return rule;
            }

            updateAlertRule(id, updates) {
                const index = this.alertRules.findIndex(rule => rule.id === id);
                if (index > -1) {
                    Object.assign(this.alertRules[index], updates);
                    this.alertRules[index].updatedAt = new Date().toISOString();
                    this.saveAlertRules();
                    return true;
                }
                return false;
            }

            deleteAlertRule(id) {
                const index = this.alertRules.findIndex(rule => rule.id === id);
                if (index > -1) {
                    this.alertRules.splice(index, 1);
                    this.saveAlertRules();
                    return true;
                }
                return false;
            }

            getAlertRule(id) {
                return this.alertRules.find(rule => rule.id === id);
            }

            getEnabledAlertRules() {
                return this.alertRules.filter(rule => rule.enabled);
            }

            updateRuleHitStats(id, hit) {
                const rule = this.getAlertRule(id);
                if (rule) {
                    if (hit) {
                        rule.hitCount++;
                    } else {
                        rule.missCount++;
                    }
                    rule.lastTriggeredAt = new Date().toISOString();
                    this.saveAlertRules();
                    return true;
                }
                return false;
            }

            loadUserConfig() {
                const saved = localStorage.getItem('alertUserConfig');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载用户配置失败:', e);
                    }
                }
                return this.getDefaultUserConfig();
            }

            getDefaultUserConfig() {
                return {
                    userId: 'default',
                    subscriptions: [],
                    notificationMethods: ['inApp'],
                    interfacePreferences: {
                        theme: 'light',
                        language: 'zh-CN',
                        timezone: 'Asia/Shanghai'
                    },
                    dataRange: {
                        minPeriod: 10,
                        maxPeriod: 200,
                        defaultPeriod: 100
                    },
                    alertSettings: {
                        maxAlertsPerDay: 100,
                        quietHours: {
                            enabled: false,
                            start: '22:00',
                            end: '08:00'
                        }
                    }
                };
            }

            saveUserConfig() {
                localStorage.setItem('alertUserConfig', JSON.stringify(this.userConfig));
            }

            updateUserConfig(updates) {
                Object.assign(this.userConfig, updates);
                this.saveUserConfig();
                return true;
            }

            generateRecordId() {
                return `record_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            generateRuleId() {
                return `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            exportData(format = 'json') {
                const data = {
                    alertRecords: this.alertRecords,
                    alertRules: this.alertRules,
                    userConfig: this.userConfig,
                    exportedAt: new Date().toISOString()
                };

                if (format === 'json') {
                    return JSON.stringify(data, null, 2);
                } else if (format === 'csv') {
                    let csv = 'ID,类型,级别,号码,描述,状态,创建时间\n';
                    this.alertRecords.forEach(record => {
                        csv += `${record.id},${record.type},${record.level},${record.number || ''},${record.description},${record.status},${record.createdAt}\n`;
                    });
                    return csv;
                }
                return null;
            }

            importData(data, format = 'json') {
                try {
                    if (format === 'json') {
                        const parsed = JSON.parse(data);
                        if (parsed.alertRecords) {
                            this.alertRecords = [...this.alertRecords, ...parsed.alertRecords];
                            this.saveAlertRecords();
                        }
                        if (parsed.alertRules) {
                            this.alertRules = [...this.alertRules, ...parsed.alertRules];
                            this.saveAlertRules();
                        }
                        if (parsed.userConfig) {
                            this.userConfig = { ...this.userConfig, ...parsed.userConfig };
                            this.saveUserConfig();
                        }
                    }
                    return true;
                } catch (e) {
                    console.error('导入数据失败:', e);
                    return false;
                }
            }
        }

        // 特色功能类
        class AlertSpecialFeatures {
            constructor() {
                this.simulationResults = [];
                this.learningData = this.loadLearningData();
                this.viewConnections = {};
            }

            loadLearningData() {
                const saved = localStorage.getItem('alertLearningData');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('加载学习数据失败:', e);
                    }
                }
                return {
                    feedbackHistory: [],
                    patternAccuracy: {},
                    thresholdOptimizations: {}
                };
            }

            saveLearningData() {
                localStorage.setItem('alertLearningData', JSON.stringify(this.learningData));
            }

            simulateAlerts(draws, rules, startDate, endDate) {
                const results = [];
                const startDrawIndex = draws.findIndex(draw => new Date(draw.date) >= new Date(startDate));
                const endDrawIndex = draws.findIndex(draw => new Date(draw.date) >= new Date(endDate));

                if (startDrawIndex === -1 || endDrawIndex === -1) {
                    throw new Error('指定的日期范围内没有数据');
                }

                for (let i = startDrawIndex; i < endDrawIndex; i++) {
                    const historicalDraws = draws.slice(0, i);
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    const alerts = this.evaluateRules(historicalDraws, rules);
                    const hits = this.checkAlertAccuracy(alerts, nextDraw);

                    results.push({
                        period: currentDraw.period,
                        date: currentDraw.date,
                        alerts: alerts,
                        hits: hits,
                        accuracy: hits.length > 0 ? hits.filter(h => h).length / hits.length : 0
                    });
                }

                this.simulationResults = results;
                return results;
            }

            evaluateRules(draws, rules) {
                const alerts = [];
                const signalTypes = new AlertSignalTypes();
                const allSignals = signalTypes.detectAllSignals(draws);

                allSignals.forEach(signal => {
                    const rule = rules.find(r => r.type === signal.type && r.signal === signal.signal);
                    if (rule && rule.enabled) {
                        alerts.push(signal);
                    }
                });

                return alerts;
            }

            checkAlertAccuracy(alerts, nextDraw) {
                if (!nextDraw) return [];

                return alerts.map(alert => {
                    if (alert.number && nextDraw.redBalls.includes(alert.number)) {
                        return true;
                    }
                    if (alert.numbers && Array.isArray(alert.numbers)) {
                        const hitCount = alert.numbers.filter(num => nextDraw.redBalls.includes(num)).length;
                        return hitCount >= alert.numbers.length / 2;
                    }
                    return false;
                });
            }

            compareRulePerformance(results) {
                const ruleStats = {};

                results.forEach(result => {
                    result.alerts.forEach(alert => {
                        const ruleKey = `${alert.type}_${alert.signal}`;
                        if (!ruleStats[ruleKey]) {
                            ruleStats[ruleKey] = { total: 0, hits: 0 };
                        }
                        ruleStats[ruleKey].total++;
                        if (result.hits[result.alerts.indexOf(alert)]) {
                            ruleStats[ruleKey].hits++;
                        }
                    });
                });

                const performance = Object.entries(ruleStats).map(([key, stats]) => ({
                    rule: key,
                    total: stats.total,
                    hits: stats.hits,
                    accuracy: stats.total > 0 ? (stats.hits / stats.total * 100).toFixed(2) : 0
                }));

                return performance.sort((a, b) => b.accuracy - a.accuracy);
            }

            optimizeThresholds(draws, ruleType) {
                const results = [];
                const signalTypes = new AlertSignalTypes();

                for (let threshold = 0.5; threshold <= 3; threshold += 0.1) {
                    const alerts = signalTypes.detectAllSignals(draws);
                    const filteredAlerts = alerts.filter(alert => {
                        return alert.value / alert.threshold >= threshold;
                    });

                    const accuracy = this.calculateSimulationAccuracy(filteredAlerts, draws);
                    results.push({
                        threshold: threshold.toFixed(2),
                        alertCount: filteredAlerts.length,
                        accuracy: accuracy
                    });
                }

                const optimal = results.reduce((best, current) => {
                    return current.accuracy > best.accuracy ? current : best;
                }, results[0]);

                this.learningData.thresholdOptimizations[ruleType] = optimal;
                this.saveLearningData();

                return optimal;
            }

            calculateSimulationAccuracy(alerts, draws) {
                let hitCount = 0;
                let totalCount = 0;

                alerts.forEach(alert => {
                    const alertIndex = draws.findIndex(draw => new Date(draw.date) >= new Date(alert.timestamp));
                    if (alertIndex > -1 && alertIndex < draws.length - 1) {
                        const nextDraw = draws[alertIndex + 1];
                        totalCount++;

                        if (alert.number && nextDraw.redBalls.includes(alert.number)) {
                            hitCount++;
                        }
                    }
                });

                return totalCount > 0 ? (hitCount / totalCount * 100).toFixed(2) : 0;
            }

            recordFeedback(alertId, feedback) {
                this.learningData.feedbackHistory.push({
                    alertId,
                    feedback,
                    timestamp: new Date().toISOString()
                });

                this.updatePatternAccuracy(alertId, feedback);
                this.saveLearningData();
            }

            updatePatternAccuracy(alertId, feedback) {
                const feedbackHistory = this.learningData.feedbackHistory.filter(f => f.alertId === alertId);
                const positiveCount = feedbackHistory.filter(f => f.feedback === 'positive').length;
                const totalCount = feedbackHistory.length;

                if (totalCount > 0) {
                    const accuracy = (positiveCount / totalCount * 100).toFixed(2);
                    this.learningData.patternAccuracy[alertId] = accuracy;
                }
            }

            getPatternAccuracy(alertId) {
                return this.learningData.patternAccuracy[alertId] || 0;
            }

            suggestRuleAdjustments() {
                const suggestions = [];

                Object.entries(this.learningData.thresholdOptimizations).forEach(([ruleType, data]) => {
                    if (data.accuracy < 50) {
                        suggestions.push({
                            ruleType,
                            currentThreshold: data.threshold,
                            suggestedThreshold: (parseFloat(data.threshold) * 1.2).toFixed(2),
                            reason: '当前阈值命中率较低，建议提高阈值'
                        });
                    } else if (data.accuracy > 80) {
                        suggestions.push({
                            ruleType,
                            currentThreshold: data.threshold,
                            suggestedThreshold: (parseFloat(data.threshold) * 0.8).toFixed(2),
                            reason: '当前阈值命中率较高，可以降低阈值以增加预警数量'
                        });
                    }
                });

                return suggestions;
            }

            setupViewConnections() {
                this.viewConnections = {
                    'alertLevelDistributionChart': ['alertTimeHeatmap', 'alertDimensionRadar'],
                    'alertTimeHeatmap': ['alertTrendLine', 'alertTimelineChart'],
                    'alertDimensionRadar': ['alertRiskGauge', 'alertBoxPlot'],
                    'alertRiskGauge': ['alertListContainer', 'alertHitRateChart']
                };
            }

            handleViewInteraction(sourceView, data) {
                const connectedViews = this.viewConnections[sourceView] || [];
                connectedViews.forEach(targetView => {
                    this.updateConnectedView(targetView, data);
                });
            }

            updateConnectedView(targetView, data) {
                const chart = echarts.getInstanceByDom(document.getElementById(targetView));
                if (chart) {
                    if (targetView === 'alertTimeHeatmap') {
                        chart.setOption({
                            series: [{
                                data: data
                            }]
                        });
                    } else if (targetView === 'alertDimensionRadar') {
                        chart.setOption({
                            series: [{
                                data: [{
                                    value: data
                                }]
                            }]
                        });
                    }
                }
            }

            drillDownData(alert) {
                const drillDownData = {
                    alert: alert,
                    relatedAlerts: this.findRelatedAlerts(alert),
                    historicalData: this.getHistoricalDataForAlert(alert),
                    recommendations: this.generateRecommendations(alert)
                };
                return drillDownData;
            }

            findRelatedAlerts(alert) {
                const storage = new AlertDataStorage();
                const allAlerts = storage.getAlertRecords();
                const timeWindow = 24 * 60 * 60 * 1000;
                const alertTime = new Date(alert.timestamp).getTime();

                return allAlerts.filter(other => {
                    const otherTime = new Date(other.timestamp).getTime();
                    const timeDiff = Math.abs(otherTime - alertTime);
                    return timeDiff <= timeWindow && other.id !== alert.id;
                });
            }

            getHistoricalDataForAlert(alert) {
                const draws = currentDatabaseData.draws || [];
                const alertDate = new Date(alert.timestamp);
                const historicalDraws = draws.filter(draw => {
                    const drawDate = new Date(draw.date);
                    return drawDate < alertDate;
                });

                return historicalDraws.slice(-50);
            }

            generateRecommendations(alert) {
                const recommendations = [];

                if (alert.level === 'red') {
                    recommendations.push({
                        type: 'action',
                        priority: 'high',
                        message: '高风险预警，建议立即关注相关号码'
                    });
                }

                if (alert.type === 'cycle') {
                    recommendations.push({
                        type: 'analysis',
                        priority: 'medium',
                        message: '周期性预警，建议分析号码的历史周期规律'
                    });
                }

                if (alert.number) {
                    recommendations.push({
                        type: 'selection',
                        priority: 'low',
                        message: `可考虑将号码${alert.number}纳入选号范围`
                    });
                }

                return recommendations;
            }

            switchTimePeriod(period) {
                const draws = currentDatabaseData.draws || [];
                let periodDraws;

                switch (period) {
                    case 'week':
                        periodDraws = draws.slice(-7);
                        break;
                    case 'month':
                        periodDraws = draws.slice(-30);
                        break;
                    case 'quarter':
                        periodDraws = draws.slice(-90);
                        break;
                    case 'year':
                        periodDraws = draws.slice(-365);
                        break;
                    default:
                        periodDraws = draws;
                }

                return periodDraws;
            }

            exportSimulationResults(format = 'csv') {
                if (this.simulationResults.length === 0) {
                    throw new Error('没有模拟结果可导出');
                }

                if (format === 'csv') {
                    let csv = '期号,日期,预警数量,命中数量,准确率\n';
                    this.simulationResults.forEach(result => {
                        csv += `${result.period},${result.date},${result.alerts.length},${result.hits.filter(h => h).length},${result.accuracy}\n`;
                    });
                    return csv;
                } else if (format === 'json') {
                    return JSON.stringify(this.simulationResults, null, 2);
                }

                return null;
            }
        }

        // 全新预警引擎类
        class NewAlertEngine {
            constructor() {
                this.indicatorSystem = new AlertIndicatorSystem();
                this.signalTypes = new AlertSignalTypes();
                this.ruleEngine = new AlertRuleEngine();
                this.visualization = new AlertVisualization();
                this.userInteraction = new AlertUserInteraction();
                this.dataStorage = new AlertDataStorage();
                this.specialFeatures = new AlertSpecialFeatures();

                this.isMonitoring = false;
                this.monitoringInterval = null;
                this.monitoringFrequency = 30000;
                this.currentAlerts = [];
                this.alertHistory = [];
            }

            initialize() {
                this.visualization.initDashboard();
                this.specialFeatures.setupViewConnections();
                this.loadAlertHistory();
            }

            loadAlertHistory() {
                this.alertHistory = this.dataStorage.getAlertRecords();
            }

            analyze(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                if (!draws || draws.length < 10) {
                    return [];
                }

                const realTimeStatus = this.indicatorSystem.getRealTimeStatus(draws);
                const allSignals = this.signalTypes.detectAllSignals(draws, basicAnalysisData, advancedAnalysisData);
                const evaluatedAlerts = this.ruleEngine.evaluateAlerts(allSignals, draws);
                const filteredAlerts = this.userInteraction.filterAlerts(evaluatedAlerts);

                filteredAlerts.forEach(alert => {
                    this.dataStorage.addAlertRecord(alert);
                });

                this.currentAlerts = filteredAlerts;
                this.alertHistory = [...filteredAlerts, ...this.alertHistory];

                return {
                    alerts: filteredAlerts,
                    realTimeStatus,
                    riskScore: this.indicatorSystem.calculateRiskScore(filteredAlerts),
                    riskLevel: this.indicatorSystem.getRiskLevelByScore(this.indicatorSystem.calculateRiskScore(filteredAlerts))
                };
            }

            startMonitoring(draws, frequency = 30000, basicAnalysisData = null, advancedAnalysisData = null) {
                try {
                    if (this.isMonitoring) {
                        this.stopMonitoring();
                    }

                    if (!draws || !Array.isArray(draws) || draws.length < 10) {
                        throw new Error('开奖数据不足，无法启动监控');
                    }

                    this.isMonitoring = true;
                    this.monitoringFrequency = frequency;

                    this.monitoringInterval = setInterval(() => {
                        this.performMonitoring(draws, basicAnalysisData, advancedAnalysisData);
                    }, this.monitoringFrequency);

                    console.log('预警监控已启动，频率:', frequency / 1000, '秒');
                    MessageSystem.showMessage('预警监控已启动', 'success');
                    return true;
                } catch (error) {
                    console.error('启动监控时出错:', error);
                    MessageSystem.showMessage(`启动监控失败: ${error.message}`, 'error');
                    return false;
                }
            }

            stopMonitoring() {
                try {
                    if (this.monitoringInterval) {
                        clearInterval(this.monitoringInterval);
                        this.monitoringInterval = null;
                    }

                    this.isMonitoring = false;
                    console.log('预警监控已停止');
                    MessageSystem.showMessage('预警监控已停止', 'info');
                } catch (error) {
                    console.error('停止监控时出错:', error);
                }
            }

            performMonitoring(draws, basicAnalysisData = null, advancedAnalysisData = null) {
                try {
                    if (!this.isMonitoring) {
                        return;
                    }

                    const result = this.analyze(draws, basicAnalysisData, advancedAnalysisData);
                    const newAlerts = result.alerts.filter(alert => {
                        return !this.currentAlerts.some(existing => existing.id === alert.id);
                    });

                    if (newAlerts.length > 0) {
                        this.currentAlerts = [...newAlerts, ...this.currentAlerts];
                        this.visualization.updateAllCharts(result.alerts);
                        this.displayAlerts(newAlerts);
                    }
                } catch (error) {
                    console.error('执行监控时出错:', error);
                }
            }

            displayAlerts(alerts) {
                alerts.forEach(alert => {
                    const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                    const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };
                    const message = `${levelIcons[alert.level]} ${alert.description}`;

                    MessageSystem.showMessage(message, alert.level);
                });
            }

            updateVisualization(alerts) {
                this.visualization.updateAllCharts(alerts);
            }

            getMonitoringStatus() {
                return {
                    isMonitoring: this.isMonitoring,
                    monitoringFrequency: this.monitoringFrequency,
                    currentAlertCount: this.currentAlerts.length,
                    totalAlertCount: this.alertHistory.length
                };
            }

            exportAlertHistory(format = 'csv') {
                const data = this.dataStorage.exportData(format);
                if (data) {
                    const blob = new Blob([data], { type: format === 'json' ? 'application/json' : 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `预警历史_${new Date().toISOString().split('T')[0]}.${format}`;
                    link.click();
                    URL.revokeObjectURL(url);
                    MessageSystem.showMessage('预警历史已导出', 'success');
                }
            }

            simulateAlerts(draws, rules, startDate, endDate) {
                return this.specialFeatures.simulateAlerts(draws, rules, startDate, endDate);
            }

            optimizeThresholds(draws, ruleType) {
                return this.specialFeatures.optimizeThresholds(draws, ruleType);
            }

            recordFeedback(alertId, feedback) {
                return this.specialFeatures.recordFeedback(alertId, feedback);
            }

            getAlertStats() {
                return this.userInteraction.getAlertStats();
            }
        }

        // 预警规则配置类
        class AlertRuleConfig {
            static defaultRules = {
                numberLevel: {
                    superCold: { threshold: 2, level: 'high', name: '超冷号码', description: '遗漏期数 > 平均遗漏×2', icon: '❄️', color: '#FF4444' },
                    hotStreak: { threshold: 3, level: 'medium', name: '热号持续', description: '连续出现 ≥ 3期', icon: '🔥', color: '#FF8C00' },
                    trendBreakthrough: { threshold: 0.8, level: 'medium', name: '趋势突破', description: '移动平均线突破阈值', icon: '📈', color: '#FFA500' },
                    reboundSignal: { threshold: 0.9, level: 'high', name: '回补信号', description: '历史最大遗漏接近', icon: '⚡', color: '#FF4444' },
                    patternMatch: { threshold: 0.7, level: 'medium', name: '模式匹配', description: '符合DNA分析模式', icon: '🧬', color: '#FFA500' }
                },
                combinationLevel: {
                    oddEvenImbalance: { threshold: 5, level: 'high', name: '奇偶失衡', description: '连续N期奇偶比异常', icon: '⚖️', color: '#FF4444' },
                    bigSmallImbalance: { threshold: 5, level: 'high', name: '大小失衡', description: '连续N期大小比异常', icon: '📊', color: '#FF4444' },
                    primeCompositeImbalance: { threshold: 5, level: 'medium', name: '质合失衡', description: '连续N期质合比异常', icon: '#️⃣', color: '#FFA500' },
                    zoneImbalance: { threshold: 3, level: 'high', name: '大中小失衡', description: '某区连续空开N期', icon: '🎯', color: '#FF4444' },
                    acValueAbnormal: { threshold: 3, level: 'medium', name: 'AC值异常', description: '连续N期超出正常范围', icon: '📐', color: '#FFA500' }
                },
                statisticsLevel: {
                    frequencyAbnormal: { threshold: 2, level: 'high', name: '频率异常', description: '某号码出现频率 > 历史平均2倍', icon: '📊', color: '#FF4444' },
                    intervalAbnormal: { threshold: 3, level: 'medium', name: '间隔异常', description: '号码间隔期数出现模式', icon: '⏱️', color: '#FFA500' },
                    distributionAbnormal: { threshold: 0.3, level: 'medium', name: '分布异常', description: '号码分布偏离正态分布', icon: '📉', color: '#FFA500' },
                    correlationAbnormal: { threshold: 0.7, level: 'low', name: '相关性异常', description: '特定组合相关性突增', icon: '🔗', color: '#FFD700' }
                }
            };

            static levelDefinitions = {
                high: {
                    name: '高级预警',
                    priority: 3,
                    color: '#FF4444',
                    icon: '🔴',
                    sound: true,
                    autoDismiss: false
                },
                medium: {
                    name: '中级预警',
                    priority: 2,
                    color: '#FFA500',
                    icon: '🟠',
                    sound: false,
                    autoDismiss: true
                },
                low: {
                    name: '警告级',
                    priority: 1,
                    color: '#FFD700',
                    icon: '🟡',
                    sound: false,
                    autoDismiss: true
                }
            };

            static getRules() {
                try {
                    const saved = localStorage.getItem('alertRules');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return { ...this.defaultRules, ...parsed };
                    }
                } catch (e) {
                    console.error('加载预警规则时出错:', e);
                }
                return this.defaultRules;
            }

            static saveRules(rules) {
                try {
                    localStorage.setItem('alertRules', JSON.stringify(rules));
                } catch (e) {
                    console.error('保存预警规则时出错:', e);
                    throw new Error('保存预警规则失败');
                }
            }

            static updateRule(category, ruleName, updates) {
                try {
                    const rules = this.getRules();
                    if (rules[category] && rules[category][ruleName]) {
                        Object.keys(updates).forEach(key => {
                            rules[category][ruleName][key] = updates[key];
                        });
                        this.saveRules(rules);
                        return true;
                    }
                    return false;
                } catch (e) {
                    console.error('更新预警规则时出错:', e);
                    return false;
                }
            }

            static resetToDefaults() {
                try {
                    localStorage.removeItem('alertRules');
                    MessageSystem.showMessage('预警规则已重置为默认值', 'success');
                } catch (e) {
                    console.error('重置预警规则时出错:', e);
                    MessageSystem.showMessage('重置预警规则失败', 'error');
                }
            }

            static getLevelDefinition(level) {
                return this.levelDefinitions[level] || this.levelDefinitions.low;
            }

            static validateRules(rules) {
                const errors = [];

                if (!rules || typeof rules !== 'object') {
                    errors.push('预警规则格式无效');
                    return errors;
                }

                const requiredCategories = ['numberLevel', 'combinationLevel', 'statisticsLevel'];
                requiredCategories.forEach(category => {
                    if (!rules[category]) {
                        errors.push(`缺少预警类别: ${category}`);
                    }
                });

                Object.entries(rules).forEach(([category, categoryRules]) => {
                    if (!categoryRules || typeof categoryRules !== 'object') {
                        errors.push(`预警类别 ${category} 格式无效`);
                        return;
                    }

                    Object.entries(categoryRules).forEach(([ruleName, rule]) => {
                        if (!rule.threshold || rule.threshold <= 0) {
                            errors.push(`${category}.${ruleName} 的阈值必须大于0`);
                        }
                        if (!rule.level || !['high', 'medium', 'low'].includes(rule.level)) {
                            errors.push(`${category}.${ruleName} 的级别必须是 high、medium 或 low`);
                        }
                    });
                });

                return errors;
            }

            static exportRules(format = 'json') {
                try {
                    const rules = this.getRules();
                    const timestamp = new Date().toISOString();

                    if (format === 'json') {
                        return JSON.stringify({ timestamp, rules }, null, 2);
                    } else if (format === 'csv') {
                        const headers = ['类别', '规则名称', '级别', '阈值', '描述'];
                        const rows = [];

                        Object.entries(rules).forEach(([category, categoryRules]) => {
                            Object.entries(categoryRules).forEach(([ruleName, rule]) => {
                                rows.push([
                                    category,
                                    ruleName,
                                    rule.level,
                                    rule.threshold,
                                    rule.description
                                ].join(','));
                            });
                        });

                        return [headers.join(','), ...rows].join('\n');
                    }

                    throw new Error('不支持的导出格式');
                } catch (e) {
                    console.error('导出预警规则时出错:', e);
                    throw new Error('导出预警规则失败');
                }
            }
        }

        // 预警引擎类
        class AlertEngine {
            constructor() {
                this.rules = AlertRuleConfig.getRules();
                this.alertHistory = this.loadAlertHistory();
                this.alertStats = this.loadAlertStats();

                this.isMonitoring = false;
                this.monitoringInterval = null;
                this.monitoringFrequency = 30000;
                this.currentAlerts = [];
                this.unreadAlerts = [];
                this.alertListeners = [];
                this.lastMonitoringTime = null;
                this.todayAlertCount = 0;
                this.hitStats = { total: 0, hit: 0, miss: 0 };
            }

            loadAlertHistory() {
                const saved = localStorage.getItem('alertHistory');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return [];
                    }
                }
                return [];
            }

            saveAlertHistory() {
                localStorage.setItem('alertHistory', JSON.stringify(this.alertHistory.slice(-1000)));
            }

            loadAlertStats() {
                const saved = localStorage.getItem('alertStats');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return { total: 0, hit: 0, miss: 0, hitRate: 0 };
                    }
                }
                return { total: 0, hit: 0, miss: 0, hitRate: 0 };
            }

            saveAlertStats() {
                localStorage.setItem('alertStats', JSON.stringify(this.alertStats));
            }

            analyze(draws) {
                if (!draws || draws.length < 10) {
                    return [];
                }

                const alerts = [];
                const recentDraws = draws.slice(-30);
                const lastDraw = draws[draws.length - 1];

                alerts.push(...this.checkNumberLevelAlerts(recentDraws, lastDraw));
                alerts.push(...this.checkCombinationLevelAlerts(recentDraws));
                alerts.push(...this.checkStatisticsLevelAlerts(draws, recentDraws));

                this.filterAndSortAlerts(alerts);
                this.recordAlerts(alerts);

                return alerts;
            }

            checkNumberLevelAlerts(draws, lastDraw) {
                const alerts = [];
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];

                const numberStats = this.calculateNumberStats(draws, redBallCount);

                Object.entries(numberStats).forEach(([num, stats]) => {
                    const rule = this.rules.numberLevel.superCold;
                    if (stats.omission >= stats.avgOmission * rule.threshold) {
                        alerts.push({
                            type: 'number',
                            level: rule.level,
                            category: '号码级',
                            name: rule.name,
                            description: `号码${num}：遗漏${stats.omission}期，超过平均遗漏${stats.avgOmission.toFixed(1)}期的${rule.threshold}倍`,
                            number: num,
                            value: stats.omission,
                            threshold: stats.avgOmission * rule.threshold,
                            timestamp: new Date().toISOString()
                        });
                    }

                    if (stats.consecutiveCount >= this.rules.numberLevel.hotStreak.threshold) {
                        alerts.push({
                            type: 'number',
                            level: this.rules.numberLevel.hotStreak.level,
                            category: '号码级',
                            name: this.rules.numberLevel.hotStreak.name,
                            description: `热号${num}：连续出现${stats.consecutiveCount}期，注意回调`,
                            number: num,
                            value: stats.consecutiveCount,
                            threshold: this.rules.numberLevel.hotStreak.threshold,
                            timestamp: new Date().toISOString()
                        });
                    }

                    if (stats.omission >= stats.maxOmission * this.rules.numberLevel.reboundSignal.threshold && stats.omission > 5) {
                        alerts.push({
                            type: 'number',
                            level: this.rules.numberLevel.reboundSignal.level,
                            category: '号码级',
                            name: this.rules.numberLevel.reboundSignal.name,
                            description: `号码${num}：遗漏${stats.omission}期，接近历史最大遗漏${stats.maxOmission}期`,
                            number: num,
                            value: stats.omission,
                            threshold: stats.maxOmission * this.rules.numberLevel.reboundSignal.threshold,
                            timestamp: new Date().toISOString()
                        });
                    }
                });

                return alerts;
            }

            checkCombinationLevelAlerts(draws) {
                const alerts = [];
                const lastNDraws = draws.slice(-this.rules.combinationLevel.oddEvenImbalance.threshold);

                const oddEvenCounts = lastNDraws.map(draw => {
                    const oddCount = draw.redBalls.filter(n => parseInt(n) % 2 === 1).length;
                    return oddCount;
                });

                const oddEvenImbalanceCount = oddEvenCounts.filter(count => count >= 5 || count <= 1).length;
                if (oddEvenImbalanceCount >= this.rules.combinationLevel.oddEvenImbalance.threshold) {
                    alerts.push({
                        type: 'combination',
                        level: this.rules.combinationLevel.oddEvenImbalance.level,
                        category: '组合级',
                        name: this.rules.combinationLevel.oddEvenImbalance.name,
                        description: `奇偶比：连续${this.rules.combinationLevel.oddEvenImbalance.threshold}期${oddEvenCounts[oddEvenCounts.length - 1]}:${6 - oddEvenCounts[oddEvenCounts.length - 1]}，${oddEvenCounts[oddEvenCounts.length - 1] >= 5 ? '奇数' : '偶数'}过热`,
                        value: oddEvenImbalanceCount,
                        threshold: this.rules.combinationLevel.oddEvenImbalance.threshold,
                        timestamp: new Date().toISOString()
                    });
                }

                const bigSmallCounts = lastNDraws.map(draw => {
                    const lotteryType = currentLotteryType;
                    const rules = LOTTERY_RULES[lotteryType];
                    const boundary = lotteryType === 'ssq' ? 16 : 17;
                    const bigCount = draw.redBalls.filter(n => parseInt(n) > boundary).length;
                    return bigCount;
                });

                const bigSmallImbalanceCount = bigSmallCounts.filter(count => count >= 5 || count <= 1).length;
                if (bigSmallImbalanceCount >= this.rules.combinationLevel.bigSmallImbalance.threshold) {
                    alerts.push({
                        type: 'combination',
                        level: this.rules.combinationLevel.bigSmallImbalance.level,
                        category: '组合级',
                        name: this.rules.combinationLevel.bigSmallImbalance.name,
                        description: `大小比：连续${this.rules.combinationLevel.bigSmallImbalance.threshold}期${bigSmallCounts[bigSmallCounts.length - 1]}:${6 - bigSmallCounts[bigSmallCounts.length - 1]}，${bigSmallCounts[bigSmallCounts.length - 1] >= 5 ? '大号' : '小号'}过热`,
                        value: bigSmallImbalanceCount,
                        threshold: this.rules.combinationLevel.bigSmallImbalance.threshold,
                        timestamp: new Date().toISOString()
                    });
                }

                const zoneCounts = lastNDraws.map(draw => {
                    const zone1 = draw.redBalls.filter(n => parseInt(n) <= 11).length;
                    const zone2 = draw.redBalls.filter(n => parseInt(n) >= 12 && parseInt(n) <= 22).length;
                    const zone3 = draw.redBalls.filter(n => parseInt(n) >= 23).length;
                    return { zone1, zone2, zone3 };
                });

                const zone1EmptyCount = zoneCounts.filter(z => z.zone1 === 0).length;
                const zone2EmptyCount = zoneCounts.filter(z => z.zone2 === 0).length;
                const zone3EmptyCount = zoneCounts.filter(z => z.zone3 === 0).length;

                if (zone1EmptyCount >= this.rules.combinationLevel.zoneImbalance.threshold) {
                    alerts.push({
                        type: 'combination',
                        level: this.rules.combinationLevel.zoneImbalance.level,
                        category: '组合级',
                        name: this.rules.combinationLevel.zoneImbalance.name,
                        description: `一区：连续${zone1EmptyCount}期空开，概率回升`,
                        value: zone1EmptyCount,
                        threshold: this.rules.combinationLevel.zoneImbalance.threshold,
                        timestamp: new Date().toISOString()
                    });
                }

                if (zone2EmptyCount >= this.rules.combinationLevel.zoneImbalance.threshold) {
                    alerts.push({
                        type: 'combination',
                        level: this.rules.combinationLevel.zoneImbalance.level,
                        category: '组合级',
                        name: this.rules.combinationLevel.zoneImbalance.name,
                        description: `二区：连续${zone2EmptyCount}期空开，概率回升`,
                        value: zone2EmptyCount,
                        threshold: this.rules.combinationLevel.zoneImbalance.threshold,
                        timestamp: new Date().toISOString()
                    });
                }

                if (zone3EmptyCount >= this.rules.combinationLevel.zoneImbalance.threshold) {
                    alerts.push({
                        type: 'combination',
                        level: this.rules.combinationLevel.zoneImbalance.level,
                        category: '组合级',
                        name: this.rules.combinationLevel.zoneImbalance.name,
                        description: `大中小：连续${zone3EmptyCount}期空开，概率回升`,
                        value: zone3EmptyCount,
                        threshold: this.rules.combinationLevel.zoneImbalance.threshold,
                        timestamp: new Date().toISOString()
                    });
                }

                return alerts;
            }

            checkStatisticsLevelAlerts(allDraws, recentDraws) {
                const alerts = [];
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];

                const totalDraws = allDraws.length;
                const recentDrawsCount = recentDraws.length;

                const numberFrequency = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberFrequency[num] = 0;
                }

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberFrequency[ball] !== undefined) {
                            numberFrequency[ball]++;
                        }
                    });
                });

                const avgFrequency = (recentDrawsCount * 6) / redBallCount;

                Object.entries(numberFrequency).forEach(([num, count]) => {
                    if (count >= avgFrequency * this.rules.statisticsLevel.frequencyAbnormal.threshold) {
                        alerts.push({
                            type: 'statistics',
                            level: this.rules.statisticsLevel.frequencyAbnormal.level,
                            category: '统计级',
                            name: this.rules.statisticsLevel.frequencyAbnormal.name,
                            description: `号码${num}：近${recentDrawsCount}期出现${count}次，超过平均频率${avgFrequency.toFixed(1)}次的${this.rules.statisticsLevel.frequencyAbnormal.threshold}倍`,
                            number: num,
                            value: count,
                            threshold: avgFrequency * this.rules.statisticsLevel.frequencyAbnormal.threshold,
                            timestamp: new Date().toISOString()
                        });
                    }
                });

                return alerts;
            }

            calculateNumberStats(draws, redBallCount) {
                const stats = {};
                const omissionHistory = {};

                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    stats[num] = {
                        count: 0,
                        omission: 0,
                        maxOmission: 0,
                        avgOmission: 0,
                        consecutiveCount: 0,
                        omissionHistory: []
                    };
                    omissionHistory[num] = [];
                }

                let currentOmission = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    currentOmission[num] = 0;
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (stats[ball]) {
                            stats[ball].count++;
                            if (currentOmission[ball] > stats[ball].maxOmission) {
                                stats[ball].maxOmission = currentOmission[ball];
                            }
                            omissionHistory[ball].push(currentOmission[ball]);
                            currentOmission[ball] = 0;
                            stats[ball].consecutiveCount = 0;
                        }
                    });
                    Object.keys(stats).forEach(num => {
                        if (!draw.redBalls.includes(num)) {
                            currentOmission[num]++;
                            stats[num].consecutiveCount++;
                        }
                    });
                });

                Object.keys(stats).forEach(num => {
                    stats[num].omission = currentOmission[num];
                    const omissionSum = omissionHistory[num].reduce((a, b) => a + b, 0);
                    stats[num].avgOmission = omissionHistory[num].length > 0 ? omissionSum / omissionHistory[num].length : 0;
                });

                return stats;
            }

            filterAndSortAlerts(alerts) {
                const levelPriority = { high: 3, medium: 2, low: 1 };
                alerts.sort((a, b) => {
                    if (levelPriority[b.level] !== levelPriority[a.level]) {
                        return levelPriority[b.level] - levelPriority[a.level];
                    }
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });

                const seen = new Set();
                return alerts.filter(alert => {
                    const key = `${alert.type}-${alert.name}-${alert.number || ''}`;
                    if (seen.has(key)) {
                        return false;
                    }
                    seen.add(key);
                    return true;
                });
            }

            recordAlerts(alerts) {
                alerts.forEach(alert => {
                    this.alertHistory.push(alert);
                });
                this.saveAlertHistory();

                this.alertStats.total += alerts.length;
                this.saveAlertStats();
            }

            getAlertStats() {
                const today = new Date().toDateString();
                const todayAlerts = this.alertHistory.filter(alert => 
                    new Date(alert.timestamp).toDateString() === today
                );

                const unreadAlerts = this.alertHistory.filter(alert => !alert.read).length;

                return {
                    today: todayAlerts.length,
                    unread: unreadAlerts,
                    total: this.alertStats.total,
                    hitRate: this.alertStats.hitRate
                };
            }

            markAsRead(alertIds) {
                this.alertHistory.forEach(alert => {
                    if (alertIds.includes(alert.id)) {
                        alert.read = true;
                    }
                });
                this.saveAlertHistory();
            }

            clearOldAlerts(days = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);

                this.alertHistory = this.alertHistory.filter(alert => 
                    new Date(alert.timestamp) > cutoffDate
                );
                this.saveAlertHistory();
            }

            getAlertHistory(days = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);

                return this.alertHistory.filter(alert => 
                    new Date(alert.timestamp) > cutoffDate
                ).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }

            getAlertsByCategory(category, days = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);

                return this.alertHistory.filter(alert => 
                    alert.category === category && new Date(alert.timestamp) > cutoffDate
                ).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }

            getAlertsByLevel(level, days = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);

                return this.alertHistory.filter(alert => 
                    alert.level === level && new Date(alert.timestamp) > cutoffDate
                ).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }

            analyzeAlertEffectiveness(draws, days = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);

                const recentAlerts = this.alertHistory.filter(alert => 
                    new Date(alert.timestamp) > cutoffDate
                );

                if (recentAlerts.length === 0) {
                    return {
                        totalAlerts: 0,
                        hitCount: 0,
                        missCount: 0,
                        hitRate: 0,
                        categoryStats: {},
                        levelStats: {}
                    };
                }

                const categoryStats = {};
                const levelStats = {};
                let hitCount = 0;
                let missCount = 0;

                recentAlerts.forEach(alert => {
                    if (!categoryStats[alert.category]) {
                        categoryStats[alert.category] = { total: 0, hit: 0, miss: 0 };
                    }
                    if (!levelStats[alert.level]) {
                        levelStats[alert.level] = { total: 0, hit: 0, miss: 0 };
                    }

                    categoryStats[alert.category].total++;
                    levelStats[alert.level].total++;

                    const hit = this.checkAlertHit(alert, draws);
                    if (hit) {
                        hitCount++;
                        categoryStats[alert.category].hit++;
                        levelStats[alert.level].hit++;
                    } else {
                        missCount++;
                        categoryStats[alert.category].miss++;
                        levelStats[alert.level].miss++;
                    }
                });

                const hitRate = recentAlerts.length > 0 ? (hitCount / recentAlerts.length * 100) : 0;

                Object.keys(categoryStats).forEach(category => {
                    categoryStats[category].hitRate = categoryStats[category].total > 0 
                        ? (categoryStats[category].hit / categoryStats[category].total * 100) 
                        : 0;
                });

                Object.keys(levelStats).forEach(level => {
                    levelStats[level].hitRate = levelStats[level].total > 0 
                        ? (levelStats[level].hit / levelStats[level].total * 100) 
                        : 0;
                });

                this.alertStats.hit = hitCount;
                this.alertStats.miss = missCount;
                this.alertStats.hitRate = hitRate;
                this.saveAlertStats();

                return {
                    totalAlerts: recentAlerts.length,
                    hitCount: hitCount,
                    missCount: missCount,
                    hitRate: hitRate,
                    categoryStats: categoryStats,
                    levelStats: levelStats
                };
            }

            checkAlertHit(alert, draws) {
                if (!alert.number) {
                    return false;
                }

                const alertTime = new Date(alert.timestamp);
                const nextDraw = draws.find(draw => new Date(draw.timestamp || draw.date) > alertTime);

                if (!nextDraw) {
                    return false;
                }

                return nextDraw.redBalls.includes(alert.number);
            }

            getAlertTrend(days = 30) {
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);

                const recentAlerts = this.alertHistory.filter(alert => 
                    new Date(alert.timestamp) > cutoffDate
                );

                const dailyAlerts = {};
                recentAlerts.forEach(alert => {
                    const date = new Date(alert.timestamp).toDateString();
                    if (!dailyAlerts[date]) {
                        dailyAlerts[date] = 0;
                    }
                    dailyAlerts[date]++;
                });

                const sortedDates = Object.keys(dailyAlerts).sort();
                const trendData = sortedDates.map(date => ({
                    date: date,
                    count: dailyAlerts[date]
                }));

                const avgDailyAlerts = sortedDates.length > 0 
                    ? recentAlerts.length / sortedDates.length 
                    : 0;

                return {
                    trendData: trendData,
                    avgDailyAlerts: avgDailyAlerts,
                    maxDailyAlerts: Math.max(...Object.values(dailyAlerts), 0),
                    minDailyAlerts: Math.min(...Object.values(dailyAlerts), 0)
                };
            }

            exportAlertHistory(days = 30) {
                const alerts = this.getAlertHistory(days);

                const csvContent = [
                    ['时间', '类别', '类型', '级别', '号码', '描述', '已读'].join(','),
                    ...alerts.map(alert => [
                        new Date(alert.timestamp).toLocaleString('zh-CN'),
                        alert.category,
                        alert.name,
                        alert.level,
                        alert.number || '',
                        alert.description,
                        alert.read ? '是' : '否'
                    ].join(','))
                ].join('\n');

                const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);

                link.setAttribute('href', url);
                link.setAttribute('download', `预警历史_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            startMonitoring(draws, frequency = 30000) {
                try {
                    if (this.isMonitoring) {
                        this.stopMonitoring();
                    }

                    if (!draws || !Array.isArray(draws) || draws.length < 10) {
                        throw new Error('开奖数据不足，无法启动监控');
                    }

                    this.isMonitoring = true;
                    this.monitoringFrequency = frequency;
                    this.lastMonitoringTime = new Date();
                    this.todayAlertCount = 0;

                    this.monitoringInterval = setInterval(() => {
                        this.performMonitoring(draws);
                    }, this.monitoringFrequency);

                    console.log('预警监控已启动，频率:', frequency / 1000, '秒');
                    MessageSystem.showMessage('预警监控已启动', 'success');
                    return true;
                } catch (error) {
                    console.error('启动监控时出错:', error);
                    MessageSystem.showMessage(`启动监控失败: ${error.message}`, 'error');
                    return false;
                }
            }

            stopMonitoring() {
                try {
                    if (this.monitoringInterval) {
                        clearInterval(this.monitoringInterval);
                        this.monitoringInterval = null;
                    }

                    this.isMonitoring = false;
                    console.log('预警监控已停止');
                    MessageSystem.showMessage('预警监控已停止', 'info');
                } catch (error) {
                    console.error('停止监控时出错:', error);
                }
            }

            performMonitoring(draws) {
                try {
                    if (!this.isMonitoring) {
                        return;
                    }

                    const newAlerts = this.analyze(draws);
                    const uniqueAlerts = this.filterNewAlerts(newAlerts);

                    if (uniqueAlerts.length > 0) {
                        this.currentAlerts = [...uniqueAlerts, ...this.currentAlerts];
                        this.unreadAlerts = [...uniqueAlerts, ...this.unreadAlerts];
                        this.todayAlertCount += uniqueAlerts.length;

                        this.notifyAlertListeners(uniqueAlerts);
                        this.displayAlerts(uniqueAlerts);
                    }

                    this.lastMonitoringTime = new Date();
                } catch (error) {
                    console.error('执行监控时出错:', error);
                }
            }

            filterNewAlerts(newAlerts) {
                const existingKeys = this.currentAlerts.map(alert => 
                    `${alert.type}-${alert.name}-${alert.number || ''}`
                );

                return newAlerts.filter(alert => {
                    const key = `${alert.type}-${alert.name}-${alert.number || ''}`;
                    return !existingKeys.includes(key);
                });
            }

            addAlertListener(callback) {
                if (typeof callback === 'function' && !this.alertListeners.includes(callback)) {
                    this.alertListeners.push(callback);
                }
            }

            removeAlertListener(callback) {
                const index = this.alertListeners.indexOf(callback);
                if (index > -1) {
                    this.alertListeners.splice(index, 1);
                }
            }

            notifyAlertListeners(alerts) {
                this.alertListeners.forEach(callback => {
                    try {
                        callback(alerts);
                    } catch (error) {
                        console.error('执行预警监听器时出错:', error);
                    }
                });
            }

            displayAlerts(alerts) {
                alerts.forEach(alert => {
                    const levelDef = AlertRuleConfig.getLevelDefinition(alert.level);
                    const message = `${levelDef.icon} ${alert.category} - ${alert.name}: ${alert.description}`;

                    if (levelDef.sound) {
                        this.playAlertSound();
                    }

                    MessageSystem.showMessage(message, alert.level);
                });
            }

            playAlertSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.1;

                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (error) {
                    console.error('播放预警声音时出错:', error);
                }
            }

            getMonitoringStatus() {
                return {
                    isMonitoring: this.isMonitoring,
                    lastUpdateTime: this.lastMonitoringTime,
                    todayAlertCount: this.todayAlertCount,
                    unreadAlertCount: this.unreadAlerts.length,
                    currentAlertCount: this.currentAlerts.length,
                    monitoringFrequency: this.monitoringFrequency
                };
            }

            markAlertAsRead(alertId) {
                const index = this.unreadAlerts.findIndex(alert => alert.id === alertId);
                if (index > -1) {
                    this.unreadAlerts.splice(index, 1);
                }
            }

            markAllAlertsAsRead() {
                this.unreadAlerts = [];
            }

            getUnreadAlerts() {
                return this.unreadAlerts;
            }

            getCurrentAlerts() {
                return this.currentAlerts;
            }

            setMonitoringFrequency(frequency) {
                if (frequency < 10000) {
                    throw new Error('监控频率不能小于10秒');
                }

                this.monitoringFrequency = frequency;

                if (this.isMonitoring) {
                    this.stopMonitoring();
                    this.startMonitoring(this.getCurrentDraws(), frequency);
                }

                MessageSystem.showMessage(`监控频率已设置为${frequency / 1000}秒`, 'success');
            }

            getCurrentDraws() {
                return window.currentDraws || [];
            }

            updateHitStats(hits, total) {
                this.hitStats.total += total;
                this.hitStats.hit += hits;
                this.hitStats.miss += (total - hits);
                this.saveHitStats();
            }

            saveHitStats() {
                try {
                    localStorage.setItem('alertHitStats', JSON.stringify(this.hitStats));
                } catch (error) {
                    console.error('保存命中统计时出错:', error);
                }
            }

            loadHitStats() {
                try {
                    const saved = localStorage.getItem('alertHitStats');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                    return { total: 0, hit: 0, miss: 0 };
                } catch (error) {
                    console.error('加载命中统计时出错:', error);
                    return { total: 0, hit: 0, miss: 0 };
                }
            }

            getHitRate() {
                if (this.hitStats.total === 0) {
                    return 0;
                }
                return ((this.hitStats.hit / this.hitStats.total) * 100).toFixed(2);
            }

            exportAlertHistory(format = 'json') {
                try {
                    const history = this.alertHistory;
                    if (history.length === 0) {
                        MessageSystem.showMessage('没有可导出的预警历史', 'info');
                        return false;
                    }

                    const timestamp = new Date().toISOString();
                    let content, filename, mimeType;

                    if (format === 'json') {
                        content = JSON.stringify({ timestamp, history }, null, 2);
                        filename = `alert_history_${timestamp}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        const headers = ['时间', '类型', '级别', '类别', '名称', '描述', '号码'];
                        const rows = history.map(alert => [
                            new Date(alert.timestamp).toLocaleString(),
                            alert.type,
                            alert.level,
                            alert.category,
                            alert.name,
                            alert.description,
                            alert.number || ''
                        ].join(','));
                        content = [headers.join(','), ...rows].join('\n');
                        filename = `alert_history_${timestamp}.csv`;
                        mimeType = 'text/csv';
                    } else {
                        throw new Error('不支持的导出格式');
                    }

                    this.downloadFile(content, filename, mimeType);
                    MessageSystem.showMessage(`预警历史已导出为${filename}`, 'success');
                    return true;
                } catch (error) {
                    console.error('导出预警历史时出错:', error);
                    MessageSystem.showMessage(`导出失败: ${error.message}`, 'error');
                    return false;
                }
            }

            downloadFile(content, filename, mimeType) {
                try {
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('下载文件时出错:', error);
                    throw new Error('下载文件失败');
                }
            }
        }

        // 全局事件委托管理器
        class EventDelegate {
            static nineRingInstances = {};

            // 公共函数：获取分析期数
            static getAnalysisPeriodCount(selectorId, defaultCount = 100) {
                const periodSelect = document.getElementById(selectorId);
                if (periodSelect) {
                    const selectedValue = periodSelect.value;
                    if (selectedValue === 'all') {
                        return currentDatabaseData.draws.length;
                    } else {
                        return parseInt(selectedValue);
                    }
                } else {
                    return defaultCount;
                }
            }

            // 公共函数：获取分析数据
            static getAnalysisData(draws, periodCount) {
                return draws.slice(-periodCount);
            }

            // 公共函数：更新期数范围显示
            static updatePeriodRangeDisplay(elementId, analysisDraws) {
                const periodRange = document.getElementById(elementId);
                if (periodRange) {
                    const startPeriod = analysisDraws[0].period;
                    const endPeriod = analysisDraws[analysisDraws.length - 1].period;
                    periodRange.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisDraws.length}期）`;
                }
            }

            static init() {
                // 顶部菜单点击事件
                document.addEventListener('click', (e) => {
                    // 处理顶部菜单项点击
                    if (e.target.classList.contains('menu-item') || e.target.closest('.menu-item')) {
                        const menuItem = e.target.classList.contains('menu-item') ? e.target : e.target.closest('.menu-item');
                        EventDelegate.handleTopMenuClick(menuItem);
                    }

                    // 处理侧边栏菜单项点击
                    if (e.target.closest('.sidebar-menu li')) {
                        EventDelegate.handleSidebarMenuClick(e.target.closest('.sidebar-menu li'));
                    }

                    // 处理彩票类型切换按钮
                    if (e.target.id === 'ssqBtn' || e.target.id === 'dltBtn' || e.target.id === 'otherBtn') {
                        EventDelegate.handleLotteryTypeChange(e.target);
                    }

                    // 处理设置按钮
                    if (e.target.id === 'settingsBtn') {
                        EventDelegate.handleSettingsClick();
                    }

                    // 处理设置弹窗相关按钮
                    if (e.target.id === 'closeSettings' || e.target.id === 'cancelSettings') {
                        EventDelegate.handleCloseSettings();
                    }

                    if (e.target.id === 'saveSettings') {
                        EventDelegate.handleSaveSettings();
                    }

                            // 处理操作按钮
                    if (e.target.id === 'exportData' || 
                        e.target.id === 'switchChart' || e.target.id === 'generateReport' || e.target.id === 'exportChart') {
                        EventDelegate.handleActionClick(e.target);
                    }

                    // 处理数据库管理按钮
                    if (e.target.id === 'importExcelBtn' || e.target.id === 'addManualBtn' || 
                        e.target.id === 'selectAllBtn' || e.target.id === 'deleteSelectedBtn' ||
                        e.target.id === 'clearDatabaseBtn' || e.target.id === 'confirmAddBtn' || 
                        e.target.id === 'cancelAddBtn') {
                        EventDelegate.handleDatabaseAction(e.target);
                    }

                    // 处理号码库按钮
                    if (e.target.id === 'selectAllLibraryBtn' || e.target.id === 'deleteLibraryBtn') {
                        EventDelegate.handleLibraryAction(e.target);
                    }

                    // 处理号码分布按钮
                    if (e.target.id === 'analyzeDistribution' || e.target.id === 'exportDistributionChart') {
                        EventDelegate.handleDistributionAction(e.target);
                    }

                    // 处理分布标签页
                    if (e.target.classList.contains('distribution-tab')) {
                        EventDelegate.handleDistributionTab(e.target);
                    }

                    // 处理冷热分析标签页
                    if (e.target.classList.contains('hotcold-tab')) {
                        EventDelegate.handleHotColdTab(e.target);
                    }

                    // 处理冷热分析刷新按钮
                    if (e.target.id === 'refreshHotColdAnalysis') {
                        EventDelegate.handleRefreshHotColdAnalysis(e.target);
                    }

                    // 处理全选复选框
                    if (e.target.id === 'selectAllCheckbox') {
                        EventDelegate.handleSelectAll(e.target);
                    }

                    // 处理分页按钮
                    if (e.target.id === 'firstPageBtn' || e.target.id === 'prevPageBtn' || 
                        e.target.id === 'nextPageBtn' || e.target.id === 'lastPageBtn' || 
                        e.target.id === 'goPageBtn') {
                        EventDelegate.handlePagination(e.target);
                    }

                    // 注意：文件输入的处理现在通过change事件处理，避免重复处理
                    // 如果需要其他处理逻辑，可以在这里添加
                });

                // 处理面包屑导航点击
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('breadcrumb-item')) {
                        EventDelegate.handleBreadcrumbClick(e.target);
                    }
                });

                // 处理每页显示条数变化
                const pageSizeSelect = document.getElementById('pageSizeSelect');
                if (pageSizeSelect) {
                    pageSizeSelect.addEventListener('change', (e) => {
                        EventDelegate.handlePageSizeChange(e.target);
                    });
                }
            }

            static handleTopMenuClick(menuItem) {
                if (!menuItem) {

                    return;
                }

                const page = menuItem.getAttribute('data-page');
                const lottery = menuItem.getAttribute('data-lottery');

                // 移除所有活动状态
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });

                // 为当前点击项添加活动状态
                menuItem.classList.add('active');

                // 根据页面类型执行相应操作
                switch(page) {
                    case 'ssq-tab':
                    case 'dlt-tab':
                        dataManager.switchLotteryType(lottery);
                        break;
                    case 'ssq-database':
                    case 'dlt-database':
                        // 只切换显示数据库管理界面，不改变彩票类型
                        const dbLotteryType = page === 'ssq-database' ? 'ssq' : 'dlt';

                        // 显示数据库卡片，隐藏其他内容卡片
                        document.getElementById('databaseCard').style.display = 'block';

                        // 隐藏其他内容卡片
                        const topMenuOtherCards = document.querySelectorAll('.content-card:not(#databaseCard)');
                        topMenuOtherCards.forEach(card => {
                            card.style.display = 'none';
                        });

                        // 更新面包屑导航
                        const breadcrumbContainer = document.querySelector('.breadcrumb');
                        if (breadcrumbContainer) {
                            // 清空面包屑并重新构建
                            breadcrumbContainer.innerHTML = `
                                <div class="breadcrumb-item" data-page="home">首页</div>
                                <div class="breadcrumb-item" data-page="data-management">数据管理</div>
                                <div class="breadcrumb-item active">${menuItem.textContent}</div>
                            `;
                        }

                        // 更新数据库表格数据，传入数据库类型（updateDatabaseTable内部会恢复该彩票类型的状态）
                        dataManager.updateDatabaseTable(dbLotteryType);

                        MessageSystem.showMessage(`查看${menuItem.textContent}`, 'info');
                        break;
                    case 'export':
                        MessageSystem.showMessage('开始导出数据...', 'info');
                        break;
                    case 'refresh':
                        location.reload();
                        break;
                    case 'prize-level':
                        this.handlePrizeLevelClick();
                        break;
                    case 'settings':
                        this.handleSettingsClick();
                        break;
                    default:
                        // 隐藏数据库卡片，显示其他内容卡片
                        if (document.getElementById('databaseCard')) {
                            document.getElementById('databaseCard').style.display = 'none';
                        }

                        // 隐藏频率分析、遗漏分析、号码分布卡片
                        const analysisCards = ['frequencyCard', 'omissionCard', 'numberDistributionCard'];
                        analysisCards.forEach(cardId => {
                            const card = document.getElementById(cardId);
                            if (card) {
                                card.style.display = 'none';
                            }
                        });

                        // 显示欢迎卡片
                        const welcomeCard = document.getElementById('welcomeCard');
                        if (welcomeCard) {
                            welcomeCard.style.display = 'block';
                        }

                        MessageSystem.showMessage(`切换到${menuItem.textContent}`, 'info');
                        break;
                }
            }

            static handleSidebarMenuClick(menuItem) {
                if (!menuItem) {

                    return;
                }

                // 移除所有活动状态
                document.querySelectorAll('.sidebar-menu li').forEach(item => {
                    item.classList.remove('active');
                });

                // 为当前点击项添加活动状态
                menuItem.classList.add('active');

                const submenu = menuItem.getAttribute('data-submenu');

                // 根据子菜单类型执行相应操作
                const breadcrumbItems = document.querySelectorAll('.breadcrumb-item');

                switch(submenu) {
                    case 'selection-system': // 选号系统
                        // 隐藏其他内容卡片，显示选号系统
                        const allCards = document.querySelectorAll('.content-card');
                        allCards.forEach(card => {
                            card.style.display = 'none';
                        });

                        // 显示选号系统容器
                        const selectionSystemContainer = document.getElementById('selectionSystemContainer');
                        if (selectionSystemContainer) {
                            selectionSystemContainer.style.display = 'block';

                            // 初始化选号系统
                            EventDelegate.initSelectionSystem();
                        }

                        // 更新面包屑
                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');
                        break;
                    case 'jiuzhuan': // 九转连环图
                        // 隐藏其他内容卡片，显示九转连环图
                        const allCardsForJiuzhuan = document.querySelectorAll('.content-card');
                        allCardsForJiuzhuan.forEach(card => {
                            card.style.display = 'none';
                        });

                        // 创建九转连环图内容区域
                        let jiuzhuanContainer = document.getElementById('jiuzhuanContainer');
                        if (!jiuzhuanContainer) {
                            // 创建九转连环图容器
                            jiuzhuanContainer = document.createElement('div');
                            jiuzhuanContainer.id = 'jiuzhuanContainer';
                            jiuzhuanContainer.className = 'content-card';
                            jiuzhuanContainer.style.display = 'block';

                            // 添加九转连环图的完整HTML内容
                            jiuzhuanContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-sync-alt"></i> 九转连环图</h2>
                                    <div class="content-actions">
                                        <button class="btn btn-secondary" onclick="EventDelegate.refreshJiuzhuan()">刷新图表</button>
                                    </div>
                                </div>
                                <div class="jiuzhuan-content">
                                  <div class="card-container">
                                    <div class="canvas-card" id="card-1">
                                      <h1 class="canvas-title">衡十七</h1>
                                      <canvas id="circles-svg-1" width="560" height="560"></canvas>
                                    </div>
                                    <div class="canvas-card" id="card-2">
                                      <h1 class="canvas-title">九为尊</h1>
                                      <canvas id="circles-svg-2" width="560" height="560"></canvas>
                                    </div>
                                    <div class="canvas-card" id="card-3">
                                      <h1 class="canvas-title">三十三</h1>
                                      <canvas id="circles-svg-3" width="560" height="560"></canvas>
                                    </div>
                                  </div>
                                </div>
                            `;

                            // 添加九转连环图的样式 - 使用特定ID选择器避免冲突
                            const style = document.createElement('style');
                            style.id = 'jiuzhuan-style';
                            style.textContent = `
                                #jiuzhuanContainer {
                                    width: 100%;
                                    height: calc(100vh - 200px);
                                    box-sizing: border-box;
                                    background: #fff !important;
                                    border: none !important;
                                    box-shadow: none !important;
                                    padding: 0 !important;
                                    margin: 0 !important;
                                    overflow: hidden;
                                    display: flex;
                                    flex-direction: column;
                                }
                                
                                #jiuzhuanContainer .content-header {
                                    flex-shrink: 0;
                                    padding: 10px 20px;
                                    margin: 0;
                                }
                                
                                #jiuzhuanContainer .jiuzhuan-content {
                                    flex: 1;
                                    padding: 0;
                                    overflow: hidden;
                                    width: 100%;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    background: #fff !important;
                                    border: none !important;
                                    box-shadow: none !important;
                                }

                                #jiuzhuanContainer .card-container {
                                  display: flex;
                                  justify-content: center;
                                  align-items: center;
                                  gap: 20px;
                                  padding: 0;
                                  flex-wrap: nowrap;
                                  width: fit-content;
                                  box-sizing: border-box;
                                  background: transparent !important;
                                  border: none !important;
                                  box-shadow: none !important;
                                }

                                #jiuzhuanContainer .canvas-card {
                                  display: flex;
                                  flex-direction: column;
                                  align-items: center;
                                  gap: 10px;
                                  width: 560px;
                                  height: 640px;
                                  flex-shrink: 0;
                                  box-sizing: border-box;
                                  background: transparent !important;
                                  border: none !important;
                                  box-shadow: none !important;
                                  margin: 0;
                                  padding: 0;
                                }

                                #jiuzhuanContainer .canvas-title {
                                  font-size: 48px;
                                  font-weight: bold;
                                  color: #333;
                                  margin: 0;
                                  padding: 5px 0;
                                  text-align: center;
                                  font-family: Arial, sans-serif;
                                  line-height: 1.2;
                                }

                                #jiuzhuanContainer canvas {
                                  border: 1px solid #ccc;
                                  display: block;
                                  width: 560px;
                                  height: 560px;
                                }
                            `;
                            document.head.appendChild(style);

                            // 将九转连环图容器添加到内容区域
                            document.querySelector('.content-area').appendChild(jiuzhuanContainer);
                        }

                        // 显示容器
                        jiuzhuanContainer.style.display = 'block';

                        // 更新面包屑
                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');

                        // 初始化九转连环图，确保DOM元素已渲染
                        requestAnimationFrame(() => {
                            EventDelegate.initJiuzhuanChart('data-management-jiuzhuan');
                        });
                        break;
                    case 'data-management': // 数据库管理
                        document.getElementById('databaseCard').style.display = 'block';

                        const sidebarOtherCards = document.querySelectorAll('.content-card:not(#databaseCard)');
                        sidebarOtherCards.forEach(card => {
                            card.style.display = 'none';
                        });

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');
                        break;
                    case 'dna-query': // DNA查询
                        const allCardsForDNA = document.querySelectorAll('.content-card');
                        allCardsForDNA.forEach(card => {
                            card.style.display = 'none';
                        });

                        const dnaQueryContainer = document.getElementById('dnaQueryContainer');
                        if (dnaQueryContainer) {
                            dnaQueryContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        EventDelegate.initDNAQuery();
                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');
                        break;
                    case 'data-filter':
                        const allCardsForDataFilter = document.querySelectorAll('.content-card');
                        allCardsForDataFilter.forEach(card => {
                            card.style.display = 'none';
                        });

                        const featureContainerForDataFilter = document.getElementById('featureContainer');
                        if (featureContainerForDataFilter) {
                            featureContainerForDataFilter.style.display = 'block';
                            featureContainerForDataFilter.querySelector('.content-title').innerHTML = '<i class="fas fa-search"></i> 数据过滤';
                            featureContainerForDataFilter.querySelector('h3').textContent = '数据过滤功能开发中';
                        } else {
                            const newFeatureContainer = document.createElement('div');
                            newFeatureContainer.id = 'featureContainer';
                            newFeatureContainer.className = 'content-card';
                            newFeatureContainer.style.display = 'block';
                            newFeatureContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-search"></i> 数据过滤</h2>
                                </div>
                                <div class="content-body" style="padding: 60px; text-align: center;">
                                    <i class="fas fa-search" style="font-size: 60px; color: #6c757d; margin-bottom: 20px;"></i>
                                    <h3 style="color: #333; margin-bottom: 15px;">数据过滤功能开发中</h3>
                                    <p style="color: #666; font-size: 16px; line-height: 1.8;">
                                        该功能正在开发中，敬请期待！<br>
                                        我们将为您提供更强大的数据过滤工具。
                                    </p>
                                    <div style="margin-top: 30px;">
                                        <button class="btn btn-primary" onclick="EventDelegate.handleBackToHome()">返回首页</button>
                                    </div>
                                </div>
                            `;
                            document.querySelector('.content-area').appendChild(newFeatureContainer);
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');
                        break;
                    case 'frequency': {
                        const allCardsForFilter = document.querySelectorAll('.content-card');
                        allCardsForFilter.forEach(card => {
                            card.style.display = 'none';
                        });

                        const frequencyCard = document.getElementById('frequencyCard');
                        if (frequencyCard) {
                            frequencyCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '频率分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const charts = ['frequencyChart', 'frequencyTrendChart'];
                                charts.forEach(chartId => {
                                    const chartDom = document.getElementById(chartId);
                                    if (chartDom) {
                                        const chartInstance = echarts.getInstanceByDom(chartDom);
                                        if (chartInstance) {
                                            chartInstance.resize();
                                        }
                                    }
                                });
                            }
                        }, 100);
                        break;
                    }
                    case 'omission':
                        const allCardsForOmission = document.querySelectorAll('.content-card');
                        allCardsForOmission.forEach(card => {
                            card.style.display = 'none';
                        });

                        const omissionCard = document.getElementById('omissionCard');
                        if (omissionCard) {
                            omissionCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const chartDom = document.getElementById('omissionChart');
                                if (chartDom) {
                                    const chartInstance = echarts.getInstanceByDom(chartDom);
                                    if (chartInstance) {
                                        chartInstance.resize();
                                    }
                                }
                            }
                            EventDelegate.performOmissionAnalysis();
                        }, 100);
                        break;
                    case 'number-distribution':
                        const allCardsForDistribution = document.querySelectorAll('.content-card');
                        allCardsForDistribution.forEach(card => {
                            card.style.display = 'none';
                        });

                        const numberDistributionCard = document.getElementById('numberDistributionCard');
                        if (numberDistributionCard) {
                            numberDistributionCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = menuItem.querySelector('span').textContent;
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage(`打开${menuItem.querySelector('span').textContent}`, 'info');

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const chartDom = document.getElementById('numberDistributionChart');
                                if (chartDom) {
                                    const chartInstance = echarts.getInstanceByDom(chartDom);
                                    if (chartInstance) {
                                        chartInstance.resize();
                                    }
                                }
                            }
                        }, 100);
                        break;
                    case 'hot-cold':
                        const allCardsForHotCold = document.querySelectorAll('.content-card');
                        allCardsForHotCold.forEach(card => {
                            card.style.display = 'none';
                        });

                        const hotColdCard = document.getElementById('hotColdCard');
                        if (hotColdCard) {
                            hotColdCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '冷热分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        EventDelegate.handleHotColdAnalysis();

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const hotColdChartDom = document.getElementById('hotColdChart');
                                if (hotColdChartDom) {
                                    const hotColdChart = echarts.getInstanceByDom(hotColdChartDom);
                                    if (hotColdChart) hotColdChart.resize();
                                }
                                const hotColdTrendChartDom = document.getElementById('hotColdTrendChart');
                                if (hotColdTrendChartDom) {
                                    const hotColdTrendChart = echarts.getInstanceByDom(hotColdTrendChartDom);
                                    if (hotColdTrendChart) hotColdTrendChart.resize();
                                }
                            }
                        }, 100);

                        MessageSystem.showMessage('打开冷热分析', 'info');
                        break;
                    case 'odd-even':
                        const allCardsForOddEven = document.querySelectorAll('.content-card');
                        allCardsForOddEven.forEach(card => {
                            card.style.display = 'none';
                        });

                        const oddEvenCard = document.getElementById('oddEvenCard');
                        if (oddEvenCard) {
                            oddEvenCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '奇偶分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const charts = ['oddSingleChart', 'oddRatioPieChart', 'oddRatioBarChart', 'oddCrossChart', 'oddTrendChart'];
                                charts.forEach(chartId => {
                                    const chartDom = document.getElementById(chartId);
                                    if (chartDom) {
                                        const chartInstance = echarts.getInstanceByDom(chartDom);
                                        if (chartInstance) {
                                            chartInstance.resize();
                                        }
                                    }
                                });
                            }
                        }, 100);

                        MessageSystem.showMessage('打开奇偶分析', 'info');
                        break;
                    case 'big-small':
                        const allCardsForBigSmall = document.querySelectorAll('.content-card');
                        allCardsForBigSmall.forEach(card => {
                            card.style.display = 'none';
                        });

                        const bigSmallCard = document.getElementById('bigSmallCard');
                        if (bigSmallCard) {
                            bigSmallCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '大小分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const charts = ['bigSmallPieChart', 'bigSmallTrendChart', 'bigSmallHeatmapChart', 'bigSmallStackedChart', 'bigSmallStatusChart'];
                                charts.forEach(chartId => {
                                    const chartDom = document.getElementById(chartId);
                                    if (chartDom) {
                                        const chartInstance = echarts.getInstanceByDom(chartDom);
                                        if (chartInstance) {
                                            chartInstance.resize();
                                        }
                                    }
                                });
                            }
                        }, 100);

                        MessageSystem.showMessage('打开大小分析', 'info');
                        break;
                    case 'prime-composite':
                        const allCardsForPrimeComposite = document.querySelectorAll('.content-card');
                        allCardsForPrimeComposite.forEach(card => {
                            card.style.display = 'none';
                        });

                        const primeCompositeCard = document.getElementById('primeCompositeCardV1');
                        if (primeCompositeCard) {
                            primeCompositeCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '质合分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const charts = ['primeCompositePieChart', 'primeCompositeTrendChart', 'primeCompositeCombinationChart', 'primeCompositeHeatmapChart', 'primeCompositeStackedChart'];
                                charts.forEach(chartId => {
                                    const chartDom = document.getElementById(chartId);
                                    if (chartDom) {
                                        const chartInstance = echarts.getInstanceByDom(chartDom);
                                        if (chartInstance) {
                                            chartInstance.resize();
                                        }
                                    }
                                });
                            }
                        }, 100);

                        MessageSystem.showMessage('打开质合分析', 'info');
                        break;
                    case 'ac-value':
                        const allCardsForAcValue = document.querySelectorAll('.content-card');
                        allCardsForAcValue.forEach(card => {
                            card.style.display = 'none';
                        });

                        const acValueCard = document.getElementById('acValueCard');
                        if (acValueCard) {
                            acValueCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = 'AC值分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const chartDom = document.getElementById('acValueChart');
                                if (chartDom) {
                                    const chartInstance = echarts.getInstanceByDom(chartDom);
                                    if (chartInstance) {
                                        chartInstance.resize();
                                    }
                                }
                            }
                        }, 100);

                        MessageSystem.showMessage('打开AC值分析', 'info');
                        break;
                    case 'three-zone':
                        const allCardsForThreeZone = document.querySelectorAll('.content-card');
                        allCardsForThreeZone.forEach(card => {
                            card.style.display = 'none';
                        });

                        const threeZoneCard = document.getElementById('threeZoneCard');
                        if (threeZoneCard) {
                            threeZoneCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '大中小分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const chartDom = document.getElementById('threeZoneChart');
                                if (chartDom) {
                                    const chartInstance = echarts.getInstanceByDom(chartDom);
                                    if (chartInstance) {
                                        chartInstance.resize();
                                    }
                                }
                            }
                        }, 100);

                        MessageSystem.showMessage('打开大中小分析', 'info');
                        break;
                    case 'follow-up':
                        const allCardsForFollowUp = document.querySelectorAll('.content-card');
                        allCardsForFollowUp.forEach(card => {
                            card.style.display = 'none';
                        });

                        const followUpCard = document.getElementById('followUpCard');
                        if (followUpCard) {
                            followUpCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '跟随分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const chartDom = document.getElementById('followUpChart');
                                if (chartDom) {
                                    const chartInstance = echarts.getInstanceByDom(chartDom);
                                    if (chartInstance) {
                                        chartInstance.resize();
                                    }
                                }
                            }
                        }, 100);

                        MessageSystem.showMessage('打开跟随分析', 'info');
                        break;
                    case 'trend': {
                        const allCardsForTrend = document.querySelectorAll('.content-card');
                        allCardsForTrend.forEach(card => {
                            card.style.display = 'none';
                        });

                        const trendCard = document.getElementById('trendCard');
                        if (trendCard) {
                            trendCard.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '趋势分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        setTimeout(() => {
                            if (typeof echarts !== 'undefined') {
                                const charts = ['sumTrendChart', 'spanTrendChart', 'oddEvenTrendChart', 'sameTailHeatmap'];
                                charts.forEach(chartId => {
                                    const chartDom = document.getElementById(chartId);
                                    if (chartDom) {
                                        const chartInstance = echarts.getInstanceByDom(chartDom);
                                        if (chartInstance) {
                                            chartInstance.resize();
                                        }
                                    }
                                });
                            }
                        }, 100);

                        EventDelegate.handleTrendAnalysis();

                        MessageSystem.showMessage('打开趋势分析', 'info');
                        break;
                    }
                    case 'correlation':
                        const allCardsForCorrelation = document.querySelectorAll('.content-card');
                        allCardsForCorrelation.forEach(card => {
                            card.style.display = 'none';
                        });

                        const correlationCard = document.getElementById('correlationCard');
                        if (correlationCard) {
                            correlationCard.style.display = 'block';

                            if (correlationHeatmapChart) {
                                correlationHeatmapChart.resize();
                            }
                            if (correlationScatterChart) {
                                correlationScatterChart.resize();
                            }
                            if (correlationNetworkChart) {
                                correlationNetworkChart.resize();
                            }
                        }

                        break;
                    case 'statistics':
                        const allCardsForStatistics = document.querySelectorAll('.content-card');
                        allCardsForStatistics.forEach(card => {
                            card.style.display = 'none';
                        });

                        const statisticsCard = document.getElementById('statisticsCard');
                        if (statisticsCard) {
                            statisticsCard.style.display = 'block';

                            if (statisticalTrendChart) {
                                statisticalTrendChart.resize();
                            }
                            if (statisticalDistributionChart) {
                                statisticalDistributionChart.resize();
                            }
                            if (statisticalComparisonChart) {
                                statisticalComparisonChart.resize();
                            }
                            if (statisticalHeatmapChart) {
                                statisticalHeatmapChart.resize();
                            }
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '统计分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开统计分析', 'info');
                        break;
                    case 'pattern':
                        const allCardsForPattern = document.querySelectorAll('.content-card');
                        allCardsForPattern.forEach(card => {
                            card.style.display = 'none';
                        });

                        const patternRecognitionCard = document.getElementById('patternRecognitionCard');
                        if (patternRecognitionCard) {
                            patternRecognitionCard.style.display = 'block';

                            if (patternSequenceChart) {
                                patternSequenceChart.resize();
                            }
                            if (patternPeriodicChart) {
                                patternPeriodicChart.resize();
                            }
                            if (patternMorphologyChart) {
                                patternMorphologyChart.resize();
                            }
                            if (patternRepetitionChart) {
                                patternRepetitionChart.resize();
                            }
                            if (patternJumpChart) {
                                patternJumpChart.resize();
                            }
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '模式识别';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开模式识别', 'info');
                        break;
                    case 'dna-analysis':
                        const allCardsForDNAAnalysis = document.querySelectorAll('.content-card');
                        allCardsForDNAAnalysis.forEach(card => {
                            card.style.display = 'none';
                        });

                        const dnaAnalysisCard = document.getElementById('dnaAnalysisCard');
                        if (dnaAnalysisCard) {
                            dnaAnalysisCard.style.display = 'block';

                            if (dnaSequenceChart) {
                                dnaSequenceChart.resize();
                            }
                            if (dnaEvolutionChart) {
                                dnaEvolutionChart.resize();
                            }
                            if (dnaMutationChart) {
                                dnaMutationChart.resize();
                            }
                            if (dnaDiversityChart) {
                                dnaDiversityChart.resize();
                            }
                            if (dnaMappingChart) {
                                dnaMappingChart.resize();
                            }
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = 'DNA分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开DNA分析', 'info');
                        break;
                    case 'recovery':
                        const allCardsForRecovery = document.querySelectorAll('.content-card');
                        allCardsForRecovery.forEach(card => {
                            card.style.display = 'none';
                        });

                        let recoveryContainer = document.getElementById('recoveryContainer');
                        if (!recoveryContainer) {
                            recoveryContainer = document.createElement('div');
                            recoveryContainer.id = 'recoveryContainer';
                            recoveryContainer.className = 'content-card';
                            recoveryContainer.style.display = 'block';

                            recoveryContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-undo"></i> 回补分析 <span id="recoveryDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="content-controls" style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
                                        <label for="recoveryPeriodSelect" style="margin: 0;">分析期数：</label>
                                        <select id="recoveryPeriodSelect" class="form-control" style="width: 120px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部期数</option>
                                        </select>
                                        <button id="startRecoveryAnalysis" class="btn btn-primary">
                                            <i class="fas fa-play"></i> 开始回补分析
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body">

                                    <div class="recovery-analysis-grid">
                                        <div class="recovery-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-clock"></i> 回补周期分析</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="recoveryCycleChart" style="height: 350px;"></div>
                                                <div id="recoveryCycleStats" class="stats-container"></div>
                                            </div>
                                        </div>

                                        <div class="recovery-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-bolt"></i> 回补强度分析</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="recoveryIntensityChart" style="height: 350px;"></div>
                                                <div id="recoveryIntensityStats" class="stats-container"></div>
                                            </div>
                                        </div>

                                        <div class="recovery-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-calendar-check"></i> 回补时机分析</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="recoveryTimingChart" style="height: 350px;"></div>
                                                <div id="recoveryTimingStats" class="stats-container"></div>
                                            </div>
                                        </div>

                                        <div class="recovery-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-project-diagram"></i> 回补模式识别</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="recoveryPatternChart" style="height: 350px;"></div>
                                                <div id="recoveryPatternStats" class="stats-container"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="recovery-conclusion-card">
                                        <div class="card-header">
                                            <h3><i class="fas fa-lightbulb"></i> 回补分析结论</h3>
                                        </div>
                                        <div class="card-body">
                                            <div id="recoveryConclusion"></div>
                                        </div>
                                    </div>

                                    <div class="recovery-recommendation-card">
                                        <div class="card-header">
                                            <h3><i class="fas fa-star"></i> 回补推荐</h3>
                                        </div>
                                        <div class="card-body">
                                            <div id="recoveryRecommendation"></div>
                                        </div>
                                    </div>
                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(recoveryContainer);

                            document.getElementById('startRecoveryAnalysis').addEventListener('click', () => {
                                EventDelegate.performRecoveryAnalysis();
                            });
                        } else {
                            recoveryContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '回补分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开回补分析', 'info');
                        break;
                    case 'mandelbrot':
                        const allCardsForMandelbrot = document.querySelectorAll('.content-card');
                        allCardsForMandelbrot.forEach(card => {
                            card.style.display = 'none';
                        });

                        let mandelbrotContainer = document.getElementById('mandelbrotContainer');
                        if (!mandelbrotContainer) {
                            mandelbrotContainer = document.createElement('div');
                            mandelbrotContainer.id = 'mandelbrotContainer';
                            mandelbrotContainer.className = 'content-card';
                            mandelbrotContainer.style.display = 'block';

                            mandelbrotContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-theater-masks"></i> 曼德尔定律分析 <span id="mandelbrotDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="content-controls" style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
                                        <label for="mandelbrotPeriodSelect" style="margin: 0;">分析期数：</label>
                                        <select id="mandelbrotPeriodSelect" class="form-control" style="width: 120px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部期数</option>
                                        </select>
                                        <button id="startMandelbrotAnalysis" class="btn btn-primary">
                                            <i class="fas fa-play"></i> 开始分析
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body">

                                    <div class="mandelbrot-section">
                                        <div class="mandelbrot-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-info-circle"></i> 曼德尔定律说明</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="mandelbrot-description">
                                                    <p><strong>曼德尔定律</strong>（Mandel's Law）是一种基于概率统计和混沌理论的彩票号码分析方法，用于分析号码出现的偏差和聚合规律。</p>
                                                    <ul>
                                                        <li><strong>偏差值</strong>：衡量号码实际出现频率与理论期望频率的偏离程度</li>
                                                        <li><strong>聚合度</strong>：衡量号码在特定区间内的聚集程度</li>
                                                        <li><strong>回归趋势</strong>：基于偏差值预测号码回归正常分布的概率</li>
                                                    </ul>
                                                    <p class="note"><i class="fas fa-exclamation-triangle"></i> 本分析基于历史数据统计，仅供概率参考，无中奖保证。</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="mandelbrot-section">
                                        <div class="mandelbrot-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-calculator"></i> 核心公式展示</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="formula-container">
                                                    <div class="formula-item">
                                                        <h4>双色球组合概率公式</h4>
                                                        <div class="formula">P = C(33,6) × C(16,1) = 17,721,088</div>
                                                        <p class="formula-desc">双色球总组合数：从33个红球中选6个，从16个蓝球中选1个</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>大乐透组合概率公式</h4>
                                                        <div class="formula">P = C(35,5) × C(12,2) = 21,425,712</div>
                                                        <p class="formula-desc">大乐透总组合数：从35个前区中选5个，从12个后区中选2个</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>偏差值公式</h4>
                                                        <div class="formula">D<sub>i</sub> = (F<sub>i</sub> - E<sub>i</sub>) / E<sub>i</sub> × 100%</div>
                                                        <p class="formula-desc">其中：F<sub>i</sub>为号码i的实际出现频率，E<sub>i</sub>为理论期望频率</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>聚合度公式</h4>
                                                        <div class="formula">A = Σ |X<sub>i</sub> - μ| / (n × σ)</div>
                                                        <p class="formula-desc">其中：X<sub>i</sub>为号码出现位置，μ为平均位置，n为样本数，σ为标准差</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="mandelbrot-section">
                                        <div class="mandelbrot-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-list-ol"></i> 解析步骤</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="steps-container">
                                                    <div class="step-item">
                                                        <div class="step-number">1</div>
                                                        <div class="step-content">
                                                            <h4>数据加载</h4>
                                                            <p>从数据库加载指定期数的历史开奖数据</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">2</div>
                                                        <div class="step-content">
                                                            <h4>频率统计</h4>
                                                            <p>统计每个红球号码的出现次数和频率</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">3</div>
                                                        <div class="step-content">
                                                            <h4>偏差计算</h4>
                                                            <p>计算每个号码的实际频率与理论期望的偏差值</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">4</div>
                                                        <div class="step-content">
                                                            <h4>聚合度分析</h4>
                                                            <p>分析号码在区间内的聚集程度和分布规律</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">5</div>
                                                        <div class="step-content">
                                                            <h4>趋势预测</h4>
                                                            <p>基于偏差值和聚合度预测号码回归趋势</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="mandelbrot-section">
                                        <div class="mandelbrot-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-chart-bar"></i> 概率分析结果</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="mandelbrotStats" class="stats-grid"></div>
                                                <div id="mandelbrotDeviationChart" style="height: 400px; margin-top: 20px;"></div>
                                                <div id="mandelbrotAggregationChart" style="height: 400px; margin-top: 20px;"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="mandelbrot-section">
                                        <div class="mandelbrot-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-star"></i> 参考号码推荐</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="mandelbrotRecommendation"></div>
                                                <p class="disclaimer"><i class="fas fa-exclamation-triangle"></i> 仅为概率参考，无中奖保证。请理性购彩，量力而行。</p>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(mandelbrotContainer);

                            document.getElementById('startMandelbrotAnalysis').addEventListener('click', () => {
                                EventDelegate.performMandelbrotAnalysis();
                            });
                        } else {
                            mandelbrotContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '曼德尔定律';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开曼德尔定律分析', 'info');
                        break;
                    case 'fibonacci':
                        const allCardsForFibonacci = document.querySelectorAll('.content-card');
                        allCardsForFibonacci.forEach(card => {
                            card.style.display = 'none';
                        });

                        let fibonacciContainer = document.getElementById('fibonacciContainer');
                        if (!fibonacciContainer) {
                            fibonacciContainer = document.createElement('div');
                            fibonacciContainer.id = 'fibonacciContainer';
                            fibonacciContainer.className = 'content-card';
                            fibonacciContainer.style.display = 'block';

                            fibonacciContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-infinity"></i> 斐波那契分析 <span id="fibonacciDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="content-controls" style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
                                        <label for="fibonacciPeriodSelect" style="margin: 0;">分析期数：</label>
                                        <select id="fibonacciPeriodSelect" class="form-control" style="width: 120px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部期数</option>
                                        </select>
                                        <button id="startFibonacciAnalysis" class="btn btn-primary">
                                            <i class="fas fa-play"></i> 开始分析
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body">

                                    <div class="fibonacci-section">
                                        <div class="fibonacci-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-info-circle"></i> 斐波那契数列说明</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="fibonacci-description">
                                                    <p><strong>斐波那契数列</strong>（Fibonacci Sequence）是一个经典的数学数列，其特点是每个数字都是前两个数字之和。该数列在自然界中广泛存在，并且与黄金分割比例（0.618）密切相关。</p>
                                                    <p><strong>核心特征：</strong></p>
                                                    <ul>
                                                        <li><strong>数列定义</strong>：F(n) = F(n-1) + F(n-2)，其中 F(0)=0, F(1)=1</li>
                                                        <li><strong>黄金分割</strong>：相邻两项的比值趋近于黄金分割比例 φ ≈ 0.618</li>
                                                        <li><strong>自然分布</strong>：斐波那契数列在自然界中呈现出优美的分布规律</li>
                                                    </ul>
                                                    <p><strong>双色球适配：</strong></p>
                                                    <ul>
                                                        <li><strong>红球特征值</strong>：1, 2, 3, 5, 8, 13, 21（≤33）</li>
                                                        <li><strong>蓝球特征值</strong>：1, 2, 3, 5, 8, 13（≤16）</li>
                                                        <li><strong>黄金分割点</strong>：红球 7-8, 12-13, 19-21；蓝球 3-4, 6-7, 9-10</li>
                                                    </ul>
                                                    <p class="note"><i class="fas fa-exclamation-triangle"></i> 本分析基于斐波那契数列和黄金分割理论，仅供概率参考，无中奖保证。</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="fibonacci-section">
                                        <div class="fibonacci-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-calculator"></i> 核心公式展示</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="formula-container">
                                                    <div class="formula-item">
                                                        <h4>斐波那契数列公式</h4>
                                                        <div class="formula">F(n) = F(n-1) + F(n-2)</div>
                                                        <p class="formula-desc">斐波那契数列递推公式：每个数字等于前两个数字之和</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>黄金分割比例</h4>
                                                        <div class="formula">φ = (1 + √5) / 2 ≈ 1.618</div>
                                                        <p class="formula-desc">黄金分割比例：斐波那契数列相邻项比值趋近于1.618，其倒数为0.618</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>红球黄金分割点公式</h4>
                                                        <div class="formula">P<sub>red</sub> = 33 × φ<sub>ratio</sub></div>
                                                        <p class="formula-desc">红球黄金分割点：33×0.618≈20.4, 33×0.382≈12.6, 33×0.236≈7.8</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>蓝球黄金分割点公式</h4>
                                                        <div class="formula">P<sub>blue</sub> = 16 × φ<sub>ratio</sub></div>
                                                        <p class="formula-desc">蓝球黄金分割点：16×0.618≈9.9, 16×0.382≈6.1, 16×0.236≈3.8</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>频率偏差公式</h4>
                                                        <div class="formula">D = |F<sub>actual</sub> - F<sub>golden</sub>| / F<sub>golden</sub></div>
                                                        <p class="formula-desc">频率偏差：实际频率与黄金分割比例的偏差值，越小越贴合</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="fibonacci-section">
                                        <div class="fibonacci-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-list-ol"></i> 解析步骤</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="steps-container">
                                                    <div class="step-item">
                                                        <div class="step-number">1</div>
                                                        <div class="step-content">
                                                            <h4>数列适配</h4>
                                                            <p>提取斐波那契数列中≤33的红球特征值（1,2,3,5,8,13,21）和≤16的蓝球特征值（1,2,3,5,8,13）</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">2</div>
                                                        <div class="step-content">
                                                            <h4>黄金分割点计算</h4>
                                                            <p>计算红球和蓝球的黄金分割点：红球（7-8, 12-13, 19-21），蓝球（3-4, 6-7, 9-10）</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">3</div>
                                                        <div class="step-content">
                                                            <h4>特征值匹配分析</h4>
                                                            <p>统计每期开奖号码中落在斐波那契特征值和黄金分割点区间的号码数量</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">4</div>
                                                        <div class="step-content">
                                                            <h4>频率偏差计算</h4>
                                                            <p>计算这些号码的出现频率占比，对比黄金分割比例（0.618/0.382），得出偏差值</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">5</div>
                                                        <div class="step-content">
                                                            <h4>结果拟合与推荐</h4>
                                                            <p>结合斐波那契数列的自然分布特征，分析号码在黄金分割区间/特征值上的分布趋势，生成参考组合</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="fibonacci-section">
                                        <div class="fibonacci-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-chart-bar"></i> 黄金分割分析结果</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="fibonacciStats" class="stats-grid"></div>
                                                <div id="fibonacciFeatureChart" style="height: 400px; margin-top: 20px;"></div>
                                                <div id="fibonacciGoldenChart" style="height: 400px; margin-top: 20px;"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="fibonacci-section">
                                        <div class="fibonacci-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-star"></i> 参考号码推荐</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="fibonacciRecommendation"></div>
                                                <p class="disclaimer"><i class="fas fa-exclamation-triangle"></i> 仅为概率参考，无中奖保证。请理性购彩，量力而行。</p>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(fibonacciContainer);

                            document.getElementById('startFibonacciAnalysis').addEventListener('click', () => {
                                EventDelegate.performFibonacciAnalysis();
                            });
                        } else {
                            fibonacciContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '裴波那契分析';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开裴波那契分析', 'info');
                        break;
                    case 'monte-carlo':
                        const allCardsForMonteCarlo = document.querySelectorAll('.content-card');
                        allCardsForMonteCarlo.forEach(card => {
                            card.style.display = 'none';
                        });

                        let monteCarloContainer = document.getElementById('monteCarloContainer');
                        if (!monteCarloContainer) {
                            monteCarloContainer = document.createElement('div');
                            monteCarloContainer.id = 'monteCarloContainer';
                            monteCarloContainer.className = 'content-card';
                            monteCarloContainer.style.display = 'block';

                            monteCarloContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-dice"></i> 蒙特卡洛模拟 <span id="monteCarloDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="header-controls">
                                        <label for="monteCarloPeriodSelect">分析期数：</label>
                                        <select id="monteCarloPeriodSelect" class="form-control">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部期数</option>
                                        </select>
                                        <label for="monteCarloSimulations">模拟次数：</label>
                                        <select id="monteCarloSimulations" class="form-control">
                                            <option value="1000">1000次</option>
                                            <option value="5000" selected>5000次</option>
                                            <option value="10000">10000次</option>
                                            <option value="50000">50000次</option>
                                            <option value="100000">100000次</option>
                                        </select>
                                        <label for="monteCarloConfidence">置信度：</label>
                                        <select id="monteCarloConfidence" class="form-control">
                                            <option value="0.90">90%</option>
                                            <option value="0.95" selected>95%</option>
                                            <option value="0.99">99%</option>
                                        </select>
                                        <button id="startMonteCarloAnalysis" class="btn btn-primary">
                                            <i class="fas fa-play"></i> 开始模拟
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body">

                                    <div class="montecarlo-section">
                                        <div class="montecarlo-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-info-circle"></i> 蒙特卡洛模拟说明</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="montecarlo-description">
                                                    <p><strong>蒙特卡洛模拟</strong>（Monte Carlo Simulation）是一种基于随机抽样的数值计算方法，通过大量随机试验来估计复杂系统的概率分布和统计特征。</p>
                                                    <p><strong>核心原理：</strong></p>
                                                    <ul>
                                                        <li><strong>随机抽样</strong>：通过大量随机试验模拟真实系统行为</li>
                                                        <li><strong>大数定律</strong>：随着试验次数增加，样本均值趋近于真实期望</li>
                                                        <li><strong>概率估计</strong>：通过频率估计概率，通过样本估计总体特征</li>
                                                    </ul>
                                                    <p><strong>彩票应用：</strong></p>
                                                    <ul>
                                                        <li><strong>号码概率分布</strong>：通过模拟计算每个号码的出现概率</li>
                                                        <li><strong>组合中奖概率</strong>：计算特定号码组合的中奖概率</li>
                                                        <li><strong>置信区间估计</strong>：给出概率估计的置信区间</li>
                                                    </ul>
                                                    <p class="note"><i class="fas fa-exclamation-triangle"></i> 本分析基于蒙特卡洛模拟方法，通过大量随机试验进行概率估计，仅供概率参考，无中奖保证。</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="montecarlo-section">
                                        <div class="montecarlo-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-calculator"></i> 核心公式展示</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="formula-container">
                                                    <div class="formula-item">
                                                        <h4>蒙特卡洛估计公式</h4>
                                                        <div class="formula">E[X] ≈ (1/N) × Σ X<sub>i</sub></div>
                                                        <p class="formula-desc">期望值估计：通过N次独立试验的样本均值估计真实期望值</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>概率估计公式</h4>
                                                        <div class="formula">P(A) ≈ n(A) / N</div>
                                                        <p class="formula-desc">概率估计：事件A发生的次数n(A)与总试验次数N的比值</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>标准误差公式</h4>
                                                        <div class="formula">SE = σ / √N</div>
                                                        <p class="formula-desc">标准误差：样本标准差σ除以试验次数N的平方根，衡量估计精度</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>置信区间公式</h4>
                                                        <div class="formula">CI = X̄ ± Z<sub>α/2</sub> × (σ / √N)</div>
                                                        <p class="formula-desc">置信区间：样本均值X̄加减Z分数乘以标准误差，给出概率估计的范围</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>号码出现概率公式</h4>
                                                        <div class="formula">P(i) = n<sub>i</sub> / N</div>
                                                        <p class="formula-desc">号码i出现概率：号码i在N次模拟中出现的次数n<sub>i</sub>与总模拟次数N的比值</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="montecarlo-section">
                                        <div class="montecarlo-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-list-ol"></i> 解析步骤</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="steps-container">
                                                    <div class="step-item">
                                                        <div class="step-number">1</div>
                                                        <div class="step-content">
                                                            <h4>历史数据加载</h4>
                                                            <p>从数据库加载指定期数的历史开奖数据，分析号码频率分布特征</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">2</div>
                                                        <div class="step-content">
                                                            <h4>蒙特卡洛模拟</h4>
                                                            <p>进行N次随机模拟试验，每次试验生成一组随机号码，统计各号码出现频率</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">3</div>
                                                        <div class="step-content">
                                                            <h4>概率分布计算</h4>
                                                            <p>基于模拟结果计算每个号码的出现概率、标准误差和置信区间</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">4</div>
                                                        <div class="step-content">
                                                            <h4>统计特征分析</h4>
                                                            <p>分析号码的概率分布特征，识别高概率号码和低概率号码</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">5</div>
                                                        <div class="step-content">
                                                            <h4>结果拟合与推荐</h4>
                                                            <p>结合历史数据和模拟结果，生成基于概率的参考号码组合</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="montecarlo-section">
                                        <div class="montecarlo-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-chart-bar"></i> 概率分析结果</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="monteCarloStats" class="stats-grid"></div>
                                                <div id="monteCarloChart" style="height: 400px; margin-top: 20px;"></div>
                                                <div id="monteCarloConfidenceChart" style="height: 400px; margin-top: 20px;"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="montecarlo-section">
                                        <div class="montecarlo-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-star"></i> 参考号码推荐</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="monteCarloRecommendation"></div>
                                                <p class="disclaimer"><i class="fas fa-exclamation-triangle"></i> 仅为概率参考，无中奖保证。请理性购彩，量力而行。</p>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(monteCarloContainer);

                            document.getElementById('startMonteCarloAnalysis').addEventListener('click', () => {
                                EventDelegate.performMonteCarloAnalysis();
                            });
                        } else {
                            monteCarloContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '蒙特卡洛模拟';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开蒙特卡洛模拟', 'info');
                        break;
                    case 'stat-model':
                        const allCardsForStatModel = document.querySelectorAll('.content-card');
                        allCardsForStatModel.forEach(card => {
                            card.style.display = 'none';
                        });

                        let statModelContainer = document.getElementById('statModelContainer');
                        if (!statModelContainer) {
                            statModelContainer = document.createElement('div');
                            statModelContainer.id = 'statModelContainer';
                            statModelContainer.className = 'content-card';
                            statModelContainer.style.display = 'block';

                            statModelContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-chart-bar"></i> 统计学模型 <span id="statModelDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="header-controls">
                                        <label for="statModelPeriodSelect">分析期数：</label>
                                        <select id="statModelPeriodSelect" class="form-control">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部期数</option>
                                        </select>
                                        <label for="statModelAnalysisType">分析类型：</label>
                                        <select id="statModelAnalysisType" class="form-control">
                                            <option value="all">全部分析</option>
                                            <option value="hypothesis">假设检验</option>
                                            <option value="anova">方差分析</option>
                                            <option value="regression">回归分析</option>
                                            <option value="timeseries">时间序列分析</option>
                                            <option value="clustering">聚类分析</option>
                                        </select>
                                        <label for="statModelConfidence">显著性水平：</label>
                                        <select id="statModelConfidence" class="form-control">
                                            <option value="0.01">1%</option>
                                            <option value="0.05" selected>5%</option>
                                            <option value="0.10">10%</option>
                                        </select>
                                        <button id="startStatModelAnalysis" class="btn btn-primary">
                                            <i class="fas fa-play"></i> 开始分析
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body">

                                    <div class="statmodel-section">
                                        <div class="statmodel-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-info-circle"></i> 统计学模型说明</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="statmodel-description">
                                                    <p><strong>统计学模型</strong>（Statistical Models）是基于概率论和数理统计原理，对数据进行系统性分析和预测的数学模型。通过统计学方法，可以从历史数据中发现规律、验证假设、预测趋势。</p>
                                                    <p><strong>核心原理：</strong></p>
                                                    <ul>
                                                        <li><strong>假设检验</strong>：通过统计检验验证数据是否符合特定分布或假设</li>
                                                        <li><strong>方差分析</strong>：分析不同组别之间的差异是否显著</li>
                                                        <li><strong>回归分析</strong>：建立变量之间的数学关系模型，进行预测</li>
                                                        <li><strong>时间序列分析</strong>：分析数据随时间变化的趋势和周期性</li>
                                                        <li><strong>聚类分析</strong>：将相似的数据点分组，发现数据结构</li>
                                                    </ul>
                                                    <p><strong>彩票应用：</strong></p>
                                                    <ul>
                                                        <li><strong>号码分布检验</strong>：检验号码是否服从均匀分布</li>
                                                        <li><strong>区间差异分析</strong>：分析不同区间号码出现频率的差异</li>
                                                        <li><strong>趋势预测</strong>：预测号码出现频率的变化趋势</li>
                                                        <li><strong>周期性识别</strong>：识别号码出现的周期性规律</li>
                                                        <li><strong>号码分组</strong>：根据统计特征将号码分组</li>
                                                    </ul>
                                                    <p class="note"><i class="fas fa-exclamation-triangle"></i> 本分析基于统计学模型方法，通过多种统计检验和分析方法进行号码规律分析，仅供概率参考，无中奖保证。</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="statmodel-section">
                                        <div class="statmodel-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-calculator"></i> 核心公式展示</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="formula-container">
                                                    <div class="formula-item">
                                                        <h4>卡方检验公式</h4>
                                                        <div class="formula">χ² = Σ (O<sub>i</sub> - E<sub>i</sub>)² / E<sub>i</sub></div>
                                                        <p class="formula-desc">卡方统计量：观测值O<sub>i</sub>与期望值E<sub>i</sub>的偏差平方和除以期望值，用于检验数据是否符合理论分布</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>t检验公式</h4>
                                                        <div class="formula">t = (X̄ - μ) / (s / √n)</div>
                                                        <p class="formula-desc">t统计量：样本均值X̄与总体均值μ的差除以标准误差，用于检验样本均值是否显著不同于总体均值</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>方差分析公式</h4>
                                                        <div class="formula">F = MS<sub>B</sub> / MS<sub>W</sub></div>
                                                        <p class="formula-desc">F统计量：组间均方MS<sub>B</sub>与组内均方MS<sub>W</sub>的比值，用于检验多组数据均值是否相等</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>线性回归公式</h4>
                                                        <div class="formula">y = β<sub>0</sub> + β<sub>1</sub>x + ε</div>
                                                        <p class="formula-desc">线性回归模型：因变量y由截距β<sub>0</sub>、斜率β<sub>1</sub>乘以自变量x和误差项ε组成</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>多项式回归公式</h4>
                                                        <div class="formula">y = β<sub>0</sub> + β<sub>1</sub>x + β<sub>2</sub>x² + ... + β<sub>n</sub>x<sup>n</sup> + ε</div>
                                                        <p class="formula-desc">多项式回归模型：因变量y由多项式项和误差项ε组成，可以拟合非线性关系</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>移动平均公式</h4>
                                                        <div class="formula">MA<sub>t</sub> = (1/k) × Σ X<sub>t-i+1</sub></div>
                                                        <p class="formula-desc">移动平均：时间点t的移动平均值为最近k个观测值的平均值，用于平滑时间序列数据</p>
                                                    </div>
                                                    <div class="formula-item">
                                                        <h4>欧氏距离公式</h4>
                                                        <div class="formula">d(x, y) = √Σ (x<sub>i</sub> - y<sub>i</sub>)²</div>
                                                        <p class="formula-desc">欧氏距离：两个点x和y之间的距离，用于聚类分析中衡量数据点之间的相似性</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="statmodel-section">
                                        <div class="statmodel-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-list-ol"></i> 解析步骤</h3>
                                            </div>
                                            <div class="card-body">
                                                <div class="steps-container">
                                                    <div class="step-item">
                                                        <div class="step-number">1</div>
                                                        <div class="step-content">
                                                            <h4>历史数据加载</h4>
                                                            <p>从数据库加载指定期数的历史开奖数据，提取号码频率、区间分布等统计特征</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">2</div>
                                                        <div class="step-content">
                                                            <h4>假设检验</h4>
                                                            <p>进行卡方检验和t检验，验证号码分布是否符合均匀分布假设，识别异常号码</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">3</div>
                                                        <div class="step-content">
                                                            <h4>方差分析</h4>
                                                            <p>进行单因素方差分析，比较不同区间、不同位置号码出现频率的差异显著性</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">4</div>
                                                        <div class="step-content">
                                                            <h4>回归分析</h4>
                                                            <p>建立线性回归和多项式回归模型，分析号码频率随时间的变化趋势</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">5</div>
                                                        <div class="step-content">
                                                            <h4>时间序列分析</h4>
                                                            <p>使用移动平均和自相关分析，识别号码出现的周期性规律和趋势</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">6</div>
                                                        <div class="step-content">
                                                            <h4>聚类分析</h4>
                                                            <p>使用K-means聚类算法，根据统计特征将号码分组，发现号码群组结构</p>
                                                        </div>
                                                    </div>
                                                    <div class="step-item">
                                                        <div class="step-number">7</div>
                                                        <div class="step-content">
                                                            <h4>结果拟合与推荐</h4>
                                                            <p>综合各种统计学分析结果，生成基于统计规律的参考号码组合</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="statmodel-section">
                                        <div class="statmodel-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-chart-bar"></i> 概率分析结果</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="statModelTabs" class="tabs">
                                                    <button class="tab-btn active" data-tab="hypothesis">假设检验</button>
                                                    <button class="tab-btn" data-tab="anova">方差分析</button>
                                                    <button class="tab-btn" data-tab="regression">回归分析</button>
                                                    <button class="tab-btn" data-tab="timeseries">时间序列</button>
                                                    <button class="tab-btn" data-tab="clustering">聚类分析</button>
                                                </div>

                                                <div id="statModelHypothesis" class="tab-content active">
                                                    <div id="statModelHypothesisStats" class="stats-grid"></div>
                                                    <div id="statModelHypothesisChart" style="height: 400px; margin-top: 20px;"></div>
                                                    <div id="statModelHypothesisConclusion" class="conclusion-card"></div>
                                                </div>

                                                <div id="statModelAnova" class="tab-content">
                                                    <div id="statModelAnovaStats" class="stats-grid"></div>
                                                    <div id="statModelAnovaChart" style="height: 400px; margin-top: 20px;"></div>
                                                    <div id="statModelAnovaConclusion" class="conclusion-card"></div>
                                                </div>

                                                <div id="statModelRegression" class="tab-content">
                                                    <div id="statModelRegressionStats" class="stats-grid"></div>
                                                    <div id="statModelRegressionChart" style="height: 400px; margin-top: 20px;"></div>
                                                    <div id="statModelRegressionConclusion" class="conclusion-card"></div>
                                                </div>

                                                <div id="statModelTimeseries" class="tab-content">
                                                    <div id="statModelTimeseriesStats" class="stats-grid"></div>
                                                    <div id="statModelTimeseriesChart" style="height: 400px; margin-top: 20px;"></div>
                                                    <div id="statModelTimeseriesConclusion" class="conclusion-card"></div>
                                                </div>

                                                <div id="statModelClustering" class="tab-content">
                                                    <div id="statModelClusteringStats" class="stats-grid"></div>
                                                    <div id="statModelClusteringChart" style="height: 400px; margin-top: 20px;"></div>
                                                    <div id="statModelClusteringConclusion" class="conclusion-card"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="statmodel-section">
                                        <div class="statmodel-card">
                                            <div class="card-header">
                                                <h3><i class="fas fa-star"></i> 参考号码推荐</h3>
                                            </div>
                                            <div class="card-body">
                                                <div id="statModelRecommendation"></div>
                                                <p class="disclaimer"><i class="fas fa-exclamation-triangle"></i> 仅为概率参考，无中奖保证。请理性购彩，量力而行。</p>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(statModelContainer);

                            document.getElementById('startStatModelAnalysis').addEventListener('click', () => {
                                EventDelegate.performStatModelAnalysis();
                            });

                            document.querySelectorAll('#statModelTabs .tab-btn').forEach(btn => {
                                btn.addEventListener('click', (e) => {
                                    const tab = e.target.dataset.tab;
                                    document.querySelectorAll('#statModelTabs .tab-btn').forEach(b => b.classList.remove('active'));
                                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                                    e.target.classList.add('active');
                                    document.getElementById('statModel' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
                                });
                            });
                        } else {
                            statModelContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '统计学模型';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开统计学模型', 'info');
                        break;
                    case 'combo-opt':
                        const allCardsForComboOpt = document.querySelectorAll('.content-card');
                        allCardsForComboOpt.forEach(card => {
                            card.style.display = 'none';
                        });

                        let comboOptContainer = document.getElementById('comboOptContainer');
                        if (!comboOptContainer) {
                            comboOptContainer = document.createElement('div');
                            comboOptContainer.id = 'comboOptContainer';
                            comboOptContainer.className = 'content-card';
                            comboOptContainer.style.display = 'block';

                            comboOptContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-cogs"></i> 组合优化算法 <span id="comboOptDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="header-controls">
                                        <label>分析期数：</label>
                                        <select id="comboOptPeriodSelect" style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部</option>
                                        </select>
                                        <button class="btn btn-primary" onclick="EventDelegate.performComboOptimizationAnalysis()">
                                            <i class="fas fa-play"></i> 开始分析
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body">

                                    <div class="tab-container">
                                        <div class="tab-header">
                                            <button class="tab-btn active" data-tab="combo-opt-explanation">说明</button>
                                            <button class="tab-btn" data-tab="combo-opt-formula">核心公式展示</button>
                                            <button class="tab-btn" data-tab="combo-opt-steps">解析步骤</button>
                                            <button class="tab-btn" data-tab="combo-opt-results">概率分析结果</button>
                                            <button class="tab-btn" data-tab="combo-opt-recommendation">参考号码推荐</button>
                                        </div>

                                        <div class="tab-content">
                                            <div id="combo-opt-explanation" class="tab-pane active">
                                                <div class="explanation-card">
                                                    <h3><i class="fas fa-info-circle"></i> 组合优化算法说明</h3>
                                                    <div class="explanation-content">
                                                        <p>组合优化算法是一种基于数学优化理论的选号方法，通过分析历史数据的组合特征，寻找最优的号码组合策略。</p>
                                                        <h4>核心原理：</h4>
                                                        <ul>
                                                            <li><strong>组合覆盖：</strong>确保选定的号码组合能够覆盖尽可能多的历史中奖模式</li>
                                                            <li><strong>平衡优化：</strong>在号码分布、奇偶比例、大小比例等方面保持平衡</li>
                                                            <li><strong>概率最大化：</strong>基于历史统计数据，选择出现概率较高的组合</li>
                                                            <li><strong>风险分散：</strong>通过多样化组合降低单一选号策略的风险</li>
                                                        </ul>
                                                        <h4>应用场景：</h4>
                                                        <ul>
                                                            <li>适用于需要多组号码投注的场景</li>
                                                            <li>适用于追求中奖概率最大化的策略</li>
                                                            <li>适用于希望降低投注风险的彩民</li>
                                                        </ul>
                                                        <div class="warning-box">
                                                            <i class="fas fa-exclamation-triangle"></i>
                                                            <strong>风险提示：</strong>本算法基于历史数据统计分析，仅供娱乐参考，不保证中奖结果。彩票具有随机性，请理性投注。
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>

                                            <div id="combo-opt-formula" class="tab-pane">
                                                <div class="formula-card">
                                                    <h3><i class="fas fa-calculator"></i> 核心公式展示</h3>
                                                    <div class="formula-content">
                                                        <div class="formula-section">
                                                            <h4>1. 组合概率公式</h4>
                                                            <div class="formula-box">
                                                                <p>P(C) = Σ<sub>i=1</sub><sup>n</sup> w<sub>i</sub> × f(C, H<sub>i</sub>)</p>
                                                                <p class="formula-desc">其中：P(C)为组合C的概率，w<sub>i</sub>为第i个历史模式的权重，f(C, H<sub>i</sub>)为组合C与第i个历史模式的匹配度</p>
                                                            </div>
                                                        </div>

                                                        <div class="formula-section">
                                                            <h4>2. 平衡度计算公式</h4>
                                                            <div class="formula-box">
                                                                <p>B(C) = α × B<sub>odd</sub>(C) + β × B<sub>size</sub>(C) + γ × B<sub>zone</sub>(C)</p>
                                                                <p class="formula-desc">其中：B(C)为组合C的平衡度，B<sub>odd</sub>(C)为奇偶平衡度，B<sub>size</sub>(C)为大小平衡度，B<sub>zone</sub>(C)为区间平衡度，α、β、γ为权重系数</p>
                                                            </div>
                                                        </div>

                                                        <div class="formula-section">
                                                            <h4>3. 覆盖度计算公式</h4>
                                                            <div class="formula-box">
                                                                <p>Cov(C) = |{H<sub>i</sub> ∈ H | C ∩ H<sub>i</sub> ≥ k}| / |H|</p>
                                                                <p class="formula-desc">其中：Cov(C)为组合C的覆盖度，H为历史中奖号码集合，k为最小匹配号码数</p>
                                                            </div>
                                                        </div>

                                                        <div class="formula-section">
                                                            <h4>4. 优化目标函数</h4>
                                                            <div class="formula-box">
                                                                <p>max F(C) = λ<sub>1</sub> × P(C) + λ<sub>2</sub> × B(C) + λ<sub>3</sub> × Cov(C)</p>
                                                                <p class="formula-desc">其中：F(C)为组合C的综合得分，λ<sub>1</sub>、λ<sub>2</sub>、λ<sub>3</sub>为权重系数</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>

                                            <div id="combo-opt-steps" class="tab-pane">
                                                <div class="steps-card">
                                                    <h3><i class="fas fa-list-ol"></i> 解析步骤</h3>
                                                    <div class="steps-content">
                                                        <div class="step-item">
                                                            <div class="step-number">1</div>
                                                            <div class="step-content">
                                                                <h4>数据加载与预处理</h4>
                                                                <p>从数据库加载指定期数的历史开奖数据，包括红球号码、蓝球号码等关键信息。对数据进行清洗和标准化处理。</p>
                                                            </div>
                                                        </div>

                                                        <div class="step-item">
                                                            <div class="step-number">2</div>
                                                            <div class="step-content">
                                                                <h4>历史模式提取</h4>
                                                                <p>分析历史开奖数据，提取常见的号码组合模式，包括号码分布特征、奇偶比例、大小比例、区间分布等。</p>
                                                            </div>
                                                        </div>

                                                        <div class="step-item">
                                                            <div class="step-number">3</div>
                                                            <div class="step-content">
                                                                <h4>权重计算</h4>
                                                                <p>根据历史模式的出现频率和近期表现，计算各模式的权重系数。近期出现的模式权重较高。</p>
                                                            </div>
                                                        </div>

                                                        <div class="step-item">
                                                            <div class="step-number">4</div>
                                                            <div class="step-content">
                                                                <h4>组合生成</h4>
                                                                <p>基于优化算法，生成候选号码组合。考虑号码的平衡性、覆盖度和概率等因素。</p>
                                                            </div>
                                                        </div>

                                                        <div class="step-item">
                                                            <div class="step-number">5</div>
                                                            <div class="step-content">
                                                                <h4>组合评估</h4>
                                                                <p>对生成的候选组合进行评估，计算每个组合的综合得分，包括概率得分、平衡度得分和覆盖度得分。</p>
                                                            </div>
                                                        </div>

                                                        <div class="step-item">
                                                            <div class="step-number">6</div>
                                                            <div class="step-content">
                                                                <h4>结果输出</h4>
                                                                <p>根据综合得分排序，输出最优的号码组合推荐。提供详细的概率分析和选号建议。</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>

                                            <div id="combo-opt-results" class="tab-pane">
                                                <div class="results-card">
                                                    <h3><i class="fas fa-chart-bar"></i> 概率分析结果</h3>
                                                    <div class="results-content">
                                                        <div id="comboOptStats" class="stats-container"></div>
                                                        <div id="comboOptConclusion" class="conclusion-container"></div>
                                                        <div id="comboOptChart" class="chart-container" style="height: 500px;"></div>
                                                    </div>
                                                </div>
                                            </div>

                                            <div id="combo-opt-recommendation" class="tab-pane">
                                                <div class="recommendation-card">
                                                    <h3><i class="fas fa-lightbulb"></i> 参考号码推荐</h3>
                                                    <div class="recommendation-content">
                                                        <div id="comboOptRecommendation" class="recommendation-container"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(comboOptContainer);

                            comboOptContainer.querySelectorAll('.tab-btn').forEach(btn => {
                                btn.addEventListener('click', function() {
                                    comboOptContainer.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                                    comboOptContainer.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                                    this.classList.add('active');
                                    const tabId = this.getAttribute('data-tab');
                                    document.getElementById(tabId).classList.add('active');
                                });
                            });
                        } else {
                            comboOptContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '组合优化算法';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开组合优化算法', 'info');
                        break;
                    case 'ai-recommend':
                        const allCardsForAI = document.querySelectorAll('.content-card');
                        allCardsForAI.forEach(card => {
                            card.style.display = 'none';
                        });

                        let aiRecommendContainer = document.getElementById('aiRecommendContainer');
                        if (!aiRecommendContainer) {
                            aiRecommendContainer = document.createElement('div');
                            aiRecommendContainer.id = 'aiRecommendContainer';
                            aiRecommendContainer.className = 'content-card';
                            aiRecommendContainer.style.display = 'block';

                            aiRecommendContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-robot"></i> 智能推荐</h2>
                                </div>
                                <div class="content-body" style="padding: 30px;">
                                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(0, 123, 255, 0.1); border-left: 4px solid #007bff; border-radius: 4px;">
                                        <strong>💡 使用说明：</strong>智能推荐系统会自动整合多维度分析结果，为您提供2-3组推荐号码。建议先运行基础分析和高级分析功能，以获得更准确的推荐结果。
                                    </div>

                                    <div style="margin-bottom: 20px; text-align: center;">
                                        <button id="generateRecommendationsBtn" class="btn btn-primary" style="padding: 12px 30px; font-size: 16px;">
                                            <i class="fas fa-magic"></i> 生成智能推荐
                                        </button>
                                    </div>

                                    <div id="recommendationsLoading" style="display: none; text-align: center; padding: 40px;">
                                        <i class="fas fa-spinner fa-spin" style="font-size: 40px; color: #007bff; margin-bottom: 20px;"></i>
                                        <p style="color: #666; font-size: 16px;">正在分析数据并生成推荐...</p>
                                    </div>

                                    <div id="recommendationsContent" style="display: none;"></div>
                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(aiRecommendContainer);

                            document.getElementById('generateRecommendationsBtn').addEventListener('click', () => {
                                EventDelegate.generateSmartRecommendationsUI();
                            });
                        } else {
                            aiRecommendContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '智能推荐';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开智能推荐', 'info');
                        break;
                    case 'strategy':
                        const allCardsForStrategy = document.querySelectorAll('.content-card');
                        allCardsForStrategy.forEach(card => {
                            card.style.display = 'none';
                        });

                        let strategyContainer = document.getElementById('strategyContainer');
                        if (!strategyContainer) {
                            strategyContainer = document.createElement('div');
                            strategyContainer.id = 'strategyContainer';
                            strategyContainer.className = 'content-card';
                            strategyContainer.style.display = 'block';

                            strategyContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-chess-knight"></i> 选号策略 <span id="strategyDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="header-controls">
                                        <label>分析期数：</label>
                                        <select id="strategyPeriodSelect" style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部</option>
                                        </select>
                                        <button class="btn btn-primary" onclick="EventDelegate.performStrategyAnalysis()">
                                            <i class="fas fa-play"></i> 开始分析
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body" style="padding: 30px;">
                                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(0, 123, 255, 0.1); border-left: 4px solid #007bff; border-radius: 4px;">
                                        <strong>💡 使用说明：</strong>本系统提供多种选号策略模板，帮助您结合分析工具自主选号。请根据您的分析需求选择合适的策略，并按照步骤说明进行操作。
                                    </div>

                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                                        <div class="strategy-card" style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white; cursor: pointer;" onclick="EventDelegate.showStrategyDetail('basic')">
                                            <h3 style="margin: 0 0 10px 0; font-size: 18px;">
                                                <i class="fas fa-balance-scale"></i> 基础指标均衡策略
                                            </h3>
                                            <p style="margin: 0; font-size: 14px; opacity: 0.9;">用奇偶/大小/质合分析定比例，搭配号码分布选覆盖不同区间的号</p>
                                        </div>

                                        <div class="strategy-card" style="padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px; color: white; cursor: pointer;" onclick="EventDelegate.showStrategyDetail('omission')">
                                            <h3 style="margin: 0 0 10px 0; font-size: 18px;">
                                                <i class="fas fa-chart-line"></i> 遗漏+频率组合策略
                                            </h3>
                                            <p style="margin: 0; font-size: 14px; opacity: 0.9;">筛选"高频率+低遗漏""低频率+待回补"两类号做组合</p>
                                        </div>

                                        <div class="strategy-card" style="padding: 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 10px; color: white; cursor: pointer;" onclick="EventDelegate.showStrategyDetail('trend')">
                                            <h3 style="margin: 0 0 10px 0; font-size: 18px;">
                                                <i class="fas fa-trending-up"></i> 趋势追踪策略
                                            </h3>
                                            <p style="margin: 0; font-size: 14px; opacity: 0.9;">用趋势分析的走势拐点，搭配相关分析的关联号码做延伸选号</p>
                                        </div>

                                        <div class="strategy-card" style="padding: 20px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius: 10px; color: white; cursor: pointer;" onclick="EventDelegate.showStrategyDetail('pattern')">
                                            <h3 style="margin: 0 0 10px 0; font-size: 18px;">
                                                <i class="fas fa-puzzle-piece"></i> 模式匹配策略
                                            </h3>
                                            <p style="margin: 0; font-size: 14px; opacity: 0.9;">用模式识别的近期特征，筛选符合特征的号码</p>
                                        </div>
                                    </div>

                                    <div id="strategyDetail" style="display: none; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;"></div>
                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(strategyContainer);
                        } else {
                            strategyContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '选号策略';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开选号策略', 'info');
                        break;
                    case 'warning':
                        const allCardsForWarning = document.querySelectorAll('.content-card');
                        allCardsForWarning.forEach(card => {
                            card.style.display = 'none';
                        });

                        let warningContainer = document.getElementById('warningContainer');
                        if (!warningContainer) {
                            warningContainer = document.createElement('div');
                            warningContainer.id = 'warningContainer';
                            warningContainer.className = 'content-card';
                            warningContainer.style.display = 'block';

                            warningContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 style="margin: 0 0 15px 0; color: var(--text-primary); font-size: 18px; display: flex; align-items: center; gap: 10px;">
                                        <i class="fas fa-chart-line" style="color: #2196F3;"></i>
                                        <span>号码分析系统</span>
                                        <span id="numberAnalysisSystemDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span>
                                    </h2>
                                    <div class="header-controls">
                                        <select id="analysisPeriodSelect" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; margin-right: 5px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部</option>
                                        </select>
                                        <button id="startNumberAnalysis" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin-right: 5px;">
                                            <i class="fas fa-play"></i> 开始分析
                                        </button>
                                        <button id="exportAnalysisReport" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                            <i class="fas fa-download"></i> 导出报告
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body" style="padding: 20px;">
                                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px;">
                                        <div style="padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #4CAF50;">
                                            <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 16px;">
                                                <i class="fas fa-database"></i> 数据状态
                                            </h3>
                                            <div id="numberAnalysisDataStatus" style="font-size: 14px; color: #2c3e50;">正常</div>
                                        </div>
                                        <div style="padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #2196F3;">
                                            <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 16px;">
                                                <i class="fas fa-chart-bar"></i> 分析范围
                                            </h3>
                                            <div id="numberAnalysisRange" style="font-size: 14px; color: #2c3e50;">最近50期</div>
                                        </div>
                                        <div style="padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #FF9800;">
                                            <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 16px;">
                                                <i class="fas fa-check-circle"></i> 分析状态
                                            </h3>
                                            <div id="numberAnalysisStatus" style="font-size: 14px; color: #2c3e50;">未分析</div>
                                        </div>
                                        <div style="padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; border-left: 4px solid #9C27B0;">
                                            <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 16px;">
                                                <i class="fas fa-star"></i> 推荐号码
                                            </h3>
                                            <div id="numberAnalysisRecommendations" style="font-size: 14px; color: #2c3e50;">-</div>
                                        </div>
                                    </div>

                                    <div style="margin-bottom: 20px;">
                                        <h3 style="margin: 0 0 15px 0; color: var(--text-primary); font-size: 16px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">
                                            <i class="fas fa-chart-pie"></i> 分析总览仪表板
                                        </h3>
                                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px;">
                                            <div id="analysisLevelDistributionChart" style="height: 300px; background: white; border-radius: 8px; padding: 10px;"></div>
                                            <div id="analysisTimeHeatmap" style="height: 300px; background: white; border-radius: 8px; padding: 10px;"></div>
                                            <div id="analysisDimensionRadar" style="height: 300px; background: white; border-radius: 8px; padding: 10px;"></div>
                                            <div id="analysisRiskGauge" style="height: 300px; background: white; border-radius: 8px; padding: 10px;"></div>
                                        </div>
                                    </div>

                                    <div style="margin-bottom: 20px;">
                                        <h3 style="margin: 0 0 15px 0; color: var(--text-primary); font-size: 16px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">
                                            <i class="fas fa-list"></i> 号码分析详情
                                        </h3>
                                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                                            <div id="analysisNumberAlertChart" style="height: 400px; background: white; border-radius: 8px; padding: 10px;"></div>
                                            <div id="analysisTrendLine" style="height: 400px; background: white; border-radius: 8px; padding: 10px;"></div>
                                            <div id="analysisScatterPlot" style="height: 400px; background: white; border-radius: 8px; padding: 10px;"></div>
                                        </div>
                                    </div>

                                    <div style="margin-bottom: 20px;">
                                        <h3 style="margin: 0 0 15px 0; color: var(--text-primary); font-size: 16px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">
                                            <i class="fas fa-lightbulb"></i> 分析建议与推荐
                                        </h3>
                                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
                                            <div id="analysisSuggestions" style="max-height: 500px; overflow-y: auto; background: white; border-radius: 8px; padding: 15px;"></div>
                                            <div id="analysisRecommendations" style="max-height: 500px; overflow-y: auto; background: white; border-radius: 8px; padding: 15px;"></div>
                                        </div>
                                    </div>

                                    <div style="margin-top: 30px; padding: 20px; background: rgba(255,255,255,0.95); border-radius: 8px;">
                                        <h3 style="margin: 0 0 15px 0; color: var(--text-primary); font-size: 16px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">
                                            <i class="fas fa-chart-bar"></i> 预警统计
                                        </h3>
                                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; font-size: 14px; color: #2c3e50; margin-bottom: 20px;">
                                            <div style="padding: 15px; background: white; border-radius: 6px; border: 1px solid #e0e0e0;">
                                                <div style="font-weight: bold; margin-bottom: 10px; color: #4CAF50;">今日预警</div>
                                                <div id="newAlertTodayCount" style="font-size: 24px; color: #FF6B6B; font-weight: bold;">0条</div>
                                                <div style="margin-top: 10px; font-size: 12px; color: #999;">较昨日：<span id="newAlertYesterdayChange">0</span>条</div>
                                            </div>
                                            <div style="padding: 15px; background: white; border-radius: 6px; border: 1px solid #e0e0e0;">
                                                <div style="font-weight: bold; margin-bottom: 10px; color: #FF6B6B;">当前预警</div>
                                                <div id="newAlertCurrentCount" style="font-size: 24px; color: #FF6B6B; font-weight: bold;">0条</div>
                                                <div style="margin-top: 10px; font-size: 12px; color: #999;">最高级别：<span id="newAlertHighestLevel">无</span></div>
                                            </div>
                                            <div style="padding: 15px; background: white; border-radius: 6px; border: 1px solid #e0e0e0;">
                                                <div style="font-weight: bold; margin-bottom: 10px; color: #2196F3;">命中统计</div>
                                                <div style="font-size: 14px;">
                                                    <div>总预警数：<span id="newAlertTotalCountDisplay">0</span></div>
                                                    <div>命中数：<span id="newAlertHitCountDisplay">0</span></div>
                                                    <div>未命中：<span id="newAlertMissCountDisplay">0</span></div>
                                                    <div>命中率：<span id="newAlertHitRateDisplay">0%</span></div>
                                                    <div style="margin-top: 5px; font-size: 12px; color: #999;">近7日平均：<span id="newAlertWeeklyAvg">0%</span></div>
                                                </div>
                                            </div>
                                            <div style="padding: 15px; background: white; border-radius: 6px; border: 1px solid #e0e0e0;">
                                                <div style="font-weight: bold; margin-bottom: 10px; color: #9C27B0;">预警级别</div>
                                                <div style="font-size: 14px;">
                                                    <div style="color: #FF4444; margin-bottom: 5px;">🔴 红色预警：<span id="newAlertRedCount">0</span>条</div>
                                                    <div style="color: #FFA500; margin-bottom: 5px;">🟡 黄色预警：<span id="newAlertYellowCount">0</span>条</div>
                                                    <div style="color: #4A90E2; margin-bottom: 5px;">🔵 蓝色预警：<span id="newAlertBlueCount">0</span>条</div>
                                                    <div style="margin-top: 10px; font-size: 12px; color: #999;">占比：红色<span id="newAlertRedPercent">0%</span> / 黄色<span id="newAlertYellowPercent">0%</span> / 蓝色<span id="newAlertBluePercent">0%</span></div>
                                                </div>
                                            </div>
                                        </div>

                                        <div style="background: white; border-radius: 6px; border: 1px solid #e0e0e0; padding: 15px;">
                                            <div style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">
                                                <button id="redBallTab" class="alert-tab-btn active" style="flex: 1; padding: 10px; background: #FF4444; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s;">
                                                    🔴 红球预警
                                                </button>
                                                <button id="blueBallTab" class="alert-tab-btn" style="flex: 1; padding: 10px; background: #4A90E2; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s;">
                                                    🔵 蓝球预警
                                                </button>
                                            </div>

                                            <div id="redBallAlerts" style="display: block;">
                                                <div id="redBallAlertGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px;"></div>
                                            </div>

                                            <div id="blueBallAlerts" style="display: none;">
                                                <div id="blueBallAlertGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px;"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(warningContainer);

                            EventDelegate.setupAlertEventListeners();
                        } else {
                            warningContainer.style.display = 'block';
                            EventDelegate.setupAlertEventListeners();
                        }

                        if (breadcrumbItems.length >= 3) {

                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }


                        break;
                    case 'evaluation':
                        const allCardsForEvaluation = document.querySelectorAll('.content-card');
                        allCardsForEvaluation.forEach(card => {
                            card.style.display = 'none';
                        });

                        let evaluationContainer = document.getElementById('evaluationContainer');
                        if (!evaluationContainer) {
                            evaluationContainer = document.createElement('div');
                            evaluationContainer.id = 'evaluationContainer';
                            evaluationContainer.className = 'content-card';
                            evaluationContainer.style.display = 'block';

                            evaluationContainer.innerHTML = `
                                <div class="content-header">
                                    <h2 class="content-title"><i class="fas fa-check-circle"></i> 推荐评估 <span id="evaluationDataRangeInfo" style="color: var(--text-secondary); font-size: 14px; margin-left: 15px;"></span></h2>
                                    <div class="header-controls">
                                        <label>分析期数：</label>
                                        <select id="evaluationPeriodSelect" style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px;">
                                            <option value="10">最近10期</option>
                                            <option value="20">最近20期</option>
                                            <option value="30" selected>最近30期</option>
                                            <option value="50">最近50期</option>
                                            <option value="100">最近100期</option>
                                            <option value="200">最近200期</option>
                                            <option value="all">全部</option>
                                        </select>
                                        <button class="btn btn-primary" onclick="EventDelegate.performEvaluationAnalysis()">
                                            <i class="fas fa-play"></i> 开始评估
                                        </button>
                                    </div>
                                </div>
                                <div class="content-body" style="padding: 30px;">
                                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(0, 123, 255, 0.1); border-left: 4px solid #007bff; border-radius: 4px;">
                                        <strong>💡 使用说明：</strong>本系统提供全方位的推荐评估功能，综合基础分析、高级分析、智能推荐和选号策略，帮助您评估号码推荐质量。
                                    </div>

                                    <div id="evaluationTabs" style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">
                                        <button class="evaluation-tab-btn active" data-tab="basic" onclick="EventDelegate.switchEvaluationTab('basic')">
                                            <i class="fas fa-chart-bar"></i> 基础分析评估
                                        </button>
                                        <button class="evaluation-tab-btn" data-tab="advanced" onclick="EventDelegate.switchEvaluationTab('advanced')">
                                            <i class="fas fa-chart-line"></i> 高级分析评估
                                        </button>
                                        <button class="evaluation-tab-btn" data-tab="recommendation" onclick="EventDelegate.switchEvaluationTab('recommendation')">
                                            <i class="fas fa-robot"></i> 智能推荐评估
                                        </button>
                                        <button class="evaluation-tab-btn" data-tab="strategy" onclick="EventDelegate.switchEvaluationTab('strategy')">
                                            <i class="fas fa-chess-knight"></i> 选号策略评估
                                        </button>
                                    </div>

                                    <div id="evaluationContent">
                                        <div id="basicEvaluation" class="evaluation-content-panel active">
                                            <h3 style="margin-bottom: 20px; color: var(--text-primary);">
                                                <i class="fas fa-chart-bar"></i> 基础分析评估
                                            </h3>
                                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-chart-bar"></i> 频率分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估号码出现频率的合理性</p>
                                                    <div id="frequencyEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-chart-line"></i> 遗漏分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估号码遗漏周期的合理性</p>
                                                    <div id="omissionEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-fire"></i> 冷热分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估号码冷热状态的合理性</p>
                                                    <div id="hotColdEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-balance-scale"></i> 奇偶分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估奇偶比例的合理性</p>
                                                    <div id="oddEvenEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-ruler"></i> 大小分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估大小比例的合理性</p>
                                                    <div id="bigSmallEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); border-radius: 10px; color: #333;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-hashtag"></i> 质合分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估质合比例的合理性</p>
                                                    <div id="primeCompositeEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%); border-radius: 10px; color: #333;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-calculator"></i> AC值分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估AC值的合理性</p>
                                                    <div id="acValueEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); border-radius: 10px; color: #333;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-grip-horizontal"></i> 大中小分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估大中小分布的合理性</p>
                                                    <div id="threeZoneEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>
                                            </div>
                                        </div>

                                        <div id="advancedEvaluation" class="evaluation-content-panel" style="display: none;">
                                            <h3 style="margin-bottom: 20px; color: var(--text-primary);">
                                                <i class="fas fa-chart-line"></i> 高级分析评估
                                            </h3>
                                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-chart-line"></i> 趋势分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估号码趋势的合理性</p>
                                                    <div id="trendEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-link"></i> 相关性分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估号码关联关系的合理性</p>
                                                    <div id="correlationEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-clipboard-list"></i> 统计分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估统计指标的合理性</p>
                                                    <div id="statisticsEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-bullseye"></i> 模式识别
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估模式匹配的合理性</p>
                                                    <div id="patternEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-vial"></i> DNA分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估DNA特征的合理性</p>
                                                    <div id="dnaEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); border-radius: 10px; color: #333;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-undo"></i> 回补分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估回补概率的合理性</p>
                                                    <div id="recoveryEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%); border-radius: 10px; color: #333;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-theater-masks"></i> 曼德博分析
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估曼德博特征的合理性</p>
                                                    <div id="mandelbrotEvaluationScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>
                                            </div>
                                        </div>

                                        <div id="recommendationEvaluation" class="evaluation-content-panel" style="display: none;">
                                            <h3 style="margin-bottom: 20px; color: var(--text-primary);">
                                                <i class="fas fa-robot"></i> 智能推荐评估
                                            </h3>
                                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-star"></i> 推荐质量评分
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">综合评估推荐号码的质量</p>
                                                    <div id="recommendationQualityScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-shield-alt"></i> 推荐置信度
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估推荐结果的可信程度</p>
                                                    <div id="recommendationConfidence" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-history"></i> 历史准确率
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估历史推荐的准确程度</p>
                                                    <div id="recommendationAccuracy" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>
                                            </div>

                                            <div id="recommendationDetails" style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                                                <h4 style="margin: 0 0 15px 0; color: var(--text-primary);">
                                                    <i class="fas fa-list"></i> 推荐详情
                                                </h4>
                                                <div id="recommendationList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                                    <div style="padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff;">
                                                        <div style="font-size: 14px; color: #666; margin-bottom: 5px;">推荐号码</div>
                                                        <div style="font-size: 18px; font-weight: bold; color: #333;">--</div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <div id="strategyEvaluation" class="evaluation-content-panel" style="display: none;">
                                            <h3 style="margin-bottom: 20px; color: var(--text-primary);">
                                                <i class="fas fa-chess-knight"></i> 选号策略评估
                                            </h3>
                                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-balance-scale"></i> 基础指标均衡策略
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估基础指标均衡策略的效果</p>
                                                    <div id="basicStrategyScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-chart-line"></i> 遗漏+频率组合策略
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估遗漏+频率组合策略的效果</p>
                                                    <div id="omissionStrategyScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-trending-up"></i> 趋势追踪策略
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估趋势追踪策略的效果</p>
                                                    <div id="trendStrategyScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>

                                                <div class="evaluation-item" style="padding: 20px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius: 10px; color: white;">
                                                    <h4 style="margin: 0 0 10px 0; font-size: 16px;">
                                                        <i class="fas fa-puzzle-piece"></i> 模式匹配策略
                                                    </h4>
                                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">评估模式匹配策略的效果</p>
                                                    <div id="patternStrategyScore" style="margin-top: 10px; font-size: 24px; font-weight: bold;">--</div>
                                                </div>
                                            </div>

                                            <div id="strategyDetails" style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                                                <h4 style="margin: 0 0 15px 0; color: var(--text-primary);">
                                                    <i class="fas fa-list"></i> 策略详情
                                                </h4>
                                                <div id="strategyList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                                    <div style="padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff;">
                                                        <div style="font-size: 14px; color: #666; margin-bottom: 5px;">策略名称</div>
                                                        <div style="font-size: 16px; font-weight: bold; color: #333;">--</div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;

                            document.querySelector('.content-area').appendChild(evaluationContainer);
                        } else {
                            evaluationContainer.style.display = 'block';
                        }

                        if (breadcrumbItems.length >= 3) {
                            breadcrumbItems[2].textContent = '推荐评估';
                            breadcrumbItems[2].className = 'breadcrumb-item active';
                        }

                        MessageSystem.showMessage('打开推荐评估', 'info');
                        break;
                }
            }

            static handleLotteryTypeChange(button) {
                const lotteryType = button.getAttribute('data-lottery');
                dataManager.switchLotteryType(lotteryType);

                document.querySelectorAll('.lottery-tab').forEach(tab => {
                    tab.classList.remove('active');
                });

                button.classList.add('active');

                EventDelegate.updateMagicSquareGridByLotteryType();
            }

            static handleLotteryTypeSelectChange(lotteryType) {
                currentLotteryType = lotteryType;
                dataManager.switchLotteryType(lotteryType);
                EventDelegate.updateMagicSquareGridByLotteryType();
                EventDelegate.renderNumberLibrary();
            }

            static handleSettingsClick() {
                document.getElementById('settingsModal').style.display = 'flex';
            }

            static handlePrizeLevelClick() {
                const modal = document.createElement('div');
                modal.id = 'prizeLevelModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 8px;
                    max-width: 1100px;
                    max-height: 90vh;
                    overflow: auto;
                    position: relative;
                    width: 90%;
                `;

                const isSSQ = currentLotteryType === 'ssq';
                
                let prizeTableHTML = '';
                if (isSSQ) {
                    prizeTableHTML = `
                        <div style="margin-bottom: 30px;">
                            <h3 style="color: #E63946; border-bottom: 2px solid #E63946; padding-bottom: 10px; margin-bottom: 15px;">双色球奖级</h3>
                            <table style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                                <thead>
                                    <tr>
                                        <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖级</th>
                                        <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 60%;">中奖条件</th>
                                        <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖金</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #dc3545; font-weight: bold;">一等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">6红+1蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">500万</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #fd7e14; font-weight: bold;">二等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">6红+0蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">50万</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #ffc107; font-weight: bold;">三等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5红+1蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">3000元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #20c997; font-weight: bold;">四等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5红+0蓝 或 4红+1蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">200元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #0dcaf0; font-weight: bold;">五等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">4红+0蓝 或 3红+1蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">10元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">六等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">2红+1蓝 或 1红+1蓝 或 0红+1蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">福运奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">3红+0蓝</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5元</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    `;
                } else {
                    prizeTableHTML = `
                        <div>
                            <h3 style="color: #2A9D8F; border-bottom: 2px solid #2A9D8F; padding-bottom: 10px; margin-bottom: 15px;">大乐透奖级</h3>
                            <table style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                                <thead>
                                    <tr>
                                        <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖级</th>
                                        <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 60%;">中奖条件</th>
                                        <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖金</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #dc3545; font-weight: bold;">一等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5前+2后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">500万</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #fd7e14; font-weight: bold;">二等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5前+1后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">50万</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #ffc107; font-weight: bold;">三等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5前+0后 或 4前+2后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5000元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #20c997; font-weight: bold;">四等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">4前+1后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">300元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #0dcaf0; font-weight: bold;">五等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">4前+0后 或 3前+2后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">150元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">六等奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">3前+1后 或 2前+2后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">15元</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">好运奖</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center; font-size: 13px; line-height: 1.8;">3前+0后<br>2前+1后<br>1前+2后<br>0前+2后</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5元</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    `;
                }

                content.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2 style="margin: 0; color: #333;">奖级对照表</h2>
                        <button onclick="document.getElementById('prizeLevelModal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <p style="color: #666; margin: 0;">当前彩票类型：<strong>${isSSQ ? '双色球' : '大乐透'}</strong></p>
                    </div>
                    ${prizeTableHTML}
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px;">
                        <p style="margin: 0; color: #666; font-size: 14px;">
                            <strong>说明：</strong>以上奖金为理论值，实际奖金根据当期销量和中奖注数浮动。一等奖和二等奖为浮动奖金，其余奖级为固定奖金。2026年2月1日起双色球新增福运奖，大乐透新增好运奖。
                        </p>
                    </div>
                `;

                modal.appendChild(content);
                document.body.appendChild(modal);

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            static handleCloseSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }

            static handleSaveSettings() {
                // 获取选中的主题
                const selectedTheme = document.querySelector('.theme-option[data-theme].active');
                if (selectedTheme) {
                    const theme = selectedTheme.getAttribute('data-theme');
                    MessageSystem.showMessage(`主题已设置为${theme}`, 'success');
                }

                // 获取选中的存储方式
                const selectedStorage = document.querySelector('.theme-option[data-storage].active');
                if (selectedStorage) {
                    const storage = selectedStorage.getAttribute('data-storage');
                    if (storage !== currentStorageMethod) {
                        currentStorageMethod = storage;
                        MessageSystem.showMessage(`数据存储方式已更改为${storage}`, 'success');

                        // 重新初始化数据库
                        dataManager.databases = {};
                        dataManager.switchLotteryType(currentLotteryType);
                    }
                }

                this.handleCloseSettings();
            }

            static getOddEvenRatio(draws, periodCount = 30) {
                const recentDraws = draws;
                let oddTotal = 0;
                let evenTotal = 0;

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num % 2 === 0) {
                            evenTotal++;
                        } else {
                            oddTotal++;
                        }
                    });
                });

                const total = oddTotal + evenTotal;
                const oddRatio = total > 0 ? (oddTotal / total).toFixed(2) : 0;
                const evenRatio = total > 0 ? (evenTotal / total).toFixed(2) : 0;

                return { oddTotal, evenTotal, oddRatio, evenRatio };
            }

            static getSizeRatio(draws, periodCount = 30) {
                const recentDraws = draws;
                let bigTotal = 0;
                let smallTotal = 0;
                const midPoint = 17;

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num > midPoint) {
                            bigTotal++;
                        } else {
                            smallTotal++;
                        }
                    });
                });

                const total = bigTotal + smallTotal;
                const bigRatio = total > 0 ? (bigTotal / total).toFixed(2) : 0;
                const smallRatio = total > 0 ? (smallTotal / total).toFixed(2) : 0;

                return { bigTotal, smallTotal, bigRatio, smallRatio };
            }

            static getPrimeCompositeRatio(draws, periodCount = 30) {
                const recentDraws = draws;
                let primeTotal = 0;
                let compositeTotal = 0;

                const isPrime = (num) => {
                    if (num < 2) return false;
                    for (let i = 2; i <= Math.sqrt(num); i++) {
                        if (num % i === 0) return false;
                    }
                    return true;
                };

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (isPrime(num)) {
                            primeTotal++;
                        } else {
                            compositeTotal++;
                        }
                    });
                });

                const total = primeTotal + compositeTotal;
                const primeRatio = total > 0 ? (primeTotal / total).toFixed(2) : 0;
                const compositeRatio = total > 0 ? (compositeTotal / total).toFixed(2) : 0;

                return { primeTotal, compositeTotal, primeRatio, compositeRatio };
            }

            static getNumberDistribution(draws, periodCount = 30) {
                const recentDraws = draws;
                const distribution = {
                    '01-10': 0,
                    '11-20': 0,
                    '21-30': 0,
                    '31-33': 0
                };

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= 1 && num <= 10) {
                            distribution['01-10']++;
                        } else if (num >= 11 && num <= 20) {
                            distribution['11-20']++;
                        } else if (num >= 21 && num <= 30) {
                            distribution['21-30']++;
                        } else if (num >= 31 && num <= 33) {
                            distribution['31-33']++;
                        }
                    });
                });

                const sortedIntervals = Object.entries(distribution)
                    .sort((a, b) => b[1] - a[1]);

                return {
                    distribution,
                    highDensity: sortedIntervals.slice(0, 2).map(item => item[0]),
                    lowDensity: sortedIntervals.slice(-2).map(item => item[0])
                };
            }

            static getFrequencyOmissionData(draws, periodCount = 30) {
                const redBallFrequency = {};
                for (let i = 1; i <= 33; i++) {
                    const num = i.toString().padStart(2, '0');
                    redBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0,
                        maxOmission: 0
                    };
                }

                const recentDraws = draws;
                const reversedDraws = [...recentDraws].reverse();

                reversedDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (redBallFrequency[ball]) {
                            redBallFrequency[ball].count++;
                        }
                    });
                });

                for (let num in redBallFrequency) {
                    let omissionCount = 0;
                    let maxOmission = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < reversedDraws.length; i++) {
                        const draw = reversedDraws[i];
                        if (draw.redBalls.includes(num)) {
                            if (omissionCount > maxOmission) {
                                maxOmission = omissionCount;
                            }
                            omissionCount = 0;
                            found = true;

                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        redBallFrequency[num].currentOmission = reversedDraws.length;
                    } else {
                        redBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                    redBallFrequency[num].maxOmission = maxOmission;
                }

                const sortedByFrequency = Object.entries(redBallFrequency)
                    .sort((a, b) => b[1].count - a[1].count);

                const highFrequency = sortedByFrequency.slice(0, 10).map(item => item[0]);
                const lowFrequency = sortedByFrequency.slice(-10).map(item => item[0]);

                const sortedByOmission = Object.entries(redBallFrequency)
                    .sort((a, b) => a[1].currentOmission - b[1].currentOmission);

                const lowOmission = sortedByOmission.slice(0, 10).map(item => item[0]);
                const highOmission = sortedByOmission.slice(-10).map(item => item[0]);

                const strongNumbers = highFrequency.filter(num => lowOmission.includes(num));
                const potentialNumbers = lowFrequency.filter(num => highOmission.includes(num));

                return {
                    redBallFrequency,
                    highFrequency,
                    lowFrequency,
                    lowOmission,
                    highOmission,
                    strongNumbers,
                    potentialNumbers
                };
            }

            static getTrendData(draws, periodCount = 20) {
                const recentDraws = draws;
                const trendData = {};

                for (let i = 1; i <= 33; i++) {
                    const num = i.toString().padStart(2, '0');
                    trendData[num] = {
                        recentCount: 0,
                        trend: 'stable'
                    };
                }

                const firstHalf = recentDraws.slice(0, Math.floor(recentDraws.length / 2));
                const secondHalf = recentDraws.slice(Math.floor(recentDraws.length / 2));

                firstHalf.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (trendData[ball]) {
                            trendData[ball].firstHalfCount = (trendData[ball].firstHalfCount || 0) + 1;
                        }
                    });
                });

                secondHalf.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (trendData[ball]) {
                            trendData[ball].secondHalfCount = (trendData[ball].secondHalfCount || 0) + 1;
                        }
                    });
                });

                Object.keys(trendData).forEach(num => {
                    const firstHalfCount = trendData[num].firstHalfCount || 0;
                    const secondHalfCount = trendData[num].secondHalfCount || 0;

                    if (secondHalfCount > firstHalfCount + 1) {
                        trendData[num].trend = 'rising';
                    } else if (firstHalfCount > secondHalfCount + 1) {
                        trendData[num].trend = 'falling';
                    } else {
                        trendData[num].trend = 'stable';
                    }

                    trendData[num].recentCount = secondHalfCount;
                });

                const risingNumbers = Object.entries(trendData)
                    .filter(([num, data]) => data.trend === 'rising')
                    .sort((a, b) => b[1].recentCount - a[1].recentCount)
                    .slice(0, 5)
                    .map(item => item[0]);

                return {
                    trendData,
                    risingNumbers
                };
            }

            static getPatternData(draws, periodCount = 20) {
                const recentDraws = draws;
                const patterns = {
                    consecutive: 0,
                    sameTail: 0,
                    arithmetic: 0
                };

                recentDraws.forEach(draw => {
                    const sortedBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    let hasConsecutive = false;
                    for (let i = 0; i < sortedBalls.length - 1; i++) {
                        if (sortedBalls[i + 1] - sortedBalls[i] === 1) {
                            hasConsecutive = true;
                            break;
                        }
                    }
                    if (hasConsecutive) patterns.consecutive++;

                    const tails = sortedBalls.map(num => num % 10);
                    const tailCounts = {};
                    tails.forEach(tail => {
                        tailCounts[tail] = (tailCounts[tail] || 0) + 1;
                    });
                    if (Object.values(tailCounts).some(count => count >= 2)) {
                        patterns.sameTail++;
                    }

                    let hasArithmetic = false;
                    for (let i = 0; i < sortedBalls.length - 2; i++) {
                        const diff1 = sortedBalls[i + 1] - sortedBalls[i];
                        const diff2 = sortedBalls[i + 2] - sortedBalls[i + 1];
                        if (diff1 === diff2 && diff1 > 0) {
                            hasArithmetic = true;
                            break;
                        }
                    }
                    if (hasArithmetic) patterns.arithmetic++;
                });

                const sortedPatterns = Object.entries(patterns)
                    .sort((a, b) => b[1] - a[1]);

                return {
                    patterns,
                    topPattern: sortedPatterns[0] ? sortedPatterns[0][0] : 'none',
                    patternCounts: sortedPatterns
                };
            }

            static performStrategyAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const periodSelect = document.getElementById('strategyPeriodSelect');
                    if (!periodSelect) {
                        MessageSystem.showMessage('未找到分析期数选择器', 'error');
                        return;
                    }

                    const periodValue = periodSelect.value;
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('当前数据库暂无数据，请先导入开奖数据', 'warning');
                        return;
                    }

                    let periodCount;
                    if (periodValue === 'all') {
                        periodCount = draws.length;
                    } else {
                        periodCount = parseInt(periodValue);
                    }

                    if (periodCount > draws.length) {
                        MessageSystem.showMessage(`数据库只有 ${draws.length} 期数据，无法分析 ${periodCount} 期`, 'warning');
                        return;
                    }

                    const recentDraws = draws.slice(-periodCount);

                    // 更新分析范围显示
                    const strategyDataRangeInfo = document.getElementById('strategyDataRangeInfo');
                    if (strategyDataRangeInfo && recentDraws.length > 0) {
                        const startPeriod = recentDraws[0].period;
                        const endPeriod = recentDraws[recentDraws.length - 1].period;
                        strategyDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${recentDraws.length}期）`;
                    }

                    MessageSystem.showMessage(`开始分析最近 ${periodCount} 期数据...`, 'info');

                    setTimeout(() => {
                        const oddEvenData = this.getOddEvenRatio(recentDraws, periodCount);
                        const sizeData = this.getSizeRatio(recentDraws, periodCount);
                        const primeCompositeData = this.getPrimeCompositeRatio(recentDraws, periodCount);
                        const distributionData = this.getNumberDistribution(recentDraws, periodCount);
                        const frequencyOmissionData = this.getFrequencyOmissionData(recentDraws, periodCount);

                        const analysisResult = `
                            <div style="padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
                                <h3 style="margin: 0 0 20px 0; color: #007bff; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-bar"></i> 分析结果（最近 ${periodCount} 期）
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 基础指标分析：</strong>
                                    <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                        <div style="margin-bottom: 10px;">
                                            <strong>奇偶比例：</strong>奇数 ${oddEvenData.oddTotal} 个（${oddEvenData.oddRatio}），偶数 ${oddEvenData.evenTotal} 个（${oddEvenData.evenRatio}）
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                        <strong>大小比例：</strong>大号 ${sizeData.bigTotal} 个（${sizeData.bigRatio}），小号 ${sizeData.smallTotal} 个（${sizeData.smallRatio}）
                                    </div>
                                    <div style="margin-bottom: 10px;">
                                        <strong>质合比例：</strong>质数 ${primeCompositeData.primeTotal} 个（${primeCompositeData.primeRatio}），合数 ${primeCompositeData.compositeTotal} 个（${primeCompositeData.compositeRatio}）
                                    </div>
                                    <div>
                                        <strong>高密度区间：</strong>${distributionData.highDensity.join('、')}<br>
                                        <strong>低密度区间：</strong>${distributionData.lowDensity.join('、')}
                                    </div>
                                </div>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <strong>📈 频率与遗漏分析：</strong>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <div style="margin-bottom: 10px;">
                                        <strong>高频号码（前10）：</strong>${frequencyOmissionData.highFrequency.map(num => `${num}(${frequencyOmissionData.redBallFrequency[num].count}次)`).join('、')}
                                    </div>
                                    <div style="margin-bottom: 10px;">
                                        <strong>低遗漏号码（前10）：</strong>${frequencyOmissionData.lowOmission.map(num => `${num}(${frequencyOmissionData.redBallFrequency[num].currentOmission}期)`).join('、')}
                                    </div>
                                    <div>
                                        <strong>待回补号码（遗漏>平均1.5倍）：</strong>${frequencyOmissionData.highOmission.map(num => `${num}(${frequencyOmissionData.redBallFrequency[num].currentOmission}期)`).join('、')}
                                    </div>
                                </div>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <strong>💡 选号建议：</strong>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <ul style="margin: 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 8px;">根据奇偶比例 ${oddEvenData.oddRatio}:${oddEvenData.evenRatio}，建议选择 ${oddEvenData.oddRatio > oddEvenData.evenRatio ? '奇数较多' : '偶数较多'}的组合</li>
                                        <li style="margin-bottom: 8px;">根据大小比例 ${sizeData.bigRatio}:${sizeData.smallRatio}，建议选择 ${sizeData.bigRatio > sizeData.smallRatio ? '大号较多' : '小号较多'}的组合</li>
                                        <li style="margin-bottom: 8px;">根据质合比例 ${primeCompositeData.primeRatio}:${primeCompositeData.compositeRatio}，建议选择 ${primeCompositeData.primeRatio > primeCompositeData.compositeRatio ? '质数较多' : '合数较多'}的组合</li>
                                        <li style="margin-bottom: 8px;">从高密度区间 ${distributionData.highDensity.join('、')} 选择2-3个号，从低密度区间 ${distributionData.lowDensity.join('、')} 选择1-2个号</li>
                                        <li style="margin-bottom: 8px;">关注高频号码 ${frequencyOmissionData.highFrequency.slice(0, 5).join('、')} 和低遗漏号码 ${frequencyOmissionData.lowOmission.slice(0, 5).join('、')}</li>
                                        <li>留意待回补号码 ${frequencyOmissionData.highOmission.slice(0, 3).join('、')}，可能即将回补</li>
                                    </ul>
                                </div>
                            </div>

                            <div>
                                <strong>📋 策略选择指引：</strong>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <p style="margin: 0 0 10px 0; color: #555;">根据以上分析结果，您可以选择以下策略进行选号：</p>
                                    <ul style="margin: 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 8px;"><strong>基础指标均衡策略：</strong>点击上方"基础指标均衡策略"卡片，查看详细步骤</li>
                                        <li style="margin-bottom: 8px;"><strong>遗漏+频率组合策略：</strong>点击上方"遗漏+频率组合策略"卡片，查看详细步骤</li>
                                        <li style="margin-bottom: 8px;"><strong>趋势追踪策略：</strong>点击上方"趋势追踪策略"卡片，查看详细步骤</li>
                                        <li><strong>模式匹配策略：</strong>点击上方"模式匹配策略"卡片，查看详细步骤</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    `;

                    const detailContainer = document.getElementById('strategyDetail');
                    if (detailContainer) {
                        detailContainer.innerHTML = analysisResult;
                        detailContainer.style.borderLeftColor = '#007bff';
                        detailContainer.style.display = 'block';
                        detailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }

                    MessageSystem.showMessage(`分析完成！已生成最近 ${periodCount} 期的分析结果`, 'success');
                }, 500);
                });
            }

            static showStrategyDetail(strategyType) {
                const detailContainer = document.getElementById('strategyDetail');
                if (!detailContainer) return;

                const draws = currentDatabaseData.draws || [];
                const hasData = draws.length > 0;

                let periodCount = 30;
                let periodText = '最近30期';

                const periodSelect = document.getElementById('strategyPeriodSelect');
                if (periodSelect) {
                    const periodValue = periodSelect.value;
                    if (periodValue === 'all') {
                        periodCount = draws.length;
                        periodText = `全部${periodCount}期`;
                    } else {
                        periodCount = parseInt(periodValue);
                        periodText = `最近${periodCount}期`;
                    }
                }

                const recentDraws = draws.slice(-periodCount);

                let content = '';
                let borderColor = '';

                switch(strategyType) {
                    case 'basic':
                        borderColor = '#667eea';

                        if (hasData) {
                            const oddEvenData = this.getOddEvenRatio(recentDraws, periodCount);
                            const sizeData = this.getSizeRatio(recentDraws, periodCount);
                            const primeCompositeData = this.getPrimeCompositeRatio(recentDraws, periodCount);
                            const distributionData = this.getNumberDistribution(recentDraws, periodCount);

                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #667eea; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-balance-scale"></i> 基础指标均衡策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过分析奇偶、大小、质合等基础指标，确定合理的比例范围，并结合号码分布特征，选择覆盖不同区间的号码，实现均衡选号。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 实际数据分析（基于${periodText}）：</strong>
                                    <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #667eea;">
                                        <div style="margin-bottom: 10px;">
                                            <strong>奇偶比例：</strong>奇数 ${oddEvenData.oddTotal} 个（${oddEvenData.oddRatio}），偶数 ${oddEvenData.evenTotal} 个（${oddEvenData.evenRatio}）
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                            <strong>大小比例：</strong>大号 ${sizeData.bigTotal} 个（${sizeData.bigRatio}），小号 ${sizeData.smallTotal} 个（${sizeData.smallRatio}）
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                            <strong>质合比例：</strong>质数 ${primeCompositeData.primeTotal} 个（${primeCompositeData.primeRatio}），合数 ${primeCompositeData.compositeTotal} 个（${primeCompositeData.compositeRatio}）
                                        </div>
                                        <div>
                                            <strong>高密度区间：</strong>${distributionData.highDensity.join('、')}<br>
                                            <strong>低密度区间：</strong>${distributionData.lowDensity.join('、')}
                                        </div>
                                    </div>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：确定奇偶比例</strong><br>根据实际分析，近期奇偶比例为 ${oddEvenData.oddRatio}:${oddEvenData.evenRatio}，建议选择 ${oddEvenData.oddRatio > oddEvenData.evenRatio ? '奇数较多' : '偶数较多'}的组合。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：确定大小比例</strong><br>根据实际分析，近期大小比例为 ${sizeData.bigRatio}:${sizeData.smallRatio}，建议选择 ${sizeData.bigRatio > sizeData.smallRatio ? '大号较多' : '小号较多'}的组合。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：确定质合比例</strong><br>根据实际分析，近期质合比例为 ${primeCompositeData.primeRatio}:${primeCompositeData.compositeRatio}，建议选择 ${primeCompositeData.primeRatio > primeCompositeData.compositeRatio ? '质数较多' : '合数较多'}的组合。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：分析号码分布</strong><br>高密度区间为 ${distributionData.highDensity.join('、')}，低密度区间为 ${distributionData.lowDensity.join('、')}，建议从高密度区间选择2-3个号，从低密度区间选择1-2个号。</li>
                                        <li style="margin-bottom: 10px;"><strong>第五步：组合选号</strong><br>根据上述分析，从不同区间选择号码，确保符合近期比例分布。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">奇偶分析</span>
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">大小分析</span>
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">质合分析</span>
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">号码分布</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>比例选择应以${periodText}数据为参考，避免过度依赖短期数据</li>
                                        <li>号码分布应兼顾热区和冷区，避免过度集中在某一区间</li>
                                        <li>定期更新分析数据，及时调整选号策略</li>
                                    </ul>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #667eea; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-balance-scale"></i> 基础指标均衡策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过分析奇偶、大小、质合等基础指标，确定合理的比例范围，并结合号码分布特征，选择覆盖不同区间的号码，实现均衡选号。</p>
                                </div>

                                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                                    <strong>⚠️ 数据不足提示：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">当前数据库暂无数据，请先导入开奖数据后再使用此策略。导入数据后，系统将自动分析最近30期的奇偶、大小、质合比例和号码分布情况。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：确定奇偶比例</strong><br>打开"奇偶分析"模块，查看近期30期奇偶比例分布，选择出现频率最高的比例（如3:2或2:3）作为基准。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：确定大小比例</strong><br>打开"大小分析"模块，查看近期30期大小比例分布，选择出现频率最高的比例（如3:2或2:3）作为基准。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：确定质合比例</strong><br>打开"质合分析"模块，查看近期30期质合比例分布，选择出现频率最高的比例（如3:2或2:3）作为基准。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：分析号码分布</strong><br>打开"号码分布"模块，查看各区间号码的密度分布，识别高密度区间（热区）和低密度区间（冷区）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第五步：组合选号</strong><br>根据确定的奇偶、大小、质合比例，从不同区间选择号码，确保覆盖高密度区间（2-3个号）和低密度区间（1-2个号）。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">奇偶分析</span>
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">大小分析</span>
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">质合分析</span>
                                        <span style="padding: 5px 12px; background: #667eea; color: white; border-radius: 15px; font-size: 12px;">号码分布</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>比例选择应以近期30期数据为参考，避免过度依赖短期数据</li>
                                        <li>号码分布应兼顾热区和冷区，避免过度集中在某一区间</li>
                                        <li>定期更新分析数据，及时调整选号策略</li>
                                    </ul>
                                </div>
                            `;
                        }
                        break;

                    case 'omission':
                        borderColor = '#f5576c';

                        if (hasData) {
                            const frequencyOmissionData = this.getFrequencyOmissionData(recentDraws, periodCount);

                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #f5576c; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-line"></i> 遗漏+频率组合策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过分析号码的遗漏值和出现频率，筛选出"高频率+低遗漏"（强势号）和"低频率+待回补"（潜力号）两类号码进行组合，兼顾稳定性和回补机会。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 实际数据分析（基于${periodText}）：</strong>
                                    <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #f5576c;">
                                        <div style="margin-bottom: 10px;">
                                            <strong>强势号（高频率+低遗漏）：</strong>${frequencyOmissionData.strongNumbers.length > 0 ? frequencyOmissionData.strongNumbers.join('、') : '无'}
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                            <strong>潜力号（低频率+高遗漏）：</strong>${frequencyOmissionData.potentialNumbers.length > 0 ? frequencyOmissionData.potentialNumbers.join('、') : '无'}
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                            <strong>高频号码（前10）：</strong>${frequencyOmissionData.highFrequency.join('、')}
                                        </div>
                                        <div>
                                            <strong>低遗漏号码（前10）：</strong>${frequencyOmissionData.lowOmission.join('、')}
                                        </div>
                                    </div>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：分析频率分布</strong><br>打开"频率分析"模块，查看各号码的出现频率，识别高频号码（出现次数前30%）和低频号码（出现次数后30%）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：分析遗漏值</strong><br>打开"遗漏分析"模块，查看各号码的当前遗漏值，识别低遗漏号码（遗漏值前30%）和高遗漏号码（遗漏值后30%）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：筛选强势号</strong><br>结合频率和遗漏数据，筛选"高频率+低遗漏"的号码（如高频且遗漏值小于10期的号码），这类号码近期表现稳定，可作为主力号码。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：筛选潜力号</strong><br>结合频率和遗漏数据，筛选"低频率+待回补"的号码（如低频但遗漏值接近历史最大遗漏的号码），这类号码有回补机会，可作为辅助号码。</li>
                                        <li style="margin-bottom: 10px;"><strong>第五步：组合选号</strong><br>从强势号中选择3-4个作为主力号码，从潜力号中选择1-2个作为辅助号码，确保组合既有稳定性又有回补机会。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #f5576c; color: white; border-radius: 15px; font-size: 12px;">频率分析</span>
                                        <span style="padding: 5px 12px; background: #f5576c; color: white; border-radius: 15px; font-size: 12px;">遗漏分析</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>强势号和潜力号的比例建议为3:2或4:1，避免过度依赖某一类号码</li>
                                        <li>关注遗漏值的变化趋势，当遗漏值接近历史最大遗漏时，回补概率增加</li>
                                        <li>定期更新频率和遗漏数据，及时调整号码选择</li>
                                    </ul>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #f5576c; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-line"></i> 遗漏+频率组合策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过分析号码的遗漏值和出现频率，筛选出"高频率+低遗漏"（强势号）和"低频率+待回补"（潜力号）两类号码进行组合，兼顾稳定性和回补机会。</p>
                                </div>

                                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                                    <strong>⚠️ 数据不足提示：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">当前数据库暂无数据，请先导入开奖数据后再使用此策略。导入数据后，系统将自动分析最近30期的频率和遗漏数据，识别强势号和潜力号。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：分析频率分布</strong><br>打开"频率分析"模块，查看各号码的出现频率，识别高频号码（出现次数前30%）和低频号码（出现次数后30%）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：分析遗漏值</strong><br>打开"遗漏分析"模块，查看各号码的当前遗漏值，识别低遗漏号码（遗漏值前30%）和高遗漏号码（遗漏值后30%）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：筛选强势号</strong><br>结合频率和遗漏数据，筛选"高频率+低遗漏"的号码（如高频且遗漏值小于10期的号码），这类号码近期表现稳定，可作为主力号码。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：筛选潜力号</strong><br>结合频率和遗漏数据，筛选"低频率+待回补"的号码（如低频但遗漏值接近历史最大遗漏的号码），这类号码有回补机会，可作为辅助号码。</li>
                                        <li style="margin-bottom: 10px;"><strong>第五步：组合选号</strong><br>从强势号中选择3-4个作为主力号码，从潜力号中选择1-2个作为辅助号码，确保组合既有稳定性又有回补机会。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #f5576c; color: white; border-radius: 15px; font-size: 12px;">频率分析</span>
                                        <span style="padding: 5px 12px; background: #f5576c; color: white; border-radius: 15px; font-size: 12px;">遗漏分析</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>强势号和潜力号的比例建议为3:2或4:1，避免过度依赖某一类号码</li>
                                        <li>关注遗漏值的变化趋势，当遗漏值接近历史最大遗漏时，回补概率增加</li>
                                        <li>定期更新频率和遗漏数据，及时调整号码选择</li>
                                    </ul>
                                </div>
                            `;
                        }
                        break;

                    case 'trend':
                        borderColor = '#4facfe';

                        if (hasData) {
                            const trendData = this.getTrendData(recentDraws, periodCount);

                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #4facfe; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-trending-up"></i> 趋势追踪策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过分析号码的趋势变化，识别走势拐点和上升/下降趋势，并结合相关分析找出关联号码，进行延伸选号，捕捉趋势变化带来的机会。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 实际数据分析（基于${periodText}）：</strong>
                                    <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #4facfe;">
                                        <div style="margin-bottom: 10px;">
                                            <strong>上升趋势号码（前5）：</strong>${trendData.risingNumbers.length > 0 ? trendData.risingNumbers.join('、') : '无'}
                                        </div>
                                        <div>
                                            <strong>趋势分析说明：</strong>通过对比最近${Math.floor(periodCount/2)}期与前${Math.floor(periodCount/2)}期的出现次数，识别出近期表现活跃的上升趋势号码。
                                        </div>
                                    </div>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：分析趋势变化</strong><br>打开"趋势分析"模块，查看各号码的走势图，识别近期出现拐点的号码（如从下降转为上升的号码）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：确定趋势方向</strong><br>分析走势拐点后的趋势方向，确定哪些号码处于上升趋势（近期出现频率增加），哪些号码处于下降趋势（近期出现频率减少）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：分析相关号码</strong><br>打开"相关分析"模块，查看与趋势上升号码关联度高的号码，找出具有强相关性的号码组合。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：选择趋势号</strong><br>从处于上升趋势的号码中选择2-3个作为趋势号，这类号码近期表现活跃，有望继续上升。</li>
                                        <li style="margin-bottom: 10px;"><strong>第五步：延伸选号</strong><br>根据相关分析结果，从与趋势号关联度高的号码中选择2-3个作为延伸号，形成号码组合。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #4facfe; color: white; border-radius: 15px; font-size: 12px;">趋势分析</span>
                                        <span style="padding: 5px 12px; background: #4facfe; color: white; border-radius: 15px; font-size: 12px;">相关分析</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>趋势拐点识别应以${periodText}数据为参考，避免过度依赖长期数据</li>
                                        <li>相关分析应关注强相关系数（>0.7）的号码组合，弱相关关系可能不稳定</li>
                                        <li>定期更新趋势数据，及时调整选号策略，避免追涨杀跌</li>
                                    </ul>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #4facfe; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-trending-up"></i> 趋势追踪策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过分析号码的趋势变化，识别走势拐点和上升/下降趋势，并结合相关分析找出关联号码，进行延伸选号，捕捉趋势变化带来的机会。</p>
                                </div>

                                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                                    <strong>⚠️ 数据不足提示：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">当前数据库暂无数据，请先导入开奖数据后再使用此策略。导入数据后，系统将自动分析最近20期的趋势变化，识别上升趋势号码。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：分析趋势变化</strong><br>打开"趋势分析"模块，查看各号码的走势图，识别近期出现拐点的号码（如从下降转为上升的号码）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：确定趋势方向</strong><br>分析走势拐点后的趋势方向，确定哪些号码处于上升趋势（近期出现频率增加），哪些号码处于下降趋势（近期出现频率减少）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：分析相关号码</strong><br>打开"相关分析"模块，查看与趋势上升号码关联度高的号码，找出具有强相关性的号码组合。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：选择趋势号</strong><br>从处于上升趋势的号码中选择2-3个作为趋势号，这类号码近期表现活跃，有望继续上升。</li>
                                        <li style="margin-bottom: 10px;"><strong>第五步：延伸选号</strong><br>根据相关分析结果，从与趋势号关联度高的号码中选择2-3个作为延伸号，形成号码组合。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #4facfe; color: white; border-radius: 15px; font-size: 12px;">趋势分析</span>
                                        <span style="padding: 5px 12px; background: #4facfe; color: white; border-radius: 15px; font-size: 12px;">相关分析</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>趋势拐点识别应以近期10-20期数据为参考，避免过度依赖长期数据</li>
                                        <li>相关分析应关注强相关系数（>0.7）的号码组合，弱相关关系可能不稳定</li>
                                        <li>定期更新趋势数据，及时调整选号策略，避免追涨杀跌</li>
                                    </ul>
                                </div>
                            `;
                        }
                        break;

                    case 'pattern':
                        borderColor = '#43e97b';

                        if (hasData) {
                            const patternData = this.getPatternData(recentDraws, periodCount);

                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #43e97b; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-puzzle-piece"></i> 模式匹配策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过模式识别分析近期开奖号码的特征模式，识别高频出现的组合模式（如连号、同尾号、等差数列等），筛选符合这些特征的号码进行组合。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 实际数据分析（基于${periodText}）：</strong>
                                    <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #43e97b;">
                                        <div style="margin-bottom: 10px;">
                                            <strong>连号模式：</strong>出现 ${patternData.patterns.consecutive} 次
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                            <strong>同尾号模式：</strong>出现 ${patternData.patterns.sameTail} 次
                                        </div>
                                        <div style="margin-bottom: 10px;">
                                            <strong>等差数列模式：</strong>出现 ${patternData.patterns.arithmetic} 次
                                        </div>
                                        <div>
                                            <strong>最高频模式：</strong>${patternData.topPattern === 'consecutive' ? '连号' : patternData.topPattern === 'sameTail' ? '同尾号' : patternData.topPattern === 'arithmetic' ? '等差数列' : '无'}
                                        </div>
                                    </div>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：识别高频模式</strong><br>打开"模式识别"模块，查看近期${periodText}开奖号码的模式特征，识别高频出现的模式类型（如连号、同尾号、等差数列、对称分布等）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：分析模式特征</strong><br>对每种高频模式进行详细分析，确定其具体特征（如连号通常是2连号或3连号，同尾号通常是尾数0、5等）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：筛选符合模式的号码</strong><br>根据识别出的高频模式，筛选符合这些模式的号码（如近期连号模式频繁，则筛选可能形成连号的号码组合）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：组合选号</strong><br>将符合不同模式的号码进行组合，确保组合中包含1-2种高频模式的特征，提高中奖概率。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #43e97b; color: white; border-radius: 15px; font-size: 12px;">模式识别</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>模式识别应以${periodText}数据为参考，避免过度依赖长期数据</li>
                                        <li>不同模式的组合应避免冲突（如同时选择2连号和3连号可能导致号码重复）</li>
                                        <li>定期更新模式数据，及时调整选号策略，避免模式失效</li>
                                    </ul>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #43e97b; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-puzzle-piece"></i> 模式匹配策略
                                </h3>

                                <div style="margin-bottom: 20px;">
                                    <strong>📌 策略概述：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">通过模式识别分析近期开奖号码的特征模式，识别高频出现的组合模式（如连号、同尾号、等差数列等），筛选符合这些特征的号码进行组合。</p>
                                </div>

                                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                                    <strong>⚠️ 数据不足提示：</strong>
                                    <p style="margin: 5px 0 0 0; color: #555;">当前数据库暂无数据，请先导入开奖数据后再使用此策略。导入数据后，系统将自动分析最近20期的模式特征，识别高频出现的组合模式。</p>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>🎯 选号步骤：</strong>
                                    <ol style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li style="margin-bottom: 10px;"><strong>第一步：识别高频模式</strong><br>打开"模式识别"模块，查看近期10-20期开奖号码的模式特征，识别高频出现的模式类型（如连号、同尾号、等差数列、对称分布等）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第二步：分析模式特征</strong><br>对每种高频模式进行详细分析，确定其具体特征（如连号通常是2连号或3连号，同尾号通常是尾数0、5等）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第三步：筛选符合模式的号码</strong><br>根据识别出的高频模式，筛选符合这些模式的号码（如近期连号模式频繁，则筛选可能形成连号的号码组合）。</li>
                                        <li style="margin-bottom: 10px;"><strong>第四步：组合选号</strong><br>将符合不同模式的号码进行组合，确保组合中包含1-2种高频模式的特征，提高中奖概率。</li>
                                    </ol>
                                </div>

                                <div style="margin-bottom: 20px;">
                                    <strong>📊 需要调用的分析模块：</strong>
                                    <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span style="padding: 5px 12px; background: #43e97b; color: white; border-radius: 15px; font-size: 12px;">模式识别</span>
                                    </div>
                                </div>

                                <div>
                                    <strong>⚠️ 注意事项：</strong>
                                    <ul style="margin: 10px 0 0 0; padding-left: 20px; color: #555;">
                                        <li>模式识别应以近期10-20期数据为参考，避免过度依赖长期数据</li>
                                        <li>不同模式的组合应避免冲突（如同时选择2连号和3连号可能导致号码重复）</li>
                                        <li>定期更新模式数据，及时调整选号策略，避免模式失效</li>
                                    </ul>
                                </div>
                            `;
                        }
                        break;
                }

                detailContainer.innerHTML = content;
                detailContainer.style.borderLeftColor = borderColor;
                detailContainer.style.display = 'block';

                detailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            static performWarningAnalysis() {
                const periodSelect = document.getElementById('warningPeriodSelect');
                if (!periodSelect) {
                    MessageSystem.showMessage('未找到分析期数选择器', 'error');
                    return;
                }

                const periodValue = periodSelect.value;
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    MessageSystem.showMessage('当前数据库暂无数据，请先导入开奖数据', 'warning');
                    return;
                }

                let periodCount;
                if (periodValue === 'all') {
                    periodCount = draws.length;
                } else {
                    periodCount = parseInt(periodValue);
                }

                if (periodCount > draws.length) {
                    MessageSystem.showMessage(`数据库只有 ${draws.length} 期数据，无法分析 ${periodCount} 期`, 'warning');
                    return;
                }

                const recentDraws = draws.slice(-periodCount);

                MessageSystem.showMessage(`开始预警分析最近 ${periodCount} 期数据...`, 'info');

                setTimeout(() => {
                    const alertEngine = new AlertEngine();
                    const alerts = alertEngine.analyze(recentDraws);

                    const numberAlerts = alerts.filter(a => a.category === '号码级');
                    const combinationAlerts = alerts.filter(a => a.category === '组合级');
                    const statisticsAlerts = alerts.filter(a => a.category === '统计级');

                    document.getElementById('numberWarningCount').textContent = numberAlerts.length;
                    document.getElementById('indicatorWarningCount').textContent = combinationAlerts.length;
                    document.getElementById('trendWarningCount').textContent = statisticsAlerts.length;
                    document.getElementById('patternWarningCount').textContent = alerts.filter(a => a.name === '模式匹配').length;

                    const totalAlerts = alerts.length;
                    let riskLevel = '低';
                    let riskColor = '#28a745';

                    if (totalAlerts >= 15) {
                        riskLevel = '高';
                        riskColor = '#dc3545';
                    } else if (totalAlerts >= 8) {
                        riskLevel = '中';
                        riskColor = '#ffc107';
                    }

                    const alertStats = alertEngine.getAlertStats();

                    const summaryContent = `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 8px;">
                                <div style="font-size: 36px; font-weight: bold;">${totalAlerts}</div>
                                <div style="font-size: 14px; opacity: 0.9;">预警总数</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 8px;">
                                <div style="font-size: 36px; font-weight: bold; color: ${riskColor};">${riskLevel}</div>
                                <div style="font-size: 14px; opacity: 0.9;">风险等级</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.2); border-radius: 8px;">
                                <div style="font-size: 36px; font-weight: bold;">${periodCount}</div>
                                <div style="font-size: 14px; opacity: 0.9;">分析期数</div>
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.2); border-radius: 8px;">
                            <strong>📊 预警统计：</strong>
                            <ul style="margin: 10px 0 0 0; padding-left: 20px; opacity: 0.9;">
                                <li>今日预警：${alertStats.today}条</li>
                                <li>未读预警：${alertStats.unread}条</li>
                                <li>历史预警：${alertStats.total}条</li>
                                <li>命中统计：${alertStats.hitRate.toFixed(1)}%</li>
                            </ul>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.2); border-radius: 8px; margin-top: 10px;">
                            <strong>💡 预警建议：</strong>
                            <ul style="margin: 10px 0 0 0; padding-left: 20px; opacity: 0.9;">
                                ${riskLevel === '高' ? '<li>当前风险等级较高，建议谨慎选号，关注高风险预警项</li><li>建议等待风险缓解后再进行选号</li>' : ''}
                                ${riskLevel === '中' ? '<li>当前风险等级中等，建议结合多个预警项综合判断</li><li>可以适当关注中高风险预警项</li>' : ''}
                                ${riskLevel === '低' ? '<li>当前风险等级较低，可以正常选号</li><li>建议关注长期遗漏和冷热转换预警</li>' : ''}
                                <li>点击上方预警卡片查看详细预警信息</li>
                            </ul>
                        </div>
                    `;

                    const summaryContainer = document.getElementById('warningSummary');
                    if (summaryContainer) {
                        summaryContainer.style.display = 'block';
                        document.getElementById('warningSummaryContent').innerHTML = summaryContent;
                    }

                    MessageSystem.showMessage(`预警分析完成！发现 ${totalAlerts} 个预警项，风险等级：${riskLevel}`, 'success');
                }, 500);
            }

            static showWarningDetail(warningType) {
                const detailContainer = document.getElementById('warningDetail');
                if (!detailContainer) return;

                const draws = currentDatabaseData.draws || [];
                const hasData = draws.length > 0;

                let periodCount = 30;
                let periodText = '最近30期';

                const periodSelect = document.getElementById('warningPeriodSelect');
                if (periodSelect) {
                    const periodValue = periodSelect.value;
                    if (periodValue === 'all') {
                        periodCount = draws.length;
                        periodText = `全部${periodCount}期`;
                    } else {
                        periodCount = parseInt(periodValue);
                        periodText = `最近${periodCount}期`;
                    }
                }

                const recentDraws = draws.slice(-periodCount);
                const alertEngine = new AlertEngine();
                const alerts = alertEngine.analyze(recentDraws);

                let content = '';
                let borderColor = '';

                switch(warningType) {
                    case 'number':
                        borderColor = '#ff6b6b';
                        const numberAlerts = alerts.filter(a => a.category === '号码级');

                        if (numberAlerts.length === 0) {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #ff6b6b; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-hashtag"></i> 号码预警
                                </h3>
                                <div style="padding: 20px; text-align: center; color: #28a745;">
                                    <i class="fas fa-check-circle" style="font-size: 48px; margin-bottom: 15px;"></i>
                                    <p style="font-size: 18px; margin: 0;">未发现号码预警</p>
                                    <p style="margin: 5px 0 0 0; color: #666;">基于${periodText}数据分析，号码状态正常</p>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #ff6b6b; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-hashtag"></i> 号码预警（${numberAlerts.length}个）
                                </h3>
                                <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                                    <strong>⚠️ 预警说明：</strong>长期遗漏、冷热转换、异常波动等号码异常情况
                                </div>
                                <div style="max-height: 400px; overflow-y: auto;">
                                    ${numberAlerts.map(alert => {
                                        const levelColor = alert.level === 'high' ? '#dc3545' : alert.level === 'medium' ? '#ffc107' : '#28a745';
                                        const levelText = alert.level === 'high' ? '高' : alert.level === 'medium' ? '中' : '低';
                                        return `
                                        <div style="margin-bottom: 10px; padding: 12px; background: white; border-left: 4px solid ${levelColor}; border-radius: 4px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                                <strong style="color: ${levelColor};">
                                                    ${alert.name} - ${alert.number || ''}
                                                </strong>
                                                <span style="padding: 3px 8px; background: ${levelColor}; color: white; border-radius: 10px; font-size: 12px;">
                                                    ${levelText}风险
                                                </span>
                                            </div>
                                            <div style="color: #666; font-size: 14px;">${alert.description}</div>
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        }
                        break;

                    case 'indicator':
                        borderColor = '#feca57';
                        const combinationAlerts = alerts.filter(a => a.category === '组合级');

                        if (combinationAlerts.length === 0) {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #feca57; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-pie"></i> 指标预警
                                </h3>
                                <div style="padding: 20px; text-align: center; color: #28a745;">
                                    <i class="fas fa-check-circle" style="font-size: 48px; margin-bottom: 15px;"></i>
                                    <p style="font-size: 18px; margin: 0;">未发现指标预警</p>
                                    <p style="margin: 5px 0 0 0; color: #666;">基于${periodText}数据分析，指标状态正常</p>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #feca57; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-pie"></i> 指标预警（${combinationAlerts.length}个）
                                </h3>
                                <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                                    <strong>⚠️ 预警说明：</strong>奇偶比例、大小比例、AC值、和值等指标偏离正常范围
                                </div>
                                <div style="max-height: 400px; overflow-y: auto;">
                                    ${combinationAlerts.map(alert => {
                                        const levelColor = alert.level === 'high' ? '#dc3545' : alert.level === 'medium' ? '#ffc107' : '#28a745';
                                        const levelText = alert.level === 'high' ? '高' : alert.level === 'medium' ? '中' : '低';
                                        return `
                                        <div style="margin-bottom: 10px; padding: 12px; background: white; border-left: 4px solid ${levelColor}; border-radius: 4px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                                <strong style="color: ${levelColor};">
                                                    ${alert.name}
                                                </strong>
                                                <span style="padding: 3px 8px; background: ${levelColor}; color: white; border-radius: 10px; font-size: 12px;">
                                                    ${levelText}风险
                                                </span>
                                            </div>
                                            <div style="color: #666; font-size: 14px;">${alert.description}</div>
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        }
                        break;

                    case 'trend':
                        borderColor = '#48dbfb';
                        const statisticsAlerts = alerts.filter(a => a.category === '统计级');

                        if (statisticsAlerts.length === 0) {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #48dbfb; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-line"></i> 趋势预警
                                </h3>
                                <div style="padding: 20px; text-align: center; color: #28a745;">
                                    <i class="fas fa-check-circle" style="font-size: 48px; margin-bottom: 15px;"></i>
                                    <p style="font-size: 18px; margin: 0;">未发现趋势预警</p>
                                    <p style="margin: 5px 0 0 0; color: #666;">基于${periodText}数据分析，趋势状态正常</p>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #48dbfb; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-chart-line"></i> 趋势预警（${statisticsAlerts.length}个）
                                </h3>
                                <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                                    <strong>⚠️ 预警说明：</strong>走势转折、连号、重号等趋势异常情况
                                </div>
                                <div style="max-height: 400px; overflow-y: auto;">
                                    ${statisticsAlerts.map(alert => {
                                        const levelColor = alert.level === 'high' ? '#dc3545' : alert.level === 'medium' ? '#ffc107' : '#28a745';
                                        const levelText = alert.level === 'high' ? '高' : alert.level === 'medium' ? '中' : '低';
                                        return `
                                        <div style="margin-bottom: 10px; padding: 12px; background: white; border-left: 4px solid ${levelColor}; border-radius: 4px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                                <strong style="color: ${levelColor};">
                                                    ${alert.name} - ${alert.number || ''}
                                                </strong>
                                                <span style="padding: 3px 8px; background: ${levelColor}; color: white; border-radius: 10px; font-size: 12px;">
                                                    ${levelText}风险
                                                </span>
                                            </div>
                                            <div style="color: #666; font-size: 14px;">${alert.description}</div>
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        }
                        break;

                    case 'pattern':
                        borderColor = '#ff9ff3';
                        const patternAlerts = alerts.filter(a => a.name === '模式匹配');

                        if (patternAlerts.length === 0) {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #ff9ff3; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-puzzle-piece"></i> 模式预警
                                </h3>
                                <div style="padding: 20px; text-align: center; color: #28a745;">
                                    <i class="fas fa-check-circle" style="font-size: 48px; margin-bottom: 15px;"></i>
                                    <p style="font-size: 18px; margin: 0;">未发现模式预警</p>
                                    <p style="margin: 5px 0 0 0; color: #666;">基于${periodText}数据分析，模式状态正常</p>
                                </div>
                            `;
                        } else {
                            content = `
                                <h3 style="margin: 0 0 15px 0; color: #ff9ff3; display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-puzzle-piece"></i> 模式预警（${patternAlerts.length}个）
                                </h3>
                                <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                                    <strong>⚠️ 预警说明：</strong>重复模式、特殊组合等模式异常情况
                                </div>
                                <div style="max-height: 400px; overflow-y: auto;">
                                    ${patternAlerts.map(alert => {
                                        const levelColor = alert.level === 'high' ? '#dc3545' : alert.level === 'medium' ? '#ffc107' : '#28a745';
                                        const levelText = alert.level === 'high' ? '高' : alert.level === 'medium' ? '中' : '低';
                                        return `
                                        <div style="margin-bottom: 10px; padding: 12px; background: white; border-left: 4px solid ${levelColor}; border-radius: 4px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                                <strong style="color: ${levelColor};">
                                                    ${alert.name} - ${alert.number || ''}
                                                </strong>
                                                <span style="padding: 3px 8px; background: ${levelColor}; color: white; border-radius: 10px; font-size: 12px;">
                                                    ${levelText}风险
                                                </span>
                                            </div>
                                            <div style="color: #666; font-size: 14px;">${alert.description}</div>
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        }
                        break;
                }

                detailContainer.innerHTML = content;
                detailContainer.style.borderLeftColor = borderColor;
                detailContainer.style.display = 'block';
                detailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            static showWarningHistory() {
                const detailContainer = document.getElementById('warningDetail');
                if (!detailContainer) return;

                const draws = currentDatabaseData.draws || [];
                const alertEngine = new AlertEngine();
                const alerts = alertEngine.getAlertHistory(30);
                const effectiveness = alertEngine.analyzeAlertEffectiveness(draws, 30);

                const content = `
                    <h3 style="margin: 0 0 15px 0; color: #667eea; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-history"></i> 历史预警回溯
                    </h3>

                    <div style="margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; color: white;">
                            <div style="font-size: 14px; opacity: 0.9;">总预警数</div>
                            <div style="font-size: 28px; font-weight: bold;">${effectiveness.totalAlerts}</div>
                        </div>
                        <div style="padding: 15px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); border-radius: 8px; color: white;">
                            <div style="font-size: 14px; opacity: 0.9;">命中数</div>
                            <div style="font-size: 28px; font-weight: bold;">${effectiveness.hitCount}</div>
                        </div>
                        <div style="padding: 15px; background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); border-radius: 8px; color: white;">
                            <div style="font-size: 14px; opacity: 0.9;">未命中</div>
                            <div style="font-size: 28px; font-weight: bold;">${effectiveness.missCount}</div>
                        </div>
                        <div style="padding: 15px; background: linear-gradient(135deg, #ffc107 0%, #ff9f43 100%); border-radius: 8px; color: white;">
                            <div style="font-size: 14px; opacity: 0.9;">命中率</div>
                            <div style="font-size: 28px; font-weight: bold;">${effectiveness.hitRate.toFixed(1)}%</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #333;">分类统计</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                            ${Object.entries(effectiveness.categoryStats).map(([category, stats]) => `
                                <div style="padding: 12px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #667eea;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                        <strong>${category}</strong>
                                        <span style="font-size: 12px; color: #666;">${stats.total}条</span>
                                    </div>
                                    <div style="display: flex; gap: 10px; font-size: 12px;">
                                        <span style="color: #28a745;">命中: ${stats.hit}</span>
                                        <span style="color: #dc3545;">未命中: ${stats.miss}</span>
                                        <span style="color: #ffc107;">命中率: ${stats.hitRate.toFixed(1)}%</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #333;">级别统计</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                            ${Object.entries(effectiveness.levelStats).map(([level, stats]) => {
                                const levelColor = level === 'high' ? '#dc3545' : level === 'medium' ? '#ffc107' : '#28a745';
                                const levelText = level === 'high' ? '高' : level === 'medium' ? '中' : '低';
                                return `
                                <div style="padding: 12px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid ${levelColor};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                        <strong style="color: ${levelColor};">${levelText}风险</strong>
                                        <span style="font-size: 12px; color: #666;">${stats.total}条</span>
                                    </div>
                                    <div style="display: flex; gap: 10px; font-size: 12px;">
                                        <span style="color: #28a745;">命中: ${stats.hit}</span>
                                        <span style="color: #dc3545;">未命中: ${stats.miss}</span>
                                        <span style="color: #ffc107;">命中率: ${stats.hitRate.toFixed(1)}%</span>
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 style="margin: 0; color: #333;">预警记录</h4>
                            <button class="btn btn-secondary" onclick="const alertEngine = new AlertEngine(); alertEngine.exportAlertHistory(30);" style="padding: 5px 10px; font-size: 12px;">
                                <i class="fas fa-download"></i> 导出CSV
                            </button>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            ${alerts.length === 0 ? `
                                <div style="padding: 20px; text-align: center; color: #666;">
                                    <i class="fas fa-inbox" style="font-size: 48px; margin-bottom: 15px;"></i>
                                    <p>暂无历史预警记录</p>
                                </div>
                            ` : alerts.map(alert => {
                                const levelColor = alert.level === 'high' ? '#dc3545' : alert.level === 'medium' ? '#ffc107' : '#28a745';
                                const levelText = alert.level === 'high' ? '高' : alert.level === 'medium' ? '中' : '低';
                                return `
                                <div style="margin-bottom: 10px; padding: 12px; background: white; border-left: 4px solid ${levelColor}; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                        <strong style="color: ${levelColor};">
                                            ${alert.name} ${alert.number ? `- ${alert.number}` : ''}
                                        </strong>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="padding: 3px 8px; background: ${levelColor}; color: white; border-radius: 10px; font-size: 12px;">
                                                ${levelText}风险
                                            </span>
                                            <span style="font-size: 12px; color: #666;">
                                                ${new Date(alert.timestamp).toLocaleString('zh-CN')}
                                            </span>
                                        </div>
                                    </div>
                                    <div style="color: #666; font-size: 14px;">${alert.description}</div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                detailContainer.innerHTML = content;
                detailContainer.style.borderLeftColor = '#667eea';
                detailContainer.style.display = 'block';
                detailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            static switchEvaluationTab(tabName) {
                const tabs = document.querySelectorAll('.evaluation-tab-btn');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.getAttribute('data-tab') === tabName) {
                        tab.classList.add('active');
                    }
                });

                const panels = document.querySelectorAll('.evaluation-content-panel');
                panels.forEach(panel => {
                    panel.style.display = 'none';
                });

                const activePanel = document.getElementById(`${tabName}Evaluation`);
                if (activePanel) {
                    activePanel.style.display = 'block';
                }
            }

            static performEvaluationAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const periodSelect = document.getElementById('evaluationPeriodSelect');
                    if (!periodSelect) {
                        MessageSystem.showMessage('未找到分析期数选择器', 'error');
                        return;
                    }

                    const periodValue = periodSelect.value;
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('当前数据库暂无数据，请先导入开奖数据', 'warning');
                        return;
                    }

                    let periodCount;
                    if (periodValue === 'all') {
                        periodCount = draws.length;
                    } else {
                        periodCount = parseInt(periodValue);
                    }

                    if (periodCount > draws.length) {
                        MessageSystem.showMessage(`数据库只有 ${draws.length} 期数据，无法分析 ${periodCount} 期`, 'warning');
                        return;
                    }

                    const recentDraws = draws.slice(-periodCount);

                    // 更新分析范围显示
                    const evaluationDataRangeInfo = document.getElementById('evaluationDataRangeInfo');
                    if (evaluationDataRangeInfo && recentDraws.length > 0) {
                        const startPeriod = recentDraws[0].period;
                        const endPeriod = recentDraws[recentDraws.length - 1].period;
                        evaluationDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${recentDraws.length}期）`;
                    }

                    MessageSystem.showMessage(`开始评估分析最近 ${periodCount} 期数据...`, 'info');

                    setTimeout(() => {
                        this.updateBasicEvaluation(recentDraws, periodCount);
                        this.updateAdvancedEvaluation(recentDraws, periodCount);
                        this.updateRecommendationEvaluation(recentDraws, periodCount);
                        this.updateStrategyEvaluation(recentDraws, periodCount);

                        MessageSystem.showMessage(`评估分析完成！已生成最近 ${periodCount} 期的评估结果`, 'success');
                    }, 500);
                });
            }

            static updateBasicEvaluation(draws, periodCount) {
                const frequencyScore = this.calculateFrequencyScore(draws);
                const omissionScore = this.calculateOmissionScore(draws);
                const hotColdScore = this.calculateHotColdScore(draws);
                const oddEvenScore = this.calculateOddEvenScore(draws);
                const bigSmallScore = this.calculateBigSmallScore(draws);
                const primeCompositeScore = this.calculatePrimeCompositeScore(draws);
                const acValueScore = this.calculateACValueScore(draws);
                const threeZoneScore = this.calculateThreeZoneScore(draws);

                document.getElementById('frequencyEvaluationScore').textContent = frequencyScore;
                document.getElementById('omissionEvaluationScore').textContent = omissionScore;
                document.getElementById('hotColdEvaluationScore').textContent = hotColdScore;
                document.getElementById('oddEvenEvaluationScore').textContent = oddEvenScore;
                document.getElementById('bigSmallEvaluationScore').textContent = bigSmallScore;
                document.getElementById('primeCompositeEvaluationScore').textContent = primeCompositeScore;
                document.getElementById('acValueEvaluationScore').textContent = acValueScore;
                document.getElementById('threeZoneEvaluationScore').textContent = threeZoneScore;
            }

            static updateAdvancedEvaluation(draws, periodCount) {
                const trendScore = this.calculateTrendScore(draws);
                const correlationScore = this.calculateCorrelationScore(draws);
                const statisticsScore = this.calculateStatisticsScore(draws);
                const patternScore = this.calculatePatternScore(draws);
                const dnaScore = this.calculateDNAScore(draws);
                const recoveryScore = this.calculateRecoveryScore(draws);
                const mandelbrotScore = this.calculateMandelbrotScore(draws);

                document.getElementById('trendEvaluationScore').textContent = trendScore;
                document.getElementById('correlationEvaluationScore').textContent = correlationScore;
                document.getElementById('statisticsEvaluationScore').textContent = statisticsScore;
                document.getElementById('patternEvaluationScore').textContent = patternScore;
                document.getElementById('dnaEvaluationScore').textContent = dnaScore;
                document.getElementById('recoveryEvaluationScore').textContent = recoveryScore;
                document.getElementById('mandelbrotEvaluationScore').textContent = mandelbrotScore;
            }

            static updateRecommendationEvaluation(draws, periodCount) {
                const qualityScore = this.calculateRecommendationQuality(draws);
                const confidenceScore = this.calculateRecommendationConfidence(draws);
                const accuracyScore = this.calculateRecommendationAccuracy(draws);

                document.getElementById('recommendationQualityScore').textContent = qualityScore;
                document.getElementById('recommendationConfidence').textContent = confidenceScore;
                document.getElementById('recommendationAccuracy').textContent = accuracyScore;

                const recommendations = this.generateRecommendations(draws, periodCount);
                const recommendationList = document.getElementById('recommendationList');
                if (recommendationList) {
                    if (recommendations.length > 0) {
                        recommendationList.innerHTML = recommendations.map(rec => `
                            <div style="padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff;">
                                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">推荐号码</div>
                                <div style="font-size: 18px; font-weight: bold; color: #333;">${rec.redBalls.join(' ')} + ${rec.blueBalls.join(' ')}</div>
                                <div style="font-size: 12px; color: #999; margin-top: 5px;">推荐理由: ${rec.reason}</div>
                            </div>
                        `).join('');
                    } else {
                        recommendationList.innerHTML = `
                            <div style="padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff;">
                                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">推荐号码</div>
                                <div style="font-size: 18px; font-weight: bold; color: #333;">暂无推荐</div>
                            </div>
                        `;
                    }
                }
            }

            static updateStrategyEvaluation(draws, periodCount) {
                const basicStrategyScore = this.evaluateBasicStrategy(draws);
                const omissionStrategyScore = this.evaluateOmissionStrategy(draws);
                const trendStrategyScore = this.evaluateTrendStrategy(draws);
                const patternStrategyScore = this.evaluatePatternStrategy(draws);

                document.getElementById('basicStrategyScore').textContent = basicStrategyScore;
                document.getElementById('omissionStrategyScore').textContent = omissionStrategyScore;
                document.getElementById('trendStrategyScore').textContent = trendStrategyScore;
                document.getElementById('patternStrategyScore').textContent = patternStrategyScore;

                const strategies = this.getStrategyDetails(draws, periodCount);
                const strategyList = document.getElementById('strategyList');
                if (strategyList) {
                    if (strategies.length > 0) {
                        strategyList.innerHTML = strategies.map(str => `
                            <div style="padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff; margin-bottom: 10px;">
                                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">策略名称</div>
                                <div style="font-size: 16px; font-weight: bold; color: #333;">${str.name}</div>
                                <div style="font-size: 12px; color: #999; margin-top: 5px;">策略效果: ${str.effect}</div>
                                ${str.details ? `<div style="font-size: 12px; color: #666; margin-top: 5px; background: #f8f9fa; padding: 8px; border-radius: 4px;">${str.details}</div>` : ''}
                            </div>
                        `).join('');
                    } else {
                        strategyList.innerHTML = `
                            <div style="padding: 15px; background: white; border-radius: 8px; border-left: 4px solid #007bff;">
                                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">策略名称</div>
                                <div style="font-size: 16px; font-weight: bold; color: #333;">暂无策略详情</div>
                            </div>
                        `;
                    }
                }
            }

            static calculateFrequencyScore(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                if (frequencies.length === 0) {
                    return '0.0分';
                }

                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = avgFrequency > 0 ? stdDev / avgFrequency : 0;

                const sortedFrequencies = frequencies.sort((a, b) => a - b);
                const medianFrequency = sortedFrequencies[Math.floor(sortedFrequencies.length / 2)];
                const q1 = sortedFrequencies[Math.floor(sortedFrequencies.length / 4)];
                const q3 = sortedFrequencies[Math.floor(sortedFrequencies.length * 3 / 4)];
                const iqr = q3 - q1;

                const normalDistributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const distributionBalanceScore = avgFrequency > 0 ? 1 - Math.abs(avgFrequency - medianFrequency) / avgFrequency : 0;
                const spreadScore = avgFrequency > 0 ? 1 - Math.min(1, iqr / avgFrequency) : 0;

                const frequencyConsistency = frequencies.filter(f => Math.abs(f - avgFrequency) <= stdDev).length / frequencies.length;
                const consistencyScore = frequencyConsistency;

                const hotNumbers = frequencies.filter(f => f > avgFrequency + stdDev).length;
                const coldNumbers = frequencies.filter(f => f < avgFrequency - stdDev).length;
                const hotColdBalanceScore = frequencies.length > 0 ? 1 - Math.abs(hotNumbers - coldNumbers) / frequencies.length : 0;

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const expectedFrequency = draws.length * 6 / redBallRange;
                const frequencyAccuracy = avgFrequency > 0 ? 1 - Math.abs(avgFrequency - expectedFrequency) / expectedFrequency : 0;

                const frequencyStability = [];
                for (let i = 1; i < redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const numFrequency = frequencyMap[num] || 0;
                    if (numFrequency > 0) {
                        frequencyStability.push(numFrequency);
                    }
                }
                const stabilityScore = frequencyStability.length > 0 ? 1 - (Math.max(...frequencyStability) - Math.min(...frequencyStability)) / avgFrequency : 0;

                const finalScore = (normalDistributionScore * 0.20 + distributionBalanceScore * 0.15 + spreadScore * 0.10 + consistencyScore * 0.20 + hotColdBalanceScore * 0.15 + frequencyAccuracy * 0.10 + stabilityScore * 0.10) * 100;
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateOmissionScore(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const omissionMap = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    omissionMap[i] = 0;
                }

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        omissionMap[num] = 0;
                    });

                    for (let i = 1; i <= redBallRange; i++) {
                        if (!redBalls.includes(i.toString())) {
                            omissionMap[i]++;
                        }
                    }
                });

                const omissions = Object.values(omissionMap);
                const avgOmission = omissions.reduce((sum, o) => sum + o, 0) / omissions.length;
                const variance = omissions.reduce((sum, o) => sum + Math.pow(o - avgOmission, 2), 0) / omissions.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgOmission;

                const sortedOmissions = omissions.sort((a, b) => a - b);
                const medianOmission = sortedOmissions[Math.floor(sortedOmissions.length / 2)];
                const q1 = sortedOmissions[Math.floor(sortedOmissions.length / 4)];
                const q3 = sortedOmissions[Math.floor(sortedOmissions.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.4);
                const balanceScore = avgOmission > 0 ? 1 - Math.abs(avgOmission - medianOmission) / avgOmission : 0;
                const spreadScore = avgOmission > 0 ? 1 - Math.min(1, iqr / avgOmission) : 0;

                const normalOmissions = omissions.filter(o => Math.abs(o - avgOmission) <= stdDev).length / omissions.length;
                const consistencyScore = normalOmissions;

                const highOmissionNumbers = omissions.filter(o => o > avgOmission + stdDev).length;
                const lowOmissionNumbers = omissions.filter(o => o < avgOmission - stdDev).length;
                const balanceScore2 = omissions.length > 0 ? 1 - Math.abs(highOmissionNumbers - lowOmissionNumbers) / omissions.length : 0;

                const maxOmission = Math.max(...omissions);
                const minOmission = Math.min(...omissions);
                const rangeRatio = avgOmission > 0 ? (maxOmission - minOmission) / avgOmission : 0;
                const rangeScore = 1 - Math.min(1, rangeRatio / 2);

                const expectedOmission = draws.length / redBallRange;
                const omissionAccuracy = avgOmission > 0 ? 1 - Math.abs(avgOmission - expectedOmission) / expectedOmission : 0;

                const omissionStability = [];
                for (let i = 1; i <= redBallRange; i++) {
                    const numOmission = omissionMap[i];
                    if (numOmission > 0) {
                        omissionStability.push(numOmission);
                    }
                }
                const stabilityScore = omissionStability.length > 0 ? 1 - (Math.max(...omissionStability) - Math.min(...omissionStability)) / avgOmission : 0;

                const recoveryPotential = omissions.filter(o => o > avgOmission).length / omissions.length;
                const recoveryScore = recoveryPotential * 2;

                const finalScore = (distributionScore * 0.20 + balanceScore * 0.15 + spreadScore * 0.10 + consistencyScore * 0.15 + balanceScore2 * 0.10 + rangeScore * 0.10 + omissionAccuracy * 0.10 + stabilityScore * 0.05 + recoveryScore * 0.05) * 100;
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateHotColdScore(draws) {
                const advancedHotColdData = this.calculateAdvancedHotCold(draws);
                
                if (!advancedHotColdData || Object.keys(advancedHotColdData).length === 0) {
                    return '0.0分';
                }

                const scores = Object.values(advancedHotColdData).map(data => data.hotColdScore).filter(score => !isNaN(score) && isFinite(score));

                if (scores.length === 0) {
                    return '0.0分';
                }

                const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;

                if (isNaN(avgScore) || !isFinite(avgScore)) {
                    return '0.0分';
                }

                const variance = scores.reduce((acc, score) => acc + Math.pow(score - avgScore, 2), 0) / scores.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = avgScore > 0 ? stdDev / avgScore : 0;

                const hotNumbers = Object.values(advancedHotColdData).filter(data => data.hotColdState === '超热' || data.hotColdState === '热').length;
                const coldNumbers = Object.values(advancedHotColdData).filter(data => data.hotColdState === '超冷' || data.hotColdState === '冷').length;
                const totalNumbers = Object.keys(advancedHotColdData).length;

                if (totalNumbers === 0) {
                    return '0.0分';
                }

                const hotColdRatio = totalNumbers > 0 ? (hotNumbers + coldNumbers) / totalNumbers : 0;
                const distributionScore = Math.max(0, Math.min(100, hotColdRatio * 100));

                const stabilityScores = Object.values(advancedHotColdData).map(data => data.hotColdPersistence).filter(score => !isNaN(score) && isFinite(score));
                const avgStability = stabilityScores.length > 0 ? stabilityScores.reduce((sum, score) => sum + score, 0) / stabilityScores.length : 0;

                const predictabilityScores = Object.values(advancedHotColdData).map(data => data.hotColdPredictability).filter(score => !isNaN(score) && isFinite(score));
                const avgPredictability = predictabilityScores.length > 0 ? predictabilityScores.reduce((sum, score) => sum + score, 0) / predictabilityScores.length : 0;

                const reasonablenessScores = Object.values(advancedHotColdData).map(data => {
                    const reasonableness = data.hotColdReasonableness;
                    switch (reasonableness) {
                        case '优秀': return 90;
                        case '良好': return 75;
                        case '正常': return 60;
                        case '偏低': return 45;
                        case '异常': return 30;
                        default: return 50;
                    }
                });
                const avgReasonableness = reasonablenessScores.length > 0 ? reasonablenessScores.reduce((sum, score) => sum + score, 0) / reasonablenessScores.length : 50;

                const safeAvgScore = isNaN(avgScore) || !isFinite(avgScore) ? 0 : avgScore;
                const safeDistributionScore = isNaN(distributionScore) || !isFinite(distributionScore) ? 0 : distributionScore;
                const safeAvgStability = isNaN(avgStability) || !isFinite(avgStability) ? 0 : avgStability;
                const safeAvgPredictability = isNaN(avgPredictability) || !isFinite(avgPredictability) ? 0 : avgPredictability;
                const safeAvgReasonableness = isNaN(avgReasonableness) || !isFinite(avgReasonableness) ? 0 : avgReasonableness;

                const finalScore = (safeAvgScore * 0.3 + safeDistributionScore * 0.2 + safeAvgStability * 0.2 + safeAvgPredictability * 0.15 + safeAvgReasonableness * 0.15);

                if (isNaN(finalScore) || !isFinite(finalScore)) {
                    return '0.0分';
                }

                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateOddEvenScore(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const oddEvenMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    let oddCount = 0;
                    let evenCount = 0;
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num % 2 === 0) {
                            evenCount++;
                        } else {
                            oddCount++;
                        }
                    });
                    const ratio = `${oddCount}:${evenCount}`;
                    oddEvenMap[ratio] = (oddEvenMap[ratio] || 0) + 1;
                });

                const ratios = Object.entries(oddEvenMap).sort((a, b) => b[1] - a[1]);
                const topRatio = ratios[0];
                const topRatioScore = (topRatio[1] / draws.length) * 100;

                const oddCounts = [];
                const evenCounts = [];
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    let oddCount = 0;
                    let evenCount = 0;
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num % 2 === 0) {
                            evenCount++;
                        } else {
                            oddCount++;
                        }
                    });
                    oddCounts.push(oddCount);
                    evenCounts.push(evenCount);
                });

                const avgOddCount = oddCounts.reduce((sum, c) => sum + c, 0) / oddCounts.length;
                const avgEvenCount = evenCounts.reduce((sum, c) => sum + c, 0) / evenCounts.length;
                const oddVariance = oddCounts.reduce((sum, c) => sum + Math.pow(c - avgOddCount, 2), 0) / oddCounts.length;
                const evenVariance = evenCounts.reduce((sum, c) => sum + Math.pow(c - avgEvenCount, 2), 0) / evenCounts.length;
                const oddStdDev = Math.sqrt(oddVariance);
                const evenStdDev = Math.sqrt(evenVariance);

                const oddConsistency = oddCounts.filter(c => Math.abs(c - avgOddCount) <= oddStdDev).length / oddCounts.length;
                const evenConsistency = evenCounts.filter(c => Math.abs(c - avgEvenCount) <= evenStdDev).length / evenCounts.length;
                const consistencyScore = (oddConsistency + evenConsistency) / 2;

                const balanceScore = 1 - Math.abs(avgOddCount - avgEvenCount) / 6;

                const oddEvenRatio = avgEvenCount > 0 ? avgOddCount / avgEvenCount : 0;
                const idealRatio = 1;
                const ratioScore = 1 - Math.abs(oddEvenRatio - idealRatio) / idealRatio;

                const sortedOddCounts = oddCounts.sort((a, b) => a - b);
                const sortedEvenCounts = evenCounts.sort((a, b) => a - b);
                const oddMedian = sortedOddCounts[Math.floor(sortedOddCounts.length / 2)];
                const evenMedian = sortedEvenCounts[Math.floor(sortedEvenCounts.length / 2)];
                const oddBalance = avgOddCount > 0 ? 1 - Math.abs(avgOddCount - oddMedian) / avgOddCount : 0;
                const evenBalance = avgEvenCount > 0 ? 1 - Math.abs(avgEvenCount - evenMedian) / avgEvenCount : 0;
                const medianBalanceScore = (oddBalance + evenBalance) / 2;

                const expectedOddCount = 3;
                const expectedEvenCount = 3;
                const oddAccuracy = avgOddCount > 0 ? 1 - Math.abs(avgOddCount - expectedOddCount) / expectedOddCount : 0;
                const evenAccuracy = avgEvenCount > 0 ? 1 - Math.abs(avgEvenCount - expectedEvenCount) / expectedEvenCount : 0;
                const accuracyScore = (oddAccuracy + evenAccuracy) / 2;

                const oddEvenTransitions = [];
                for (let i = 1; i < draws.length; i++) {
                    const prevOddCount = oddCounts[i - 1];
                    const currOddCount = oddCounts[i];
                    oddEvenTransitions.push(Math.abs(currOddCount - prevOddCount));
                }
                const avgTransition = oddEvenTransitions.length > 0 ? oddEvenTransitions.reduce((sum, t) => sum + t, 0) / oddEvenTransitions.length : 0;
                const transitionStability = avgTransition > 0 ? 1 - avgTransition / 6 : 0;

                const diversityScore = Object.keys(oddEvenMap).length / 7;

                const finalScore = (topRatioScore * 0.25 + consistencyScore * 100 * 0.20 + balanceScore * 100 * 0.15 + ratioScore * 100 * 0.15 + medianBalanceScore * 100 * 0.10 + accuracyScore * 100 * 0.10 + transitionStability * 100 * 0.03 + diversityScore * 100 * 0.02);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateBigSmallScore(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const bigSmallMap = {};
                const midPoint = 17;

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    let bigCount = 0;
                    let smallCount = 0;
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num > midPoint) {
                            bigCount++;
                        } else {
                            smallCount++;
                        }
                    });
                    const ratio = `${bigCount}:${smallCount}`;
                    bigSmallMap[ratio] = (bigSmallMap[ratio] || 0) + 1;
                });

                const ratios = Object.entries(bigSmallMap).sort((a, b) => b[1] - a[1]);
                const topRatio = ratios[0];
                const topRatioScore = (topRatio[1] / draws.length) * 100;

                const bigCounts = [];
                const smallCounts = [];
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    let bigCount = 0;
                    let smallCount = 0;
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num > midPoint) {
                            bigCount++;
                        } else {
                            smallCount++;
                        }
                    });
                    bigCounts.push(bigCount);
                    smallCounts.push(smallCount);
                });

                const avgBigCount = bigCounts.reduce((sum, c) => sum + c, 0) / bigCounts.length;
                const avgSmallCount = smallCounts.reduce((sum, c) => sum + c, 0) / smallCounts.length;
                const bigVariance = bigCounts.reduce((sum, c) => sum + Math.pow(c - avgBigCount, 2), 0) / bigCounts.length;
                const smallVariance = smallCounts.reduce((sum, c) => sum + Math.pow(c - avgSmallCount, 2), 0) / smallCounts.length;
                const bigStdDev = Math.sqrt(bigVariance);
                const smallStdDev = Math.sqrt(smallVariance);

                const bigConsistency = bigCounts.filter(c => Math.abs(c - avgBigCount) <= bigStdDev).length / bigCounts.length;
                const smallConsistency = smallCounts.filter(c => Math.abs(c - avgSmallCount) <= smallStdDev).length / smallCounts.length;
                const consistencyScore = (bigConsistency + smallConsistency) / 2;

                const balanceScore = 1 - Math.abs(avgBigCount - avgSmallCount) / 6;

                const bigSmallRatio = avgSmallCount > 0 ? avgBigCount / avgSmallCount : 0;
                const idealRatio = 1;
                const ratioScore = 1 - Math.abs(bigSmallRatio - idealRatio) / idealRatio;

                const sortedBigCounts = bigCounts.sort((a, b) => a - b);
                const sortedSmallCounts = smallCounts.sort((a, b) => a - b);
                const bigMedian = sortedBigCounts[Math.floor(sortedBigCounts.length / 2)];
                const smallMedian = sortedSmallCounts[Math.floor(sortedSmallCounts.length / 2)];
                const bigBalance = avgBigCount > 0 ? 1 - Math.abs(avgBigCount - bigMedian) / avgBigCount : 0;
                const smallBalance = avgSmallCount > 0 ? 1 - Math.abs(avgSmallCount - smallMedian) / avgSmallCount : 0;
                const medianBalanceScore = (bigBalance + smallBalance) / 2;

                const expectedBigCount = 3;
                const expectedSmallCount = 3;
                const bigAccuracy = avgBigCount > 0 ? 1 - Math.abs(avgBigCount - expectedBigCount) / expectedBigCount : 0;
                const smallAccuracy = avgSmallCount > 0 ? 1 - Math.abs(avgSmallCount - expectedSmallCount) / expectedSmallCount : 0;
                const accuracyScore = (bigAccuracy + smallAccuracy) / 2;

                const bigSmallTransitions = [];
                for (let i = 1; i < draws.length; i++) {
                    const prevBigCount = bigCounts[i - 1];
                    const currBigCount = bigCounts[i];
                    bigSmallTransitions.push(Math.abs(currBigCount - prevBigCount));
                }
                const avgTransition = bigSmallTransitions.length > 0 ? bigSmallTransitions.reduce((sum, t) => sum + t, 0) / bigSmallTransitions.length : 0;
                const transitionStability = avgTransition > 0 ? 1 - avgTransition / 6 : 0;

                const diversityScore = Object.keys(bigSmallMap).length / 7;

                const finalScore = (topRatioScore * 0.25 + consistencyScore * 100 * 0.20 + balanceScore * 100 * 0.15 + ratioScore * 100 * 0.15 + medianBalanceScore * 100 * 0.10 + accuracyScore * 100 * 0.10 + transitionStability * 100 * 0.03 + diversityScore * 100 * 0.02);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculatePrimeCompositeScore(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const primeCompositeMap = {};
                const isPrime = (num) => {
                    if (num < 2) return false;
                    for (let i = 2; i <= Math.sqrt(num); i++) {
                        if (num % i === 0) return false;
                    }
                    return true;
                };

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    let primeCount = 0;
                    let compositeCount = 0;
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (isPrime(num)) {
                            primeCount++;
                        } else {
                            compositeCount++;
                        }
                    });
                    const ratio = `${primeCount}:${compositeCount}`;
                    primeCompositeMap[ratio] = (primeCompositeMap[ratio] || 0) + 1;
                });

                const ratios = Object.entries(primeCompositeMap).sort((a, b) => b[1] - a[1]);
                const topRatio = ratios[0];
                const topRatioScore = (topRatio[1] / draws.length) * 100;

                const primeCounts = [];
                const compositeCounts = [];
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    let primeCount = 0;
                    let compositeCount = 0;
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (isPrime(num)) {
                            primeCount++;
                        } else {
                            compositeCount++;
                        }
                    });
                    primeCounts.push(primeCount);
                    compositeCounts.push(compositeCount);
                });

                const avgPrimeCount = primeCounts.reduce((sum, c) => sum + c, 0) / primeCounts.length;
                const avgCompositeCount = compositeCounts.reduce((sum, c) => sum + c, 0) / compositeCounts.length;
                const primeVariance = primeCounts.reduce((sum, c) => sum + Math.pow(c - avgPrimeCount, 2), 0) / primeCounts.length;
                const compositeVariance = compositeCounts.reduce((sum, c) => sum + Math.pow(c - avgCompositeCount, 2), 0) / compositeCounts.length;
                const primeStdDev = Math.sqrt(primeVariance);
                const compositeStdDev = Math.sqrt(compositeVariance);

                const primeConsistency = primeCounts.filter(c => Math.abs(c - avgPrimeCount) <= primeStdDev).length / primeCounts.length;
                const compositeConsistency = compositeCounts.filter(c => Math.abs(c - avgCompositeCount) <= compositeStdDev).length / compositeCounts.length;
                const consistencyScore = (primeConsistency + compositeConsistency) / 2;

                const balanceScore = 1 - Math.abs(avgPrimeCount - avgCompositeCount) / 6;

                const primeCompositeRatio = avgCompositeCount > 0 ? avgPrimeCount / avgCompositeCount : 0;
                const idealRatio = 1;
                const ratioScore = 1 - Math.abs(primeCompositeRatio - idealRatio) / idealRatio;

                const sortedPrimeCounts = primeCounts.sort((a, b) => a - b);
                const sortedCompositeCounts = compositeCounts.sort((a, b) => a - b);
                const primeMedian = sortedPrimeCounts[Math.floor(sortedPrimeCounts.length / 2)];
                const compositeMedian = sortedCompositeCounts[Math.floor(sortedCompositeCounts.length / 2)];
                const primeBalance = avgPrimeCount > 0 ? 1 - Math.abs(avgPrimeCount - primeMedian) / avgPrimeCount : 0;
                const compositeBalance = avgCompositeCount > 0 ? 1 - Math.abs(avgCompositeCount - compositeMedian) / avgCompositeCount : 0;
                const medianBalanceScore = (primeBalance + compositeBalance) / 2;

                const expectedPrimeCount = 3;
                const expectedCompositeCount = 3;
                const primeAccuracy = avgPrimeCount > 0 ? 1 - Math.abs(avgPrimeCount - expectedPrimeCount) / expectedPrimeCount : 0;
                const compositeAccuracy = avgCompositeCount > 0 ? 1 - Math.abs(avgCompositeCount - expectedCompositeCount) / expectedCompositeCount : 0;
                const accuracyScore = (primeAccuracy + compositeAccuracy) / 2;

                const primeCompositeTransitions = [];
                for (let i = 1; i < draws.length; i++) {
                    const prevPrimeCount = primeCounts[i - 1];
                    const currPrimeCount = primeCounts[i];
                    primeCompositeTransitions.push(Math.abs(currPrimeCount - prevPrimeCount));
                }
                const avgTransition = primeCompositeTransitions.length > 0 ? primeCompositeTransitions.reduce((sum, t) => sum + t, 0) / primeCompositeTransitions.length : 0;
                const transitionStability = avgTransition > 0 ? 1 - avgTransition / 6 : 0;

                const diversityScore = Object.keys(primeCompositeMap).length / 7;

                const finalScore = (topRatioScore * 0.25 + consistencyScore * 100 * 0.20 + balanceScore * 100 * 0.15 + ratioScore * 100 * 0.15 + medianBalanceScore * 100 * 0.10 + accuracyScore * 100 * 0.10 + transitionStability * 100 * 0.03 + diversityScore * 100 * 0.02);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateACValueScore(draws) {
                const acValues = [];

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const numbers = redBalls.map(b => parseInt(b));
                    let differences = new Set();
                    for (let i = 0; i < numbers.length; i++) {
                        for (let j = i + 1; j < numbers.length; j++) {
                            differences.add(Math.abs(numbers[i] - numbers[j]));
                        }
                    }
                    const acValue = differences.size - (numbers.length - 1);
                    acValues.push(acValue);
                });

                const avgACValue = acValues.reduce((sum, ac) => sum + ac, 0) / acValues.length;
                const variance = acValues.reduce((sum, ac) => sum + Math.pow(ac - avgACValue, 2), 0) / acValues.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgACValue;

                const sortedACValues = acValues.sort((a, b) => a - b);
                const medianACValue = sortedACValues[Math.floor(sortedACValues.length / 2)];
                const q1 = sortedACValues[Math.floor(sortedACValues.length / 4)];
                const q3 = sortedACValues[Math.floor(sortedACValues.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const balanceScore = 1 - Math.abs(avgACValue - medianACValue) / avgACValue;
                const spreadScore = 1 - (iqr / avgACValue);

                const normalACValues = acValues.filter(ac => Math.abs(ac - avgACValue) <= stdDev).length / acValues.length;
                const consistencyScore = normalACValues;

                const idealACValue = 6;
                const idealScore = 1 - Math.abs(avgACValue - idealACValue) / idealACValue;

                const maxACValue = Math.max(...acValues);
                const minACValue = Math.min(...acValues);
                const rangeRatio = (maxACValue - minACValue) / avgACValue;
                const rangeScore = 1 - Math.min(1, rangeRatio / 2);

                const finalScore = (distributionScore * 0.25 + balanceScore * 0.20 + spreadScore * 0.15 + consistencyScore * 0.15 + idealScore * 0.15 + rangeScore * 0.10) * 100;
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateThreeZoneScore(draws) {
                const threeZoneMap = {};

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const zone1 = redBalls.filter(b => parseInt(b) >= 1 && parseInt(b) <= 11).length;
                    const zone2 = redBalls.filter(b => parseInt(b) >= 12 && parseInt(b) <= 22).length;
                    const zone3 = redBalls.filter(b => parseInt(b) >= 23 && parseInt(b) <= 33).length;
                    const ratio = `${zone3}:${zone2}:${zone1}`;
                    threeZoneMap[ratio] = (threeZoneMap[ratio] || 0) + 1;
                });

                const ratios = Object.entries(threeZoneMap).sort((a, b) => b[1] - a[1]);
                const topRatio = ratios[0];
                const topRatioScore = (topRatio[1] / draws.length) * 100;

                const zone1Counts = [];
                const zone2Counts = [];
                const zone3Counts = [];
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const zone1 = redBalls.filter(b => parseInt(b) >= 1 && parseInt(b) <= 11).length;
                    const zone2 = redBalls.filter(b => parseInt(b) >= 12 && parseInt(b) <= 22).length;
                    const zone3 = redBalls.filter(b => parseInt(b) >= 23 && parseInt(b) <= 33).length;
                    zone1Counts.push(zone1);
                    zone2Counts.push(zone2);
                    zone3Counts.push(zone3);
                });

                const avgZone1Count = zone1Counts.reduce((sum, c) => sum + c, 0) / zone1Counts.length;
                const avgZone2Count = zone2Counts.reduce((sum, c) => sum + c, 0) / zone2Counts.length;
                const avgZone3Count = zone3Counts.reduce((sum, c) => sum + c, 0) / zone3Counts.length;
                const zone1Variance = zone1Counts.reduce((sum, c) => sum + Math.pow(c - avgZone1Count, 2), 0) / zone1Counts.length;
                const zone2Variance = zone2Counts.reduce((sum, c) => sum + Math.pow(c - avgZone2Count, 2), 0) / zone2Counts.length;
                const zone3Variance = zone3Counts.reduce((sum, c) => sum + Math.pow(c - avgZone3Count, 2), 0) / zone3Counts.length;
                const zone1StdDev = Math.sqrt(zone1Variance);
                const zone2StdDev = Math.sqrt(zone2Variance);
                const zone3StdDev = Math.sqrt(zone3Variance);

                const zone1Consistency = zone1Counts.filter(c => Math.abs(c - avgZone1Count) <= zone1StdDev).length / zone1Counts.length;
                const zone2Consistency = zone2Counts.filter(c => Math.abs(c - avgZone2Count) <= zone2StdDev).length / zone2Counts.length;
                const zone3Consistency = zone3Counts.filter(c => Math.abs(c - avgZone3Count) <= zone3StdDev).length / zone3Counts.length;
                const consistencyScore = (zone1Consistency + zone2Consistency + zone3Consistency) / 3;

                const idealZoneCount = 2;
                const zone1Balance = 1 - Math.abs(avgZone1Count - idealZoneCount) / 6;
                const zone2Balance = 1 - Math.abs(avgZone2Count - idealZoneCount) / 6;
                const zone3Balance = 1 - Math.abs(avgZone3Count - idealZoneCount) / 6;
                const balanceScore = (zone1Balance + zone2Balance + zone3Balance) / 3;

                const sortedZone1Counts = zone1Counts.sort((a, b) => a - b);
                const sortedZone2Counts = zone2Counts.sort((a, b) => a - b);
                const sortedZone3Counts = zone3Counts.sort((a, b) => a - b);
                const zone1Median = sortedZone1Counts[Math.floor(sortedZone1Counts.length / 2)];
                const zone2Median = sortedZone2Counts[Math.floor(sortedZone2Counts.length / 2)];
                const zone3Median = sortedZone3Counts[Math.floor(sortedZone3Counts.length / 2)];
                const zone1MedianBalance = 1 - Math.abs(avgZone1Count - zone1Median) / avgZone1Count;
                const zone2MedianBalance = 1 - Math.abs(avgZone2Count - zone2Median) / avgZone2Count;
                const zone3MedianBalance = 1 - Math.abs(avgZone3Count - zone3Median) / avgZone3Count;
                const medianBalanceScore = (zone1MedianBalance + zone2MedianBalance + zone3MedianBalance) / 3;

                const zone1Zone2Ratio = avgZone1Count / avgZone2Count;
                const zone2Zone3Ratio = avgZone2Count / avgZone3Count;
                const zone1Zone3Ratio = avgZone1Count / avgZone3Count;
                const idealRatio = 1;
                const ratioScore = (1 - Math.abs(zone1Zone2Ratio - idealRatio) / idealRatio + 1 - Math.abs(zone2Zone3Ratio - idealRatio) / idealRatio + 1 - Math.abs(zone1Zone3Ratio - idealRatio) / idealRatio) / 3;

                const finalScore = (topRatioScore * 0.30 + consistencyScore * 100 * 0.25 + balanceScore * 100 * 0.20 + medianBalanceScore * 100 * 0.15 + ratioScore * 100 * 0.10);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateTrendScore(draws) {
                const frequencyMap = {};
                draws.forEach((draw, index) => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (!frequencyMap[num]) {
                            frequencyMap[num] = [];
                        }
                        frequencyMap[num].push(index);
                    });
                });

                const totalNumbers = Object.keys(frequencyMap).length;

                if (totalNumbers === 0 || draws.length === 0) {
                    return '0.0分';
                }

                let trendCount = 0;
                let totalGaps = 0;
                let totalVariance = 0;
                Object.values(frequencyMap).forEach(positions => {
                    if (positions.length >= 2) {
                        const gaps = [];
                        for (let i = 1; i < positions.length; i++) {
                            gaps.push(positions[i] - positions[i - 1]);
                        }
                        const avgGap = gaps.reduce((sum, g) => sum + g, 0) / gaps.length;
                        const variance = gaps.reduce((sum, g) => sum + Math.pow(g - avgGap, 2), 0) / gaps.length;
                        totalGaps += gaps.length;
                        totalVariance += variance * gaps.length;
                        if (variance < avgGap * 2) {
                            trendCount++;
                        }
                    }
                });

                if (totalGaps === 0) {
                    return '0.0分';
                }

                const avgVariance = totalVariance / totalGaps;
                const trendRatio = trendCount / totalNumbers;
                const expectedGap = draws.length / totalNumbers;

                if (expectedGap === 0) {
                    return '0.0分';
                }

                const consistencyScore = Math.max(0, Math.min(100, (1 - (avgVariance / expectedGap)) * 100));

                const trendStability = [];
                Object.values(frequencyMap).forEach(positions => {
                    if (positions.length >= 3) {
                        const gaps = [];
                        for (let i = 1; i < positions.length; i++) {
                            gaps.push(positions[i] - positions[i - 1]);
                        }
                        const avgGap = gaps.reduce((sum, g) => sum + g, 0) / gaps.length;
                        const stableGaps = gaps.filter(g => Math.abs(g - avgGap) <= avgGap * 0.5).length;
                        trendStability.push(stableGaps / gaps.length);
                    }
                });
                const avgTrendStability = trendStability.length > 0 ? trendStability.reduce((sum, s) => sum + s, 0) / trendStability.length : 0;

                const trendPredictability = [];
                Object.values(frequencyMap).forEach(positions => {
                    if (positions.length >= 4) {
                        const gaps = [];
                        for (let i = 1; i < positions.length; i++) {
                            gaps.push(positions[i] - positions[i - 1]);
                        }
                        const avgGap = gaps.slice(0, gaps.length - 1).reduce((sum, g) => sum + g, 0) / (gaps.length - 1);
                        const lastGap = gaps[gaps.length - 1];
                        const predictionAccuracy = 1 - Math.abs(lastGap - avgGap) / avgGap;
                        trendPredictability.push(predictionAccuracy);
                    }
                });
                const avgTrendPredictability = trendPredictability.length > 0 ? trendPredictability.reduce((sum, p) => sum + p, 0) / trendPredictability.length : 0;

                const trendConsistency = [];
                for (let i = 1; i < draws.length; i++) {
                    const prevDraw = draws[i - 1].redBalls || [];
                    const currDraw = draws[i].redBalls || [];
                    const commonBalls = prevDraw.filter(ball => currDraw.includes(ball)).length;
                    trendConsistency.push(commonBalls);
                }
                const avgTrendConsistency = trendConsistency.length > 0 ? trendConsistency.reduce((sum, c) => sum + c, 0) / trendConsistency.length : 0;
                const consistencyRatio = avgTrendConsistency / 6;

                const trendDiversity = [];
                Object.values(frequencyMap).forEach(positions => {
                    if (positions.length >= 2) {
                        const gaps = [];
                        for (let i = 1; i < positions.length; i++) {
                            gaps.push(positions[i] - positions[i - 1]);
                        }
                        const uniqueGaps = new Set(gaps).size;
                        trendDiversity.push(uniqueGaps / gaps.length);
                    }
                });
                const avgTrendDiversity = trendDiversity.length > 0 ? trendDiversity.reduce((sum, d) => sum + d, 0) / trendDiversity.length : 0;

                const finalScore = (trendRatio * 100 * 0.30 + consistencyScore * 0.25 + avgTrendStability * 100 * 0.20 + avgTrendPredictability * 100 * 0.15 + consistencyRatio * 100 * 0.05 + avgTrendDiversity * 100 * 0.05);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateCorrelationScore(draws) {
                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgFrequency;

                const sortedFrequencies = frequencies.sort((a, b) => a - b);
                const medianFrequency = sortedFrequencies[Math.floor(sortedFrequencies.length / 2)];
                const q1 = sortedFrequencies[Math.floor(sortedFrequencies.length / 4)];
                const q3 = sortedFrequencies[Math.floor(sortedFrequencies.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const balanceScore = 1 - Math.abs(avgFrequency - medianFrequency) / avgFrequency;
                const spreadScore = 1 - (iqr / avgFrequency);

                const normalFrequencies = frequencies.filter(f => Math.abs(f - avgFrequency) <= stdDev).length / frequencies.length;
                const consistencyScore = normalFrequencies;

                const highFrequencyNumbers = frequencies.filter(f => f > avgFrequency + stdDev).length;
                const lowFrequencyNumbers = frequencies.filter(f => f < avgFrequency - stdDev).length;
                const balanceScore2 = 1 - Math.abs(highFrequencyNumbers - lowFrequencyNumbers) / frequencies.length;

                const correlationMatrix = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                for (let i = 1; i <= redBallRange; i++) {
                    correlationMatrix[i] = {};
                    for (let j = 1; j <= redBallRange; j++) {
                        if (i !== j) {
                            correlationMatrix[i][j] = 0;
                        }
                    }
                }

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const numbers = redBalls.map(b => parseInt(b));
                    for (let i = 0; i < numbers.length; i++) {
                        for (let j = i + 1; j < numbers.length; j++) {
                            correlationMatrix[numbers[i]][numbers[j]]++;
                            correlationMatrix[numbers[j]][numbers[i]]++;
                        }
                    }
                });

                const correlationStrengths = [];
                for (let i = 1; i <= redBallRange; i++) {
                    for (let j = i + 1; j <= redBallRange; j++) {
                        correlationStrengths.push(correlationMatrix[i][j]);
                    }
                }

                const avgCorrelation = correlationStrengths.reduce((sum, c) => sum + c, 0) / correlationStrengths.length;
                const correlationVariance = correlationStrengths.reduce((sum, c) => sum + Math.pow(c - avgCorrelation, 2), 0) / correlationStrengths.length;
                const correlationStdDev = Math.sqrt(correlationVariance);
                const correlationScore = avgCorrelation > 0 ? 1 - (correlationStdDev / avgCorrelation) : 0;

                const strongCorrelations = correlationStrengths.filter(c => c > avgCorrelation + correlationStdDev).length;
                const weakCorrelations = correlationStrengths.filter(c => c < avgCorrelation - correlationStdDev).length;
                const correlationBalance = correlationStrengths.length > 0 ? 1 - Math.abs(strongCorrelations - weakCorrelations) / correlationStrengths.length : 0;

                const correlationPredictability = [];
                for (let i = 1; i <= redBallRange; i++) {
                    const correlations = [];
                    for (let j = 1; j <= redBallRange; j++) {
                        if (i !== j) {
                            correlations.push(correlationMatrix[i][j]);
                        }
                    }
                    const maxCorrelation = Math.max(...correlations);
                    const sumCorrelation = correlations.reduce((sum, c) => sum + c, 0);
                    const predictability = sumCorrelation > 0 ? maxCorrelation / sumCorrelation : 0;
                    correlationPredictability.push(predictability);
                }
                const avgCorrelationPredictability = correlationPredictability.length > 0 ? correlationPredictability.reduce((sum, p) => sum + p, 0) / correlationPredictability.length : 0;

                const correlationStability = [];
                for (let i = 0; i < draws.length - 1; i++) {
                    const prevDraw = draws[i].redBalls || [];
                    const currDraw = draws[i + 1].redBalls || [];
                    const prevNumbers = prevDraw.map(b => parseInt(b));
                    const currNumbers = currDraw.map(b => parseInt(b));
                    let overlapCount = 0;
                    prevNumbers.forEach(num => {
                        if (currNumbers.includes(num)) {
                            overlapCount++;
                        }
                    });
                    correlationStability.push(overlapCount);
                }
                const avgCorrelationStability = correlationStability.length > 0 ? correlationStability.reduce((sum, c) => sum + c, 0) / correlationStability.length : 0;
                const stabilityRatio = avgCorrelationStability / 6;

                const correlationDiversity = correlationStrengths.filter(c => c > 0).length / correlationStrengths.length;

                const finalScore = (distributionScore * 0.15 + balanceScore * 0.10 + spreadScore * 0.08 + consistencyScore * 0.12 + balanceScore2 * 0.10 + correlationScore * 100 * 0.20 + correlationBalance * 100 * 0.10 + avgCorrelationPredictability * 100 * 0.08 + stabilityRatio * 100 * 0.05 + correlationDiversity * 100 * 0.02);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateStatisticsScore(draws) {
                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgFrequency;

                const sortedFrequencies = frequencies.sort((a, b) => a - b);
                const medianFrequency = sortedFrequencies[Math.floor(sortedFrequencies.length / 2)];
                const q1 = sortedFrequencies[Math.floor(sortedFrequencies.length / 4)];
                const q3 = sortedFrequencies[Math.floor(sortedFrequencies.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const balanceScore = 1 - Math.abs(avgFrequency - medianFrequency) / avgFrequency;
                const spreadScore = 1 - (iqr / avgFrequency);

                const normalFrequencies = frequencies.filter(f => Math.abs(f - avgFrequency) <= stdDev).length / frequencies.length;
                const consistencyScore = normalFrequencies;

                const highFrequencyNumbers = frequencies.filter(f => f > avgFrequency + stdDev).length;
                const lowFrequencyNumbers = frequencies.filter(f => f < avgFrequency - stdDev).length;
                const balanceScore2 = 1 - Math.abs(highFrequencyNumbers - lowFrequencyNumbers) / frequencies.length;

                const skewness = frequencies.reduce((sum, f) => sum + Math.pow((f - avgFrequency) / stdDev, 3), 0) / frequencies.length;
                const kurtosis = frequencies.reduce((sum, f) => sum + Math.pow((f - avgFrequency) / stdDev, 4), 0) / frequencies.length - 3;
                const normalityScore = 1 - (Math.abs(skewness) + Math.abs(kurtosis)) / 4;

                const finalScore = (distributionScore * 0.20 + balanceScore * 0.15 + spreadScore * 0.10 + consistencyScore * 0.15 + balanceScore2 * 0.15 + normalityScore * 0.25) * 100;
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculatePatternScore(draws) {
                let consecutiveCount = 0;
                let sameTailCount = 0;
                let repeatCount = 0;
                let spanCount = 0;

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const numbers = redBalls.map(b => parseInt(b)).sort((a, b) => a - b);

                    for (let i = 0; i < numbers.length - 1; i++) {
                        if (numbers[i + 1] - numbers[i] === 1) {
                            consecutiveCount++;
                            break;
                        }
                    }

                    const tails = numbers.map(n => n % 10);
                    const tailSet = new Set(tails);
                    if (tailSet.size < numbers.length) {
                        sameTailCount++;
                    }

                    const numberSet = new Set(numbers);
                    if (numberSet.size < numbers.length) {
                        repeatCount++;
                    }

                    const span = numbers[numbers.length - 1] - numbers[0];
                    if (span <= 20) {
                        spanCount++;
                    }
                });

                const consecutiveRatio = consecutiveCount / draws.length;
                const sameTailRatio = sameTailCount / draws.length;
                const repeatRatio = repeatCount / draws.length;
                const spanRatio = spanCount / draws.length;

                const patternRatio = (consecutiveRatio + sameTailRatio + repeatRatio + spanRatio) / 4;
                const baseScore = patternRatio * 100;

                const patternConsistency = [];
                draws.forEach((draw, index) => {
                    if (index > 0) {
                        const prevDraw = draws[index - 1];
                        const prevRedBalls = prevDraw.redBalls || [];
                        const prevNumbers = prevRedBalls.map(b => parseInt(b));
                        const currRedBalls = draw.redBalls || [];
                        const currNumbers = currRedBalls.map(b => parseInt(b));

                        const overlap = prevNumbers.filter(n => currNumbers.includes(n)).length;
                        patternConsistency.push(overlap / 6);
                    }
                });
                const avgPatternConsistency = patternConsistency.length > 0 ? patternConsistency.reduce((sum, c) => sum + c, 0) / patternConsistency.length : 0;

                const patternVariance = [];
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const numbers = redBalls.map(b => parseInt(b)).sort((a, b) => a - b);
                    const gaps = [];
                    for (let i = 0; i < numbers.length - 1; i++) {
                        gaps.push(numbers[i + 1] - numbers[i]);
                    }
                    const avgGap = gaps.reduce((sum, g) => sum + g, 0) / gaps.length;
                    const variance = gaps.reduce((sum, g) => sum + Math.pow(g - avgGap, 2), 0) / gaps.length;
                    patternVariance.push(variance);
                });
                const avgPatternVariance = patternVariance.reduce((sum, v) => sum + v, 0) / patternVariance.length;
                const varianceScore = 1 - (avgPatternVariance / 10);

                const finalScore = (baseScore * 0.50 + avgPatternConsistency * 100 * 0.30 + varianceScore * 100 * 0.20);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateDNAScore(draws) {
                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);

                const score = Math.max(0, Math.min(100, 100 - (stdDev / avgFrequency) * 50));
                return `${score.toFixed(1)}分`;
            }

            static calculateRecoveryScore(draws) {
                const omissionMap = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    omissionMap[i] = 0;
                }

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        omissionMap[num] = 0;
                    });

                    for (let i = 1; i <= redBallRange; i++) {
                        if (!redBalls.includes(i.toString())) {
                            omissionMap[i]++;
                        }
                    }
                });

                const omissions = Object.values(omissionMap);

                if (omissions.length === 0) {
                    return '0.0分';
                }

                const avgOmission = omissions.reduce((sum, o) => sum + o, 0) / omissions.length;

                if (avgOmission === 0) {
                    return '0.0分';
                }

                const variance = omissions.reduce((sum, o) => sum + Math.pow(o - avgOmission, 2), 0) / omissions.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgOmission;

                const sortedOmissions = omissions.sort((a, b) => a - b);
                const medianOmission = sortedOmissions[Math.floor(sortedOmissions.length / 2)];
                const q1 = sortedOmissions[Math.floor(sortedOmissions.length / 4)];
                const q3 = sortedOmissions[Math.floor(sortedOmissions.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = Math.max(0, Math.min(100, (1 - Math.abs(coefficientOfVariation - 0.4)) * 100));
                const balanceScore = Math.max(0, Math.min(100, (1 - Math.abs(avgOmission - medianOmission) / avgOmission) * 100));
                const spreadScore = Math.max(0, Math.min(100, (1 - (iqr / avgOmission)) * 100));

                const normalOmissions = omissions.filter(o => Math.abs(o - avgOmission) <= stdDev).length / omissions.length;
                const consistencyScore = Math.max(0, Math.min(100, normalOmissions * 100));

                const highOmissionNumbers = omissions.filter(o => o > avgOmission + stdDev).length;
                const lowOmissionNumbers = omissions.filter(o => o < avgOmission - stdDev).length;
                const balanceScore2 = Math.max(0, Math.min(100, (1 - Math.abs(highOmissionNumbers - lowOmissionNumbers) / omissions.length) * 100));

                const maxOmission = Math.max(...omissions);
                const minOmission = Math.min(...omissions);
                const rangeRatio = avgOmission > 0 ? (maxOmission - minOmission) / avgOmission : 0;
                const rangeScore = Math.max(0, Math.min(100, (1 - Math.min(1, rangeRatio / 2)) * 100));

                const highOmissionCount = omissions.filter(o => o > avgOmission * 1.5).length;
                const recoveryRatio = omissions.length > 0 ? highOmissionCount / omissions.length : 0;
                const recoveryScore = Math.max(0, Math.min(100, recoveryRatio * 100));

                const finalScore = (distributionScore * 0.20 + balanceScore * 0.15 + spreadScore * 0.10 + consistencyScore * 0.15 + balanceScore2 * 0.15 + rangeScore * 0.10 + recoveryScore * 0.15);
                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateMandelbrotScore(draws) {
                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);

                const score = Math.max(0, Math.min(100, 100 - (stdDev / avgFrequency) * 50));
                return `${score.toFixed(1)}分`;
            }

            static calculateRecommendationQuality(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const blueBallRange = currentLotteryType === 'ssq' ? 16 : 12;

                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                if (frequencies.length === 0) {
                    return '0.0分';
                }

                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = avgFrequency > 0 ? stdDev / avgFrequency : 0;

                const sortedFrequencies = frequencies.sort((a, b) => a - b);
                const medianFrequency = sortedFrequencies[Math.floor(sortedFrequencies.length / 2)];
                const q1 = sortedFrequencies[Math.floor(sortedFrequencies.length / 4)];
                const q3 = sortedFrequencies[Math.floor(sortedFrequencies.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const balanceScore = avgFrequency > 0 ? 1 - Math.abs(avgFrequency - medianFrequency) / avgFrequency : 0;
                const spreadScore = avgFrequency > 0 ? 1 - Math.min(1, iqr / avgFrequency) : 0;

                const normalFrequencies = frequencies.filter(f => Math.abs(f - avgFrequency) <= stdDev).length / frequencies.length;
                const consistencyScore = normalFrequencies;

                const highFrequencyNumbers = frequencies.filter(f => f > avgFrequency + stdDev).length;
                const lowFrequencyNumbers = frequencies.filter(f => f < avgFrequency - stdDev).length;
                const balanceScore2 = frequencies.length > 0 ? 1 - Math.abs(highFrequencyNumbers - lowFrequencyNumbers) / frequencies.length : 0;

                const topNumbers = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]).slice(0, 6);
                const topFrequencySum = topNumbers.reduce((sum, entry) => sum + entry[1], 0);
                const topFrequencyRatio = avgFrequency > 0 ? topFrequencySum / (avgFrequency * 6) : 0;
                const concentrationScore = 1 - Math.abs(topFrequencyRatio - 1.5) / 1.5;

                const cycleAnalysisData = this.performCycleAnalysis(draws);
                const cycleScores = Object.values(cycleAnalysisData).map(data => data.cycleStability).filter(s => !isNaN(s) && isFinite(s));
                const avgCycleStability = cycleScores.length > 0 ? cycleScores.reduce((sum, s) => sum + s, 0) / cycleScores.length : 0;
                const cyclePredictabilityScores = Object.values(cycleAnalysisData).map(data => data.predictability).filter(s => !isNaN(s) && isFinite(s));
                const avgCyclePredictability = cyclePredictabilityScores.length > 0 ? cyclePredictabilityScores.reduce((sum, s) => sum + s, 0) / cyclePredictabilityScores.length : 0;
                const cycleEndCount = Object.values(cycleAnalysisData).filter(data => data.isCycleEnd).length;
                const cycleEndRatio = redBallRange > 0 ? cycleEndCount / redBallRange : 0;
                const cycleScore = (avgCycleStability * 0.4 + avgCyclePredictability * 0.4 + cycleEndRatio * 0.2) * 100;

                const stabilityAnalysisData = this.performStabilityAnalysis(draws);
                const stabilityScores = Object.values(stabilityAnalysisData).map(data => data.stabilityScore).filter(s => !isNaN(s) && isFinite(s));
                const avgStabilityScore = stabilityScores.length > 0 ? stabilityScores.reduce((sum, s) => sum + s, 0) / stabilityScores.length : 0;
                const consistencyScores = Object.values(stabilityAnalysisData).map(data => data.consistencyScore).filter(s => !isNaN(s) && isFinite(s));
                const avgConsistencyScore = consistencyScores.length > 0 ? consistencyScores.reduce((sum, s) => sum + s, 0) / consistencyScores.length : 0;
                const regularityScores = Object.values(stabilityAnalysisData).map(data => data.regularityScore).filter(s => !isNaN(s) && isFinite(s));
                const avgRegularityScore = regularityScores.length > 0 ? regularityScores.reduce((sum, s) => sum + s, 0) / regularityScores.length : 0;
                const stabilityScore = (avgStabilityScore * 0.4 + avgConsistencyScore * 0.3 + avgRegularityScore * 0.3) * 100;

                const recoveryAnalysisData = this.performRecoveryProbabilityAnalysis(draws);
                const recoveryProbabilities = Object.values(recoveryAnalysisData).map(data => data.recoveryProbability).filter(p => !isNaN(p) && isFinite(p));
                const avgRecoveryProbability = recoveryProbabilities.length > 0 ? recoveryProbabilities.reduce((sum, p) => sum + p, 0) / recoveryProbabilities.length : 0;
                const highUrgencyCount = Object.values(recoveryAnalysisData).filter(data => data.urgencyLevel === 'high').length;
                const urgencyScore = redBallRange > 0 ? highUrgencyCount / redBallRange : 0;
                const recoveryScore = (avgRecoveryProbability * 0.7 + urgencyScore * 0.3) * 100;

                const correlationAnalysisData = this.performCorrelationAnalysis(draws) || {};
                const strongCorrelationCounts = Object.values(correlationAnalysisData).map(data => data.strongCorrelations?.length || 0);
                const avgStrongCorrelationCount = strongCorrelationCounts.length > 0 ? strongCorrelationCounts.reduce((sum, c) => sum + c, 0) / strongCorrelationCounts.length : 0;
                const clusterEffectCount = Object.values(correlationAnalysisData).filter(data => data.clusterEffect).length;
                const clusterEffectRatio = redBallRange > 0 ? clusterEffectCount / redBallRange : 0;
                const conductionEffectCount = Object.values(correlationAnalysisData).filter(data => data.conductionEffect).length;
                const conductionEffectRatio = redBallRange > 0 ? conductionEffectCount / redBallRange : 0;
                const correlationScore = (avgStrongCorrelationCount / 5 * 0.4 + clusterEffectRatio * 0.3 + conductionEffectRatio * 0.3) * 100;

                const historicalAnalysisData = this.performHistoricalAccuracyAnalysis(draws);
                const shortTermAccuracies = Object.values(historicalAnalysisData).map(data => data.shortTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgShortTermAccuracy = shortTermAccuracies.length > 0 ? shortTermAccuracies.reduce((sum, a) => sum + a, 0) / shortTermAccuracies.length : 0;
                const mediumTermAccuracies = Object.values(historicalAnalysisData).map(data => data.mediumTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgMediumTermAccuracy = mediumTermAccuracies.length > 0 ? mediumTermAccuracies.reduce((sum, a) => sum + a, 0) / mediumTermAccuracies.length : 0;
                const longTermAccuracies = Object.values(historicalAnalysisData).map(data => data.longTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgLongTermAccuracy = longTermAccuracies.length > 0 ? longTermAccuracies.reduce((sum, a) => sum + a, 0) / longTermAccuracies.length : 0;
                const historicalScore = (avgShortTermAccuracy * 0.5 + avgMediumTermAccuracy * 0.3 + avgLongTermAccuracy * 0.2) * 100;

                const finalScore = (
                    distributionScore * 0.10 +
                    balanceScore * 0.08 +
                    spreadScore * 0.05 +
                    consistencyScore * 0.08 +
                    balanceScore2 * 0.08 +
                    concentrationScore * 0.10 +
                    (cycleScore / 100) * 0.15 +
                    (stabilityScore / 100) * 0.12 +
                    (recoveryScore / 100) * 0.10 +
                    (correlationScore / 100) * 0.08 +
                    (historicalScore / 100) * 0.06
                ) * 100;

                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}分`;
            }

            static calculateRecommendationConfidence(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0%';
                }

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                if (frequencies.length === 0) {
                    return '0.0%';
                }

                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = avgFrequency > 0 ? stdDev / avgFrequency : 0;

                const sortedFrequencies = frequencies.sort((a, b) => a - b);
                const medianFrequency = sortedFrequencies[Math.floor(sortedFrequencies.length / 2)];
                const q1 = sortedFrequencies[Math.floor(sortedFrequencies.length / 4)];
                const q3 = sortedFrequencies[Math.floor(sortedFrequencies.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const balanceScore = avgFrequency > 0 ? 1 - Math.abs(avgFrequency - medianFrequency) / avgFrequency : 0;
                const spreadScore = avgFrequency > 0 ? 1 - Math.min(1, iqr / avgFrequency) : 0;

                const normalFrequencies = frequencies.filter(f => Math.abs(f - avgFrequency) <= stdDev).length / frequencies.length;
                const consistencyScore = normalFrequencies;

                const highFrequencyNumbers = frequencies.filter(f => f > avgFrequency + stdDev).length;
                const lowFrequencyNumbers = frequencies.filter(f => f < avgFrequency - stdDev).length;
                const balanceScore2 = frequencies.length > 0 ? 1 - Math.abs(highFrequencyNumbers - lowFrequencyNumbers) / frequencies.length : 0;

                const topNumbers = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]).slice(0, 6);
                const topFrequencySum = topNumbers.reduce((sum, entry) => sum + entry[1], 0);
                const topFrequencyRatio = avgFrequency > 0 ? topFrequencySum / (avgFrequency * 6) : 0;
                const concentrationScore = 1 - Math.abs(topFrequencyRatio - 1.5) / 1.5;

                const recentDraws = draws.slice(-10);
                const recentFrequencyMap = {};
                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        recentFrequencyMap[num] = (recentFrequencyMap[num] || 0) + 1;
                    });
                });

                const recentFrequencies = Object.values(recentFrequencyMap);
                if (recentFrequencies.length === 0) {
                    return '0.0%';
                }

                const recentAvgFrequency = recentFrequencies.reduce((sum, f) => sum + f, 0) / recentFrequencies.length;
                const recentVariance = recentFrequencies.reduce((sum, f) => sum + Math.pow(f - recentAvgFrequency, 2), 0) / recentFrequencies.length;
                const recentStdDev = Math.sqrt(recentVariance);
                const recentCoefficientOfVariation = recentAvgFrequency > 0 ? recentStdDev / recentAvgFrequency : 0;
                const recentStabilityScore = 1 - recentCoefficientOfVariation;

                const cycleAnalysisData = this.performCycleAnalysis(draws);
                const cycleScores = Object.values(cycleAnalysisData).map(data => data.cycleStability).filter(s => !isNaN(s) && isFinite(s));
                const avgCycleStability = cycleScores.length > 0 ? cycleScores.reduce((sum, s) => sum + s, 0) / cycleScores.length : 0;
                const cyclePredictabilityScores = Object.values(cycleAnalysisData).map(data => data.predictability).filter(s => !isNaN(s) && isFinite(s));
                const avgCyclePredictability = cyclePredictabilityScores.length > 0 ? cyclePredictabilityScores.reduce((sum, s) => sum + s, 0) / cyclePredictabilityScores.length : 0;
                const cycleConfidenceScore = (avgCycleStability * 0.5 + avgCyclePredictability * 0.5) * 100;

                const stabilityAnalysisData = this.performStabilityAnalysis(draws);
                const stabilityScores = Object.values(stabilityAnalysisData).map(data => data.stabilityScore).filter(s => !isNaN(s) && isFinite(s));
                const avgStabilityScore = stabilityScores.length > 0 ? stabilityScores.reduce((sum, s) => sum + s, 0) / stabilityScores.length : 0;
                const consistencyScores = Object.values(stabilityAnalysisData).map(data => data.consistencyScore).filter(s => !isNaN(s) && isFinite(s));
                const avgConsistencyScore = consistencyScores.length > 0 ? consistencyScores.reduce((sum, s) => sum + s, 0) / consistencyScores.length : 0;
                const stabilityConfidenceScore = (avgStabilityScore * 0.6 + avgConsistencyScore * 0.4) * 100;

                const recoveryAnalysisData = this.performRecoveryProbabilityAnalysis(draws);
                const recoveryProbabilities = Object.values(recoveryAnalysisData).map(data => data.recoveryProbability).filter(p => !isNaN(p) && isFinite(p));
                const avgRecoveryProbability = recoveryProbabilities.length > 0 ? recoveryProbabilities.reduce((sum, p) => sum + p, 0) / recoveryProbabilities.length : 0;
                const highUrgencyCount = Object.values(recoveryAnalysisData).filter(data => data.urgencyLevel === 'high').length;
                const urgencyScore = redBallRange > 0 ? highUrgencyCount / redBallRange : 0;
                const recoveryConfidenceScore = (avgRecoveryProbability * 0.7 + urgencyScore * 0.3) * 100;

                const correlationAnalysisData = this.performCorrelationAnalysis(draws) || {};
                const strongCorrelationCounts = Object.values(correlationAnalysisData).map(data => data.strongCorrelations?.length || 0);
                const avgStrongCorrelationCount = strongCorrelationCounts.length > 0 ? strongCorrelationCounts.reduce((sum, c) => sum + c, 0) / strongCorrelationCounts.length : 0;
                const clusterEffectCount = Object.values(correlationAnalysisData).filter(data => data.clusterEffect).length;
                const clusterEffectRatio = redBallRange > 0 ? clusterEffectCount / redBallRange : 0;
                const correlationConfidenceScore = (avgStrongCorrelationCount / 5 * 0.6 + clusterEffectRatio * 0.4) * 100;

                const historicalAnalysisData = this.performHistoricalAccuracyAnalysis(draws);
                const shortTermAccuracies = Object.values(historicalAnalysisData).map(data => data.shortTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgShortTermAccuracy = shortTermAccuracies.length > 0 ? shortTermAccuracies.reduce((sum, a) => sum + a, 0) / shortTermAccuracies.length : 0;
                const mediumTermAccuracies = Object.values(historicalAnalysisData).map(data => data.mediumTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgMediumTermAccuracy = mediumTermAccuracies.length > 0 ? mediumTermAccuracies.reduce((sum, a) => sum + a, 0) / mediumTermAccuracies.length : 0;
                const historicalConfidenceScore = (avgShortTermAccuracy * 0.6 + avgMediumTermAccuracy * 0.4) * 100;

                const hitRates = [];
                for (let i = 1; i < recentDraws.length; i++) {
                    const prevDraw = recentDraws[i - 1];
                    const currDraw = recentDraws[i];
                    const prevRedBalls = prevDraw.redBalls || [];
                    const prevNumbers = prevRedBalls.map(b => parseInt(b));
                    const currRedBalls = currDraw.redBalls || [];
                    const currNumbers = currRedBalls.map(b => parseInt(b));

                    const hitCount = prevNumbers.filter(n => currNumbers.includes(n)).length;
                    hitRates.push(hitCount / 6);
                }

                const avgHitRate = hitRates.length > 0 ? hitRates.reduce((sum, rate) => sum + rate, 0) / hitRates.length : 0;
                const hitRateVariance = hitRates.length > 0 ? hitRates.reduce((sum, rate) => sum + Math.pow(rate - avgHitRate, 2), 0) / hitRates.length : 0;
                const hitRateStdDev = Math.sqrt(hitRateVariance);
                const hitRateStabilityScore = avgHitRate > 0 ? 1 - (hitRateStdDev / avgHitRate) : 0;
                const hitRateConfidenceScore = hitRateStabilityScore * 100;

                const finalScore = (
                    distributionScore * 0.08 +
                    balanceScore * 0.06 +
                    spreadScore * 0.05 +
                    consistencyScore * 0.06 +
                    balanceScore2 * 0.06 +
                    concentrationScore * 0.08 +
                    recentStabilityScore * 0.10 +
                    (cycleConfidenceScore / 100) * 0.15 +
                    (stabilityConfidenceScore / 100) * 0.12 +
                    (recoveryConfidenceScore / 100) * 0.10 +
                    (correlationConfidenceScore / 100) * 0.08 +
                    (historicalConfidenceScore / 100) * 0.06 +
                    (hitRateConfidenceScore / 100) * 0.10
                ) * 100;

                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}%`;
            }

            static calculateRecommendationAccuracy(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0%';
                }

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                const recentDraws = draws.slice(-10);
                const frequencyMap = {};
                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const frequencies = Object.values(frequencyMap);
                if (frequencies.length === 0) {
                    return '0.0%';
                }

                const avgFrequency = frequencies.reduce((sum, f) => sum + f, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, f) => sum + Math.pow(f - avgFrequency, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = avgFrequency > 0 ? stdDev / avgFrequency : 0;

                const sortedFrequencies = frequencies.sort((a, b) => a - b);
                const medianFrequency = sortedFrequencies[Math.floor(sortedFrequencies.length / 2)];
                const q1 = sortedFrequencies[Math.floor(sortedFrequencies.length / 4)];
                const q3 = sortedFrequencies[Math.floor(sortedFrequencies.length * 3 / 4)];
                const iqr = q3 - q1;

                const distributionScore = 1 - Math.abs(coefficientOfVariation - 0.3);
                const balanceScore = avgFrequency > 0 ? 1 - Math.abs(avgFrequency - medianFrequency) / avgFrequency : 0;
                const spreadScore = avgFrequency > 0 ? 1 - Math.min(1, iqr / avgFrequency) : 0;

                const normalFrequencies = frequencies.filter(f => Math.abs(f - avgFrequency) <= stdDev).length / frequencies.length;
                const consistencyScore = normalFrequencies;

                const highFrequencyNumbers = frequencies.filter(f => f > avgFrequency + stdDev).length;
                const lowFrequencyNumbers = frequencies.filter(f => f < avgFrequency - stdDev).length;
                const balanceScore2 = frequencies.length > 0 ? 1 - Math.abs(highFrequencyNumbers - lowFrequencyNumbers) / frequencies.length : 0;

                const topNumbers = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]).slice(0, 6);
                const topFrequencySum = topNumbers.reduce((sum, entry) => sum + entry[1], 0);
                const topFrequencyRatio = avgFrequency > 0 ? topFrequencySum / (avgFrequency * 6) : 0;
                const concentrationScore = 1 - Math.abs(topFrequencyRatio - 1.5) / 1.5;

                const hitRates = [];
                for (let i = 1; i < recentDraws.length; i++) {
                    const prevDraw = recentDraws[i - 1];
                    const currDraw = recentDraws[i];
                    const prevRedBalls = prevDraw.redBalls || [];
                    const prevNumbers = prevRedBalls.map(b => parseInt(b));
                    const currRedBalls = currDraw.redBalls || [];
                    const currNumbers = currRedBalls.map(b => parseInt(b));

                    const hitCount = prevNumbers.filter(n => currNumbers.includes(n)).length;
                    hitRates.push(hitCount / 6);
                }

                const avgHitRate = hitRates.length > 0 ? hitRates.reduce((sum, rate) => sum + rate, 0) / hitRates.length : 0;
                const hitRateVariance = hitRates.length > 0 ? hitRates.reduce((sum, rate) => sum + Math.pow(rate - avgHitRate, 2), 0) / hitRates.length : 0;
                const hitRateStdDev = Math.sqrt(hitRateVariance);
                const hitRateStabilityScore = avgHitRate > 0 ? 1 - (hitRateStdDev / avgHitRate) : 0;

                const cycleAnalysisData = this.performCycleAnalysis(draws);
                const cycleScores = Object.values(cycleAnalysisData).map(data => data.cycleStability).filter(s => !isNaN(s) && isFinite(s));
                const avgCycleStability = cycleScores.length > 0 ? cycleScores.reduce((sum, s) => sum + s, 0) / cycleScores.length : 0;
                const cyclePredictabilityScores = Object.values(cycleAnalysisData).map(data => data.predictability).filter(s => !isNaN(s) && isFinite(s));
                const avgCyclePredictability = cyclePredictabilityScores.length > 0 ? cyclePredictabilityScores.reduce((sum, s) => sum + s, 0) / cyclePredictabilityScores.length : 0;
                const cycleAccuracyScore = (avgCycleStability * 0.5 + avgCyclePredictability * 0.5) * 100;

                const stabilityAnalysisData = this.performStabilityAnalysis(draws);
                const stabilityScores = Object.values(stabilityAnalysisData).map(data => data.stabilityScore).filter(s => !isNaN(s) && isFinite(s));
                const avgStabilityScore = stabilityScores.length > 0 ? stabilityScores.reduce((sum, s) => sum + s, 0) / stabilityScores.length : 0;
                const consistencyScores = Object.values(stabilityAnalysisData).map(data => data.consistencyScore).filter(s => !isNaN(s) && isFinite(s));
                const avgConsistencyScore = consistencyScores.length > 0 ? consistencyScores.reduce((sum, s) => sum + s, 0) / consistencyScores.length : 0;
                const stabilityAccuracyScore = (avgStabilityScore * 0.6 + avgConsistencyScore * 0.4) * 100;

                const recoveryAnalysisData = this.performRecoveryProbabilityAnalysis(draws);
                const recoveryProbabilities = Object.values(recoveryAnalysisData).map(data => data.recoveryProbability).filter(p => !isNaN(p) && isFinite(p));
                const avgRecoveryProbability = recoveryProbabilities.length > 0 ? recoveryProbabilities.reduce((sum, p) => sum + p, 0) / recoveryProbabilities.length : 0;
                const highUrgencyCount = Object.values(recoveryAnalysisData).filter(data => data.urgencyLevel === 'high').length;
                const urgencyScore = redBallRange > 0 ? highUrgencyCount / redBallRange : 0;
                const recoveryAccuracyScore = (avgRecoveryProbability * 0.7 + urgencyScore * 0.3) * 100;

                const correlationAnalysisData = this.performCorrelationAnalysis(draws) || {};
                const strongCorrelationCounts = Object.values(correlationAnalysisData).map(data => data.strongCorrelations?.length || 0);
                const avgStrongCorrelationCount = strongCorrelationCounts.length > 0 ? strongCorrelationCounts.reduce((sum, c) => sum + c, 0) / strongCorrelationCounts.length : 0;
                const clusterEffectCount = Object.values(correlationAnalysisData).filter(data => data.clusterEffect).length;
                const clusterEffectRatio = redBallRange > 0 ? clusterEffectCount / redBallRange : 0;
                const correlationAccuracyScore = (avgStrongCorrelationCount / 5 * 0.6 + clusterEffectRatio * 0.4) * 100;

                const historicalAnalysisData = this.performHistoricalAccuracyAnalysis(draws);
                const shortTermAccuracies = Object.values(historicalAnalysisData).map(data => data.shortTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgShortTermAccuracy = shortTermAccuracies.length > 0 ? shortTermAccuracies.reduce((sum, a) => sum + a, 0) / shortTermAccuracies.length : 0;
                const mediumTermAccuracies = Object.values(historicalAnalysisData).map(data => data.mediumTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgMediumTermAccuracy = mediumTermAccuracies.length > 0 ? mediumTermAccuracies.reduce((sum, a) => sum + a, 0) / mediumTermAccuracies.length : 0;
                const longTermAccuracies = Object.values(historicalAnalysisData).map(data => data.longTermAccuracy).filter(a => !isNaN(a) && isFinite(a));
                const avgLongTermAccuracy = longTermAccuracies.length > 0 ? longTermAccuracies.reduce((sum, a) => sum + a, 0) / longTermAccuracies.length : 0;
                const historicalAccuracyScore = (avgShortTermAccuracy * 0.5 + avgMediumTermAccuracy * 0.3 + avgLongTermAccuracy * 0.2) * 100;

                const predictionAccuracy = [];
                for (let i = 1; i < recentDraws.length; i++) {
                    const prevDraw = recentDraws[i - 1];
                    const currDraw = recentDraws[i];
                    const prevRedBalls = prevDraw.redBalls || [];
                    const prevNumbers = prevRedBalls.map(b => parseInt(b));
                    const currRedBalls = currDraw.redBalls || [];
                    const currNumbers = currRedBalls.map(b => parseInt(b));

                    const hitCount = prevNumbers.filter(n => currNumbers.includes(n)).length;
                    predictionAccuracy.push(hitCount / 6);
                }

                const avgPredictionAccuracy = predictionAccuracy.length > 0 ? predictionAccuracy.reduce((sum, acc) => sum + acc, 0) / predictionAccuracy.length : 0;
                const predictionVariance = predictionAccuracy.length > 0 ? predictionAccuracy.reduce((sum, acc) => sum + Math.pow(acc - avgPredictionAccuracy, 2), 0) / predictionAccuracy.length : 0;
                const predictionStdDev = Math.sqrt(predictionVariance);
                const predictionStabilityScore = avgPredictionAccuracy > 0 ? 1 - (predictionStdDev / avgPredictionAccuracy) : 0;
                const predictionAccuracyScore = predictionStabilityScore * 100;

                const finalScore = (
                    distributionScore * 0.08 +
                    balanceScore * 0.06 +
                    spreadScore * 0.05 +
                    consistencyScore * 0.06 +
                    balanceScore2 * 0.06 +
                    concentrationScore * 0.08 +
                    hitRateStabilityScore * 0.10 +
                    (cycleAccuracyScore / 100) * 0.15 +
                    (stabilityAccuracyScore / 100) * 0.12 +
                    (recoveryAccuracyScore / 100) * 0.10 +
                    (correlationAccuracyScore / 100) * 0.08 +
                    (historicalAccuracyScore / 100) * 0.06 +
                    (predictionAccuracyScore / 100) * 0.10
                ) * 100;

                return `${Math.max(0, Math.min(100, finalScore)).toFixed(1)}%`;
            }

            static generateRecommendations(draws, periodCount) {
                if (!draws || draws.length === 0) {
                    return [];
                }

                const frequencyMap = {};
                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
                    });
                });

                const sortedNumbers = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]);
                const topNumbers = sortedNumbers.slice(0, 6).map(entry => parseInt(entry[0])).sort((a, b) => a - b);
                const blueBallRange = currentLotteryType === 'ssq' ? 16 : 12;
                const blueBalls = [];
                while (blueBalls.length < 1) {
                    const num = Math.floor(Math.random() * blueBallRange) + 1;
                    if (!blueBalls.includes(num)) {
                        blueBalls.push(num);
                    }
                }

                return [{
                    redBalls: topNumbers,
                    blueBalls: blueBalls,
                    reason: `基于最近${periodCount}期高频号码推荐`
                }];
            }

            static evaluateBasicStrategy(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const oddEvenScore = parseFloat(this.calculateOddEvenScore(draws));
                const bigSmallScore = parseFloat(this.calculateBigSmallScore(draws));
                const primeCompositeScore = parseFloat(this.calculatePrimeCompositeScore(draws));
                const acValueScore = parseFloat(this.calculateACValueScore(draws));
                const threeZoneScore = parseFloat(this.calculateThreeZoneScore(draws));

                const score = (oddEvenScore * 0.25 + bigSmallScore * 0.25 + primeCompositeScore * 0.20 + acValueScore * 0.15 + threeZoneScore * 0.15);
                return `${score.toFixed(1)}分`;
            }

            static evaluateOmissionStrategy(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const frequencyScore = parseFloat(this.calculateFrequencyScore(draws));
                const omissionScore = parseFloat(this.calculateOmissionScore(draws));
                const hotColdScore = parseFloat(this.calculateHotColdScore(draws));

                const score = (frequencyScore * 0.40 + omissionScore * 0.40 + hotColdScore * 0.20);
                return `${score.toFixed(1)}分`;
            }

            static evaluateTrendStrategy(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const trendScore = parseFloat(this.calculateTrendScore(draws));
                const correlationScore = parseFloat(this.calculateCorrelationScore(draws));
                const statisticsScore = parseFloat(this.calculateStatisticsScore(draws));

                const score = (trendScore * 0.45 + correlationScore * 0.35 + statisticsScore * 0.20);
                return `${score.toFixed(1)}分`;
            }

            static evaluatePatternStrategy(draws) {
                if (!draws || draws.length === 0) {
                    return '0.0分';
                }

                const patternScore = parseFloat(this.calculatePatternScore(draws));
                const statisticsScore = parseFloat(this.calculateStatisticsScore(draws));
                const dnaScore = parseFloat(this.calculateDNAScore(draws));
                const recoveryScore = parseFloat(this.calculateRecoveryScore(draws));

                const score = (patternScore * 0.35 + statisticsScore * 0.25 + dnaScore * 0.20 + recoveryScore * 0.20);
                return `${score.toFixed(1)}分`;
            }

            static getStrategyDetails(draws, periodCount) {
                if (!draws || draws.length === 0) {
                    return [
                        { name: '基础指标均衡策略', effect: '暂无数据，请先导入彩票数据' },
                        { name: '遗漏+频率组合策略', effect: '暂无数据，请先导入彩票数据' },
                        { name: '趋势追踪策略', effect: '暂无数据，请先导入彩票数据' },
                        { name: '模式匹配策略', effect: '暂无数据，请先导入彩票数据' }
                    ];
                }

                const basicStrategyScore = parseFloat(this.evaluateBasicStrategy(draws));
                const omissionStrategyScore = parseFloat(this.evaluateOmissionStrategy(draws));
                const trendStrategyScore = parseFloat(this.evaluateTrendStrategy(draws));
                const patternStrategyScore = parseFloat(this.evaluatePatternStrategy(draws));

                const oddEvenScore = parseFloat(this.calculateOddEvenScore(draws));
                const bigSmallScore = parseFloat(this.calculateBigSmallScore(draws));
                const primeCompositeScore = parseFloat(this.calculatePrimeCompositeScore(draws));

                const frequencyScore = parseFloat(this.calculateFrequencyScore(draws));
                const omissionScore = parseFloat(this.calculateOmissionScore(draws));
                const hotColdScore = parseFloat(this.calculateHotColdScore(draws));

                const trendScore = parseFloat(this.calculateTrendScore(draws));
                const correlationScore = parseFloat(this.calculateCorrelationScore(draws));
                const statisticsScore = parseFloat(this.calculateStatisticsScore(draws));

                const patternScore = parseFloat(this.calculatePatternScore(draws));
                const dnaScore = parseFloat(this.calculateDNAScore(draws));
                const recoveryScore = parseFloat(this.calculateRecoveryScore(draws));

                const basicEffect = basicStrategyScore >= 80 ? '综合评分优秀，各项指标均衡，适合稳健选号' : 
                                  basicStrategyScore >= 60 ? '综合评分良好，基础指标表现稳定，建议结合其他策略使用' : 
                                  '综合评分一般，建议关注高频号码和均衡分布';

                const omissionEffect = omissionStrategyScore >= 80 ? '遗漏与频率分析优秀，回补机会大，适合中长期选号' : 
                                    omissionStrategyScore >= 60 ? '遗漏与频率分析良好，兼顾稳定性与回补机会' : 
                                    '遗漏与频率分析一般，建议结合趋势分析使用';

                const trendEffect = trendStrategyScore >= 80 ? '趋势追踪能力优秀，号码走势清晰，适合短期选号' : 
                                  trendStrategyScore >= 60 ? '趋势追踪能力良好，能够捕捉号码走势变化' : 
                                  '趋势追踪能力一般，建议增加分析周期';

                const patternEffect = patternStrategyScore >= 80 ? '模式识别能力优秀，高频模式明显，适合模式选号' : 
                                   patternStrategyScore >= 60 ? '模式识别能力良好，能够识别号码模式特征' : 
                                   '模式识别能力一般，建议结合统计分析使用';

                return [
                    { 
                        name: '基础指标均衡策略', 
                        effect: basicEffect,
                        details: `奇偶:${oddEvenScore.toFixed(1)}分 大小:${bigSmallScore.toFixed(1)}分 质合:${primeCompositeScore.toFixed(1)}分`
                    },
                    { 
                        name: '遗漏+频率组合策略', 
                        effect: omissionEffect,
                        details: `频率:${frequencyScore.toFixed(1)}分 遗漏:${omissionScore.toFixed(1)}分 冷热:${hotColdScore.toFixed(1)}分`
                    },
                    { 
                        name: '趋势追踪策略', 
                        effect: trendEffect,
                        details: `趋势:${trendScore.toFixed(1)}分 关联:${correlationScore.toFixed(1)}分 统计:${statisticsScore.toFixed(1)}分`
                    },
                    { 
                        name: '模式匹配策略', 
                        effect: patternEffect,
                        details: `模式:${patternScore.toFixed(1)}分 DNA:${dnaScore.toFixed(1)}分 回补:${recoveryScore.toFixed(1)}分`
                    }
                ];
            }

            static showWarningConfig() {
                const detailContainer = document.getElementById('warningDetail');
                if (!detailContainer) return;

                const rules = AlertRuleConfig.getRules();

                const content = `
                    <h3 style="margin: 0 0 15px 0; color: #667eea; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-cog"></i> 预警规则配置
                    </h3>

                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-left: 4px solid #667eea; border-radius: 4px;">
                        <strong>💡 配置说明：</strong>您可以自定义预警规则的阈值和级别。修改后点击"保存配置"按钮生效。
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #333;">号码级预警规则</h4>
                        ${Object.entries(rules.numberLevel).map(([ruleKey, rule]) => `
                            <div style="margin-bottom: 10px; padding: 12px; background: #f8f9fa; border-radius: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                    <strong>${rule.name}</strong>
                                    <span style="padding: 3px 8px; background: ${rule.level === 'high' ? '#dc3545' : rule.level === 'medium' ? '#ffc107' : '#28a745'}; color: white; border-radius: 10px; font-size: 12px;">
                                        ${rule.level === 'high' ? '高' : rule.level === 'medium' ? '中' : '低'}风险
                                    </span>
                                </div>
                                <div style="color: #666; font-size: 14px; margin-bottom: 10px;">${rule.description}</div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="font-size: 14px;">阈值：</label>
                                    <input type="number" id="rule-number-${ruleKey}" value="${rule.threshold}" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px; width: 100px;">
                                    <select id="rule-number-${ruleKey}-level" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                        <option value="high" ${rule.level === 'high' ? 'selected' : ''}>高</option>
                                        <option value="medium" ${rule.level === 'medium' ? 'selected' : ''}>中</option>
                                        <option value="low" ${rule.level === 'low' ? 'selected' : ''}>低</option>
                                    </select>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #333;">组合级预警规则</h4>
                        ${Object.entries(rules.combinationLevel).map(([ruleKey, rule]) => `
                            <div style="margin-bottom: 10px; padding: 12px; background: #f8f9fa; border-radius: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                    <strong>${rule.name}</strong>
                                    <span style="padding: 3px 8px; background: ${rule.level === 'high' ? '#dc3545' : rule.level === 'medium' ? '#ffc107' : '#28a745'}; color: white; border-radius: 10px; font-size: 12px;">
                                        ${rule.level === 'high' ? '高' : rule.level === 'medium' ? '中' : '低'}风险
                                    </span>
                                </div>
                                <div style="color: #666; font-size: 14px; margin-bottom: 10px;">${rule.description}</div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="font-size: 14px;">阈值：</label>
                                    <input type="number" id="rule-combination-${ruleKey}" value="${rule.threshold}" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px; width: 100px;">
                                    <select id="rule-combination-${ruleKey}-level" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                        <option value="high" ${rule.level === 'high' ? 'selected' : ''}>高</option>
                                        <option value="medium" ${rule.level === 'medium' ? 'selected' : ''}>中</option>
                                        <option value="low" ${rule.level === 'low' ? 'selected' : ''}>低</option>
                                    </select>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #333;">统计级预警规则</h4>
                        ${Object.entries(rules.statisticsLevel).map(([ruleKey, rule]) => `
                            <div style="margin-bottom: 10px; padding: 12px; background: #f8f9fa; border-radius: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                    <strong>${rule.name}</strong>
                                    <span style="padding: 3px 8px; background: ${rule.level === 'high' ? '#dc3545' : rule.level === 'medium' ? '#ffc107' : '#28a745'}; color: white; border-radius: 10px; font-size: 12px;">
                                        ${rule.level === 'high' ? '高' : rule.level === 'medium' ? '中' : '低'}风险
                                    </span>
                                </div>
                                <div style="color: #666; font-size: 14px; margin-bottom: 10px;">${rule.description}</div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="font-size: 14px;">阈值：</label>
                                    <input type="number" id="rule-statistics-${ruleKey}" value="${rule.threshold}" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px; width: 100px;">
                                    <select id="rule-statistics-${ruleKey}-level" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                        <option value="high" ${rule.level === 'high' ? 'selected' : ''}>高</option>
                                        <option value="medium" ${rule.level === 'medium' ? 'selected' : ''}>中</option>
                                        <option value="low" ${rule.level === 'low' ? 'selected' : ''}>低</option>
                                    </select>
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="text-align: center;">
                        <button class="btn btn-primary" onclick="EventDelegate.saveWarningConfig()" style="padding: 10px 30px;">
                            <i class="fas fa-save"></i> 保存配置
                        </button>
                        <button class="btn btn-secondary" onclick="EventDelegate.resetWarningConfig()" style="padding: 10px 30px;">
                            <i class="fas fa-undo"></i> 重置默认
                        </button>
                    </div>
                `;

                detailContainer.innerHTML = content;
                detailContainer.style.borderLeftColor = '#667eea';
                detailContainer.style.display = 'block';
                detailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            static saveWarningConfig() {
                const rules = AlertRuleConfig.getRules();

                Object.keys(rules.numberLevel).forEach(ruleKey => {
                    const threshold = parseFloat(document.getElementById(`rule-number-${ruleKey}`).value);
                    const level = document.getElementById(`rule-number-${ruleKey}-level`).value;
                    AlertRuleConfig.updateRule('numberLevel', ruleKey, { threshold, level });
                });

                Object.keys(rules.combinationLevel).forEach(ruleKey => {
                    const threshold = parseFloat(document.getElementById(`rule-combination-${ruleKey}`).value);
                    const level = document.getElementById(`rule-combination-${ruleKey}-level`).value;
                    AlertRuleConfig.updateRule('combinationLevel', ruleKey, { threshold, level });
                });

                Object.keys(rules.statisticsLevel).forEach(ruleKey => {
                    const threshold = parseFloat(document.getElementById(`rule-statistics-${ruleKey}`).value);
                    const level = document.getElementById(`rule-statistics-${ruleKey}-level`).value;
                    AlertRuleConfig.updateRule('statisticsLevel', ruleKey, { threshold, level });
                });

                MessageSystem.showMessage('预警配置已保存', 'success');
            }

            static resetWarningConfig() {
                if (confirm('确定要重置所有预警规则为默认值吗？')) {
                    AlertRuleConfig.resetToDefaults();
                    this.showWarningConfig();
                    MessageSystem.showMessage('预警配置已重置', 'success');
                }
            }

            static handleManualAdd() {
                const warnings = [];
                const allNumbers = Array.from({ length: 33 }, (_, i) => i + 1);

                const numberStats = {};
                allNumbers.forEach(num => {
                    numberStats[num] = {
                        currentOmission: 0,
                        frequency: 0,
                        recentAppearances: [],
                        maxOmission: 0,
                        avgOmission: 0,
                        omissionHistory: []
                    };
                });

                let currentOmission = {};
                allNumbers.forEach(num => currentOmission[num] = 0);

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    allNumbers.forEach(num => {
                        if (redBalls.includes(num)) {
                            numberStats[num].frequency++;
                            numberStats[num].recentAppearances.push(draw.period);
                            if (currentOmission[num] > numberStats[num].maxOmission) {
                                numberStats[num].maxOmission = currentOmission[num];
                            }
                            numberStats[num].omissionHistory.push(currentOmission[num]);
                            currentOmission[num] = 0;
                        } else {
                            currentOmission[num]++;
                        }
                    });
                });

                allNumbers.forEach(num => {
                    numberStats[num].currentOmission = currentOmission[num];
                    const omissionSum = numberStats[num].omissionHistory.reduce((a, b) => a + b, 0);
                    numberStats[num].avgOmission = numberStats[num].omissionHistory.length > 0 ? omissionSum / numberStats[num].omissionHistory.length : 0;
                });

                const avgOmission = periodCount / 33;
                const maxOmissionThreshold = avgOmission * 3;

                allNumbers.forEach(num => {
                    const stats = numberStats[num];
                    const omissionRatio = stats.currentOmission / (stats.avgOmission || 1);

                    if (stats.currentOmission > maxOmissionThreshold * 1.5) {
                        warnings.push({
                            type: '极端遗漏',
                            number: num,
                            level: this.calculateWarningLevel('extreme', stats.currentOmission, avgOmission),
                            message: `号码${num}已遗漏${stats.currentOmission}期，超过平均遗漏值${avgOmission.toFixed(1)}期的4.5倍，历史最大遗漏${stats.maxOmission}期，极强回补信号`
                        });
                    } else if (stats.currentOmission > maxOmissionThreshold) {
                        warnings.push({
                            type: '极端遗漏',
                            number: num,
                            level: this.calculateWarningLevel('high', stats.currentOmission, avgOmission),
                            message: `号码${num}已遗漏${stats.currentOmission}期，超过平均遗漏值${avgOmission.toFixed(1)}期的3倍，历史最大遗漏${stats.maxOmission}期，强烈建议关注回补`
                        });
                    } else if (stats.currentOmission > avgOmission * 2.5) {
                        warnings.push({
                            type: '长期遗漏',
                            number: num,
                            level: this.calculateWarningLevel('high', stats.currentOmission, avgOmission),
                            message: `号码${num}已遗漏${stats.currentOmission}期，超过平均遗漏值${avgOmission.toFixed(1)}期的2.5倍，建议重点关注`
                        });
                    } else if (stats.currentOmission > avgOmission * 2) {
                        warnings.push({
                            type: '长期遗漏',
                            number: num,
                            level: this.calculateWarningLevel('medium', stats.currentOmission, avgOmission),
                            message: `号码${num}已遗漏${stats.currentOmission}期，超过平均遗漏值${avgOmission.toFixed(1)}期的2倍，可能即将回补`
                        });
                    } else if (stats.currentOmission > avgOmission * 1.5 && omissionRatio > 1.8) {
                        warnings.push({
                            type: '长期遗漏',
                            number: num,
                            level: this.calculateWarningLevel('medium', stats.currentOmission, avgOmission),
                            message: `号码${num}已遗漏${stats.currentOmission}期，遗漏比例${omissionRatio.toFixed(2)}倍于平均值`
                        });
                    }

                    if (stats.currentOmission >= stats.maxOmission * 0.95 && stats.currentOmission > 10) {
                        warnings.push({
                            type: '接近历史极值',
                            number: num,
                            level: this.calculateWarningLevel('extreme', stats.currentOmission, stats.maxOmission),
                            message: `号码${num}当前遗漏${stats.currentOmission}期，接近历史最大遗漏${stats.maxOmission}期，回补概率极高`
                        });
                    } else if (stats.currentOmission >= stats.maxOmission * 0.85 && stats.currentOmission > 8) {
                        warnings.push({
                            type: '接近历史极值',
                            number: num,
                            level: this.calculateWarningLevel('high', stats.currentOmission, stats.maxOmission),
                            message: `号码${num}当前遗漏${stats.currentOmission}期，接近历史最大遗漏${stats.maxOmission}期，回补概率较高`
                        });
                    }

                    const recentPeriodDraws = draws.slice(-10);
                    let recent10Count = 0;
                    recentPeriodDraws.forEach(draw => {
                        if (draw.redBalls && draw.redBalls.includes(num)) {
                            recent10Count++;
                        }
                    });

                    if (recent10Count >= 5 && stats.currentOmission <= 1) {
                        warnings.push({
                            type: '热号预警',
                            number: num,
                            level: this.calculateWarningLevel('high', recent10Count, 10),
                            message: `号码${num}在最近10期出现${recent10Count}次，当前遗漏${stats.currentOmission}期，处于极热状态，可能继续热`
                        });
                    } else if (recent10Count >= 4 && stats.currentOmission <= 2) {
                        warnings.push({
                            type: '热号预警',
                            number: num,
                            level: this.calculateWarningLevel('medium', recent10Count, 10),
                            message: `号码${num}在最近10期出现${recent10Count}次，当前遗漏${stats.currentOmission}期，处于热态，可能继续热`
                        });
                    } else if (recent10Count >= 3 && stats.currentOmission === 0) {
                        warnings.push({
                            type: '热号预警',
                            number: num,
                            level: this.calculateWarningLevel('low', recent10Count, 10),
                            message: `号码${num}在最近10期出现${recent10Count}次，连续出现，注意热号延续`
                        });
                    }

                    if (recent10Count === 0 && stats.currentOmission > 20) {
                        warnings.push({
                            type: '冷号预警',
                            number: num,
                            level: this.calculateWarningLevel('extreme', stats.currentOmission, avgOmission),
                            message: `号码${num}在最近10期未出现且遗漏${stats.currentOmission}期，出现异常冷态，历史最大遗漏${stats.maxOmission}期`
                        });
                    } else if (recent10Count === 0 && stats.currentOmission > 15) {
                        warnings.push({
                            type: '冷号预警',
                            number: num,
                            level: this.calculateWarningLevel('high', stats.currentOmission, avgOmission),
                            message: `号码${num}在最近10期未出现且遗漏${stats.currentOmission}期，出现明显冷态，历史最大遗漏${stats.maxOmission}期`
                        });
                    } else if (recent10Count <= 1 && stats.currentOmission > 12 && omissionRatio > 2) {
                        warnings.push({
                            type: '冷号预警',
                            number: num,
                            level: this.calculateWarningLevel('medium', stats.currentOmission, avgOmission),
                            message: `号码${num}在最近10期仅出现${recent10Count}次，遗漏${stats.currentOmission}期，冷态明显`
                        });
                    }

                    const recent20Draws = draws.slice(-20);
                    let recent20Count = 0;
                    recent20Draws.forEach(draw => {
                        if (draw.redBalls && draw.redBalls.includes(num)) {
                            recent20Count++;
                        }
                    });

                    const frequencyRatio = stats.frequency / periodCount;
                    if (frequencyRatio > 0.25 && stats.currentOmission > avgOmission * 2) {
                        warnings.push({
                            type: '高频遗漏',
                            number: num,
                            level: this.calculateWarningLevel('high', frequencyRatio, 0.2),
                            message: `号码${num}为高频号（频率${(frequencyRatio * 100).toFixed(1)}%），当前遗漏${stats.currentOmission}期，回补概率极高`
                        });
                    } else if (frequencyRatio > 0.2 && stats.currentOmission > avgOmission * 1.5) {
                        warnings.push({
                            type: '高频遗漏',
                            number: num,
                            level: this.calculateWarningLevel('medium', frequencyRatio, 0.2),
                            message: `号码${num}为高频号（频率${(frequencyRatio * 100).toFixed(1)}%），当前遗漏${stats.currentOmission}期，回补概率较高`
                        });
                    } else if (frequencyRatio < 0.03 && stats.currentOmission < avgOmission * 0.3) {
                        warnings.push({
                            type: '低频活跃',
                            number: num,
                            level: this.calculateWarningLevel('low', frequencyRatio, 0.05),
                            message: `号码${num}为低频号（频率${(frequencyRatio * 100).toFixed(1)}%），近期活跃，注意冷热转换`
                        });
                    }

                    if (stats.omissionHistory.length >= 5) {
                        const recentOmissions = stats.omissionHistory.slice(-5);
                        const avgRecentOmission = recentOmissions.reduce((a, b) => a + b, 0) / recentOmissions.length;

                        if (stats.currentOmission > avgRecentOmission * 3 && stats.currentOmission > 10) {
                            warnings.push({
                                type: '遗漏异常',
                                number: num,
                                level: this.calculateWarningLevel('high', stats.currentOmission, avgRecentOmission),
                                message: `号码${num}当前遗漏${stats.currentOmission}期，近期平均遗漏${avgRecentOmission.toFixed(1)}期，遗漏异常延长`
                            });
                        } else if (stats.currentOmission > avgRecentOmission * 2 && stats.currentOmission > 8) {
                            warnings.push({
                                type: '遗漏异常',
                                number: num,
                                level: this.calculateWarningLevel('medium', stats.currentOmission, avgRecentOmission),
                                message: `号码${num}当前遗漏${stats.currentOmission}期，近期平均遗漏${avgRecentOmission.toFixed(1)}期，遗漏异常延长`
                            });
                        }
                    }
                });

                const extremeOmissionNumbers = allNumbers.filter(num => numberStats[num].currentOmission > maxOmissionThreshold);
                if (extremeOmissionNumbers.length >= 4) {
                    warnings.push({
                        type: '群体遗漏',
                        level: this.calculateWarningLevel('extreme', extremeOmissionNumbers.length, 3),
                        message: `有${extremeOmissionNumbers.length}个号码(${extremeOmissionNumbers.join('、')})处于极端遗漏状态，极可能集中回补`
                    });
                } else if (extremeOmissionNumbers.length >= 3) {
                    warnings.push({
                        type: '群体遗漏',
                        level: this.calculateWarningLevel('high', extremeOmissionNumbers.length, 3),
                        message: `有${extremeOmissionNumbers.length}个号码(${extremeOmissionNumbers.join('、')})处于极端遗漏状态，可能集中回补`
                    });
                }

                const hotNumbers = allNumbers.filter(num => {
                    const recent10Draws = draws.slice(-10);
                    let count = 0;
                    recent10Draws.forEach(draw => {
                        if (draw.redBalls && draw.redBalls.includes(num)) count++;
                    });
                    return count >= 4 && numberStats[num].currentOmission <= 2;
                });

                if (hotNumbers.length >= 6) {
                    warnings.push({
                        type: '群体热号',
                        level: this.calculateWarningLevel('high', hotNumbers.length, 5),
                        message: `有${hotNumbers.length}个号码(${hotNumbers.join('、')})处于热态，热号集中，注意分散选号`
                    });
                } else if (hotNumbers.length >= 5) {
                    warnings.push({
                        type: '群体热号',
                        level: this.calculateWarningLevel('medium', hotNumbers.length, 5),
                        message: `有${hotNumbers.length}个号码(${hotNumbers.join('、')})处于热态，热号集中，注意分散选号`
                    });
                }

                return warnings;
            }

            static checkIndicatorWarnings(draws, periodCount) {
                const warnings = [];

                let oddCount = 0, evenCount = 0;
                let bigCount = 0, smallCount = 0;
                let primeCount = 0, compositeCount = 0;
                let sumValues = [];
                let acValues = [];
                let spanValues = [];
                let oddEvenRatios = [];
                let bigSmallRatios = [];
                let primeCompositeRatios = [];
                const primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];

                    let drawOddCount = 0, drawEvenCount = 0;
                    let drawBigCount = 0, drawSmallCount = 0;
                    let drawPrimeCount = 0, drawCompositeCount = 0;

                    redBalls.forEach(num => {
                        if (num % 2 === 0) {
                            evenCount++;
                            drawEvenCount++;
                        } else {
                            oddCount++;
                            drawOddCount++;
                        }

                        if (num > 16) {
                            bigCount++;
                            drawBigCount++;
                        } else {
                            smallCount++;
                            drawSmallCount++;
                        }

                        if (primeNumbers.includes(num)) {
                            primeCount++;
                            drawPrimeCount++;
                        } else {
                            compositeCount++;
                            drawCompositeCount++;
                        }
                    });

                    oddEvenRatios.push(drawOddCount / 6);
                    bigSmallRatios.push(drawBigCount / 6);
                    primeCompositeRatios.push(drawPrimeCount / 6);

                    const sum = redBalls.reduce((a, b) => a + b, 0);
                    sumValues.push(sum);

                    const sorted = [...redBalls].sort((a, b) => a - b);
                    const span = sorted[sorted.length - 1] - sorted[0];
                    spanValues.push(span);

                    let ac = 0;
                    for (let i = 0; i < sorted.length; i++) {
                        for (let j = i + 1; j < sorted.length; j++) {
                            ac += Math.abs(sorted[j] - sorted[i]);
                        }
                    }
                    acValues.push(ac);
                });

                const oddRatio = oddCount / (oddCount + evenCount);
                const evenRatio = evenCount / (oddCount + evenCount);
                const avgOddEvenRatio = oddEvenRatios.reduce((a, b) => a + b, 0) / oddEvenRatios.length;
                const recentOddEvenRatio = oddEvenRatios.slice(-5).reduce((a, b) => a + b, 0) / 5;

                if (oddRatio > 0.75) {
                    warnings.push({
                        type: '奇偶比例严重失衡',
                        level: '极高',
                        message: `奇偶比例极严重失衡，奇数占比${(oddRatio * 100).toFixed(1)}%，极强烈建议关注偶数回补，历史平均奇数占比${(avgOddEvenRatio * 100).toFixed(1)}%`
                    });
                } else if (oddRatio > 0.7) {
                    warnings.push({
                        type: '奇偶比例严重失衡',
                        level: '高',
                        message: `奇偶比例严重失衡，奇数占比${(oddRatio * 100).toFixed(1)}%，强烈建议关注偶数回补，历史平均奇数占比${(avgOddEvenRatio * 100).toFixed(1)}%`
                    });
                } else if (oddRatio > 0.65) {
                    warnings.push({
                        type: '奇偶比例异常',
                        level: '高',
                        message: `奇偶比例严重失衡，奇数占比${(oddRatio * 100).toFixed(1)}%，建议关注偶数回补，历史平均奇数占比${(avgOddEvenRatio * 100).toFixed(1)}%`
                    });
                } else if (oddRatio > 0.6) {
                    warnings.push({
                        type: '奇偶比例偏高',
                        level: '中',
                        message: `奇偶比例偏高，奇数占比${(oddRatio * 100).toFixed(1)}%，近期奇数占比${(recentOddEvenRatio * 100).toFixed(1)}%`
                    });
                } else if (evenRatio > 0.75) {
                    warnings.push({
                        type: '奇偶比例严重失衡',
                        level: '极高',
                        message: `奇偶比例极严重失衡，偶数占比${(evenRatio * 100).toFixed(1)}%，极强烈建议关注奇数回补，历史平均偶数占比${((1 - avgOddEvenRatio) * 100).toFixed(1)}%`
                    });
                } else if (evenRatio > 0.7) {
                    warnings.push({
                        type: '奇偶比例严重失衡',
                        level: '高',
                        message: `奇偶比例严重失衡，偶数占比${(evenRatio * 100).toFixed(1)}%，强烈建议关注奇数回补，历史平均偶数占比${((1 - avgOddEvenRatio) * 100).toFixed(1)}%`
                    });
                } else if (evenRatio > 0.65) {
                    warnings.push({
                        type: '奇偶比例异常',
                        level: '高',
                        message: `奇偶比例严重失衡，偶数占比${(evenRatio * 100).toFixed(1)}%，建议关注奇数回补，历史平均偶数占比${((1 - avgOddEvenRatio) * 100).toFixed(1)}%`
                    });
                } else if (evenRatio > 0.6) {
                    warnings.push({
                        type: '奇偶比例偏高',
                        level: '中',
                        message: `偶数比例偏高，偶数占比${(evenRatio * 100).toFixed(1)}%，近期偶数占比${((1 - recentOddEvenRatio) * 100).toFixed(1)}%`
                    });
                }

                const bigRatio = bigCount / (bigCount + smallCount);
                const smallRatio = smallCount / (bigCount + smallCount);
                const avgBigSmallRatio = bigSmallRatios.reduce((a, b) => a + b, 0) / bigSmallRatios.length;
                const recentBigSmallRatio = bigSmallRatios.slice(-5).reduce((a, b) => a + b, 0) / 5;

                if (bigRatio > 0.7) {
                    warnings.push({
                        type: '大小比例严重失衡',
                        level: '高',
                        message: `大小比例严重失衡，大号占比${(bigRatio * 100).toFixed(1)}%，强烈建议关注小号回补，历史平均大号占比${(avgBigSmallRatio * 100).toFixed(1)}%`
                    });
                } else if (bigRatio > 0.65) {
                    warnings.push({
                        type: '大小比例异常',
                        level: '高',
                        message: `大小比例严重失衡，大号占比${(bigRatio * 100).toFixed(1)}%，建议关注小号回补，历史平均大号占比${(avgBigSmallRatio * 100).toFixed(1)}%`
                    });
                } else if (bigRatio > 0.6) {
                    warnings.push({
                        type: '大小比例偏高',
                        level: '中',
                        message: `大号比例偏高，大号占比${(bigRatio * 100).toFixed(1)}%，近期大号占比${(recentBigSmallRatio * 100).toFixed(1)}%`
                    });
                } else if (smallRatio > 0.7) {
                    warnings.push({
                        type: '大小比例严重失衡',
                        level: '高',
                        message: `大小比例严重失衡，小号占比${(smallRatio * 100).toFixed(1)}%，强烈建议关注大号回补，历史平均小号占比${((1 - avgBigSmallRatio) * 100).toFixed(1)}%`
                    });
                } else if (smallRatio > 0.65) {
                    warnings.push({
                        type: '大小比例异常',
                        level: '高',
                        message: `大小比例严重失衡，小号占比${(smallRatio * 100).toFixed(1)}%，建议关注大号回补，历史平均小号占比${((1 - avgBigSmallRatio) * 100).toFixed(1)}%`
                    });
                } else if (smallRatio > 0.6) {
                    warnings.push({
                        type: '大小比例偏高',
                        level: '中',
                        message: `小号比例偏高，小号占比${(smallRatio * 100).toFixed(1)}%，近期小号占比${((1 - recentBigSmallRatio) * 100).toFixed(1)}%`
                    });
                }

                const primeRatio = primeCount / (primeCount + compositeCount);
                const avgPrimeCompositeRatio = primeCompositeRatios.reduce((a, b) => a + b, 0) / primeCompositeRatios.length;
                const recentPrimeCompositeRatio = primeCompositeRatios.slice(-5).reduce((a, b) => a + b, 0) / 5;

                if (primeRatio > 0.65) {
                    warnings.push({
                        type: '质合比例异常',
                        level: '高',
                        message: `质合比例异常，质数占比${(primeRatio * 100).toFixed(1)}%，建议关注合数回补，历史平均质数占比${(avgPrimeCompositeRatio * 100).toFixed(1)}%`
                    });
                } else if (primeRatio > 0.6) {
                    warnings.push({
                        type: '质合比例偏高',
                        level: '中',
                        message: `质数比例偏高，质数占比${(primeRatio * 100).toFixed(1)}%，近期质数占比${(recentPrimeCompositeRatio * 100).toFixed(1)}%`
                    });
                } else if (primeRatio < 0.35) {
                    warnings.push({
                        type: '质合比例异常',
                        level: '高',
                        message: `质合比例异常，质数占比${(primeRatio * 100).toFixed(1)}%，建议关注质数回补，历史平均质数占比${(avgPrimeCompositeRatio * 100).toFixed(1)}%`
                    });
                } else if (primeRatio < 0.4) {
                    warnings.push({
                        type: '质合比例偏低',
                        level: '中',
                        message: `质数比例偏低，质数占比${(primeRatio * 100).toFixed(1)}%，近期质数占比${(recentPrimeCompositeRatio * 100).toFixed(1)}%`
                    });
                }

                const avgSum = sumValues.reduce((a, b) => a + b, 0) / sumValues.length;
                const recentSum = sumValues.slice(-5).reduce((a, b) => a + b, 0) / 5;
                const sumStdDev = Math.sqrt(sumValues.reduce((sum, val) => sum + Math.pow(val - avgSum, 2), 0) / sumValues.length);

                if (Math.abs(recentSum - avgSum) > 50) {
                    warnings.push({
                        type: '和值极严重异常',
                        level: '极高',
                        message: `最近5期平均和值${recentSum.toFixed(0)}偏离历史平均值${avgSum.toFixed(0)}超过50点，和值波动极严重异常，标准差${sumStdDev.toFixed(1)}`
                    });
                } else if (Math.abs(recentSum - avgSum) > 40) {
                    warnings.push({
                        type: '和值严重异常',
                        level: '高',
                        message: `最近5期平均和值${recentSum.toFixed(0)}偏离历史平均值${avgSum.toFixed(0)}超过40点，和值波动严重异常，标准差${sumStdDev.toFixed(1)}`
                    });
                } else if (Math.abs(recentSum - avgSum) > 30) {
                    warnings.push({
                        type: '和值异常',
                        level: '高',
                        message: `最近5期平均和值${recentSum.toFixed(0)}偏离历史平均值${avgSum.toFixed(0)}超过30点，和值波动异常，标准差${sumStdDev.toFixed(1)}`
                    });
                } else if (Math.abs(recentSum - avgSum) > 20) {
                    warnings.push({
                        type: '和值偏离',
                        level: '中',
                        message: `最近5期平均和值${recentSum.toFixed(0)}偏离历史平均值${avgSum.toFixed(0)}超过20点`
                    });
                }

                const minSum = Math.min(...sumValues);
                const maxSum = Math.max(...sumValues);
                if (recentSum < minSum + 10) {
                    warnings.push({
                        type: '和值过低',
                        level: '中',
                        message: `最近5期平均和值${recentSum.toFixed(0)}接近历史最低值${minSum}，和值偏低，可能反弹`
                    });
                } else if (recentSum > maxSum - 10) {
                    warnings.push({
                        type: '和值过高',
                        level: '中',
                        message: `最近5期平均和值${recentSum.toFixed(0)}接近历史最高值${maxSum}，和值偏高，可能回调`
                    });
                }

                const avgAC = acValues.reduce((a, b) => a + b, 0) / acValues.length;
                const recentAC = acValues.slice(-5).reduce((a, b) => a + b, 0) / 5;
                const acStdDev = Math.sqrt(acValues.reduce((sum, val) => sum + Math.pow(val - avgAC, 2), 0) / acValues.length);

                if (Math.abs(recentAC - avgAC) > 20) {
                    warnings.push({
                        type: 'AC值严重异常',
                        level: '高',
                        message: `最近5期平均AC值${recentAC.toFixed(1)}偏离历史平均值${avgAC.toFixed(1)}超过20，号码分布严重异常，标准差${acStdDev.toFixed(1)}`
                    });
                } else if (Math.abs(recentAC - avgAC) > 15) {
                    warnings.push({
                        type: 'AC值异常',
                        level: '高',
                        message: `最近5期平均AC值${recentAC.toFixed(1)}偏离历史平均值${avgAC.toFixed(1)}超过15，号码分布异常，标准差${acStdDev.toFixed(1)}`
                    });
                } else if (Math.abs(recentAC - avgAC) > 10) {
                    warnings.push({
                        type: 'AC值偏离',
                        level: '中',
                        message: `最近5期平均AC值${recentAC.toFixed(1)}偏离历史平均值${avgAC.toFixed(1)}超过10`
                    });
                }

                if (recentAC < 10) {
                    warnings.push({
                        type: 'AC值过低',
                        level: '中',
                        message: `最近5期平均AC值${recentAC.toFixed(1)}过低，号码分布过于集中，建议选择分散的号码组合`
                    });
                } else if (recentAC > 25) {
                    warnings.push({
                        type: 'AC值过高',
                        level: '中',
                        message: `最近5期平均AC值${recentAC.toFixed(1)}过高，号码分布过于分散，建议选择相对集中的号码组合`
                    });
                }

                const avgSpan = spanValues.reduce((a, b) => a + b, 0) / spanValues.length;
                const recentSpan = spanValues.slice(-5).reduce((a, b) => a + b, 0) / 5;

                if (Math.abs(recentSpan - avgSpan) > 8) {
                    warnings.push({
                        type: '跨度异常',
                        level: '中',
                        message: `最近5期平均跨度${recentSpan.toFixed(0)}偏离历史平均值${avgSpan.toFixed(0)}超过8，跨度波动异常`
                    });
                }

                if (recentSpan < 15) {
                    warnings.push({
                        type: '跨度过小',
                        level: '中',
                        message: `最近5期平均跨度${recentSpan.toFixed(0)}过小，号码分布过于集中，建议选择跨度较大的组合`
                    });
                } else if (recentSpan > 28) {
                    warnings.push({
                        type: '跨度过大',
                        level: '中',
                        message: `最近5期平均跨度${recentSpan.toFixed(0)}过大，号码分布过于分散，建议选择跨度较小的组合`
                    });
                }

                const consecutiveSameRatioCount = oddEvenRatios.slice(-10).filter((r, i, arr) => i > 0 && Math.abs(r - arr[i-1]) < 0.05).length;
                if (consecutiveSameRatioCount >= 7) {
                    warnings.push({
                        type: '指标僵化',
                        level: '中',
                        message: `最近10期奇偶比例变化幅度过小，指标呈现僵化趋势，可能即将出现大幅变化`
                    });
                }

                const sumTrend = sumValues.slice(-10);
                let sumIncreasingCount = 0;
                for (let i = 1; i < sumTrend.length; i++) {
                    if (sumTrend[i] > sumTrend[i-1]) sumIncreasingCount++;
                }
                if (sumIncreasingCount >= 8) {
                    warnings.push({
                        type: '和值单边上涨',
                        level: '中',
                        message: `最近10期和值持续上涨趋势明显，可能即将回调，建议关注和值下降`
                    });
                } else if (sumIncreasingCount <= 2) {
                    warnings.push({
                        type: '和值单边下跌',
                        level: '中',
                        message: `最近10期和值持续下跌趋势明显，可能即将反弹，建议关注和值上涨`
                    });
                }

                return warnings;
            }

            static checkTrendWarnings(draws, periodCount) {
                const warnings = [];

                for (let i = 1; i < draws.length; i++) {
                    const currentDraw = draws[i];
                    const prevDraw = draws[i - 1];

                    const currentRed = currentDraw.redBalls || [];
                    const prevRed = prevDraw.redBalls || [];

                    const repeats = currentRed.filter(num => prevRed.includes(num));

                    if (repeats.length >= 4) {
                        warnings.push({
                            type: '重号过多',
                            level: '中',
                            message: `第${currentDraw.period}期与上期有${repeats.length}个重号(${repeats.join('、')})，重号过多`
                        });
                    }
                }

                const recentDraws = draws.slice(-10);
                let consecutiveCount = 0;

                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const sorted = [...redBalls].sort((a, b) => a - b);

                    for (let i = 0; i < sorted.length - 1; i++) {
                        if (sorted[i + 1] - sorted[i] === 1) {
                            consecutiveCount++;
                        }
                    }
                });

                const avgConsecutive = consecutiveCount / 10;

                if (avgConsecutive > 2) {
                    warnings.push({
                        type: '连号过多',
                        level: '中',
                        message: `最近10期平均每期连号${avgConsecutive.toFixed(1)}对，连号出现频率较高`
                    });
                }

                const sumValues = draws.map(draw => {
                    const redBalls = draw.redBalls || [];
                    return redBalls.reduce((a, b) => a + b, 0);
                });

                let trendChanges = 0;
                for (let i = 2; i < sumValues.length; i++) {
                    const prev1 = sumValues[i - 1];
                    const prev2 = sumValues[i - 2];
                    const current = sumValues[i];

                    if ((prev1 > prev2 && current < prev1) || (prev1 < prev2 && current > prev1)) {
                        trendChanges++;
                    }
                }

                const recentTrendChanges = trendChanges / (sumValues.length - 2);

                if (recentTrendChanges > 0.6) {
                    warnings.push({
                        type: '走势转折频繁',
                        level: '中',
                        message: `和值走势转折频繁，近期趋势不稳定，建议谨慎选号`
                    });
                }

                return warnings;
            }

            static checkPatternWarnings(draws, periodCount) {
                const warnings = [];

                const patternCounts = {};

                draws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const sorted = [...redBalls].sort((a, b) => a - b);

                    const pattern = sorted.map((num, idx) => {
                        if (idx === 0) return 'S';
                        const diff = num - sorted[idx - 1];
                        if (diff === 1) return 'C';
                        if (diff <= 3) return 'N';
                        return 'F';
                    }).join('');

                    patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
                });

                Object.entries(patternCounts).forEach(([pattern, count]) => {
                    if (count >= 3) {
                        warnings.push({
                            type: '重复模式',
                            level: '中',
                            message: `模式"${pattern}"在${count}期中重复出现，近期可能继续出现`
                        });
                    }
                });

                const recentDraws = draws.slice(-10);
                const specialCombinations = [];

                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];

                    const hasAllSmall = redBalls.every(num => num <= 10);
                    const hasAllBig = redBalls.every(num => num >= 24);
                    const hasAllOdd = redBalls.every(num => num % 2 === 1);
                    const hasAllEven = redBalls.every(num => num % 2 === 0);

                    if (hasAllSmall || hasAllBig || hasAllOdd || hasAllEven) {
                        specialCombinations.push({
                            period: draw.period,
                            type: hasAllSmall ? '全小' : hasAllBig ? '全大' : hasAllOdd ? '全奇' : '全偶',
                            numbers: redBalls.join('、')
                        });
                    }
                });

                if (specialCombinations.length >= 2) {
                    warnings.push({
                        type: '特殊组合',
                        level: '高',
                        message: `最近10期出现${specialCombinations.length}次特殊组合(${specialCombinations.map(c => c.type).join('、')})，建议关注`
                    });
                }

                const primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];

                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const primeCount = redBalls.filter(num => primeNumbers.includes(num)).length;

                    if (primeCount >= 5) {
                        warnings.push({
                            type: '质数过多',
                            level: '中',
                            message: `第${draw.period}期质数${primeCount}个(${redBalls.filter(num => primeNumbers.includes(num)).join('、')})，质数比例偏高`
                        });
                    } else if (primeCount === 0) {
                        warnings.push({
                            type: '质数缺失',
                            level: '中',
                            message: `第${draw.period}期无质数，质数缺失，建议关注质数回补`
                        });
                    }
                });

                const tailDistribution = {};
                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(num => {
                        const tail = num % 10;
                        tailDistribution[tail] = (tailDistribution[tail] || 0) + 1;
                    });
                });

                const missingTails = Object.keys(tailDistribution).length < 10 ? 
                    Array.from({length: 10}, (_, i) => i).filter(t => !tailDistribution[t]) : [];

                if (missingTails.length >= 4) {
                    warnings.push({
                        type: '尾数缺失',
                        level: '中',
                        message: `最近10期缺失${missingTails.length}个尾数(${missingTails.join('、')})，建议关注缺失尾数`
                    });
                }

                const zoneDistribution = { zone1: 0, zone2: 0, zone3: 0 };
                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    redBalls.forEach(num => {
                        if (num <= 11) zoneDistribution.zone1++;
                        else if (num <= 22) zoneDistribution.zone2++;
                        else zoneDistribution.zone3++;
                    });
                });

                const totalNumbers = recentDraws.length * 6;
                const zone1Ratio = zoneDistribution.zone1 / totalNumbers;
                const zone2Ratio = zoneDistribution.zone2 / totalNumbers;
                const zone3Ratio = zoneDistribution.zone3 / totalNumbers;

                if (zone1Ratio > 0.5) {
                    warnings.push({
                        type: '区间失衡',
                        level: '高',
                        message: `最近10期一区号码占比${(zone1Ratio * 100).toFixed(1)}%，严重偏高，建议关注二、三区`
                    });
                } else if (zone3Ratio > 0.5) {
                    warnings.push({
                        type: '区间失衡',
                        level: '高',
                        message: `最近10期三区号码占比${(zone3Ratio * 100).toFixed(1)}%，严重偏高，建议关注一、二区`
                    });
                }

                const sameTailGroups = {};
                recentDraws.forEach(draw => {
                    const redBalls = draw.redBalls || [];
                    const tails = redBalls.map(num => num % 10);
                    const tailCounts = {};
                    tails.forEach(tail => {
                        tailCounts[tail] = (tailCounts[tail] || 0) + 1;
                    });
                    Object.entries(tailCounts).forEach(([tail, count]) => {
                        if (count >= 2) {
                            sameTailGroups[tail] = (sameTailGroups[tail] || 0) + 1;
                        }
                    });
                });

                const frequentSameTails = Object.entries(sameTailGroups)
                    .filter(([tail, count]) => count >= 4)
                    .map(([tail, count]) => ({ tail, count }));

                if (frequentSameTails.length > 0) {
                    warnings.push({
                        type: '同尾号频繁',
                        level: '中',
                        message: `最近10期尾数${frequentSameTails.map(t => t.tail).join('、')}频繁出现同尾号，建议关注`
                    });
                }

                const repeatNumbers = {};
                for (let i = 1; i < recentDraws.length; i++) {
                    const current = recentDraws[i].redBalls || [];
                    const prev = recentDraws[i - 1].redBalls || [];
                    const repeats = current.filter(num => prev.includes(num));
                    repeats.forEach(num => {
                        repeatNumbers[num] = (repeatNumbers[num] || 0) + 1;
                    });
                }

                const frequentRepeats = Object.entries(repeatNumbers)
                    .filter(([num, count]) => count >= 3)
                    .map(([num, count]) => ({ num: parseInt(num), count }));

                if (frequentRepeats.length > 0) {
                    warnings.push({
                        type: '重号频繁',
                        level: '中',
                        message: `号码${frequentRepeats.map(r => r.num).join('、')}频繁重号，建议关注`
                    });
                }

                return warnings;
            }

            static async handleManualAdd() {
                const input = document.getElementById('manualInput').value.trim();
                if (!input) {
                    MessageSystem.showMessage('请输入数据', 'warning');
                    return;
                }

                // 确定当前显示的数据库类型
                let displayLotteryType = 'ssq';
                const databaseCard = document.getElementById('databaseCard');
                if (databaseCard && databaseCard.style.display !== 'none') {
                    // 检查面包屑导航确定当前是哪个数据库
                    const breadcrumbContainer = document.querySelector('.breadcrumb');
                    if (breadcrumbContainer) {
                        const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                        if (breadcrumbItems.length >= 3) {
                            const breadcrumbText = breadcrumbItems[2].textContent;
                            if (breadcrumbText.includes('大乐透')) {
                                displayLotteryType = 'dlt';
                            }
                        }
                    }
                }

                // 确保数据库已初始化
                if (!dataManager.databases[displayLotteryType]) {
                    dataManager.databases[displayLotteryType] = new LotteryDatabase(displayLotteryType);
                    await dataManager.databases[displayLotteryType].init();
                }

                // 获取当前显示数据库的数据
                const displayDatabaseData = await dataManager.databases[displayLotteryType].getData();

                // 按行分割输入内容
                let lines = input.split('\n').filter(line => line.trim() !== '');

                // 检查是否是表格格式（包含制表符）
                const hasTab = lines.some(line => line.includes('\t'));
                if (hasTab) {
                    // 处理表格格式：A列为期号，B列为开奖号码
                    const processedLines = [];
                    lines.forEach(line => {
                        if (line.trim() === '') return;

                        const columns = line.split('\t');
                        if (columns.length >= 2) {
                            const period = columns[0].trim(); // A列：期号
                            const numbers = columns[1].trim(); // B列：开奖号码

                            // 组合成期望的格式：期号,开奖号码
                            if (period && numbers) {
                                processedLines.push(`${period},${numbers}`);
                            }
                        }
                    });
                    lines = processedLines;
                } else {
                    // 检查是否为预期的CSV格式
                    const hasCommaSeparated = lines.some(line => {
                        const parts = line.split(',');
                        return parts.length >= 2 && parts[0].trim().match(/^\d{7}$/); // 期号必须正好7位
                    });

                    if (!hasCommaSeparated && lines.length > 0) {
                        // 如果不是预期格式，提示用户正确格式

                    }
                }

                let addedCount = 0;
                let errorCount = 0;
                let duplicateCount = 0;

                for (const line of lines) {
                    const result = dataManager.parseAndValidateDrawData(line.trim(), displayLotteryType);
                    if (result.success) {
                        // 检查是否已存在相同期号的数据
                        const exists = displayDatabaseData.draws.some(draw => draw.period === result.data.period);
                        if (!exists) {
                            displayDatabaseData.draws.push(result.data);
                            addedCount++;
                        } else {
                            duplicateCount++;

                        }
                    } else {
                        errorCount++;

                    }
                }

                // 保存数据到对应的数据库
                await dataManager.databases[displayLotteryType].saveData(displayDatabaseData);

                // 更新表格显示
                dataManager.updateDatabaseTable(displayLotteryType);

                // 隐藏输入区域
                document.getElementById('manualInputArea').style.display = 'none';

                let message = `成功添加 ${addedCount} 条数据`;
                if (errorCount > 0) message += `，${errorCount} 条数据格式错误`;
                if (duplicateCount > 0) message += `，${duplicateCount} 条数据重复`;
                MessageSystem.showMessage(message, 'info');
            }

            static async handleDeleteSelected() {
                const selectedCheckboxes = document.querySelectorAll('#databaseTableBody input[type="checkbox"]:checked');
                if (selectedCheckboxes.length === 0) {
                    MessageSystem.showMessage('请先选择要删除的数据', 'warning');
                    return;
                }

                if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 条数据吗？`)) {
                    return;
                }

                // 确定当前显示的数据库类型
                let displayLotteryType = 'ssq';
                const databaseCard = document.getElementById('databaseCard');
                if (databaseCard && databaseCard.style.display !== 'none') {
                    // 检查面包屑导航确定当前是哪个数据库
                    const breadcrumbContainer = document.querySelector('.breadcrumb');
                    if (breadcrumbContainer) {
                        const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                        if (breadcrumbItems.length >= 3) {
                            const breadcrumbText = breadcrumbItems[2].textContent;
                            if (breadcrumbText.includes('大乐透')) {
                                displayLotteryType = 'dlt';
                            }
                        }
                    }
                }

                // 确保数据库已初始化
                if (!dataManager.databases[displayLotteryType]) {
                    dataManager.databases[displayLotteryType] = new LotteryDatabase(displayLotteryType);
                    await dataManager.databases[displayLotteryType].init();
                }

                // 获取当前显示数据库的数据
                const displayDatabaseData = await dataManager.databases[displayLotteryType].getData();

                // 获取选中行的期号
                const selectedPeriods = [];
                selectedCheckboxes.forEach(checkbox => {
                    const row = checkbox.closest('tr');
                    const period = row.getAttribute('data-period');
                    selectedPeriods.push(period);
                });

                // 从当前显示数据库的数据中移除选中的记录
                displayDatabaseData.draws = displayDatabaseData.draws.filter(draw => !selectedPeriods.includes(draw.period));

                // 保存数据到对应的数据库
                await dataManager.databases[displayLotteryType].saveData(displayDatabaseData);

                // 更新表格显示
                dataManager.updateDatabaseTable(displayLotteryType);

                MessageSystem.showMessage(`成功删除 ${selectedCheckboxes.length} 条数据`, 'success');
            }

            static handleFileInput(input) {
                if (input.files && input.files[0]) {
                    const file = input.files[0];

                    const fileExtension = file.name.split('.').pop().toLowerCase();

                    if (['xlsx', 'xls', 'csv', 'txt'].includes(fileExtension)) {
                        const reader = new FileReader();

                        reader.onload = function(e) {
                            try {
                                let lines = [];

                                if (fileExtension === 'csv' || fileExtension === 'txt') {
                                    let content = e.target.result;
                                    lines = content.split(/\r?\n/).filter(line => line.trim() !== '');


                                    EventDelegate.processImportedLines(lines);
                                } else {
                                    let arrayBuffer = e.target.result;

                                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });


                                    const firstSheetName = workbook.SheetNames[0];
                                    const worksheet = workbook.Sheets[firstSheetName];

                                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });


                                    lines = [];
                                    jsonData.forEach((row, index) => {
                                        if (row.length >= 2) {
                                            const period = row[0] ? row[0].toString().trim() : '';
                                            const numbers = row[1] ? row[1].toString().trim() : '';

                                            if (index === 0 && (period.includes('期号') || period.includes('号码') || numbers.includes('开奖号码') || numbers.includes('号码'))) {

                                                return;
                                            }

                                            if (period && numbers) {
                                                const combinedLine = `${period},${numbers}`;

                                                lines.push(combinedLine);
                                            }
                                        }
                                    });

                                    EventDelegate.processImportedLines(lines);
                                }

                            } catch (error) {

                                MessageSystem.showMessage('文件处理失败: ' + error.message, 'error');
                            }
                        };

                        reader.onerror = function() {
                            MessageSystem.showMessage('文件读取失败', 'error');
                        };

                        if (['xlsx', 'xls'].includes(fileExtension)) {
                            reader.readAsArrayBuffer(file);
                        } else {
                            reader.readAsText(file);
                        }
                    } else {
                        MessageSystem.showMessage('不支持的文件格式，请上传Excel(.xlsx, .xls)、CSV或TXT文件', 'error');
                    }
                }
            }

            static async processImportedLines(lines) {
                // 确定当前显示的数据库类型
                let displayLotteryType = 'ssq';
                const databaseCard = document.getElementById('databaseCard');
                if (databaseCard && databaseCard.style.display !== 'none') {
                    // 检查面包屑导航确定当前是哪个数据库
                    const breadcrumbContainer = document.querySelector('.breadcrumb');
                    if (breadcrumbContainer) {
                        const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                        if (breadcrumbItems.length >= 3) {
                            const breadcrumbText = breadcrumbItems[2].textContent;
                            console.log('导入数据 - 面包屑文本:', breadcrumbText);
                            if (breadcrumbText.includes('大乐透')) {
                                displayLotteryType = 'dlt';
                                console.log('导入数据 - 检测到大乐透数据库');
                            } else if (breadcrumbText.includes('双色球')) {
                                displayLotteryType = 'ssq';
                                console.log('导入数据 - 检测到双色球数据库');
                            } else {
                                console.log('导入数据 - 使用默认双色球数据库');
                            }
                        }
                    }
                }

                console.log('导入数据 - 彩票类型:', displayLotteryType);
                console.log('导入数据 - 数据行数:', lines.length);

                // 确保数据库已初始化
                if (!dataManager.databases[displayLotteryType]) {
                    dataManager.databases[displayLotteryType] = new LotteryDatabase(displayLotteryType);
                    await dataManager.databases[displayLotteryType].init();
                }

                // 获取当前显示数据库的数据
                const displayDatabaseData = await dataManager.databases[displayLotteryType].getData();

                let addedCount = 0;
                let errorCount = 0;
                let duplicateCount = 0;

                for (const line of lines) {
                    if (line.trim() === '') continue;

                    const result = dataManager.parseAndValidateDrawData(line.trim(), displayLotteryType);
                    if (result.success) {
                        const exists = displayDatabaseData.draws.some(draw => draw.period === result.data.period);
                        if (!exists) {
                            displayDatabaseData.draws.push(result.data);
                            addedCount++;
                        } else {
                            duplicateCount++;

                        }
                    } else {
                        errorCount++;
                        console.log('导入数据 - 格式错误:', line, result.error);

                    }
                }

                // 保存数据到对应的数据库
                await dataManager.databases[displayLotteryType].saveData(displayDatabaseData);

                // 更新表格显示
                dataManager.updateDatabaseTable(displayLotteryType);

                let message = `文件导入完成：成功添加 ${addedCount} 条数据`;
                if (errorCount > 0) message += `，${errorCount} 条数据格式错误`;
                if (duplicateCount > 0) message += `，${duplicateCount} 条数据重复`;
                MessageSystem.showMessage(message, 'success');
            }

            static handleBreadcrumbClick(breadcrumbItem) {
                if (!breadcrumbItem.classList.contains('active')) {
                    // 移除所有活动状态
                    document.querySelectorAll('.breadcrumb-item').forEach(item => {
                        item.classList.remove('active');
                    });

                    // 为当前点击项添加活动状态
                    breadcrumbItem.classList.add('active');

                    MessageSystem.showMessage(`导航到${breadcrumbItem.textContent}`, 'info');
                }
            }

            static handleActionClick(button) {
                switch(button.id) {
                    case 'exportData':
                        MessageSystem.showMessage('导出数据功能待实现', 'info');
                        break;
                    case 'switchChart':
                        MessageSystem.showMessage('切换图表功能待实现', 'info');
                        break;
                    case 'generateReport':
                        MessageSystem.showMessage('生成报告功能待实现', 'info');
                        break;
                    case 'exportChart':
                        MessageSystem.showMessage('导出图表功能待实现', 'info');
                        break;
                }
            }

            static handleDatabaseAction(button) {
                switch(button.id) {
                    case 'importExcelBtn':
                        // 触发文件选择对话框，文件选择后会自动触发change事件处理
                        document.getElementById('excelFileInput').click();
                        break;
                    case 'addManualBtn':
                        document.getElementById('manualInputArea').style.display = 'block';
                        document.getElementById('manualInput').value = '';
                        break;
                    case 'confirmAddBtn':
                        this.handleManualAdd();
                        break;
                    case 'cancelAddBtn':
                        document.getElementById('manualInputArea').style.display = 'none';
                        break;
                    case 'selectAllBtn':
                        this.handleSelectAllClick();
                        break;
                    case 'deleteSelectedBtn':
                        this.handleDeleteSelected();
                        break;
                    case 'clearDatabaseBtn':
                        this.handleClearDatabase();
                        break;
                }
            }

            static handleLibraryAction(button) {
                switch(button.id) {
                    case 'selectAllLibraryBtn':
                        this.handleSelectAllLibrary();
                        break;
                    case 'deleteLibraryBtn':
                        this.handleDeleteLibrary();
                        break;
                }
            }

            static handleSelectAll(checkbox) {
                const isChecked = checkbox.checked;
                const checkboxes = document.querySelectorAll('#databaseTableBody input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = isChecked);
            }

            static handleSelectAllClick() {
                const selectAllCheckbox = document.getElementById('selectAllCheckbox');
                selectAllCheckbox.checked = true;
                this.handleSelectAll(selectAllCheckbox);
            }

            static handleSelectAllLibrary() {
                const checkboxes = document.querySelectorAll('.library-checkbox');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                checkboxes.forEach(cb => cb.checked = !allChecked);
            }

            static handleDeleteLibrary() {
                const selectedCheckboxes = document.querySelectorAll('.library-checkbox:checked');
                if (selectedCheckboxes.length === 0) {
                    MessageSystem.showMessage('请先选择要删除的号码', 'warning');
                    return;
                }

                if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 条号码吗？`)) {
                    return;
                }

                const lotteryType = currentLotteryType;
                const currentLibrary = lotteryType === 'ssq' ? 
                    window.selectionSystemData.ssqNumberLibrary : 
                    window.selectionSystemData.dltNumberLibrary;

                const selectedIds = [];
                selectedCheckboxes.forEach(checkbox => {
                    selectedIds.push(parseInt(checkbox.getAttribute('data-id')));
                });

                const newLibrary = currentLibrary.filter(item => !selectedIds.includes(item.id));

                if (lotteryType === 'ssq') {
                    window.selectionSystemData.ssqNumberLibrary = newLibrary;
                    localStorage.setItem('ssqNumberLibrary', JSON.stringify(newLibrary));
                } else {
                    window.selectionSystemData.dltNumberLibrary = newLibrary;
                    localStorage.setItem('dltNumberLibrary', JSON.stringify(newLibrary));
                }

                EventDelegate.renderNumberLibrary();
                MessageSystem.showMessage(`成功删除 ${selectedCheckboxes.length} 条号码`, 'success');
            }

            static handleDistributionAction(button) {
                switch(button.id) {
                    case 'analyzeDistribution':
                        this.performDistributionAnalysis();
                        break;
                    case 'exportDistributionChart':
                        this.exportDistributionChart();
                        break;
                }
            }

            static handleDistributionTab(tab) {
                const tabs = document.querySelectorAll('.distribution-tab');
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                const type = tab.getAttribute('data-type');
                this.performDistributionAnalysis(type);
            }

            static handleHotColdTab(tab) {
                const tabs = document.querySelectorAll('.hotcold-tab');
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                const tabType = tab.getAttribute('data-tab');

                const contents = document.querySelectorAll('.hotcold-tab-content');
                contents.forEach(c => c.classList.remove('active'));

                const contentMap = {
                    'single': 'single-indicator',
                    'interval': 'interval-breakdown',
                    'combination': 'combination-feature',
                    'trend': 'trend-change'
                };

                const targetContentId = contentMap[tabType];
                if (targetContentId) {
                    const targetContent = document.getElementById(targetContentId);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                }

                this.performHotColdAnalysisByTab(tabType);
            }

            static handleRefreshHotColdAnalysis(button) {
                const activeTab = document.querySelector('.hotcold-tab.active');
                const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'single';
                this.performHotColdAnalysisByTab(tabType);
            }

            static calculateWarningLevel(type, value, threshold) {
                if (type === 'extreme') {
                    if (value > threshold * 4) return 'extreme';
                    if (value > threshold * 3) return 'high';
                    if (value > threshold * 2) return 'medium';
                    return 'low';
                } else if (type === 'high') {
                    if (value > threshold * 1.5) return 'high';
                    if (value > threshold * 1.2) return 'medium';
                    return 'low';
                } else if (type === 'medium') {
                    if (value > threshold * 1.1) return 'medium';
                    return 'low';
                } else {
                    return 'low';
                }
            }

            static setupAlertEventListeners() {
                document.getElementById('startNumberAnalysis').addEventListener('click', () => {
                    const draws = currentDatabaseData.draws;
                    const periodSelect = document.getElementById('analysisPeriodSelect');
                    const period = periodSelect ? periodSelect.value : '30';

                    let analysisDraws = draws;
                    if (period !== 'all' && draws) {
                        const periodNum = parseInt(period);
                        analysisDraws = draws.slice(-periodNum);
                    }

                    if (analysisDraws && analysisDraws.length >= 10) {
                        EventDelegate.performNumberAnalysis(analysisDraws, period);
                    } else {
                        MessageSystem.showMessage('开奖数据不足，至少需要10期数据才能进行分析', 'error');
                    }
                });

                document.getElementById('exportAnalysisReport').addEventListener('click', () => {
                    EventDelegate.exportAnalysisReport();
                });

                const redBallTab = document.getElementById('redBallTab');
                const blueBallTab = document.getElementById('blueBallTab');
                const redBallAlerts = document.getElementById('redBallAlerts');
                const blueBallAlerts = document.getElementById('blueBallAlerts');

                if (redBallTab && blueBallTab && redBallAlerts && blueBallAlerts) {
                    redBallTab.addEventListener('click', () => {
                        redBallTab.classList.add('active');
                        blueBallTab.classList.remove('active');
                        redBallAlerts.style.display = 'block';
                        blueBallAlerts.style.display = 'none';
                    });

                    blueBallTab.addEventListener('click', () => {
                        blueBallTab.classList.add('active');
                        redBallTab.classList.remove('active');
                        blueBallAlerts.style.display = 'block';
                        redBallAlerts.style.display = 'none';
                    });
                }
            }

            static performNumberAnalysis(draws, period = '30') {
                if (!draws || draws.length === 0) {
                    MessageSystem.showMessage('没有可分析的数据', 'error');
                    return;
                }
                
                const basicAnalysisData = EventDelegate.getBasicAnalysisData(draws);
                const advancedAnalysisData = EventDelegate.getAdvancedAnalysisData(draws);

                const signalTypes = new AlertSignalTypes();
                const analysisResults = signalTypes.detectAllSignals(draws, basicAnalysisData, advancedAnalysisData);

                const cycleAnalysisData = EventDelegate.performCycleAnalysis(draws);
                const stabilityAnalysisData = EventDelegate.performStabilityAnalysis(draws);
                const recoveryProbabilityData = EventDelegate.performRecoveryProbabilityAnalysis(draws);
                const correlationAnalysisData = EventDelegate.performCorrelationAnalysis(draws);
                const historicalAccuracyData = EventDelegate.performHistoricalAccuracyAnalysis(draws);

                window.numberAnalysisResults = analysisResults;
                window.numberBasicAnalysisData = basicAnalysisData;
                window.numberAdvancedAnalysisData = advancedAnalysisData;
                window.numberCycleAnalysisData = cycleAnalysisData;
                window.numberStabilityAnalysisData = stabilityAnalysisData;
                window.numberRecoveryProbabilityData = recoveryProbabilityData;
                window.numberCorrelationAnalysisData = correlationAnalysisData;
                window.numberHistoricalAccuracyData = historicalAccuracyData;
                window.numberAnalysisPeriod = period;

                // 更新分析范围显示
                const numberAnalysisSystemDataRangeInfo = document.getElementById('numberAnalysisSystemDataRangeInfo');
                if (numberAnalysisSystemDataRangeInfo && draws.length > 0) {
                    const startPeriod = draws[0].period;
                    const endPeriod = draws[draws.length - 1].period;
                    numberAnalysisSystemDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${draws.length}期）`;
                }

                EventDelegate.updateNumberAnalysisStatus('analyzing');
                EventDelegate.updateNumberAnalysisDashboard(analysisResults, basicAnalysisData, advancedAnalysisData, period);
                EventDelegate.updateBallAlertDisplay(analysisResults);
                EventDelegate.generateNumberAnalysisRecommendations(draws, analysisResults, basicAnalysisData, advancedAnalysisData, cycleAnalysisData, stabilityAnalysisData, recoveryProbabilityData, correlationAnalysisData, historicalAccuracyData);

                MessageSystem.showMessage(`号码分析完成（${period === 'all' ? '全部' : '最近' + period + '期'}）`, 'success');
                EventDelegate.updateNumberAnalysisStatus('completed');
            }

            static updateNumberAnalysisStatus(status) {
                const statusElement = document.getElementById('numberAnalysisStatus');
                if (statusElement) {
                    const statusMap = {
                        'unanalyzed': '未分析',
                        'analyzing': '分析中...',
                        'completed': '已完成'
                    };
                    statusElement.textContent = statusMap[status] || '未分析';
                }
            }

            static updateNumberAnalysisDashboard(analysisResults, basicAnalysisData, advancedAnalysisData, period = '30') {
                const indicatorSystem = new AlertIndicatorSystem();
                const visualization = new AlertVisualization();

                const riskScore = indicatorSystem.calculateRiskScore(analysisResults);
                const riskLevel = indicatorSystem.getRiskLevelByScore(riskScore);

                const riskScoreElement = document.getElementById('numberAnalysisRiskScore');
                if (riskScoreElement) {
                    riskScoreElement.textContent = riskScore.toFixed(0) + '分';
                    const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                    riskScoreElement.style.color = levelColors[riskLevel];
                }

                const analysisRangeElement = document.getElementById('numberAnalysisRange');
                if (analysisRangeElement) {
                    analysisRangeElement.textContent = period === 'all' ? '全部' : '最近' + period + '期';
                }

                visualization.initOverviewDashboard(analysisResults);
                visualization.initMonitoringWall(analysisResults);
                visualization.initHistoryAnalysis(analysisResults);
            }

            static generateNumberAnalysisRecommendations(draws, analysisResults, basicAnalysisData, advancedAnalysisData, cycleAnalysisData = null, stabilityAnalysisData = null, recoveryProbabilityData = null, correlationAnalysisData = null, historicalAccuracyData = null) {
                const recommendations = [];
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                const numberAnalysis = {};
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberAnalysis[num] = {
                        alerts: analysisResults.filter(a => a.number === num),
                        frequency: basicAnalysisData.frequencies[num] || 0,
                        omission: basicAnalysisData.omissions[num] || 0,
                        hotCold: basicAnalysisData.hotCold[num] || 'normal',
                        trend: advancedAnalysisData.trends[num] || 'stable',
                        cycle: cycleAnalysisData ? cycleAnalysisData[num] || {} : {},
                        stability: stabilityAnalysisData ? stabilityAnalysisData[num] || {} : {},
                        recoveryProbability: recoveryProbabilityData ? recoveryProbabilityData[num] || {} : {},
                        correlation: correlationAnalysisData ? correlationAnalysisData[num] || {} : {},
                        historicalAccuracy: historicalAccuracyData ? historicalAccuracyData[num] || {} : {}
                    };
                }

                Object.entries(numberAnalysis).forEach(([num, data]) => {
                    const numInt = parseInt(num);
                    const recommendation = EventDelegate.generateNumberRecommendation(draws, num, data, basicAnalysisData, advancedAnalysisData, cycleAnalysisData, stabilityAnalysisData, recoveryProbabilityData, correlationAnalysisData, historicalAccuracyData);
                    if (recommendation) {
                        recommendations.push(recommendation);
                    }
                });

                recommendations.sort((a, b) => b.priority - a.priority);
                const topRecommendations = recommendations.slice(0, 10);

                EventDelegate.displayRecommendations(topRecommendations);
                const recommendationsElement = document.getElementById('numberAnalysisRecommendations');
                if (recommendationsElement) {
                    recommendationsElement.textContent = topRecommendations.map(r => r.number).join(', ');
                }
            }

            static generateNumberRecommendation(draws, num, data, basicAnalysisData, advancedAnalysisData, cycleAnalysisData = null, stabilityAnalysisData = null, recoveryProbabilityData = null, correlationAnalysisData = null, historicalAccuracyData = null) {
                const numInt = parseInt(num);
                const recommendation = {
                    number: num,
                    priority: 0,
                    type: '',
                    reason: '',
                    suggestion: '',
                    confidence: 0,
                    strategyMatch: [],
                    additionalInfo: {}
                };

                const avgFrequency = Object.values(basicAnalysisData.frequencies).reduce((a, b) => a + b, 0) / Object.values(basicAnalysisData.frequencies).length;
                const avgOmission = Object.values(basicAnalysisData.omissions).reduce((a, b) => a + b, 0) / Object.values(basicAnalysisData.omissions).length;

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const blueBallRange = 16;
                const isRedBall = numInt <= redBallRange;
                const isBlueBall = numInt > redBallRange && numInt <= redBallRange + blueBallRange;

                let strategyScore = 0;
                let strategyReasons = [];
                let cycleScore = 0;
                let stabilityScore = 0;
                let recoveryScore = 0;
                let correlationScore = 0;
                let historicalScore = 0;

                if (isRedBall) {
                    const oddEvenData = this.getOddEvenRatio(draws, draws.length);
                    const sizeData = this.getSizeRatio(draws, draws.length);
                    const primeCompositeData = this.getPrimeCompositeRatio(draws, draws.length);

                    const numOdd = numInt % 2 === 1;
                    const numBig = numInt > 17;
                    const numPrime = this.isPrime(numInt);

                    if (oddEvenData.oddRatio > 0.5 && numOdd) {
                        strategyScore += 2;
                        strategyReasons.push('符合奇偶偏好');
                    }
                    if (oddEvenData.evenRatio > 0.5 && !numOdd) {
                        strategyScore += 2;
                        strategyReasons.push('符合偶偶偏好');
                    }
                    if (sizeData.bigRatio > 0.5 && numBig) {
                        strategyScore += 2;
                        strategyReasons.push('符合大小偏好');
                    }
                    if (sizeData.smallRatio > 0.5 && !numBig) {
                        strategyScore += 2;
                        strategyReasons.push('符合大小偏好');
                    }
                    if (primeCompositeData.primeRatio > 0.5 && numPrime) {
                        strategyScore += 2;
                        strategyReasons.push('符合质数偏好');
                    }
                    if (primeCompositeData.compositeRatio > 0.5 && !numPrime) {
                        strategyScore += 2;
                        strategyReasons.push('符合合数偏好');
                    }

                    const distributionData = this.getNumberDistribution(draws, draws.length);
                    const numZone = this.getNumberZone(numInt, redBallRange);
                    const isHighDensity = distributionData.highDensity.includes(numZone);
                    const isLowDensity = distributionData.lowDensity.includes(numZone);

                    if (isHighDensity) {
                        strategyScore += 3;
                        strategyReasons.push('位于高密度区间');
                    }
                    if (isLowDensity) {
                        strategyScore += 1;
                        strategyReasons.push('位于低密度区间');
                    }

                    const frequencyOmissionData = this.getFrequencyOmissionData(draws, draws.length);
                    const isStrongNumber = frequencyOmissionData.strongNumbers.includes(num);
                    const isPotentialNumber = frequencyOmissionData.potentialNumbers.includes(num);

                    if (isStrongNumber) {
                        strategyScore += 4;
                        strategyReasons.push('强势号码');
                    }
                    if (isPotentialNumber) {
                        strategyScore += 2;
                        strategyReasons.push('潜力号码');
                    }

                    const trendData = advancedAnalysisData.trends[num] || 'stable';
                    if (trendData === '上升') {
                        strategyScore += 3;
                        strategyReasons.push('趋势上升');
                    }
                    if (trendData === '下降') {
                        strategyScore -= 2;
                        strategyReasons.push('趋势下降');
                    }

                    const hotColdData = basicAnalysisData.hotCold[num] || 'normal';
                    if (hotColdData === 'hot') {
                        strategyScore += 3;
                        strategyReasons.push('热号');
                    }
                    if (hotColdData === 'cold') {
                        strategyScore -= 1;
                        strategyReasons.push('冷号');
                    }

                    if (cycleAnalysisData && cycleAnalysisData[num]) {
                        const cycleData = cycleAnalysisData[num];
                        if (cycleData.isCycleEnd) {
                            cycleScore += 5;
                            strategyReasons.push('周期结束');
                        }
                        if (cycleData.cycleStability > 0.7) {
                            cycleScore += 3;
                            strategyReasons.push('周期稳定');
                        }
                        if (cycleData.predictability > 0.6) {
                            cycleScore += 2;
                            strategyReasons.push('可预测');
                        }
                        if (cycleData.cyclePattern === 'resonance') {
                            cycleScore += 4;
                            strategyReasons.push('周期共振');
                        }
                    }

                    if (stabilityAnalysisData && stabilityAnalysisData[num]) {
                        const stabilityData = stabilityAnalysisData[num];
                        if (stabilityData.stabilityScore > 0.7) {
                            stabilityScore += 4;
                            strategyReasons.push('稳定性高');
                        }
                        if (stabilityData.consistencyScore > 0.6) {
                            stabilityScore += 3;
                            strategyReasons.push('一致性强');
                        }
                        if (stabilityData.regularityScore > 0.5) {
                            stabilityScore += 2;
                            strategyReasons.push('规律性强');
                        }
                    }

                    if (recoveryProbabilityData && recoveryProbabilityData[num]) {
                        const recoveryData = recoveryProbabilityData[num];
                        if (recoveryData.recoveryProbability > 0.7) {
                            recoveryScore += 5;
                            strategyReasons.push('回补概率高');
                        }
                        if (recoveryData.urgencyLevel === 'high') {
                            recoveryScore += 4;
                            strategyReasons.push('急需回补');
                        }
                        if (recoveryData.recoveryTrend === 'increasing') {
                            recoveryScore += 3;
                            strategyReasons.push('回补趋势上升');
                        }
                    }

                    if (correlationAnalysisData && correlationAnalysisData[num]) {
                        const correlationData = correlationAnalysisData[num];
                        if (correlationData.strongCorrelations.length > 0) {
                            correlationScore += 3;
                            strategyReasons.push(`强关联${correlationData.strongCorrelations.length}个`);
                        }
                        if (correlationData.clusterEffect) {
                            correlationScore += 2;
                            strategyReasons.push('集群效应');
                        }
                        if (correlationData.conductionEffect) {
                            correlationScore += 2;
                            strategyReasons.push('传导效应');
                        }
                    }

                    if (historicalAccuracyData && historicalAccuracyData[num]) {
                        const historicalData = historicalAccuracyData[num];
                        if (historicalData.shortTermAccuracy > 0.6) {
                            historicalScore += 3;
                            strategyReasons.push('短期准确率高');
                        }
                        if (historicalData.mediumTermAccuracy > 0.5) {
                            historicalScore += 2;
                            strategyReasons.push('中期准确率高');
                        }
                        if (historicalData.longTermAccuracy > 0.4) {
                            historicalScore += 1;
                            strategyReasons.push('长期准确率高');
                        }
                    }

                    const totalScore = strategyScore + cycleScore + stabilityScore + recoveryScore + correlationScore + historicalScore;

                    if (data.frequency > avgFrequency * 1.5 && data.omission > avgOmission * 2) {
                        recommendation.type = 'hot';
                        recommendation.priority = 3 + Math.floor(totalScore / 3);
                        recommendation.reason = `高频遗漏：频率${data.frequency}次，遗漏${data.omission}期，综合评分${totalScore}`;
                        recommendation.suggestion = '号码热度高且遗漏较大，建议重点关注';
                        recommendation.confidence = Math.min(0.95, 0.7 + totalScore * 0.02);
                    } else if (data.frequency < avgFrequency * 0.5 && data.omission < avgOmission * 0.5) {
                        recommendation.type = 'cold';
                        recommendation.priority = 1 + Math.floor(totalScore / 3);
                        recommendation.reason = `低频低遗漏：频率${data.frequency}次，遗漏${data.omission}期，综合评分${totalScore}`;
                        recommendation.suggestion = '号码热度低且遗漏较小，可能即将回补';
                        recommendation.confidence = Math.min(0.85, 0.5 + totalScore * 0.02);
                    } else if (trendData === '上升' && hotColdData === 'hot' && recoveryScore > 0) {
                        recommendation.type = 'trend_up';
                        recommendation.priority = 4 + Math.floor(totalScore / 3);
                        recommendation.reason = `趋势上升且为热号：趋势${trendData}，热度${hotColdData}，回补评分${recoveryScore}`;
                        recommendation.suggestion = '号码趋势上升且为热号，强烈推荐';
                        recommendation.confidence = Math.min(0.98, 0.8 + totalScore * 0.02);
                    } else if (trendData === '下降' && hotColdData === 'cold') {
                        recommendation.type = 'trend_down';
                        recommendation.priority = 2 + Math.floor(totalScore / 3);
                        recommendation.reason = `趋势下降且为冷号：趋势${trendData}，热度${hotColdData}，综合评分${totalScore}`;
                        recommendation.suggestion = '号码趋势下降且为冷号，建议观望';
                        recommendation.confidence = Math.min(0.75, 0.4 + totalScore * 0.02);
                    } else if (data.alerts.length >= 2) {
                        recommendation.type = 'alert';
                        recommendation.priority = 5 + Math.floor(totalScore / 3);
                        recommendation.reason = `多重预警：${data.alerts.length}条预警信号，综合评分${totalScore}`;
                        recommendation.suggestion = '号码存在多重预警，需要特别关注';
                        recommendation.confidence = Math.min(0.95, 0.75 + totalScore * 0.02);
                    } else if (totalScore >= 10) {
                        recommendation.type = 'strategy';
                        recommendation.priority = Math.max(1, Math.floor(totalScore / 2));
                        recommendation.reason = `策略匹配：${strategyReasons.join('、')}，综合评分${totalScore}`;
                        recommendation.suggestion = `符合${strategyReasons.length}个选号策略条件`;
                        recommendation.confidence = Math.min(0.95, 0.5 + totalScore * 0.03);
                    } else {
                        recommendation.type = 'strategy';
                        recommendation.priority = Math.max(1, Math.floor(totalScore / 3));
                        recommendation.reason = `策略匹配：${strategyReasons.join('、')}，综合评分${totalScore}`;
                        recommendation.suggestion = `符合${strategyReasons.length}个选号策略条件`;
                        recommendation.confidence = Math.min(0.85, 0.4 + totalScore * 0.03);
                    }

                    recommendation.strategyMatch = strategyReasons;
                    recommendation.additionalInfo = {
                        oddEven: numOdd ? '奇数' : '偶数',
                        bigSmall: numBig ? '大号' : '小号',
                        primeComposite: numPrime ? '质数' : '合数',
                        zone: numZone,
                        frequency: data.frequency,
                        omission: data.omission,
                        hotCold: hotColdData,
                        trend: trendData,
                        alertCount: data.alerts.length,
                        strategyScore: strategyScore,
                        cycleScore: cycleScore,
                        stabilityScore: stabilityScore,
                        recoveryScore: recoveryScore,
                        correlationScore: correlationScore,
                        historicalScore: historicalScore,
                        totalScore: totalScore
                    };
                } else if (isBlueBall) {
                    const blueFrequency = basicAnalysisData.frequencies[num] || 0;
                    const blueOmission = basicAnalysisData.omissions[num] || 0;
                    const blueHotCold = basicAnalysisData.hotCold[num] || 'normal';
                    const blueTrend = advancedAnalysisData.trends[num] || 'stable';
                    const blueAlerts = data.alerts || [];

                    const avgBlueFrequency = Object.values(basicAnalysisData.frequencies)
                        .filter((_, i) => i >= redBallRange)
                        .reduce((a, b) => a + b, 0) / blueBallRange;
                    const avgBlueOmission = Object.values(basicAnalysisData.omissions)
                        .filter((_, i) => i >= redBallRange)
                        .reduce((a, b) => a + b, 0) / blueBallRange;

                    let blueStrategyScore = 0;
                    let blueStrategyReasons = [];

                    if (blueFrequency > avgBlueFrequency * 1.2) {
                        blueStrategyScore += 3;
                        blueStrategyReasons.push('高频蓝球');
                    }
                    if (blueOmission > avgBlueOmission * 1.5) {
                        blueStrategyScore += 3;
                        blueStrategyReasons.push('高遗漏蓝球');
                    }
                    if (blueHotCold === 'hot') {
                        blueStrategyScore += 2;
                        blueStrategyReasons.push('热蓝球');
                    }
                    if (blueTrend === '上升') {
                        blueStrategyScore += 2;
                        blueStrategyReasons.push('趋势上升');
                    }
                    if (blueAlerts.length >= 1) {
                        blueStrategyScore += 4;
                        blueStrategyReasons.push('存在预警');
                    }

                    if (recoveryProbabilityData && recoveryProbabilityData[num]) {
                        const recoveryData = recoveryProbabilityData[num];
                        if (recoveryData.recoveryProbability > 0.7) {
                            blueStrategyScore += 5;
                            blueStrategyReasons.push('回补概率高');
                        }
                    }

                    if (historicalAccuracyData && historicalAccuracyData[num]) {
                        const historicalData = historicalAccuracyData[num];
                        if (historicalData.shortTermAccuracy > 0.6) {
                            blueStrategyScore += 3;
                            blueStrategyReasons.push('短期准确率高');
                        }
                    }

                    if (blueFrequency > avgBlueFrequency * 1.2 && blueOmission > avgBlueOmission * 1.5) {
                        recommendation.type = 'hot';
                        recommendation.priority = 3 + Math.floor(blueStrategyScore / 2);
                        recommendation.reason = `高频遗漏：频率${blueFrequency}次，遗漏${blueOmission}期，综合评分${blueStrategyScore}`;
                        recommendation.suggestion = '蓝球热度高且遗漏较大，建议重点关注';
                        recommendation.confidence = Math.min(0.9, 0.7 + blueStrategyScore * 0.02);
                    } else if (blueAlerts.length >= 1) {
                        recommendation.type = 'alert';
                        recommendation.priority = 5 + Math.floor(blueStrategyScore / 2);
                        recommendation.reason = `预警信号：${blueAlerts.length}条预警，综合评分${blueStrategyScore}`;
                        recommendation.suggestion = '蓝球存在预警信号，需要特别关注';
                        recommendation.confidence = Math.min(0.9, 0.75 + blueStrategyScore * 0.02);
                    } else if (blueStrategyScore >= 5) {
                        recommendation.type = 'strategy';
                        recommendation.priority = Math.max(1, Math.floor(blueStrategyScore / 2));
                        recommendation.reason = `策略匹配：${blueStrategyReasons.join('、')}，综合评分${blueStrategyScore}`;
                        recommendation.suggestion = `符合${blueStrategyReasons.length}个选号策略条件`;
                        recommendation.confidence = Math.min(0.9, 0.5 + blueStrategyScore * 0.03);
                    } else {
                        recommendation.type = 'strategy';
                        recommendation.priority = Math.max(1, Math.floor(blueStrategyScore / 3));
                        recommendation.reason = `策略匹配：${blueStrategyReasons.join('、')}，综合评分${blueStrategyScore}`;
                        recommendation.suggestion = `符合${blueStrategyReasons.length}个选号策略条件`;
                        recommendation.confidence = Math.min(0.8, 0.4 + blueStrategyScore * 0.03);
                    }

                    recommendation.strategyMatch = blueStrategyReasons;
                    recommendation.additionalInfo = {
                        frequency: blueFrequency,
                        omission: blueOmission,
                        hotCold: blueHotCold,
                        trend: blueTrend,
                        alertCount: blueAlerts.length,
                        strategyScore: blueStrategyScore
                    };
                }

                return recommendation.priority > 0 ? recommendation : null;
            }

            static isPrime(num) {
                if (num <= 1) return false;
                if (num <= 3) return true;
                if (num % 2 === 0) return false;
                for (let i = 3; i * i <= num; i += 2) {
                    if (num % i === 0) return false;
                }
                return true;
            }

            static performCycleAnalysis(draws) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const cycleData = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    cycleData[num] = {
                        intervals: [],
                        avgInterval: 0,
                        stdInterval: 0,
                        currentInterval: 0,
                        cycleStability: 0,
                        predictability: 0,
                        isCycleEnd: false,
                        cyclePattern: 'normal',
                        nextExpectedInterval: 0
                    };
                }

                const numberPositions = {};
                for (let i = 1; i <= redBallRange; i++) {
                    numberPositions[i.toString().padStart(2, '0')] = [];
                }

                draws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (numberPositions[ball]) {
                            numberPositions[ball].push(index);
                        }
                    });
                });

                Object.entries(numberPositions).forEach(([num, positions]) => {
                    if (positions.length < 3) return;

                    const intervals = [];
                    for (let i = 1; i < positions.length; i++) {
                        intervals.push(positions[i] - positions[i - 1]);
                    }

                    cycleData[num].intervals = intervals;

                    if (intervals.length > 0) {
                        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                        cycleData[num].avgInterval = avgInterval;

                        const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;
                        const stdInterval = Math.sqrt(variance);
                        cycleData[num].stdInterval = stdInterval;

                        cycleData[num].cycleStability = stdInterval > 0 ? Math.max(0, 1 - stdInterval / avgInterval) : 0;

                        const recentIntervals = intervals.slice(-Math.min(5, Math.floor(intervals.length * 0.5)));
                        let recentAvg = 0;
                        if (recentIntervals.length >= 3) {
                            recentAvg = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                            const recentVariance = recentIntervals.reduce((sum, val) => sum + Math.pow(val - recentAvg, 2), 0) / recentIntervals.length;
                            const recentStd = Math.sqrt(recentVariance);
                            cycleData[num].predictability = recentStd > 0 ? Math.max(0, 1 - recentStd / recentAvg) : 0;
                        }

                        const lastPosition = positions[positions.length - 1];
                        const currentInterval = draws.length - 1 - lastPosition;
                        cycleData[num].currentInterval = currentInterval;

                        if (currentInterval >= avgInterval - stdInterval && currentInterval <= avgInterval + stdInterval) {
                            cycleData[num].isCycleEnd = true;
                        }

                        if (recentIntervals.length >= 4 && recentAvg > 0) {
                            const isStable = recentIntervals.every(interval => Math.abs(interval - recentAvg) < 2);
                            if (isStable) {
                                cycleData[num].cyclePattern = 'resonance';
                            }
                        }

                        cycleData[num].nextExpectedInterval = Math.round(avgInterval);
                    }
                });

                return cycleData;
            }

            static performStabilityAnalysis(draws) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const stabilityData = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    stabilityData[num] = {
                        stabilityScore: 0,
                        consistencyScore: 0,
                        regularityScore: 0,
                        frequencyStability: 0,
                        omissionStability: 0,
                        trendStability: 0
                    };
                }

                const numberFrequencies = {};
                const numberOmissions = {};
                const numberTrends = {};

                for (let i = 1; i <= redBallRange; i++) {
                    numberFrequencies[i.toString().padStart(2, '0')] = [];
                    numberOmissions[i.toString().padStart(2, '0')] = [];
                    numberTrends[i.toString().padStart(2, '0')] = [];
                }

                const windowSize = Math.min(10, Math.floor(draws.length / 5));
                for (let i = windowSize; i <= draws.length; i++) {
                    const windowDraws = draws.slice(i - windowSize, i);

                    windowDraws.forEach(draw => {
                        draw.redBalls.forEach(ball => {
                            if (numberFrequencies[ball]) {
                                numberFrequencies[ball].push(1);
                            }
                        });
                    });

                    for (let j = 1; j <= redBallRange; j++) {
                        const num = j.toString().padStart(2, '0');
                        const freq = numberFrequencies[num].slice(-windowSize).reduce((a, b) => a + b, 0);
                        numberFrequencies[num][numberFrequencies[num].length - 1] = freq;
                    }
                }

                Object.entries(numberFrequencies).forEach(([num, frequencies]) => {
                    if (frequencies.length < 5) return;

                    const avgFreq = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
                    const variance = frequencies.reduce((sum, val) => sum + Math.pow(val - avgFreq, 2), 0) / frequencies.length;
                    const stdFreq = Math.sqrt(variance);

                    stabilityData[num].frequencyStability = stdFreq > 0 ? Math.max(0, 1 - stdFreq / avgFreq) : 0;

                    const recentFreqs = frequencies.slice(-Math.min(10, Math.floor(frequencies.length * 0.5)));
                    const recentAvg = recentFreqs.reduce((a, b) => a + b, 0) / recentFreqs.length;
                    const recentVariance = recentFreqs.reduce((sum, val) => sum + Math.pow(val - recentAvg, 2), 0) / recentFreqs.length;
                    const recentStd = Math.sqrt(recentVariance);

                    stabilityData[num].consistencyScore = recentStd > 0 ? Math.max(0, 1 - recentStd / recentAvg) : 0;

                    const trendChanges = [];
                    for (let i = 1; i < recentFreqs.length; i++) {
                        trendChanges.push(recentFreqs[i] - recentFreqs[i - 1]);
                    }

                    const avgTrendChange = trendChanges.reduce((a, b) => a + b, 0) / trendChanges.length;
                    const trendVariance = trendChanges.reduce((sum, val) => sum + Math.pow(val - avgTrendChange, 2), 0) / trendChanges.length;
                    const trendStd = Math.sqrt(trendVariance);

                    stabilityData[num].trendStability = trendStd > 0 ? Math.max(0, 1 - trendStd / Math.abs(avgTrendChange || 1)) : 0;

                    const regularity = frequencies.filter(f => Math.abs(f - avgFreq) < 1).length / frequencies.length;
                    stabilityData[num].regularityScore = regularity;

                    stabilityData[num].stabilityScore = (
                        stabilityData[num].frequencyStability * 0.4 +
                        stabilityData[num].consistencyScore * 0.3 +
                        stabilityData[num].trendStability * 0.2 +
                        stabilityData[num].regularityScore * 0.1
                    );
                });

                return stabilityData;
            }

            static performRecoveryProbabilityAnalysis(draws) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const recoveryData = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    recoveryData[num] = {
                        recoveryProbability: 0,
                        urgencyLevel: 'low',
                        recoveryTrend: 'stable',
                        expectedRecoveryPeriod: 0,
                        historicalRecoveryRate: 0,
                        currentOmission: 0,
                        avgOmission: 0
                    };
                }

                const numberOmissions = {};
                const numberRecoveryTimes = {};

                for (let i = 1; i <= redBallRange; i++) {
                    numberOmissions[i.toString().padStart(2, '0')] = [];
                    numberRecoveryTimes[i.toString().padStart(2, '0')] = [];
                }

                let lastAppearance = {};
                for (let i = 1; i <= redBallRange; i++) {
                    lastAppearance[i.toString().padStart(2, '0')] = -1;
                }

                draws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (lastAppearance[ball] !== -1) {
                            const omission = index - lastAppearance[ball];
                            numberOmissions[ball].push(omission);
                        }
                        lastAppearance[ball] = index;
                    });
                });

                const lastIndex = draws.length - 1;
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const currentOmission = lastIndex - lastAppearance[num];
                    recoveryData[num].currentOmission = currentOmission;

                    if (numberOmissions[num].length > 0) {
                        const avgOmission = numberOmissions[num].reduce((a, b) => a + b, 0) / numberOmissions[num].length;
                        recoveryData[num].avgOmission = avgOmission;

                        const recoveryProbability = Math.min(1, currentOmission / (avgOmission * 1.5));
                        recoveryData[num].recoveryProbability = recoveryProbability;

                        if (recoveryProbability > 0.8) {
                            recoveryData[num].urgencyLevel = 'high';
                        } else if (recoveryProbability > 0.5) {
                            recoveryData[num].urgencyLevel = 'medium';
                        } else {
                            recoveryData[num].urgencyLevel = 'low';
                        }

                        const recentOmissions = numberOmissions[num].slice(-Math.min(10, Math.floor(numberOmissions[num].length * 0.5)));
                        if (recentOmissions.length >= 3) {
                            const recentAvg = recentOmissions.reduce((a, b) => a + b, 0) / recentOmissions.length;
                            if (recentAvg < avgOmission) {
                                recoveryData[num].recoveryTrend = 'increasing';
                            } else if (recentAvg > avgOmission) {
                                recoveryData[num].recoveryTrend = 'decreasing';
                            }
                        }

                        recoveryData[num].expectedRecoveryPeriod = Math.round(avgOmission - currentOmission);

                        const recoveryCount = numberOmissions[num].filter(o => o <= avgOmission * 1.2).length;
                        recoveryData[num].historicalRecoveryRate = recoveryCount / numberOmissions[num].length;
                    }
                }

                return recoveryData;
            }

            static performCorrelationAnalysis(draws) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const correlationData = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    correlationData[num] = {
                        strongCorrelations: [],
                        clusterEffect: false,
                        conductionEffect: false,
                        correlationScore: 0,
                        relatedNumbers: []
                    };
                }

                const pairCounts = {};
                const numberAppearances = {};

                for (let i = 1; i <= redBallRange; i++) {
                    numberAppearances[i.toString().padStart(2, '0')] = 0;
                }

                draws.forEach(draw => {
                        const balls = draw.redBalls;
                        balls.forEach(ball => {
                            numberAppearances[ball]++;
                        });

                        for (let i = 0; i < balls.length; i++) {
                            for (let j = i + 1; j < balls.length; j++) {
                                const pair = [balls[i], balls[j]].sort().join('-');
                                pairCounts[pair] = (pairCounts[pair] || 0) + 1;
                            }
                        }
                    });

                    Object.entries(pairCounts).forEach(([pair, count]) => {
                        const [num1, num2] = pair.split('-');
                        const totalDraws = draws.length;

                        if (numberAppearances[num1] > 0 && numberAppearances[num2] > 0) {
                            const expectedCount = (numberAppearances[num1] * numberAppearances[num2]) / (totalDraws * 6);
                            const correlationRatio = count / expectedCount;

                            if (correlationRatio > 1.5 && count >= 5) {
                                correlationData[num1].strongCorrelations.push(num2);
                                correlationData[num2].strongCorrelations.push(num1);
                            }
                        }
                    });

                    const clusterThreshold = 3;
                    Object.entries(correlationData).forEach(([num, data]) => {
                        if (data.strongCorrelations.length >= clusterThreshold) {
                            data.clusterEffect = true;
                            data.correlationScore = data.strongCorrelations.length * 2;
                        }

                        const relatedNumbers = data.strongCorrelations.map(n => parseInt(n)).sort((a, b) => a - b);
                        data.relatedNumbers = relatedNumbers;

                        if (data.strongCorrelations.length > 0) {
                            const hasConduction = data.strongCorrelations.some(relatedNum => {
                                return correlationData[relatedNum].strongCorrelations.some(n => n !== num);
                            });
                            data.conductionEffect = hasConduction;
                        }
                    });

                    return correlationData;
            }

            static performHistoricalAccuracyAnalysis(draws) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const accuracyData = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    accuracyData[num] = {
                        shortTermAccuracy: 0,
                        mediumTermAccuracy: 0,
                        longTermAccuracy: 0,
                        overallAccuracy: 0,
                        predictionHits: 0,
                        predictionTotal: 0,
                        shortTermHits: 0,
                        mediumTermHits: 0,
                        longTermHits: 0,
                        shortTermTotal: 0,
                        mediumTermTotal: 0,
                        longTermTotal: 0
                    };
                }

                const shortTermWindow = Math.min(10, Math.floor(draws.length / 5));
                const mediumTermWindow = Math.min(30, Math.floor(draws.length / 3));
                const longTermWindow = Math.min(50, Math.floor(draws.length / 2));

                for (let i = longTermWindow; i < draws.length; i++) {
                    const historicalDraws = draws.slice(0, i);
                    const nextDraw = draws[i];

                    const shortTermDraws = historicalDraws.slice(-shortTermWindow);
                    const mediumTermDraws = historicalDraws.slice(-mediumTermWindow);
                    const longTermDraws = historicalDraws.slice(-longTermWindow);

                    const predictNumbers = (windowDraws) => {
                        const numberCounts = {};
                        for (let j = 1; j <= redBallRange; j++) {
                            numberCounts[j.toString().padStart(2, '0')] = 0;
                        }

                        windowDraws.forEach(draw => {
                            draw.redBalls.forEach(ball => {
                                numberCounts[ball]++;
                            });
                        });

                        const sortedNumbers = Object.entries(numberCounts)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 10)
                            .map(([num]) => num);

                        return sortedNumbers;
                    };

                    const shortTermPredictions = predictNumbers(shortTermDraws);
                    const mediumTermPredictions = predictNumbers(mediumTermDraws);
                    const longTermPredictions = predictNumbers(longTermDraws);

                    const actualNumbers = nextDraw.redBalls;

                    const checkAccuracy = (predictions, actuals) => {
                        const hits = predictions.filter(p => actuals.includes(p)).length;
                        return hits / actuals.length;
                    };

                    const shortTermAccuracy = checkAccuracy(shortTermPredictions, actualNumbers);
                    const mediumTermAccuracy = checkAccuracy(mediumTermPredictions, actualNumbers);
                    const longTermAccuracy = checkAccuracy(longTermPredictions, actualNumbers);

                    actualNumbers.forEach(num => {
                        accuracyData[num].predictionTotal++;
                        accuracyData[num].shortTermTotal++;
                        accuracyData[num].mediumTermTotal++;
                        accuracyData[num].longTermTotal++;

                        if (shortTermPredictions.includes(num)) {
                            accuracyData[num].predictionHits++;
                            accuracyData[num].shortTermHits++;
                        }
                        if (mediumTermPredictions.includes(num)) {
                            accuracyData[num].mediumTermHits++;
                        }
                        if (longTermPredictions.includes(num)) {
                            accuracyData[num].longTermHits++;
                        }
                    });
                }

                Object.entries(accuracyData).forEach(([num, data]) => {
                    if (data.predictionTotal > 0) {
                        data.overallAccuracy = data.predictionHits / data.predictionTotal;
                    }
                    if (data.shortTermTotal > 0) {
                        data.shortTermAccuracy = data.shortTermHits / data.shortTermTotal;
                    }
                    if (data.mediumTermTotal > 0) {
                        data.mediumTermAccuracy = data.mediumTermHits / data.mediumTermTotal;
                    }
                    if (data.longTermTotal > 0) {
                        data.longTermAccuracy = data.longTermHits / data.longTermTotal;
                    }
                });

                return accuracyData;
            }

            static getNumberZone(num, redBallRange) {
                if (num <= 11) return '一区(01-11)';
                if (num <= 22) return '二区(12-22)';
                if (num <= redBallRange) return '三区(23-' + redBallRange + ')';
                return '超出范围';
            }

            static displayRecommendations(recommendations) {
                const suggestionsContainer = document.getElementById('analysisSuggestions');
                const recommendationsContainer = document.getElementById('analysisRecommendations');

                if (!suggestionsContainer || !recommendationsContainer) return;

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const blueBallRange = 16;

                const redRecommendations = recommendations.filter(rec => {
                    const num = parseInt(rec.number);
                    return num <= redBallRange;
                });

                const blueRecommendations = recommendations.filter(rec => {
                    const num = parseInt(rec.number);
                    return num > redBallRange && num <= redBallRange + blueBallRange;
                });

                let suggestionsHtml = '<div style="display: flex; flex-direction: column; gap: 10px;">';

                if (redRecommendations.length > 0) {
                    suggestionsHtml += `
                        <div style="padding: 10px; background: #e3f2fd; border-radius: 6px; margin-bottom: 10px;">
                            <div style="font-size: 16px; font-weight: bold; color: #1565c0; margin-bottom: 8px;">🔴 红球推荐</div>
                        </div>
                    `;

                    redRecommendations.forEach(rec => {
                        const typeColors = {
                            'hot': '#FF6B6B',
                            'cold': '#4A90E2',
                            'trend_up': '#4CAF50',
                            'trend_down': '#FFA500',
                            'alert': '#FF4444',
                            'strategy': '#9C27B0'
                        };
                        const typeIcons = {
                            'hot': '🔥',
                            'cold': '❄️',
                            'trend_up': '📈',
                            'trend_down': '📉',
                            'alert': '⚠️',
                            'strategy': '🎯'
                        };
                        const typeNames = {
                            'hot': '热号推荐',
                            'cold': '冷号推荐',
                            'trend_up': '趋势上升',
                            'trend_down': '趋势下降',
                            'alert': '预警推荐',
                            'strategy': '策略匹配'
                        };

                        const additionalInfo = rec.additionalInfo || {};
                        const strategyMatch = rec.strategyMatch || [];

                        suggestionsHtml += `
                            <div style="
                                padding: 12px;
                                background: white;
                                border-radius: 6px;
                                border-left: 4px solid ${typeColors[rec.type]};
                                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                            ">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 20px;">${typeIcons[rec.type]}</span>
                                    <span style="font-weight: bold; color: #2c3e50;">${typeNames[rec.type]}</span>
                                    <span style="font-size: 18px; font-weight: bold; color: ${typeColors[rec.type]};">${rec.number}号</span>
                                    <span style="font-size: 12px; background: ${typeColors[rec.type]}; color: white; padding: 2px 8px; border-radius: 10px;">优先级：${rec.priority}</span>
                                </div>
                                <div style="margin-bottom: 6px; font-size: 13px; color: #666;">
                                    <strong>原因：</strong>${rec.reason}
                                </div>
                                <div style="margin-bottom: 6px; font-size: 13px; color: #666;">
                                    <strong>建议：</strong>${rec.suggestion}
                                </div>
                                ${strategyMatch.length > 0 ? `
                                <div style="margin-bottom: 6px; padding: 8px; background: #f5f5f5; border-radius: 4px; font-size: 12px; color: #555;">
                                    <strong>策略匹配：</strong>${strategyMatch.join('、')}
                                </div>
                                ` : ''}
                                ${additionalInfo && Object.keys(additionalInfo).length > 0 ? `
                                <div style="padding: 8px; background: #fff3e0; border-radius: 4px; font-size: 12px; color: #555;">
                                    <strong>详细参数：</strong><br/>
                                    ${additionalInfo.oddEven ? `• 奇偶：${additionalInfo.oddEven}<br/>` : ''}
                                    ${additionalInfo.bigSmall ? `• 大小：${additionalInfo.bigSmall}<br/>` : ''}
                                    ${additionalInfo.primeComposite ? `• 质合：${additionalInfo.primeComposite}<br/>` : ''}
                                    ${additionalInfo.zone ? `• 区间：${additionalInfo.zone}<br/>` : ''}
                                    ${additionalInfo.frequency !== undefined ? `• 频率：${additionalInfo.frequency}次<br/>` : ''}
                                    ${additionalInfo.omission !== undefined ? `• 遗漏：${additionalInfo.omission}期<br/>` : ''}
                                    ${additionalInfo.hotCold ? `• 冷热：${additionalInfo.hotCold === 'hot' ? '🔥 热号' : additionalInfo.hotCold === 'cold' ? '❄️ 冷号' : '🌡️ 正常'}<br/>` : ''}
                                    ${additionalInfo.trend ? `• 趋势：${additionalInfo.trend === '上升' ? '📈 上升' : additionalInfo.trend === '下降' ? '📉 下降' : '➡️ 稳定'}<br/>` : ''}
                                    ${additionalInfo.alertCount !== undefined ? `• 预警：${additionalInfo.alertCount}条<br/>` : ''}
                                    ${additionalInfo.strategyScore !== undefined ? `• 策略评分：${additionalInfo.strategyScore}<br/>` : ''}
                                    ${additionalInfo.cycleScore !== undefined ? `• 周期评分：${additionalInfo.cycleScore}<br/>` : ''}
                                    ${additionalInfo.stabilityScore !== undefined ? `• 稳定性评分：${additionalInfo.stabilityScore}<br/>` : ''}
                                    ${additionalInfo.recoveryScore !== undefined ? `• 回补评分：${additionalInfo.recoveryScore}<br/>` : ''}
                                    ${additionalInfo.correlationScore !== undefined ? `• 关联评分：${additionalInfo.correlationScore}<br/>` : ''}
                                    ${additionalInfo.historicalScore !== undefined ? `• 历史评分：${additionalInfo.historicalScore}<br/>` : ''}
                                    ${additionalInfo.totalScore !== undefined ? `• 综合评分：${additionalInfo.totalScore}` : ''}
                                </div>
                                ` : ''}
                                <div style="font-size: 12px; color: #999; margin-top: 6px;">
                                    置信度：${(rec.confidence * 100).toFixed(0)}%
                                </div>
                            </div>
                        `;
                    });
                }

                if (blueRecommendations.length > 0) {
                    suggestionsHtml += `
                        <div style="padding: 10px; background: #e8f5e9; border-radius: 6px; margin-bottom: 10px; margin-top: 15px;">
                            <div style="font-size: 16px; font-weight: bold; color: #2e7d32; margin-bottom: 8px;">🔵 蓝球推荐</div>
                        </div>
                    `;

                    blueRecommendations.forEach(rec => {
                        const typeColors = {
                            'hot': '#FF6B6B',
                            'cold': '#4A90E2',
                            'trend_up': '#4CAF50',
                            'trend_down': '#FFA500',
                            'alert': '#FF4444',
                            'strategy': '#9C27B0'
                        };
                        const typeIcons = {
                            'hot': '🔥',
                            'cold': '❄️',
                            'trend_up': '📈',
                            'trend_down': '📉',
                            'alert': '⚠️',
                            'strategy': '🎯'
                        };
                        const typeNames = {
                            'hot': '热号推荐',
                            'cold': '冷号推荐',
                            'trend_up': '趋势上升',
                            'trend_down': '趋势下降',
                            'alert': '预警推荐',
                            'strategy': '策略匹配'
                        };

                        const additionalInfo = rec.additionalInfo || {};
                        const strategyMatch = rec.strategyMatch || [];

                        suggestionsHtml += `
                            <div style="
                                padding: 12px;
                                background: white;
                                border-radius: 6px;
                                border-left: 4px solid ${typeColors[rec.type]};
                                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                            ">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 20px;">${typeIcons[rec.type]}</span>
                                    <span style="font-weight: bold; color: #2c3e50;">${typeNames[rec.type]}</span>
                                    <span style="font-size: 18px; font-weight: bold; color: ${typeColors[rec.type]};">${rec.number}号</span>
                                    <span style="font-size: 12px; background: ${typeColors[rec.type]}; color: white; padding: 2px 8px; border-radius: 10px;">优先级：${rec.priority}</span>
                                </div>
                                <div style="margin-bottom: 6px; font-size: 13px; color: #666;">
                                    <strong>原因：</strong>${rec.reason}
                                </div>
                                <div style="margin-bottom: 6px; font-size: 13px; color: #666;">
                                    <strong>建议：</strong>${rec.suggestion}
                                </div>
                                ${strategyMatch.length > 0 ? `
                                <div style="margin-bottom: 6px; padding: 8px; background: #f5f5f5; border-radius: 4px; font-size: 12px; color: #555;">
                                    <strong>策略匹配：</strong>${strategyMatch.join('、')}
                                </div>
                                ` : ''}
                                ${additionalInfo && Object.keys(additionalInfo).length > 0 ? `
                                <div style="padding: 8px; background: #fff3e0; border-radius: 4px; font-size: 12px; color: #555;">
                                    <strong>详细参数：</strong><br/>
                                    ${additionalInfo.frequency !== undefined ? `• 频率：${additionalInfo.frequency}次<br/>` : ''}
                                    ${additionalInfo.omission !== undefined ? `• 遗漏：${additionalInfo.omission}期<br/>` : ''}
                                    ${additionalInfo.hotCold ? `• 冷热：${additionalInfo.hotCold === 'hot' ? '🔥 热号' : additionalInfo.hotCold === 'cold' ? '❄️ 冷号' : '🌡️ 正常'}<br/>` : ''}
                                    ${additionalInfo.trend ? `• 趋势：${additionalInfo.trend === '上升' ? '📈 上升' : additionalInfo.trend === '下降' ? '📉 下降' : '➡️ 稳定'}<br/>` : ''}
                                    ${additionalInfo.alertCount !== undefined ? `• 预警：${additionalInfo.alertCount}条` : ''}
                                </div>
                                ` : ''}
                                <div style="font-size: 12px; color: #999; margin-top: 6px;">
                                    置信度：${(rec.confidence * 100).toFixed(0)}%
                                </div>
                            </div>
                        `;
                    });
                }

                suggestionsHtml += '</div>';
                suggestionsContainer.innerHTML = suggestionsHtml;

                let recommendationsHtml = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px;">';

                if (redRecommendations.length > 0) {
                    redRecommendations.forEach(rec => {
                        const priorityColors = { 1: '#4A90E2', 2: '#FFA500', 3: '#FF6B6B', 4: '#4CAF50', 5: '#FF4444', 6: '#9C27B0', 7: '#E91E63', 8: '#00BCD4', 9: '#FF9800', 10: '#795548' };
                        const priorityNames = { 1: '低', 2: '中低', 3: '中', 4: '中高', 5: '高', 6: '很高', 7: '极高', 8: '超高', 9: '顶级', 10: '终极' };

                        recommendationsHtml += `
                            <div style="
                                padding: 12px;
                                background: white;
                                border-radius: 6px;
                                border: 2px solid ${priorityColors[rec.priority]};
                                text-align: center;
                                cursor: pointer;
                                transition: all 0.3s;
                            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'" 
                               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                               onclick="EventDelegate.showAlertDetail('${rec.number}', 'red')">
                                <div style="font-size: 28px; font-weight: bold; color: ${priorityColors[rec.priority]}; margin-bottom: 5px;">${rec.number}</div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 3px;">${rec.suggestion.substring(0, 15)}${rec.suggestion.length > 15 ? '...' : ''}</div>
                                <div style="font-size: 11px; color: #999; margin-bottom: 3px;">优先级：${priorityNames[rec.priority] || rec.priority}</div>
                                <div style="font-size: 11px; color: #999;">置信度：${(rec.confidence * 100).toFixed(0)}%</div>
                            </div>
                        `;
                    });
                }

                if (blueRecommendations.length > 0) {
                    blueRecommendations.forEach(rec => {
                        const priorityColors = { 1: '#4A90E2', 2: '#FFA500', 3: '#FF6B6B', 4: '#4CAF50', 5: '#FF4444', 6: '#9C27B0', 7: '#E91E63', 8: '#00BCD4', 9: '#FF9800', 10: '#795548' };
                        const priorityNames = { 1: '低', 2: '中低', 3: '中', 4: '中高', 5: '高', 6: '很高', 7: '极高', 8: '超高', 9: '顶级', 10: '终极' };

                        recommendationsHtml += `
                            <div style="
                                padding: 12px;
                                background: white;
                                border-radius: 6px;
                                border: 2px solid ${priorityColors[rec.priority]};
                                text-align: center;
                                cursor: pointer;
                                transition: all 0.3s;
                            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'" 
                               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                               onclick="EventDelegate.showAlertDetail('${rec.number}', 'blue')">
                                <div style="font-size: 28px; font-weight: bold; color: ${priorityColors[rec.priority]}; margin-bottom: 5px;">${rec.number}</div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 3px;">${rec.suggestion.substring(0, 15)}${rec.suggestion.length > 15 ? '...' : ''}</div>
                                <div style="font-size: 11px; color: #999; margin-bottom: 3px;">优先级：${priorityNames[rec.priority] || rec.priority}</div>
                                <div style="font-size: 11px; color: #999;">置信度：${(rec.confidence * 100).toFixed(0)}%</div>
                            </div>
                        `;
                    });
                }

                recommendationsHtml += '</div>';
                recommendationsContainer.innerHTML = recommendationsHtml;
            }

            static exportAnalysisReport() {
                if (!window.numberAnalysisResults || window.numberAnalysisResults.length === 0) {
                    MessageSystem.showMessage('没有可导出的分析报告，请先进行分析', 'error');
                    return;
                }

                const basicData = window.numberBasicAnalysisData || {};
                const advancedData = window.numberAdvancedAnalysisData || {};

                let reportContent = '号码分析报告\n';
                reportContent += '====================\n\n';
                reportContent += `分析时间：${new Date().toLocaleString()}\n`;
                reportContent += `彩票类型：${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}\n`;
                reportContent += `分析期数：最近50期\n\n`;
                reportContent += `总预警数量：${window.numberAnalysisResults.length}条\n\n`;

                const levelCounts = { red: 0, yellow: 0, blue: 0 };
                window.numberAnalysisResults.forEach(alert => {
                    levelCounts[alert.level]++;
                });
                reportContent += '预警级别分布：\n';
                reportContent += `  红色预警：${levelCounts.red}条\n`;
                reportContent += `  黄色预警：${levelCounts.yellow}条\n`;
                reportContent += `  蓝色预警：${levelCounts.blue}条\n\n`;

                const typeCounts = { cycle: 0, distribution: 0, statistics: 0, trend: 0, correlation: 0 };
                window.numberAnalysisResults.forEach(alert => {
                    typeCounts[alert.type]++;
                });
                reportContent += '预警类型分布：\n';
                reportContent += `  周期规律：${typeCounts.cycle}条\n`;
                reportContent += `  分布异常：${typeCounts.distribution}条\n`;
                reportContent += `  统计极值：${typeCounts.statistics}条\n`;
                reportContent += `  趋势拐点：${typeCounts.trend}条\n`;
                reportContent += `  关联断裂：${typeCounts.correlation}条\n\n`;

                reportContent += '详细预警信息：\n';
                reportContent += '====================\n\n';
                window.numberAnalysisResults.forEach((alert, index) => {
                    reportContent += `${index + 1}. 号码：${alert.number || 'N/A'}\n`;
                    reportContent += `   类型：${alert.type}\n`;
                    reportContent += `   信号：${alert.signal}\n`;
                    reportContent += `   级别：${alert.level}\n`;
                    reportContent += `   描述：${alert.description}\n`;
                    reportContent += `   数值：${alert.value}\n`;
                    reportContent += `   阈值：${alert.threshold}\n`;
                    reportContent += `   数据来源：${alert.dataSource}\n`;
                    reportContent += `   时间：${new Date(alert.timestamp).toLocaleString()}\n\n`;
                });

                const blob = new Blob([reportContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `号码分析报告_${new Date().toISOString().slice(0, 10)}.txt`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                MessageSystem.showMessage('分析报告已导出', 'success');
            }

            static getBasicAnalysisData(draws) {
                return {
                    frequencies: EventDelegate.calculateFrequencies(draws),
                    omissions: EventDelegate.calculateOmissions(draws),
                    hotCold: EventDelegate.calculateHotCold(draws)
                };
            }

            static getAdvancedAnalysisData(draws) {
                return {
                    trends: EventDelegate.calculateTrends(draws),
                    patterns: EventDelegate.calculatePatterns(draws),
                    correlations: EventDelegate.calculateCorrelations(draws)
                };
            }

            static calculateFrequencies(draws) {
                const frequencies = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    frequencies[num] = 0;
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (frequencies[ball] !== undefined) {
                            frequencies[ball]++;
                        }
                    });
                });

                return frequencies;
            }

            static calculateOmissions(draws) {
                const omissions = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    omissions[num] = 0;
                }

                draws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (omissions[ball] === 0) {
                            omissions[ball] = index;
                        }
                    });
                });

                return omissions;
            }

            static calculateHotCold(draws) {
                const hotCold = {};
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    hotCold[num] = { hot: 0, cold: 0 };
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        hotCold[ball].hot++;
                    });
                });

                return hotCold;
            }

            static calculateAdvancedHotCold(draws) {
                if (!draws || draws.length === 0) {
                    return {};
                }

                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const hotColdData = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    hotColdData[num] = {
                        number: num,
                        shortTermCount: 0,
                        mediumTermCount: 0,
                        longTermCount: 0,
                        currentOmission: 0,
                        historyOmissions: [],
                        hotColdHistory: [],
                        hotColdTrend: 'stable',
                        hotColdState: 'normal',
                        hotColdScore: 0,
                        hotColdIntensity: 0,
                        hotColdPersistence: 0,
                        hotColdPredictability: 0,
                        hotColdReasonableness: 'normal',
                        hotColdRecommendation: '',
                        hotColdConfidence: 0
                    };
                }

                const shortTermDraws = draws.slice(-Math.min(10, Math.floor(draws.length / 5)));
                const mediumTermDraws = draws.slice(-Math.min(30, Math.floor(draws.length / 3)));
                const longTermDraws = draws;

                shortTermDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        hotColdData[ball].shortTermCount++;
                    });
                });

                mediumTermDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        hotColdData[ball].mediumTermCount++;
                    });
                });

                longTermDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        hotColdData[ball].longTermCount++;
                    });
                });

                const shortTermAvg = shortTermDraws.length * 6 / redBallRange;
                const mediumTermAvg = mediumTermDraws.length * 6 / redBallRange;
                const longTermAvg = longTermDraws.length * 6 / redBallRange;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const data = hotColdData[num];

                    data.hotColdScore = this.calculateHotColdScore(
                        data.shortTermCount, data.mediumTermCount, data.longTermCount,
                        shortTermAvg, mediumTermAvg, longTermAvg
                    );

                    data.hotColdState = this.determineHotColdState(data.hotColdScore);

                    data.hotColdIntensity = this.calculateHotColdIntensity(
                        data.shortTermCount, shortTermAvg
                    );

                    data.hotColdTrend = this.analyzeHotColdTrend(draws, num);

                    data.hotColdPersistence = this.calculateHotColdPersistence(draws, num);

                    data.hotColdPredictability = this.calculateHotColdPredictability(draws, num);

                    data.hotColdReasonableness = this.evaluateHotColdReasonableness(
                        data.hotColdScore, data.hotColdPersistence, data.hotColdPredictability
                    );

                    const recommendation = this.generateHotColdRecommendation(data);
                    data.hotColdRecommendation = recommendation.text;
                    data.hotColdConfidence = recommendation.confidence;

                    let currentOmission = 0;
                    for (let j = draws.length - 1; j >= 0; j--) {
                        if (draws[j].redBalls.includes(num)) {
                            data.currentOmission = currentOmission;
                            break;
                        }
                        currentOmission++;
                    }
                    if (currentOmission === draws.length) {
                        data.currentOmission = currentOmission;
                    }

                    for (let j = draws.length - 1; j >= 0; j--) {
                        if (draws[j].redBalls.includes(num)) {
                            data.historyOmissions.push(currentOmission);
                            currentOmission = 0;
                        } else {
                            currentOmission++;
                        }
                    }
                }

                return hotColdData;
            }

            static calculateHotColdScore(shortTermCount, mediumTermCount, longTermCount, shortTermAvg, mediumTermAvg, longTermAvg) {
                if (shortTermAvg === 0 || mediumTermAvg === 0 || longTermAvg === 0) {
                    return 0;
                }

                const shortTermRatio = shortTermCount / shortTermAvg;
                const mediumTermRatio = mediumTermCount / mediumTermAvg;
                const longTermRatio = longTermCount / longTermAvg;

                const weightedScore = (shortTermRatio * 0.5 + mediumTermRatio * 0.3 + longTermRatio * 0.2) * 100;
                return Math.max(0, Math.min(100, weightedScore));
            }

            static determineHotColdState(score) {
                if (score >= 80) return '超热';
                if (score >= 65) return '热';
                if (score >= 55) return '温';
                if (score >= 40) return '冷';
                return '超冷';
            }

            static calculateHotColdIntensity(shortTermCount, avg) {
                if (avg === 0) return 0;
                const intensity = (shortTermCount - avg) / avg * 100;
                return Math.max(-100, Math.min(100, intensity));
            }

            static analyzeHotColdTrend(draws, num) {
                const recentDraws = draws.slice(-Math.min(20, Math.floor(draws.length / 2)));
                const segmentSize = 5;
                const segments = [];

                for (let i = 0; i < recentDraws.length; i += segmentSize) {
                    const segment = recentDraws.slice(i, i + segmentSize);
                    const count = segment.filter(draw => draw.redBalls.includes(num)).length;
                    segments.push(count);
                }

                if (segments.length < 2) return '稳定';

                const firstHalf = segments.slice(0, Math.floor(segments.length / 2));
                const secondHalf = segments.slice(Math.floor(segments.length / 2));

                if (firstHalf.length === 0 || secondHalf.length === 0) return '稳定';

                const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

                const trend = secondAvg - firstAvg;

                if (trend > 0.5) return '上升';
                if (trend < -0.5) return '下降';
                return '稳定';
            }

            static calculateHotColdPersistence(draws, num) {
                const recentDraws = draws.slice(-Math.min(30, Math.floor(draws.length / 2)));
                const stateHistory = [];

                for (let i = 0; i < recentDraws.length; i += 5) {
                    const segment = recentDraws.slice(i, i + 5);
                    const count = segment.filter(draw => draw.redBalls.includes(num)).length;
                    const avg = 5 * 6 / (currentLotteryType === 'ssq' ? 33 : 35);

                    if (avg === 0) return 0;

                    const ratio = count / avg;

                    if (ratio >= 1.2) stateHistory.push('hot');
                    else if (ratio <= 0.8) stateHistory.push('cold');
                    else stateHistory.push('normal');
                }

                if (stateHistory.length < 2) return 0;

                const currentState = stateHistory[stateHistory.length - 1];
                const sameStateCount = stateHistory.filter(s => s === currentState).length;
                const persistence = sameStateCount / stateHistory.length * 100;

                return persistence;
            }

            static calculateHotColdPredictability(draws, num) {
                const recentDraws = draws.slice(-50);
                const intervals = [];
                let lastIndex = -1;

                recentDraws.forEach((draw, index) => {
                    if (draw.redBalls.includes(num)) {
                        if (lastIndex >= 0) {
                            intervals.push(index - lastIndex);
                        }
                        lastIndex = index;
                    }
                });

                if (intervals.length < 3) return 0;

                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;

                if (avgInterval === 0) return 0;

                const variance = intervals.reduce((acc, val) => acc + Math.pow(val - avgInterval, 2), 0) / intervals.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgInterval;

                const predictability = Math.max(0, 100 - coefficientOfVariation * 100);
                return predictability;
            }

            static evaluateHotColdReasonableness(score, persistence, predictability) {
                const safeScore = isNaN(score) ? 0 : score;
                const safePersistence = isNaN(persistence) ? 0 : persistence;
                const safePredictability = isNaN(predictability) ? 0 : predictability;

                const avgScore = (safeScore + safePersistence + safePredictability) / 3;

                if (avgScore >= 75) return '优秀';
                if (avgScore >= 60) return '良好';
                if (avgScore >= 45) return '正常';
                if (avgScore >= 30) return '偏低';
                return '异常';
            }

            static generateHotColdRecommendation(data) {
                const state = data.hotColdState;
                const trend = data.hotColdTrend;
                const persistence = data.hotColdPersistence;
                const predictability = data.hotColdPredictability;

                let text = '';
                let confidence = 0;

                if (state === '超热' || state === '热') {
                    if (trend === '上升' && persistence > 60) {
                        text = '热号持续上升，建议重点关注';
                        confidence = Math.min(95, 70 + persistence * 0.25);
                    } else if (trend === '下降') {
                        text = '热号开始降温，建议谨慎选择';
                        confidence = Math.min(85, 60 + predictability * 0.25);
                    } else {
                        text = '热号状态稳定，可适当关注';
                        confidence = Math.min(80, 60 + persistence * 0.2);
                    }
                } else if (state === '超冷' || state === '冷') {
                    if (trend === '上升' && persistence < 40) {
                        text = '冷号开始回暖，关注回补机会';
                        confidence = Math.min(90, 65 + predictability * 0.25);
                    } else if (data.currentOmission > 10) {
                        text = '冷号遗漏较大，回补概率增加';
                        confidence = Math.min(85, 60 + persistence * 0.25);
                    } else {
                        text = '冷号状态稳定，建议观望';
                        confidence = Math.min(70, 50 + predictability * 0.2);
                    }
                } else {
                    text = '温号状态平稳，可结合其他指标分析';
                    confidence = Math.min(75, 55 + predictability * 0.2);
                }

                return { text, confidence };
            }

            static calculateTrends(draws) {
                const trends = [];
                const recentDraws = draws;

                const sums = recentDraws.map(draw => {
                    return draw.redBalls.reduce((sum, ball) => sum + parseInt(ball), 0);
                });

                const avgSum = sums.reduce((a, b) => a + b, 0) / sums.length;
                const trend = sums.length > 0 ? (sums[sums.length - 1] - sums[0]) / sums.length : 0;

                return {
                    sums,
                    avgSum,
                    trend,
                    direction: trend > 0 ? 'up' : trend < 0 ? 'down' : 'stable'
                };
            }

            static calculatePatterns(draws) {
                const patterns = {};
                const recentDraws = draws;
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    patterns[num] = { consecutive: 0, intervals: [] };
                }

                recentDraws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (patterns[ball].intervals.length > 0) {
                            const lastIndex = patterns[ball].intervals[patterns[ball].intervals.length - 1];
                            const interval = index - lastIndex;
                            patterns[ball].intervals.push(interval);
                        } else {
                            patterns[ball].intervals.push(index);
                        }
                    });
                });

                return patterns;
            }

            static calculateCorrelations(draws) {
                const correlations = {};
                const recentDraws = draws.slice(-50);
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    correlations[num] = [];
                }

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        correlations[ball].push(draw.redBalls);
                    });
                });

                return correlations;
            }

            static updateNewAlertMonitoringStatus(newAlertEngine) {
                const status = newAlertEngine.getMonitoringStatus();
                const realTimeStatus = newAlertEngine.indicatorSystem.getRealTimeStatus(currentDatabaseData.draws);

                document.getElementById('newAlertDrawCountdown').textContent = `${realTimeStatus.drawCountdown}小时`;
                document.getElementById('newAlertDataStatus').textContent = 
                    realTimeStatus.dataUpdateStatus === 'normal' ? '正常' : 
                    realTimeStatus.dataUpdateStatus === 'warning' ? '警告' : '过期';
                document.getElementById('newAlertSystemStatus').textContent = 
                    status.isMonitoring ? '运行中' : '停止运行';

                const riskScore = newAlertEngine.indicatorSystem.calculateRiskScore(newAlertEngine.currentAlerts);
                document.getElementById('newAlertRiskScore').textContent = `${riskScore.toFixed(0)}分`;

                document.getElementById('newAlertCurrentCount').textContent = `${status.currentAlertCount}条`;
                document.getElementById('newAlertTodayCount').textContent = `${status.todayAlertCount}条`;

                const stats = newAlertEngine.getAlertStats();
                document.getElementById('newAlertTotalCountDisplay').textContent = stats.total;
                document.getElementById('newAlertHitCountDisplay').textContent = stats.hitCount || 0;
                document.getElementById('newAlertMissCountDisplay').textContent = stats.missCount || 0;
                document.getElementById('newAlertHitRateDisplay').textContent = `${stats.hitRate || 0}%`;

                const redCount = newAlertEngine.currentAlerts.filter(a => a.level === 'red').length;
                const yellowCount = newAlertEngine.currentAlerts.filter(a => a.level === 'yellow').length;
                const blueCount = newAlertEngine.currentAlerts.filter(a => a.level === 'blue').length;
                const totalCount = redCount + yellowCount + blueCount;

                document.getElementById('newAlertRedCount').textContent = redCount;
                document.getElementById('newAlertYellowCount').textContent = yellowCount;
                document.getElementById('newAlertBlueCount').textContent = blueCount;

                document.getElementById('newAlertRedPercent').textContent = totalCount > 0 ? `${((redCount / totalCount) * 100).toFixed(1)}%` : '0%';
                document.getElementById('newAlertYellowPercent').textContent = totalCount > 0 ? `${((yellowCount / totalCount) * 100).toFixed(1)}%` : '0%';
                document.getElementById('newAlertBluePercent').textContent = totalCount > 0 ? `${((blueCount / totalCount) * 100).toFixed(1)}%` : '0%';

                const highestLevel = redCount > 0 ? '🔴 红色' : yellowCount > 0 ? '🟡 黄色' : blueCount > 0 ? '🔵 蓝色' : '无';
                document.getElementById('newAlertHighestLevel').textContent = highestLevel;

                document.getElementById('newAlertWeeklyAvg').textContent = `${stats.hitRate || 0}%`;

                EventDelegate.updateBallAlertDisplay(newAlertEngine.currentAlerts);

                newAlertEngine.updateVisualization(newAlertEngine.currentAlerts);
            }

            static updateBallAlertDisplay(alerts) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const blueBallRange = 16;

                const redBallAlertGrid = document.getElementById('redBallAlertGrid');
                const blueBallAlertGrid = document.getElementById('blueBallAlertGrid');

                if (!redBallAlertGrid || !blueBallAlertGrid) return;

                const validAlerts = (alerts && Array.isArray(alerts)) ? alerts : [];

                const redBallAlerts = {};
                const blueBallAlerts = {};

                validAlerts.forEach(alert => {
                    if (alert.number) {
                        const num = parseInt(alert.number);
                        if (num <= redBallRange) {
                            if (!redBallAlerts[alert.number]) {
                                redBallAlerts[alert.number] = [];
                            }
                            redBallAlerts[alert.number].push(alert);
                        } else if (num <= redBallRange + blueBallRange) {
                            const blueNum = num - redBallRange;
                            const blueNumStr = blueNum.toString().padStart(2, '0');
                            if (!blueBallAlerts[blueNumStr]) {
                                blueBallAlerts[blueNumStr] = [];
                            }
                            blueBallAlerts[blueNumStr].push(alert);
                        }
                    }
                });

                let redBallHtml = '';
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const ballAlerts = redBallAlerts[num] || [];
                    const highestLevel = ballAlerts.length > 0 ? 
                        ballAlerts.some(a => a.level === 'red') ? 'red' : 
                        ballAlerts.some(a => a.level === 'yellow') ? 'yellow' : 'blue' : null;

                    const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2', null: '#4CAF50' };
                    const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵', null: '✓' };
                    const levelNames = { red: '红色', yellow: '黄色', blue: '蓝色', null: '正常' };

                    const bgColor = levelColors[highestLevel];
                    const icon = levelIcons[highestLevel];
                    const levelName = levelNames[highestLevel];

                    const alertInfo = ballAlerts.length > 0 ? 
                        ballAlerts.map(a => `${a.type}: ${a.description}`).join('<br/>') : 
                        '无预警';

                    redBallHtml += `
                        <div style="
                            background: ${bgColor};
                            color: white;
                            border-radius: 8px;
                            padding: 10px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" 
                        onclick="EventDelegate.showAlertDetail('${num}', 'red')">
                            <div style="font-size: 24px; font-weight: bold; margin-bottom: 5px;">${num}</div>
                            <div style="font-size: 12px;">${icon} ${levelName}</div>
                            <div style="font-size: 10px; margin-top: 3px;">${ballAlerts.length}条预警</div>
                        </div>
                    `;
                }

                let blueBallHtml = '';
                for (let i = 1; i <= blueBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const ballAlerts = blueBallAlerts[num] || [];
                    const highestLevel = ballAlerts.length > 0 ? 
                        ballAlerts.some(a => a.level === 'red') ? 'red' : 
                        ballAlerts.some(a => a.level === 'yellow') ? 'yellow' : 'blue' : null;

                    const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2', null: '#4CAF50' };
                    const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵', null: '✓' };
                    const levelNames = { red: '红色', yellow: '黄色', blue: '蓝色', null: '正常' };

                    const bgColor = levelColors[highestLevel];
                    const icon = levelIcons[highestLevel];
                    const levelName = levelNames[highestLevel];

                    blueBallHtml += `
                        <div style="
                            background: ${bgColor};
                            color: white;
                            border-radius: 8px;
                            padding: 10px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'"
                        onclick="EventDelegate.showAlertDetail('${num}', 'blue')">
                            <div style="font-size: 24px; font-weight: bold; margin-bottom: 5px;">${num}</div>
                            <div style="font-size: 12px;">${icon} ${levelName}</div>
                            <div style="font-size: 10px; margin-top: 3px;">${ballAlerts.length}条预警</div>
                        </div>
                    `;
                }

                redBallAlertGrid.innerHTML = redBallHtml;
                blueBallAlertGrid.innerHTML = blueBallHtml;
            }

            static showAlertDetail(number, ballType) {
                const redBallRange = currentLotteryType === 'ssq' ? 33 : 35;
                const blueBallRange = 16;

                let alerts = [];
                let alertHtml;
                const period = window.numberAnalysisPeriod || '未知';

                if (window.numberAnalysisResults && window.numberAnalysisResults.length > 0) {
                    alerts = window.numberAnalysisResults.filter(alert => {
                        if (alert.number) {
                            const num = parseInt(alert.number);
                            if (ballType === 'red') {
                                return num <= redBallRange && alert.number === number;
                            } else if (ballType === 'blue') {
                                return num > redBallRange && num <= redBallRange + blueBallRange && alert.number === number;
                            }
                        }
                        return false;
                    });
                }

                if (alerts.length === 0) {
                    const basicData = window.numberBasicAnalysisData || {};
                    const advancedData = window.numberAdvancedAnalysisData || {};
                    const period = window.numberAnalysisPeriod || '未知';

                    const numInt = parseInt(number);
                    const isRedBall = ballType === 'red';

                    const numData = basicData[number] || {};
                    const advData = advancedData[number] || {};

                    const frequency = numData.frequency || 0;
                    const omission = numData.omission || 0;
                    const hotCold = numData.hotCold || 'normal';
                    const trend = advData.trend || 'stable';

                    const avgFrequency = Object.values(basicData).reduce((sum, d) => sum + (d.frequency || 0), 0) / Object.keys(basicData).length;
                    const avgOmission = Object.values(basicData).reduce((sum, d) => sum + (d.omission || 0), 0) / Object.keys(basicData).length;

                    let alertStatus = '无预警';
                    let alertStatusColor = '#4CAF50';
                    let attentionLevel = '一般关注';
                    let attentionColor = '#FFA500';

                    if (frequency > avgFrequency * 1.5) {
                        alertStatus = '高频预警';
                        alertStatusColor = '#FF4444';
                        attentionLevel = '重点关注';
                        attentionColor = '#FF4444';
                    } else if (omission > avgOmission * 2) {
                        alertStatus = '高遗漏预警';
                        alertStatusColor = '#FF4444';
                        attentionLevel = '重点关注';
                        attentionColor = '#FF4444';
                    } else if (frequency > avgFrequency * 1.2) {
                        alertStatus = '频率偏高';
                        alertStatusColor = '#FFA500';
                        attentionLevel = '适度关注';
                        attentionColor = '#FFA500';
                    } else if (omission > avgOmission * 1.5) {
                        alertStatus = '遗漏偏高';
                        alertStatusColor = '#FFA500';
                        attentionLevel = '适度关注';
                        attentionColor = '#FFA500';
                    } else if (hotCold === 'hot' && trend === '上升') {
                        alertStatus = '热号上升';
                        alertStatusColor = '#FFA500';
                        attentionLevel = '适度关注';
                        attentionColor = '#FFA500';
                    }

                    let infoHtml = '';

                    infoHtml = `
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #2196F3; margin-bottom: 15px;">
                            <div style="font-size: 16px; font-weight: bold; color: #1565c0; margin-bottom: 10px;">📊 基础参数</div>
                            <div style="font-size: 14px; color: #555; line-height: 1.8;">
                                <div>• <strong>出现频率：</strong>${frequency}次（平均：${avgFrequency.toFixed(1)}次）</div>
                                <div>• <strong>当前遗漏：</strong>${omission}期（平均：${avgOmission.toFixed(1)}期）</div>
                                <div>• <strong>冷热状态：</strong>${hotCold === 'hot' ? '🔥 热号' : hotCold === 'cold' ? '❄️ 冷号' : '🌡️ 正常'}</div>
                                <div>• <strong>频率偏离：</strong>${frequency > avgFrequency ? '+' : ''}${((frequency - avgFrequency) / avgFrequency * 100).toFixed(1)}%</div>
                                <div>• <strong>遗漏偏离：</strong>${omission > avgOmission ? '+' : ''}${((omission - avgOmission) / avgOmission * 100).toFixed(1)}%</div>
                            </div>
                        </div>

                        <div style="padding: 15px; background: #fff3cd; border-radius: 4px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                            <div style="font-size: 16px; font-weight: bold; color: #856404; margin-bottom: 10px;">📈 高级参数</div>
                            <div style="font-size: 14px; color: #555; line-height: 1.8;">
                                <div>• <strong>趋势方向：</strong>${trend === '上升' ? '📈 上升' : trend === '下降' ? '📉 下降' : '➡️ 稳定'}</div>
                                <div>• <strong>关联号码：</strong>${advData.relatedNumbers && advData.relatedNumbers.length > 0 ? advData.relatedNumbers.join('、') : '无'}</div>
                                <div>• <strong>近期表现：</strong>${hotCold === 'hot' ? '表现活跃' : hotCold === 'cold' ? '表现低迷' : '表现平稳'}</div>
                            </div>
                        </div>

                        <div style="padding: 15px; background: #e8f5e9; border-radius: 4px; border-left: 4px solid #4caf50; margin-bottom: 15px;">
                            <div style="font-size: 16px; font-weight: bold; color: #2e7d32; margin-bottom: 10px;">⚠️ 预警状态</div>
                            <div style="font-size: 14px; color: #555; line-height: 1.8;">
                                <div>• <strong>当前预警：</strong><span style="color: ${alertStatusColor}; font-weight: bold;">${alertStatus}</span></div>
                                <div>• <strong>预警值：</strong>${frequency > avgFrequency * 1.5 ? frequency + '次（高频）' : omission > avgOmission * 2 ? omission + '期（高遗漏）' : '无'}</div>
                                <div>• <strong>关注级别：</strong><span style="color: ${attentionColor}; font-weight: bold;">${attentionLevel}</span></div>
                            </div>
                        </div>

                        <div style="padding: 15px; background: #e3f2fd; border-radius: 4px; border-left: 4px solid #2196f3; margin-bottom: 15px;">
                            <div style="font-size: 16px; font-weight: bold; color: #1565c0; margin-bottom: 10px;">💡 分析建议</div>
                            <div style="font-size: 14px; color: #555; line-height: 1.8;">
                                ${frequency > avgFrequency * 1.5 ? '<div>• 该号码出现频率较高（' + frequency + '次），建议关注但需谨慎追热</div>' : ''}
                                ${omission > avgOmission * 2 ? '<div>• 该号码遗漏较大（' + omission + '期），有回补机会，可适当关注</div>' : ''}
                                ${hotCold === 'hot' && trend === '上升' ? '<div>• 该号码为热号且趋势上升，近期表现活跃，值得重点关注</div>' : ''}
                                ${hotCold === 'cold' && omission > 10 ? '<div>• 该号码为冷号且遗漏较大，冷号回补概率增加，可适当关注</div>' : ''}
                                ${trend === '下降' && hotCold === 'hot' ? '<div>• 该号码虽为热号但趋势下降，可能进入调整期，建议观望</div>' : ''}
                                ${frequency < avgFrequency * 0.5 && omission < avgOmission * 0.5 ? '<div>• 该号码各项指标平稳，建议结合其他号码综合分析</div>' : ''}
                                ${!frequency > avgFrequency * 1.5 && !omission > avgOmission * 2 && !(hotCold === 'hot' && trend === '上升') ? '<div>• 该号码各项指标平稳，建议结合其他号码综合分析</div>' : ''}
                            </div>
                        </div>
                    `;

                    alertHtml = `
                        <div style="padding: 30px; max-width: 800px; max-height: 85vh; overflow-y: auto;">
                            <div style="font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #2c3e50; text-align: center; border-bottom: 3px solid #4CAF50; padding-bottom: 15px;">
                                ${ballType === 'red' ? '红球' : '蓝球'}号码 ${number} 全方位分析
                            </div>
                            <div style="margin-bottom: 15px; font-size: 14px; color: #666; text-align: center;">
                                分析期数：${period}期
                            </div>
                            ${infoHtml}

                            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center;">
                                <button id="closeAlertModalBtn" 
                                    style="
                                        background: linear-gradient(135deg, #4CAF50, #45a049);
                                        color: white;
                                        border: none;
                                        border-radius: 25px;
                                        padding: 12px 40px;
                                        font-size: 16px;
                                        font-weight: bold;
                                        cursor: pointer;
                                        transition: all 0.3s;
                                        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
                                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(76, 175, 80, 0.4)'" 
                                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(76, 175, 80, 0.3)'">
                                    关闭
                                </button>
                            </div>
                        </div>
                    `;
                }

                const levelColors = { red: '#FF4444', yellow: '#FFA500', blue: '#4A90E2' };
                const levelIcons = { red: '🔴', yellow: '🟡', blue: '🔵' };
                const levelNames = { red: '红色', yellow: '黄色', blue: '蓝色' };

                const typeTranslations = {
                    'frequency': '频率预警',
                    'omission': '遗漏预警',
                    'trend': '趋势预警',
                    'hotCold': '冷热预警',
                    'correlation': '关联预警',
                    'pattern': '模式预警',
                    'statistical': '统计预警',
                    'statistics': '统计预警',
                    'composite': '综合预警',
                    'cycle': '周期预警',
                    'missing': '缺失预警',
                    'anomaly': '异常预警',
                    'deviation': '偏离预警',
                    'outlier': '离群预警'
                };

                const signalTranslations = {
                    'high_frequency': '高频出现',
                    'low_frequency': '低频出现',
                    'high_omission': '高遗漏',
                    'low_omission': '低遗漏',
                    'omissionHigh': '高遗漏',
                    'omissionLow': '低遗漏',
                    'rising_trend': '上升趋势',
                    'falling_trend': '下降趋势',
                    'stable_trend': '稳定趋势',
                    'hot_number': '热号',
                    'cold_number': '冷号',
                    'correlation_found': '发现关联',
                    'pattern_detected': '检测到模式',
                    'cycle_detected': '检测到周期',
                    'cycleResonance': '周期共振',
                    'stdDeviation': '标准差偏离',
                    'anomaly_detected': '检测到异常',
                    'deviation_detected': '检测到偏离',
                    'outlier_detected': '检测到离群值'
                };

                const dimensionTranslations = {
                    'frequency': '频率维度',
                    'omission': '遗漏维度',
                    'trend': '趋势维度',
                    'hotCold': '冷热维度',
                    'correlation': '关联维度',
                    'pattern': '模式维度',
                    'statistical': '统计维度',
                    'statistics': '统计维度',
                    'composite': '综合维度',
                    'cycle': '周期维度',
                    'missing': '缺失维度',
                    'anomaly': '异常维度',
                    'deviation': '偏离维度',
                    'outlier': '离群维度'
                };

                const dataSourceTranslations = {
                    'basic': '基础分析',
                    'advanced': '高级分析',
                    'pattern': '模式分析',
                    'statistical': '统计分析',
                    'composite': '综合分析',
                    'database': '数据库',
                    'database+basicAnalysis': '数据库+基础分析',
                    'database+advancedAnalysis': '数据库+高级分析',
                    'database+patternAnalysis': '数据库+模式分析',
                    'database+statisticalAnalysis': '数据库+统计分析',
                    'database+compositeAnalysis': '数据库+综合分析'
                };

                alertHtml = `
                    <div style="padding: 30px; max-width: 800px; max-height: 85vh; overflow-y: auto;">
                        <div style="font-size: 24px; font-weight: bold; margin-bottom: 20px; color: #2c3e50; text-align: center; border-bottom: 3px solid #4CAF50; padding-bottom: 15px;">
                            ${ballType === 'red' ? '红球' : '蓝球'}号码 ${number} 全方位分析
                        </div>
                        <div style="margin-bottom: 15px; font-size: 14px; color: #666; text-align: center;">
                            分析期数：${period}期
                        </div>
                `;

                const basicData = window.numberBasicAnalysisData || {};
                const advancedData = window.numberAdvancedAnalysisData || {};

                const numData = basicData[number] || {};
                const advData = advancedData[number] || {};

                const frequency = numData.frequency || 0;
                const omission = numData.omission || 0;
                const hotCold = numData.hotCold || 'normal';
                const trend = advData.trend || 'stable';

                const basicDataValues = Object.values(basicData);
                const avgFrequency = basicDataValues.length > 0 ? basicDataValues.reduce((sum, d) => sum + (d.frequency || 0), 0) / basicDataValues.length : 0;
                const avgOmission = basicDataValues.length > 0 ? basicDataValues.reduce((sum, d) => sum + (d.omission || 0), 0) / basicDataValues.length : 0;

                const frequencyDeviation = avgFrequency > 0 ? ((frequency - avgFrequency) / avgFrequency * 100).toFixed(1) : '0.0';
                const omissionDeviation = avgOmission > 0 ? ((omission - avgOmission) / avgOmission * 100).toFixed(1) : '0.0';

                let alertStatus = '无预警';
                let alertStatusColor = '#4CAF50';
                let attentionLevel = '一般关注';
                let attentionColor = '#FFA500';

                if (frequency > avgFrequency * 1.5) {
                    alertStatus = '高频预警';
                    alertStatusColor = '#FF4444';
                    attentionLevel = '重点关注';
                    attentionColor = '#FF4444';
                } else if (omission > avgOmission * 2) {
                    alertStatus = '高遗漏预警';
                    alertStatusColor = '#FF4444';
                    attentionLevel = '重点关注';
                    attentionColor = '#FF4444';
                } else if (frequency > avgFrequency * 1.2) {
                    alertStatus = '频率偏高';
                    alertStatusColor = '#FFA500';
                    attentionLevel = '适度关注';
                    attentionColor = '#FFA500';
                } else if (omission > avgOmission * 1.5) {
                    alertStatus = '遗漏偏高';
                    alertStatusColor = '#FFA500';
                    attentionLevel = '适度关注';
                    attentionColor = '#FFA500';
                } else if (hotCold === 'hot' && trend === '上升') {
                    alertStatus = '热号上升';
                    alertStatusColor = '#FFA500';
                    attentionLevel = '适度关注';
                    attentionColor = '#FFA500';
                }

                alertHtml += `
                    <div style="padding: 15px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #2196F3; margin-bottom: 15px;">
                        <div style="font-size: 16px; font-weight: bold; color: #1565c0; margin-bottom: 10px;">📊 基础参数</div>
                        <div style="font-size: 14px; color: #555; line-height: 1.8;">
                            <div>• <strong>出现频率：</strong>${frequency}次（平均：${avgFrequency.toFixed(1)}次）</div>
                            <div>• <strong>当前遗漏：</strong>${omission}期（平均：${avgOmission.toFixed(1)}期）</div>
                            <div>• <strong>冷热状态：</strong>${hotCold === 'hot' ? '🔥 热号' : hotCold === 'cold' ? '❄️ 冷号' : '🌡️ 正常'}</div>
                            <div>• <strong>频率偏离：</strong>${frequency > avgFrequency ? '+' : ''}${frequencyDeviation}%</div>
                            <div>• <strong>遗漏偏离：</strong>${omission > avgOmission ? '+' : ''}${omissionDeviation}%</div>
                        </div>
                    </div>

                    <div style="padding: 15px; background: #fff3cd; border-radius: 4px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <div style="font-size: 16px; font-weight: bold; color: #856404; margin-bottom: 10px;">📈 高级参数</div>
                        <div style="font-size: 14px; color: #555; line-height: 1.8;">
                            <div>• <strong>趋势方向：</strong>${trend === '上升' ? '📈 上升' : trend === '下降' ? '📉 下降' : '➡️ 稳定'}</div>
                            <div>• <strong>关联号码：</strong>${advData.relatedNumbers && advData.relatedNumbers.length > 0 ? advData.relatedNumbers.join('、') : '无'}</div>
                            <div>• <strong>近期表现：</strong>${hotCold === 'hot' ? '表现活跃' : hotCold === 'cold' ? '表现低迷' : '表现平稳'}</div>
                        </div>
                    </div>

                    <div style="padding: 15px; background: #e8f5e9; border-radius: 4px; border-left: 4px solid #4caf50; margin-bottom: 15px;">
                        <div style="font-size: 16px; font-weight: bold; color: #2e7d32; margin-bottom: 10px;">⚠️ 预警状态</div>
                        <div style="font-size: 14px; color: #555; line-height: 1.8;">
                            <div>• <strong>当前预警：</strong><span style="color: ${alertStatusColor}; font-weight: bold;">${alertStatus}</span></div>
                            <div>• <strong>预警值：</strong>${frequency > avgFrequency * 1.5 ? frequency + '次（高频）' : omission > avgOmission * 2 ? omission + '期（高遗漏）' : '无'}</div>
                            <div>• <strong>关注级别：</strong><span style="color: ${attentionColor}; font-weight: bold;">${attentionLevel}</span></div>
                        </div>
                    </div>

                    <div style="padding: 15px; background: #e3f2fd; border-radius: 4px; border-left: 4px solid #2196f3; margin-bottom: 15px;">
                        <div style="font-size: 16px; font-weight: bold; color: #1565c0; margin-bottom: 10px;">💡 分析建议</div>
                        <div style="font-size: 14px; color: #555; line-height: 1.8;">
                            ${frequency > avgFrequency * 1.5 ? '<div>• 该号码出现频率较高（' + frequency + '次），建议关注但需谨慎追热</div>' : ''}
                            ${omission > avgOmission * 2 ? '<div>• 该号码遗漏较大（' + omission + '期），有回补机会，可适当关注</div>' : ''}
                            ${hotCold === 'hot' && trend === '上升' ? '<div>• 该号码为热号且趋势上升，近期表现活跃，值得重点关注</div>' : ''}
                            ${hotCold === 'cold' && omission > 10 ? '<div>• 该号码为冷号且遗漏较大，冷号回补概率增加，可适当关注</div>' : ''}
                            ${trend === '下降' && hotCold === 'hot' ? '<div>• 该号码虽为热号但趋势下降，可能进入调整期，建议观望</div>' : ''}
                            ${frequency < avgFrequency * 0.5 && omission < avgOmission * 0.5 ? '<div>• 该号码各项指标平稳，建议结合其他号码综合分析</div>' : ''}
                            ${!frequency > avgFrequency * 1.5 && !omission > avgOmission * 2 && !(hotCold === 'hot' && trend === '上升') ? '<div>• 该号码各项指标平稳，建议结合其他号码综合分析</div>' : ''}
                        </div>
                    </div>
                `;

                if (alerts.length > 0) {
                    alertHtml += `
                        <div style="padding: 15px; background: #fff3e0; border-radius: 4px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                            <div style="font-size: 16px; font-weight: bold; color: #856404; margin-bottom: 10px;">🚨 预警详情</div>
                    `;

                    alerts.forEach(alert => {
                        const bgColor = levelColors[alert.level] || '#4CAF50';
                        const icon = levelIcons[alert.level] || '✓';
                        const levelName = levelNames[alert.level] || '正常';

                        const translatedType = typeTranslations[alert.type] || alert.type || '未知';
                        const translatedSignal = signalTranslations[alert.signal] || alert.signal || '未知';
                        const translatedDimension = dimensionTranslations[alert.dimension] || alert.dimension || '未知';
                        const translatedDataSource = dataSourceTranslations[alert.dataSource] || alert.dataSource || '未知';

                        alertHtml += `
                            <div style="
                                background: white;
                                border-left: 4px solid ${bgColor};
                                border-radius: 4px;
                                padding: 15px;
                                margin-bottom: 10px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            ">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <div style="font-size: 14px; font-weight: bold; color: #2c3e50;">
                                        ${icon} ${levelName}预警
                                    </div>
                                    <div style="font-size: 12px; color: #999;">
                                        ${new Date(alert.timestamp).toLocaleString()}
                                    </div>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>预警类型：</strong>${translatedType}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>预警信号：</strong>${translatedSignal}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>预警描述：</strong>${alert.description || '无描述'}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>预警值：</strong>${alert.value || 0}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>预警阈值：</strong>${alert.threshold || 0}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>数据来源：</strong>${translatedDataSource}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>预警维度：</strong>${translatedDimension}
                                </div>
                            </div>
                        `;
                    });

                    alertHtml += `
                        </div>
                    `;
                }

                alertHtml += `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0; text-align: center;">
                        <button id="closeAlertModalBtn" 
                            style="
                                background: #4CAF50;
                                color: white;
                                border: none;
                                border-radius: 5px;
                                padding: 10px 30px;
                                font-size: 14px;
                                cursor: pointer;
                                transition: all 0.3s;
                            " onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4CAF50'">
                            关闭
                        </button>
                    </div>
                `;

                alertHtml += '</div>';

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    max-width: 90%;
                    max-height: 90%;
                    overflow: auto;
                `;
                modalContent.innerHTML = alertHtml;

                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);

                const closeBtn = modalContent.querySelector('#closeAlertModalBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        modalOverlay.remove();
                    });
                }

                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) {
                        modalOverlay.remove();
                    }
                });
            }

            static performAlertBacktest() {
                const draws = currentDatabaseData.draws || [];
                if (draws.length < 20) {
                    MessageSystem.showMessage('数据不足，至少需要20期数据才能进行历史回溯分析', 'error');
                    return;
                }

                const signalTypes = new AlertSignalTypes();
                const backtestResults = [];
                const backtestPeriods = [10, 20, 30, 50];

                backtestPeriods.forEach(period => {
                    if (draws.length < period) return;

                    for (let i = period; i < draws.length - 1; i++) {
                        const historicalDraws = draws.slice(0, i);
                        const nextDraw = draws[i];

                        const basicAnalysisData = EventDelegate.getBasicAnalysisData(historicalDraws);
                        const advancedAnalysisData = EventDelegate.getAdvancedAnalysisData(historicalDraws);

                        const alerts = signalTypes.detectAllSignals(historicalDraws, basicAnalysisData, advancedAnalysisData);
                        const hitAlerts = alerts.filter(alert => {
                            if (alert.number && nextDraw.redBalls.includes(alert.number)) {
                                return true;
                            }
                            if (alert.numbers && Array.isArray(alert.numbers)) {
                                const hitCount = alert.numbers.filter(num => nextDraw.redBalls.includes(num)).length;
                                return hitCount >= alert.numbers.length / 2;
                            }
                            return false;
                        });

                        backtestResults.push({
                            period: period,
                            testIndex: i,
                            testPeriod: `${draws[i - period].period}-${draws[i - 1].period}`,
                            predictionPeriod: draws[i].period,
                            totalAlerts: alerts.length,
                            hitAlerts: hitAlerts.length,
                            hitNumbers: hitAlerts.map(a => a.number).filter(n => n),
                            hitCount: hitAlerts.length > 0 ? 1 : 0
                        });
                    }
                });

                EventDelegate.displayBacktestResults(backtestResults);
            }

            static displayBacktestResults(results) {
                const totalTests = results.length;
                const hitTests = results.filter(r => r.hitCount === 1).length;
                const hitRate = totalTests > 0 ? ((hitTests / totalTests) * 100).toFixed(2) : 0;

                const periodStats = {};
                results.forEach(r => {
                    if (!periodStats[r.period]) {
                        periodStats[r.period] = { total: 0, hits: 0 };
                    }
                    periodStats[r.period].total++;
                    periodStats[r.period].hits += r.hitCount;
                });

                let periodHtml = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;">';
                Object.entries(periodStats).forEach(([period, stats]) => {
                    const rate = stats.total > 0 ? ((stats.hits / stats.total) * 100).toFixed(2) : 0;
                    periodHtml += `
                        <div style="padding: 15px; background: white; border-radius: 8px; border: 1px solid #e0e0e0;">
                            <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">
                                回溯期数：${period}期
                            </div>
                            <div style="margin-bottom: 5px;">总测试次数：<span style="color: #2196F3; font-weight: bold;">${stats.total}</span></div>
                            <div style="margin-bottom: 5px;">命中次数：<span style="color: #4CAF50; font-weight: bold;">${stats.hits}</span></div>
                            <div>命中率：<span style="color: ${rate > 30 ? '#FF4444' : rate > 15 ? '#FFA500' : '#4CAF50'}; font-weight: bold;">${rate}%</span></div>
                        </div>
                    `;
                });
                periodHtml += '</div>';

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    max-width: 90%;
                    max-height: 90%;
                    overflow: auto;
                    padding: 20px;
                `;

                modalContent.innerHTML = `
                    <div style="font-size: 20px; font-weight: bold; margin-bottom: 20px; color: #2c3e50; text-align: center;">
                        <i class="fas fa-history"></i> 预警历史回溯分析结果
                    </div>
                    <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #2196F3;">
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #2c3e50;">总体统计</div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; font-size: 14px;">
                            <div>总测试次数：<span style="color: #2196F3; font-weight: bold; font-size: 18px;">${totalTests}</span></div>
                            <div>命中次数：<span style="color: #4CAF50; font-weight: bold; font-size: 18px;">${hitTests}</span></div>
                            <div>命中率：<span style="color: ${hitRate > 30 ? '#FF4444' : hitRate > 15 ? '#FFA500' : '#4CAF50'}; font-weight: bold; font-size: 18px;">${hitRate}%</span></div>
                        </div>
                    </div>
                    <div style="margin-bottom: 20px; font-size: 16px; font-weight: bold; color: #2c3e50;">不同回溯期数统计</div>
                    ${periodHtml}
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; text-align: center;">
                        <button id="closeBacktestModalBtn" 
                            style="
                                background: #4CAF50;
                                color: white;
                                border: none;
                                border-radius: 5px;
                                padding: 10px 30px;
                                font-size: 14px;
                                cursor: pointer;
                                transition: all 0.3s;
                            " onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4CAF50'">
                            关闭
                        </button>
                    </div>
                `;

                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);

                const closeBtn = modalContent.querySelector('#closeBacktestModalBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        modalOverlay.remove();
                    });
                }

                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) {
                        modalOverlay.remove();
                    }
                });
            }

            static performHotColdAnalysisByTab(tabType) {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const hotColdPeriodSelect = document.getElementById('hotColdPeriodSelect');
                    const selectedPeriod = hotColdPeriodSelect ? hotColdPeriodSelect.value : '100';
                    const periodCount = selectedPeriod !== 'all' ? parseInt(selectedPeriod) : draws.length;
                    const analysisDraws = draws.slice(-periodCount);

                    // 更新分析范围显示
                    const hotColdDataRangeInfo = document.getElementById('hotColdDataRangeInfo');
                    if (hotColdDataRangeInfo && analysisDraws.length > 0) {
                        const startPeriod = analysisDraws[0].period;
                        const endPeriod = analysisDraws[analysisDraws.length - 1].period;
                        hotColdDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisDraws.length}期）`;
                    }

                    switch(tabType) {
                        case 'single':
                            this.performSingleIndicatorAnalysis(analysisDraws, periodCount);
                            break;
                        case 'interval':
                            this.performIntervalBreakdownAnalysis(analysisDraws, periodCount);
                            break;
                        case 'combination':
                            this.performCombinationFeatureAnalysis(analysisDraws, periodCount);
                            break;
                        case 'trend':
                            this.performTrendChangeAnalysis(analysisDraws, periodCount);
                            break;
                    }
                });
            }

            static performDistributionAnalysis(type = null) {
                dataManager.loadDataForCurrentLottery().then(() => {
                    if (!type) {
                        const activeTab = document.querySelector('.distribution-tab.active');
                        type = activeTab ? activeTab.getAttribute('data-type') : 'interval';
                    }

                    const periodSelect = document.getElementById('distributionPeriodSelect');
                    let periodCount = parseInt(periodSelect.value);

                    if (!currentDatabaseData || !currentDatabaseData.draws || currentDatabaseData.draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');

                        const chartDom = document.getElementById('numberDistributionChart');
                        if (chartDom) {
                            const chart = echarts.getInstanceByDom(chartDom);
                            if (chart) {
                                chart.clear();
                                chart.setOption({
                                    title: {
                                        text: '暂无数据',
                                        subtext: '请先导入数据后再进行分析',
                                        left: 'center',
                                        top: 'center',
                                        textStyle: {
                                            fontSize: 20,
                                            color: '#999'
                                        },
                                        subtextStyle: {
                                            fontSize: 14,
                                            color: '#999'
                                        }
                                    }
                                });
                            }
                        }

                        const insightsContent = document.getElementById('distributionInsightsContent');
                        if (insightsContent) {
                            insightsContent.innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #999;">
                                    <i class="fas fa-database" style="font-size: 60px; margin-bottom: 20px;"></i>
                                    <h3 style="margin-bottom: 15px;">暂无数据</h3>
                                    <p>请先导入${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}数据后再进行分析</p>
                                </div>
                            `;
                        }

                        return;
                    }

                    if (periodCount === 'all') {
                        periodCount = currentDatabaseData.draws.length;
                    }

                    const draws = currentDatabaseData.draws.slice(-periodCount);

                    // 更新分析范围显示
                    const distributionDataRangeInfo = document.getElementById('distributionDataRangeInfo');
                    if (distributionDataRangeInfo && draws.length > 0) {
                        const startPeriod = draws[0].period;
                        const endPeriod = draws[draws.length - 1].period;
                        distributionDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${draws.length}期）`;
                    }

                    switch(type) {
                        case 'interval':
                            this.performIntervalDistributionAnalysis(draws);
                            break;
                        case 'density':
                            this.performDensityDistributionAnalysis(draws);
                            break;
                        case 'uniformity':
                            this.performUniformityAnalysis(draws);
                            break;
                        case 'trend':
                            this.performDistributionTrendAnalysis(draws);
                            break;
                        case 'comprehensive':
                            this.performComprehensiveAnalysis(draws);
                            break;
                    }
                });
            }

            static performIntervalDistributionAnalysis(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const intervalSize = Math.ceil(redBallRange / 5);
                const intervals = [];

                for (let i = 0; i < 5; i++) {
                    const start = i * intervalSize + 1;
                    const end = Math.min((i + 1) * intervalSize, redBallRange);
                    intervals.push({
                        name: `区间${i + 1} (${start}-${end})`,
                        start: start,
                        end: end,
                        count: 0,
                        numbers: []
                    });
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        intervals.forEach(interval => {
                            if (num >= interval.start && num <= interval.end) {
                                interval.count++;
                                if (!interval.numbers.includes(num)) {
                                    interval.numbers.push(num);
                                }
                            }
                        });
                    });
                });

                const totalRedBalls = draws.length * 6;
                intervals.forEach(interval => {
                    interval.percentage = ((interval.count / totalRedBalls) * 100).toFixed(2);
                });

                this.updateIntervalDistributionChart(intervals);
                this.generateIntervalInsights(intervals, draws);
            }

            static updateIntervalDistributionChart(intervals) {
                const chartDom = document.getElementById('numberDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const colors = ['#E63946', '#F4A261', '#2A9D8F', '#457B9D', '#A8DADC'];
                const gradientColors = colors.map(color => {
                    return {
                        type: 'linear',
                        x: 0,
                        y: 0,
                        x2: 0,
                        y2: 1,
                        colorStops: [
                            { offset: 0, color: color },
                            { offset: 1, color: this.adjustColor(color, -30) }
                        ]
                    };
                });

                const option = {
                    backgroundColor: '#ffffff',
                    title: {
                        text: '号码区间分布分析',
                        subtext: '各区间出现次数及占比统计',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 18,
                            fontWeight: 'bold'
                        },
                        subtextStyle: {
                            color: '#7f8c8d',
                            fontSize: 12
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow',
                            shadowStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            const interval = intervals[data.dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; color: ${colors[data.dataIndex % colors.length]};">${interval.name}</div>
                                    <div style="margin-bottom: 3px;">出现次数: <span style="color: #e74c3c; font-weight: bold;">${interval.count}</span></div>
                                    <div style="margin-bottom: 3px;">占比: <span style="color: #3498db; font-weight: bold;">${interval.percentage}%</span></div>
                                    <div style="font-size: 11px; color: #7f8c8d;">包含号码: ${interval.numbers.join(', ')}</div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '5%',
                        right: '5%',
                        bottom: '10%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: intervals.map(i => i.name),
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 12,
                            fontWeight: 'bold',
                            interval: 0
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        axisTick: {
                            show: false
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            color: '#7f8c8d',
                            fontSize: 12
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        splitLine: {
                            lineStyle: {
                                color: '#ecf0f1',
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: intervals.map(i => i.count),
                            barWidth: '50%',
                            itemStyle: {
                                borderRadius: [5, 5, 0, 0],
                                color: function(params) {
                                    return gradientColors[params.dataIndex % gradientColors.length];
                                },
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.2)',
                                shadowOffsetY: 3
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}',
                                color: '#2c3e50',
                                fontSize: 12,
                                fontWeight: 'bold',
                                textShadowBlur: 2,
                                textShadowColor: '#ffffff'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(0, 0, 0, 0.3)',
                                    shadowOffsetY: 5
                                },
                                label: {
                                    fontSize: 14,
                                    fontWeight: 'bold'
                                }
                            },
                            animationDelay: function(idx) {
                                return idx * 100;
                            }
                        }
                    ],
                    animationEasing: 'elasticOut',
                    animationDelayUpdate: function(idx) {
                        return idx * 5;
                    }
                };

                chart.setOption(option, true);

                eventManager.on(window, 'resize', function() {
                    chart.resize();
                });
            }

            static adjustColor(color, amount) {
                const hex = color.replace('#', '');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);

                const newR = Math.max(0, Math.min(255, r + amount));
                const newG = Math.max(0, Math.min(255, g + amount));
                const newB = Math.max(0, Math.min(255, b + amount));

                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }

            static generateIntervalInsights(intervals, draws) {
                const insightsContent = document.getElementById('distributionInsightsContent');
                if (!insightsContent) return;

                const maxInterval = intervals.reduce((max, i) => i.count > max.count ? i : max);
                const minInterval = intervals.reduce((min, i) => i.count < min.count ? i : min);
                const avgCount = intervals.reduce((sum, i) => sum + i.count, 0) / intervals.length;

                const hotIntervals = intervals.filter(i => i.count > avgCount * 1.2);
                const coldIntervals = intervals.filter(i => i.count < avgCount * 0.8);

                const counts = intervals.map(i => i.count);
                const mean = avgCount;
                const variance = counts.reduce((sum, count) => sum + Math.pow(count - mean, 2), 0) / counts.length;
                const standardDeviation = Math.sqrt(variance);
                const coefficientOfVariation = (standardDeviation / mean) * 100;

                const sortedCounts = [...counts].sort((a, b) => a - b);
                const giniCoefficient = this.calculateGiniCoefficient(sortedCounts);

                const expectedPercentage = (100 / intervals.length).toFixed(2);
                const deviations = intervals.map(i => ({
                    name: i.name,
                    deviation: (parseFloat(i.percentage) - parseFloat(expectedPercentage)).toFixed(2)
                }));

                const positiveDeviations = deviations.filter(d => parseFloat(d.deviation) > 0);
                const negativeDeviations = deviations.filter(d => parseFloat(d.deviation) < 0);

                const maxPositiveDeviation = positiveDeviations.length > 0 
                    ? positiveDeviations.reduce((max, d) => parseFloat(d.deviation) > parseFloat(max.deviation) ? d : max)
                    : null;
                const maxNegativeDeviation = negativeDeviations.length > 0
                    ? negativeDeviations.reduce((min, d) => parseFloat(d.deviation) < parseFloat(min.deviation) ? d : min)
                    : null;

                const balanceScore = 100 - coefficientOfVariation;
                const balanceLevel = balanceScore >= 80 ? '优秀' : balanceScore >= 60 ? '良好' : balanceScore >= 40 ? '一般' : '较差';

                const trendAnalysis = this.analyzeIntervalTrend(intervals, draws);

                const analysisPeriodRange = draws.length > 0 
                    ? `${draws[0].period} 至 ${draws[draws.length - 1].period}（共${draws.length}期）`
                    : '无数据';

                let insights = `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(69, 123, 157, 0.1); border-left: 4px solid #457B9D; border-radius: 4px;">
                        <strong>📅 分析期数范围：</strong> ${analysisPeriodRange}
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 区间分布统计：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>均衡性得分：${balanceScore.toFixed(1)}分（${balanceLevel}）</li>
                        <li>变异系数：${coefficientOfVariation.toFixed(2)}%（数值越小越均衡）</li>
                        <li>基尼系数：${giniCoefficient.toFixed(4)}（数值越小越均衡）</li>
                        <li>标准差：${standardDeviation.toFixed(2)}</li>
                        <li>理论占比：${expectedPercentage}%（每个区间）</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📈 热门区间：</strong> ${hotIntervals.map(i => i.name).join(', ')}（出现次数高于平均值20%）
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>📉 冷门区间：</strong> ${coldIntervals.map(i => i.name).join(', ')}（出现次数低于平均值20%）
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>🔥 最热区间：</strong> ${maxInterval.name}（出现${maxInterval.count}次，占比${maxInterval.percentage}%）
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>❄️ 最冷区间：</strong> ${minInterval.name}（出现${minInterval.count}次，占比${minInterval.percentage}%）
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 偏差分析：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        ${maxPositiveDeviation ? `<li>最大正向偏差：${maxPositiveDeviation.name}（+${maxPositiveDeviation.deviation}%）</li>` : ''}
                        ${maxNegativeDeviation ? `<li>最大负向偏差：${maxNegativeDeviation.name}（${maxNegativeDeviation.deviation}%）</li>` : ''}
                        <li>正向偏差区间数：${positiveDeviations.length}个</li>
                        <li>负向偏差区间数：${negativeDeviations.length}个</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📈 趋势分析：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>趋势方向：${trendAnalysis.direction}</li>
                        <li>趋势强度：${trendAnalysis.strength}</li>
                        <li>活跃区间：${trendAnalysis.activeIntervals.join(', ')}</li>
                        <li>沉寂区间：${trendAnalysis.inactiveIntervals.join(', ')}</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>💡 选号建议：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>区间选择策略：</strong></li>
                        <li>• 重点关注：${hotIntervals.map(i => i.name).join('、')}（热门区间）</li>
                        <li>• 适当关注：${coldIntervals.map(i => i.name).join('、')}（冷门区间，可能存在回补机会）</li>
                        <li>• 建议从${maxInterval.name}中选择2-3个号码</li>
                        <li>• 建议从其他区间中各选择1-2个号码，保持号码分布的均衡性</li>
                        <li><strong>偏差利用策略：</strong></li>
                        ${maxPositiveDeviation ? `<li>• ${maxPositiveDeviation.name}偏离理论值${maxPositiveDeviation.deviation}%，建议适度关注</li>` : ''}
                        ${maxNegativeDeviation ? `<li>• ${maxNegativeDeviation.name}偏离理论值${maxNegativeDeviation.deviation}%，可能存在回补机会</li>` : ''}
                        <li><strong>趋势跟随策略：</strong></li>
                        <li>• 活跃区间：${trendAnalysis.activeIntervals.join('、')}（近期表现活跃）</li>
                        <li>• 沉寂区间：${trendAnalysis.inactiveIntervals.join('、')}（近期表现低迷）</li>
                        <li>• 建议优先从活跃区间中选择号码</li>
                        <li><strong>风险控制：</strong></li>
                        <li>• 避免过度集中在单一区间</li>
                        <li>• 保持各区间号码选择的均衡性</li>
                        <li>• 结合遗漏值分析，避免遗漏值过大的号码</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📋 科学分析结论：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>分布特征：</strong>${balanceLevel === '优秀' ? '区间分布较为均衡，各区间出现概率接近理论值' : balanceLevel === '良好' ? '区间分布基本均衡，存在一定偏差但整体合理' : '区间分布不够均衡，存在明显偏差，需谨慎选择'}</li>
                        <li><strong>趋势判断：</strong>${trendAnalysis.direction === '上升' ? '热门区间热度上升，建议跟随趋势' : trendAnalysis.direction === '下降' ? '热门区间热度下降，建议关注冷门区间' : '区间分布相对稳定，建议均衡选号'}</li>
                        <li><strong>推荐策略：</strong>基于当前数据分析，建议采用"热冷结合、区间均衡、趋势跟随"的选号策略</li>
                        <li><strong>风险提示：</strong>历史数据分析仅供参考，实际选号需结合个人判断和风险承受能力</li>
                    </ul>
                `;

                insightsContent.innerHTML = insights;
            }

            static analyzeIntervalTrend(intervals, draws) {
                const periodSize = Math.max(10, Math.floor(draws.length / 5));
                const recentDraws = draws.slice(-periodSize);

                const recentIntervalCounts = {};
                intervals.forEach(interval => {
                    recentIntervalCounts[interval.name] = 0;
                });

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        intervals.forEach(interval => {
                            if (num >= interval.start && num <= interval.end) {
                                recentIntervalCounts[interval.name]++;
                            }
                        });
                    });
                });

                const totalRecentRedBalls = recentDraws.length * 6;
                const recentIntervals = intervals.map(interval => ({
                    name: interval.name,
                    recentCount: recentIntervalCounts[interval.name],
                    totalCount: interval.count,
                    recentPercentage: ((recentIntervalCounts[interval.name] / totalRecentRedBalls) * 100).toFixed(2),
                    totalPercentage: interval.percentage
                }));

                const activeIntervals = recentIntervals
                    .filter(i => parseFloat(i.recentPercentage) > parseFloat(i.totalPercentage))
                    .map(i => i.name);
                const inactiveIntervals = recentIntervals
                    .filter(i => parseFloat(i.recentPercentage) < parseFloat(i.totalPercentage))
                    .map(i => i.name);

                const avgRecentPercentage = recentIntervals.reduce((sum, i) => sum + parseFloat(i.recentPercentage), 0) / recentIntervals.length;
                const avgTotalPercentage = recentIntervals.reduce((sum, i) => sum + parseFloat(i.totalPercentage), 0) / recentIntervals.length;

                let direction = '稳定';
                let strength = '一般';

                if (avgRecentPercentage > avgTotalPercentage * 1.05) {
                    direction = '上升';
                    strength = (avgRecentPercentage / avgTotalPercentage - 1) * 100 > 10 ? '强烈' : '中等';
                } else if (avgRecentPercentage < avgTotalPercentage * 0.95) {
                    direction = '下降';
                    strength = (1 - avgRecentPercentage / avgTotalPercentage) * 100 > 10 ? '强烈' : '中等';
                }

                return {
                    direction: direction,
                    strength: strength,
                    activeIntervals: activeIntervals,
                    inactiveIntervals: inactiveIntervals,
                    recentIntervals: recentIntervals
                };
            }

            static performDensityDistributionAnalysis(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const numberDensity = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberDensity[num] = {
                        count: 0,
                        positions: []
                    };
                }

                draws.forEach((draw, drawIndex) => {
                    draw.redBalls.forEach(ball => {
                        if (numberDensity[ball]) {
                            numberDensity[ball].count++;
                            numberDensity[ball].positions.push(drawIndex);
                        }
                    });
                });

                const sortedNumbers = Object.entries(numberDensity)
                    .sort((a, b) => b[1].count - a[1].count);

                const highDensityNumbers = sortedNumbers.filter(n => n[1].count >= draws.length * 0.3);
                const mediumDensityNumbers = sortedNumbers.filter(n => n[1].count >= draws.length * 0.15 && n[1].count < draws.length * 0.3);
                const lowDensityNumbers = sortedNumbers.filter(n => n[1].count < draws.length * 0.15);

                this.updateDensityDistributionChart(highDensityNumbers, mediumDensityNumbers, lowDensityNumbers);
                this.generateDensityInsights(highDensityNumbers, mediumDensityNumbers, lowDensityNumbers, draws);
            }

            static updateDensityDistributionChart(highDensityNumbers, mediumDensityNumbers, lowDensityNumbers) {
                const chartDom = document.getElementById('numberDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const colors = ['#E63946', '#F4A261', '#457B9D'];
                const gradientColors = colors.map(color => {
                    return {
                        type: 'linear',
                        x: 0,
                        y: 0,
                        x2: 0,
                        y2: 1,
                        colorStops: [
                            { offset: 0, color: color },
                            { offset: 1, color: this.adjustColor(color, -30) }
                        ]
                    };
                });

                const totalNumbers = highDensityNumbers.length + mediumDensityNumbers.length + lowDensityNumbers.length;

                const option = {
                    backgroundColor: '#ffffff',
                    title: {
                        text: '号码密度分布分析（各密度级别号码数量及占比统计）',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow',
                            shadowStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            const densityTypes = ['高密度', '中密度', '低密度'];
                            const densityNumbers = [highDensityNumbers, mediumDensityNumbers, lowDensityNumbers];
                            const percentages = [
                                ((highDensityNumbers.length / totalNumbers) * 100).toFixed(1),
                                ((mediumDensityNumbers.length / totalNumbers) * 100).toFixed(1),
                                ((lowDensityNumbers.length / totalNumbers) * 100).toFixed(1)
                            ];
                            const descriptions = [
                                '出现频率≥30%',
                                '出现频率15%-30%',
                                '出现频率<15%'
                            ];

                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; color: ${colors[data.dataIndex]};">${densityTypes[data.dataIndex]}</div>
                                    <div style="margin-bottom: 3px;">号码数量: <span style="color: #e74c3c; font-weight: bold;">${data.value}个</span></div>
                                    <div style="margin-bottom: 3px;">占比: <span style="color: #3498db; font-weight: bold;">${percentages[data.dataIndex]}%</span></div>
                                    <div style="font-size: 11px; color: #7f8c8d;">${descriptions[data.dataIndex]}</div>
                                    ${densityNumbers[data.dataIndex].length > 0 ? `<div style="font-size: 11px; color: #7f8c8d; margin-top: 3px;">包含号码: ${densityNumbers[data.dataIndex].map(n => n[0]).join(', ')}</div>` : ''}
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['高密度', '中密度', '低密度'],
                        top: '10%',
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 12,
                            fontWeight: 'bold'
                        },
                        itemGap: 20
                    },
                    grid: {
                        left: '5%',
                        right: '5%',
                        bottom: '10%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ['号码密度'],
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 12,
                            fontWeight: 'bold'
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        axisTick: {
                            show: false
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '号码数量',
                        nameTextStyle: {
                            color: '#7f8c8d',
                            fontSize: 12
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        splitLine: {
                            lineStyle: {
                                color: '#ecf0f1',
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '高密度',
                            type: 'bar',
                            stack: 'total',
                            data: [highDensityNumbers.length],
                            barWidth: '60%',
                            itemStyle: {
                                borderRadius: [5, 5, 0, 0],
                                color: gradientColors[0],
                                shadowBlur: 10,
                                shadowColor: 'rgba(230, 57, 70, 0.3)',
                                shadowOffsetY: 3
                            },
                            label: {
                                show: true,
                                position: 'inside',
                                formatter: '{c}',
                                color: '#ffffff',
                                fontSize: 14,
                                fontWeight: 'bold',
                                textShadowBlur: 2,
                                textShadowColor: 'rgba(0, 0, 0, 0.3)'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(230, 57, 70, 0.5)',
                                    shadowOffsetY: 5
                                }
                            },
                            animationDelay: 0
                        },
                        {
                            name: '中密度',
                            type: 'bar',
                            stack: 'total',
                            data: [mediumDensityNumbers.length],
                            barWidth: '60%',
                            itemStyle: {
                                borderRadius: [0, 0, 0, 0],
                                color: gradientColors[1],
                                shadowBlur: 10,
                                shadowColor: 'rgba(244, 162, 97, 0.3)',
                                shadowOffsetY: 3
                            },
                            label: {
                                show: true,
                                position: 'inside',
                                formatter: '{c}',
                                color: '#ffffff',
                                fontSize: 14,
                                fontWeight: 'bold',
                                textShadowBlur: 2,
                                textShadowColor: 'rgba(0, 0, 0, 0.3)'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(244, 162, 97, 0.5)',
                                    shadowOffsetY: 5
                                }
                            },
                            animationDelay: 100
                        },
                        {
                            name: '低密度',
                            type: 'bar',
                            stack: 'total',
                            data: [lowDensityNumbers.length],
                            barWidth: '60%',
                            itemStyle: {
                                borderRadius: [0, 0, 5, 5],
                                color: gradientColors[2],
                                shadowBlur: 10,
                                shadowColor: 'rgba(69, 123, 157, 0.3)',
                                shadowOffsetY: 3
                            },
                            label: {
                                show: true,
                                position: 'inside',
                                formatter: '{c}',
                                color: '#ffffff',
                                fontSize: 14,
                                fontWeight: 'bold',
                                textShadowBlur: 2,
                                textShadowColor: 'rgba(0, 0, 0, 0.3)'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(69, 123, 157, 0.5)',
                                    shadowOffsetY: 5
                                }
                            },
                            animationDelay: 200
                        }
                    ],
                    animationEasing: 'elasticOut',
                    animationDelayUpdate: function(idx) {
                        return idx * 50;
                    }
                };

                chart.setOption(option, true);

                eventManager.on(window, 'resize', function() {
                    chart.resize();
                });
            }

            static generateDensityInsights(highDensityNumbers, mediumDensityNumbers, lowDensityNumbers, draws) {
                const insightsContent = document.getElementById('distributionInsightsContent');
                if (!insightsContent) return;

                const totalNumbers = highDensityNumbers.length + mediumDensityNumbers.length + lowDensityNumbers.length;

                const numberActivity = this.calculateNumberActivity(draws);
                const periodicity = this.analyzeNumberPeriodicity(draws);
                const recentActivity = this.analyzeRecentActivity(draws);

                const topActiveNumbers = numberActivity
                    .sort((a, b) => b.activityScore - a.activityScore)
                    .slice(0, 10)
                    .map(n => n.number);

                const risingNumbers = recentActivity.rising.slice(0, 8).map(n => n.number);
                const fallingNumbers = recentActivity.falling.slice(0, 8).map(n => n.number);

                const stableNumbers = recentActivity.stable.slice(0, 10).map(n => n.number);

                const analysisPeriodRange = draws.length > 0 
                    ? `${draws[0].period} 至 ${draws[draws.length - 1].period}（共${draws.length}期）`
                    : '无数据';

                let insights = `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(69, 123, 157, 0.1); border-left: 4px solid #457B9D; border-radius: 4px;">
                        <strong>📅 分析期数范围：</strong> ${analysisPeriodRange}
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 密度分布概览：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>高密度号码（出现频率≥30%）：${highDensityNumbers.length}个，占比${((highDensityNumbers.length / totalNumbers) * 100).toFixed(1)}%</li>
                        <li>中密度号码（出现频率15%-30%）：${mediumDensityNumbers.length}个，占比${((mediumDensityNumbers.length / totalNumbers) * 100).toFixed(1)}%</li>
                        <li>低密度号码（出现频率<15%）：${lowDensityNumbers.length}个，占比${((lowDensityNumbers.length / totalNumbers) * 100).toFixed(1)}%</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>🔥 高密度号码：</strong> ${highDensityNumbers.map(n => n[0]).join(', ')}
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📈 号码活跃度分析：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>活跃度评估：基于近期出现频率和连续性</li>
                        <li>高活跃号码（Top 10）：${topActiveNumbers.join(', ')}</li>
                        <li>上升号码（近期活跃）：${risingNumbers.join(', ')}</li>
                        <li>下降号码（近期低迷）：${fallingNumbers.join(', ')}</li>
                        <li>稳定号码（表现平稳）：${stableNumbers.join(', ')}</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>🔄 周期性分析：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>周期性识别：${periodicity.hasPeriodicity ? '发现明显周期性规律' : '未发现明显周期性规律'}</li>
                        ${periodicity.hasPeriodicity ? `<li>主要周期：${periodicity.mainPeriod}期</li>` : ''}
                        ${periodicity.hasPeriodicity ? `<li>周期性号码：${periodicity.periodicNumbers.slice(0, 10).join(', ')}</li>` : ''}
                        <li>平均间隔：${periodicity.avgInterval.toFixed(1)}期</li>
                        <li>间隔标准差：${periodicity.intervalStdDev.toFixed(1)}期</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>💡 选号建议：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>密度选择策略：</strong></li>
                        <li>• 高密度号码出现频率高，建议作为主要选号对象，可从中选择3-4个号码</li>
                        <li>• 中密度号码出现频率适中，建议作为辅助选号对象，可从中选择2-3个号码</li>
                        <li>• 低密度号码出现频率低，但可能存在回补机会，可适当关注，选择1-2个号码</li>
                        <li>• 建议号码组合：高密度3-4个 + 中密度2-3个 + 低密度1-2个 = 6个红球</li>
                        <li><strong>活跃度策略：</strong></li>
                        <li>• 优先选择高活跃号码：${topActiveNumbers.slice(0, 3).join(', ')}</li>
                        <li>• 关注上升号码：${risingNumbers.slice(0, 3).join(', ')}（近期表现活跃）</li>
                        <li>• 适当考虑稳定号码：${stableNumbers.slice(0, 3).join(', ')}（表现平稳）</li>
                        <li>• 谨慎选择下降号码：${fallingNumbers.slice(0, 3).join(', ')}（近期表现低迷）</li>
                        <li><strong>周期性策略：</strong></li>
                        ${periodicity.hasPeriodicity ? `<li>• 利用周期性规律：${periodicity.periodicNumbers.slice(0, 5).join(', ')}（按${periodicity.mainPeriod}期周期出现）</li>` : ''}
                        <li>• 关注间隔接近平均值的号码</li>
                        <li>• 结合遗漏值分析，选择即将到期的号码</li>
                        <li><strong>风险控制：</strong></li>
                        <li>• 避免过度集中在高活跃号码上</li>
                        <li>• 保持号码选择的多样性和平衡性</li>
                        <li>• 定期关注号码活跃度变化，及时调整选号策略</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📋 科学分析结论：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>密度特征：</strong>${highDensityNumbers.length > totalNumbers * 0.3 ? '高密度号码占比较高，说明存在明显热号' : '密度分布较为均衡，各密度级别号码分布合理'}</li>
                        <li><strong>活跃度特征：</strong>${numberActivity.filter(n => n.activityScore > 0.6).length > totalNumbers * 0.4 ? '活跃号码较多，建议重点关注高活跃号码' : '活跃号码分布均匀，建议结合密度分析选号'}</li>
                        <li><strong>周期性特征：</strong>${periodicity.hasPeriodicity ? '发现周期性规律，可利用周期性进行选号' : '未发现明显周期性规律，建议以活跃度和密度分析为主'}</li>
                        <li><strong>推荐策略：</strong>基于当前数据分析，建议采用"密度优先、活跃辅助、周期参考"的选号策略</li>
                        <li><strong>风险提示：</strong>历史数据分析仅供参考，实际选号需结合个人判断和风险承受能力</li>
                    </ul>
                `;

                insightsContent.innerHTML = insights;
            }

            static calculateNumberActivity(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const numberActivity = [];
                const recentPeriod = Math.min(30, Math.floor(draws.length / 3));
                const recentDraws = draws.slice(-recentPeriod);

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');

                    let totalCount = 0;
                    let recentCount = 0;
                    let consecutiveCount = 0;
                    let maxConsecutive = 0;
                    let positions = [];

                    draws.forEach((draw, index) => {
                        if (draw.redBalls.includes(num)) {
                            totalCount++;
                            positions.push(index);

                            if (index >= draws.length - recentPeriod) {
                                recentCount++;
                            }

                            consecutiveCount++;
                            maxConsecutive = Math.max(maxConsecutive, consecutiveCount);
                        } else {
                            consecutiveCount = 0;
                        }
                    });

                    const frequencyScore = totalCount / draws.length;
                    const recentFrequencyScore = recentCount / recentPeriod;
                    const consecutiveScore = maxConsecutive / recentPeriod;

                    const activityScore = (frequencyScore * 0.4 + recentFrequencyScore * 0.4 + consecutiveScore * 0.2);

                    numberActivity.push({
                        number: num,
                        totalCount: totalCount,
                        recentCount: recentCount,
                        maxConsecutive: maxConsecutive,
                        activityScore: activityScore,
                        positions: positions
                    });
                }

                return numberActivity;
            }

            static analyzeRecentActivity(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const recentPeriod = Math.min(20, Math.floor(draws.length / 4));
                const previousPeriod = Math.min(20, Math.floor(draws.length / 4));

                const recentDraws = draws.slice(-recentPeriod);
                const previousDraws = draws.slice(-(recentPeriod + previousPeriod), -recentPeriod);

                const recentCounts = {};
                const previousCounts = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    recentCounts[num] = 0;
                    previousCounts[num] = 0;
                }

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (recentCounts[ball] !== undefined) {
                            recentCounts[ball]++;
                        }
                    });
                });

                previousDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (previousCounts[ball] !== undefined) {
                            previousCounts[ball]++;
                        }
                    });
                });

                const rising = [];
                const falling = [];
                const stable = [];

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const recentCount = recentCounts[num];
                    const previousCount = previousCounts[num];

                    const change = recentCount - previousCount;
                    const changeRate = previousCount > 0 ? (change / previousCount) * 100 : (recentCount > 0 ? 100 : 0);

                    if (changeRate > 30) {
                        rising.push({ number: num, changeRate: changeRate });
                    } else if (changeRate < -30) {
                        falling.push({ number: num, changeRate: changeRate });
                    } else {
                        stable.push({ number: num, changeRate: changeRate });
                    }
                }

                return {
                    rising: rising.sort((a, b) => b.changeRate - a.changeRate),
                    falling: falling.sort((a, b) => a.changeRate - b.changeRate),
                    stable: stable.sort((a, b) => Math.abs(b.changeRate) - Math.abs(a.changeRate))
                };
            }

            static analyzeNumberPeriodicity(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const numberIntervals = {};

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberIntervals[num] = [];
                }

                draws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (numberIntervals[ball] !== undefined) {
                            numberIntervals[ball].push(index);
                        }
                    });
                });

                const intervals = [];
                const periodicNumbers = [];

                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const positions = numberIntervals[num];

                    if (positions.length > 2) {
                        for (let j = 1; j < positions.length; j++) {
                            intervals.push(positions[j] - positions[j - 1]);
                        }
                    }
                }

                const avgInterval = intervals.length > 0 ? intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length : 0;
                const intervalVariance = intervals.length > 0 
                    ? intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length 
                    : 0;
                const intervalStdDev = Math.sqrt(intervalVariance);

                const hasPeriodicity = intervalStdDev < avgInterval * 0.5 && intervals.length > 10;

                if (hasPeriodicity) {
                    const mainPeriod = Math.round(avgInterval);

                    for (let i = 1; i <= redBallRange; i++) {
                        const num = i.toString().padStart(2, '0');
                        const positions = numberIntervals[num];

                        if (positions.length > 2) {
                            const numIntervals = [];
                            for (let j = 1; j < positions.length; j++) {
                                numIntervals.push(positions[j] - positions[j - 1]);
                            }

                            const numAvgInterval = numIntervals.reduce((sum, interval) => sum + interval, 0) / numIntervals.length;
                            const deviation = Math.abs(numAvgInterval - mainPeriod);

                            if (deviation < mainPeriod * 0.3) {
                                periodicNumbers.push(num);
                            }
                        }
                    }
                }

                return {
                    hasPeriodicity: hasPeriodicity,
                    mainPeriod: hasPeriodicity ? Math.round(avgInterval) : 0,
                    periodicNumbers: periodicNumbers,
                    avgInterval: avgInterval,
                    intervalStdDev: intervalStdDev
                };
            }

            static performUniformityAnalysis(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const numberCounts = {};
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberCounts[num] = 0;
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberCounts[ball] !== undefined) {
                            numberCounts[ball]++;
                        }
                    });
                });

                const counts = Object.values(numberCounts);
                const mean = counts.reduce((sum, count) => sum + count, 0) / counts.length;

                const variance = counts.reduce((sum, count) => sum + Math.pow(count - mean, 2), 0) / counts.length;
                const standardDeviation = Math.sqrt(variance);
                const coefficientOfVariation = (standardDeviation / mean) * 100;

                const sortedCounts = [...counts].sort((a, b) => a - b);
                const giniCoefficient = this.calculateGiniCoefficient(sortedCounts);

                const skewness = this.calculateSkewness(counts, mean, standardDeviation);
                const kurtosis = this.calculateKurtosis(counts, mean, standardDeviation);

                const uniformityScore = this.calculateUniformityScore(coefficientOfVariation, giniCoefficient, skewness, kurtosis);

                this.updateUniformityChart(numberCounts, mean, standardDeviation);
                this.generateUniformityInsights(coefficientOfVariation, giniCoefficient, skewness, kurtosis, uniformityScore, mean, standardDeviation, numberCounts, draws);
            }

            static calculateGiniCoefficient(sortedCounts) {
                const n = sortedCounts.length;
                if (n === 0) return 0;

                let sumNumerator = 0;
                let sumDenominator = 0;

                for (let i = 0; i < n; i++) {
                    sumNumerator += (i + 1) * sortedCounts[i];
                    sumDenominator += sortedCounts[i];
                }

                const gini = (2 * sumNumerator) / (n * sumDenominator) - (n + 1) / n;
                return Math.abs(gini);
            }

            static calculateSkewness(counts, mean, standardDeviation) {
                const n = counts.length;
                if (n === 0 || standardDeviation === 0) return 0;

                const skewness = counts.reduce((sum, count) => {
                    return sum + Math.pow((count - mean) / standardDeviation, 3);
                }, 0) / n;

                return skewness;
            }

            static calculateKurtosis(counts, mean, standardDeviation) {
                const n = counts.length;
                if (n === 0 || standardDeviation === 0) return 0;

                const kurtosis = counts.reduce((sum, count) => {
                    return sum + Math.pow((count - mean) / standardDeviation, 4);
                }, 0) / n - 3;

                return kurtosis;
            }

            static calculateUniformityScore(coefficientOfVariation, giniCoefficient, skewness, kurtosis) {
                const cvScore = Math.max(0, 100 - coefficientOfVariation);
                const giniScore = Math.max(0, 100 - giniCoefficient * 100);
                const skewnessScore = Math.max(0, 100 - Math.abs(skewness) * 50);
                const kurtosisScore = Math.max(0, 100 - Math.abs(kurtosis) * 25);

                const uniformityScore = (cvScore * 0.3 + giniScore * 0.3 + skewnessScore * 0.2 + kurtosisScore * 0.2);

                return {
                    score: uniformityScore.toFixed(1),
                    level: uniformityScore >= 70 ? '优秀' : uniformityScore >= 50 ? '良好' : uniformityScore >= 30 ? '一般' : '较差',
                    cvScore: cvScore,
                    giniScore: giniScore,
                    skewnessScore: skewnessScore,
                    kurtosisScore: kurtosisScore
                };
            }

            static updateUniformityChart(numberCounts, mean, standardDeviation) {
                const chartDom = document.getElementById('numberDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const numbers = Object.keys(numberCounts).sort((a, b) => parseInt(a) - parseInt(b));
                const counts = numbers.map(num => numberCounts[num]);

                const minCount = Math.min(...counts);
                const maxCount = Math.max(...counts);

                const barColors = counts.map(count => {
                    const ratio = (count - minCount) / (maxCount - minCount || 1);
                    if (ratio < 0.3) {
                        return '#457B9D';
                    } else if (ratio < 0.7) {
                        return '#F4A261';
                    } else {
                        return '#E63946';
                    }
                });

                const option = {
                    backgroundColor: '#ffffff',
                    title: {
                        text: '号码分布均匀性分析',
                        subtext: '各号码出现次数与平均值对比',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 18,
                            fontWeight: 'bold'
                        },
                        subtextStyle: {
                            color: '#7f8c8d',
                            fontSize: 12
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow',
                            shadowStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            const deviation = (data.value - mean).toFixed(2);
                            const percentage = ((data.value / mean) * 100).toFixed(1);
                            const deviationPercent = ((data.value - mean) / mean * 100).toFixed(1);
                            const deviationType = deviation > 0 ? '高于' : deviation < 0 ? '低于' : '等于';
                            const color = deviation > 0 ? '#e74c3c' : deviation < 0 ? '#3498db' : '#2ecc71';

                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px; color: ${barColors[data.dataIndex]};">号码${data.name}</div>
                                    <div style="margin-bottom: 3px;">出现次数: <span style="color: #e74c3c; font-weight: bold;">${data.value}次</span></div>
                                    <div style="margin-bottom: 3px;">平均次数: <span style="color: #3498db; font-weight: bold;">${mean.toFixed(2)}次</span></div>
                                    <div style="margin-bottom: 3px;">偏差: <span style="color: ${color}; font-weight: bold;">${deviationType}平均值${Math.abs(deviation).toFixed(2)}次</span></div>
                                    <div style="margin-bottom: 3px;">占比: <span style="color: #9b59b6; font-weight: bold;">${percentage}%</span></div>
                                    <div style="font-size: 11px; color: #7f8c8d;">${deviationPercent > 0 ? '+' : ''}${deviationPercent}% 相对于平均值</div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '5%',
                        right: '5%',
                        bottom: '10%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            rotate: 45,
                            color: '#2c3e50',
                            fontSize: 10,
                            fontWeight: 'bold',
                            interval: 0
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        axisTick: {
                            show: false
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            color: '#7f8c8d',
                            fontSize: 12
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        splitLine: {
                            lineStyle: {
                                color: '#ecf0f1',
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: counts,
                            barWidth: '60%',
                            itemStyle: {
                                color: function(params) {
                                    return {
                                        type: 'linear',
                                        x: 0,
                                        y: 0,
                                        x2: 0,
                                        y2: 1,
                                        colorStops: [
                                            { offset: 0, color: barColors[params.dataIndex] },
                                            { offset: 1, color: this.adjustColor(barColors[params.dataIndex], -30) }
                                        ]
                                    };
                                }.bind(this),
                                borderRadius: [3, 3, 0, 0],
                                shadowBlur: 8,
                                shadowColor: 'rgba(0, 0, 0, 0.15)',
                                shadowOffsetY: 2
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#2A9D8F',
                                    type: 'dashed',
                                    width: 2
                                },
                                label: {
                                    show: true,
                                    position: 'end',
                                    formatter: '平均值: {c}',
                                    color: '#2A9D8F',
                                    fontSize: 11,
                                    fontWeight: 'bold'
                                },
                                symbol: 'none',
                                emphasis: {
                                    lineStyle: {
                                        width: 3
                                    }
                                }
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(0, 0, 0, 0.3)',
                                    shadowOffsetY: 5
                                }
                            },
                            animationDelay: function(idx) {
                                return idx * 20;
                            }
                        }
                    ],
                    animationEasing: 'elasticOut',
                    animationDelayUpdate: function(idx) {
                        return idx * 5;
                    }
                };

                chart.setOption(option, true);

                eventManager.on(window, 'resize', function() {
                    chart.resize();
                });
            }

            static generateUniformityInsights(coefficientOfVariation, giniCoefficient, skewness, kurtosis, uniformityScore, mean, standardDeviation, numberCounts, draws) {
                const insightsContent = document.getElementById('distributionInsightsContent');
                if (!insightsContent) return;

                const numbers = Object.keys(numberCounts);
                const counts = Object.values(numberCounts);
                const aboveAverage = numbers.filter(n => numberCounts[n] > mean);
                const belowAverage = numbers.filter(n => numberCounts[n] < mean);

                const maxCount = Math.max(...Object.values(numberCounts));
                const minCount = Math.min(...Object.values(numberCounts));
                const maxNumbers = numbers.filter(n => numberCounts[n] === maxCount);
                const minNumbers = numbers.filter(n => numberCounts[n] === minCount);

                const skewnessInterpretation = Math.abs(skewness) < 0.5 ? '分布较为对称' : skewness > 0 ? '右偏分布（长尾在右侧）' : '左偏分布（长尾在左侧）';
                const kurtosisInterpretation = Math.abs(kurtosis) < 0.5 ? '分布接近正态分布' : kurtosis > 0 ? '尖峰分布（峰值较高）' : '平峰分布（峰值较低）';

                const skewnessLevel = Math.abs(skewness) < 0.5 ? '优秀' : Math.abs(skewness) < 1 ? '良好' : '一般';
                const kurtosisLevel = Math.abs(kurtosis) < 0.5 ? '优秀' : Math.abs(kurtosis) < 1 ? '良好' : '一般';

                const nearAverageNumbers = numbers.filter(n => Math.abs(numberCounts[n] - mean) <= standardDeviation);
                const extremeNumbers = numbers.filter(n => Math.abs(numberCounts[n] - mean) > 2 * standardDeviation);

                const analysisPeriodRange = draws.length > 0 
                    ? `${draws[0].period} 至 ${draws[draws.length - 1].period}（共${draws.length}期）`
                    : '无数据';

                let insights = `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(69, 123, 157, 0.1); border-left: 4px solid #457B9D; border-radius: 4px;">
                        <strong>📅 分析期数范围：</strong> ${analysisPeriodRange}
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 均匀性评估：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>均匀性得分：${uniformityScore.score}分（${uniformityScore.level}）</li>
                        <li>变异系数：${coefficientOfVariation.toFixed(2)}%（数值越小越均匀）</li>
                        <li>基尼系数：${giniCoefficient.toFixed(4)}（数值越小越均匀）</li>
                        <li>标准差：${standardDeviation.toFixed(2)}</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📐 分布形态分析：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>偏度：${skewness.toFixed(4)}（${skewnessLevel}）- ${skewnessInterpretation}</li>
                        <li>峰度：${kurtosis.toFixed(4)}（${kurtosisLevel}）- ${kurtosisInterpretation}</li>
                        <li>偏度得分：${uniformityScore.skewnessScore.toFixed(1)}分</li>
                        <li>峰度得分：${uniformityScore.kurtosisScore.toFixed(1)}分</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📈 分布统计：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>平均出现次数：${mean.toFixed(2)}次</li>
                        <li>高于平均值的号码：${aboveAverage.length}个</li>
                        <li>低于平均值的号码：${belowAverage.length}个</li>
                        <li>接近平均值（±1标准差）：${nearAverageNumbers.length}个</li>
                        <li>极端值（±2标准差外）：${extremeNumbers.length}个</li>
                        <li>出现最多：${maxNumbers.join(', ')}（${maxCount}次）</li>
                        <li>出现最少：${minNumbers.join(', ')}（${minCount}次）</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>💡 选号建议：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>均匀性策略：</strong></li>
                        <li>${uniformityScore.level === '优秀' ? '• 分布较为均匀，建议从各个号码中均衡选择' : '• 分布不够均匀，建议重点关注出现次数接近平均值的号码'}</li>
                        <li>• 建议从高于平均值的号码中选择2-3个</li>
                        <li>• 建议从低于平均值的号码中选择2-3个，可能存在回补机会</li>
                        <li>• 优先选择接近平均值的号码：${nearAverageNumbers.slice(0, 5).join(', ')}（表现稳定）</li>
                        <li><strong>分布形态策略：</strong></li>
                        <li>${skewness > 0 ? '• 右偏分布：左侧号码出现较多，建议关注右侧号码（可能存在回补机会）' : skewness < 0 ? '• 左偏分布：右侧号码出现较多，建议关注左侧号码（可能存在回补机会）' : '• 对称分布：号码分布较为均衡，建议均衡选号'}</li>
                        <li>${kurtosis > 0 ? '• 尖峰分布：号码集中在平均值附近，建议选择接近平均值的号码' : kurtosis < 0 ? '• 平峰分布：号码分布较为分散，建议均衡选择各个号码' : '• 正态分布：号码分布符合正态分布，建议均衡选号'}</li>
                        <li><strong>风险控制：</strong></li>
                        <li>• 避免过度集中在出现次数最多或最少的号码上</li>
                        <li>• 谨慎选择极端值号码：${extremeNumbers.length > 0 ? extremeNumbers.join(', ') : '无'}（偏离平均值较大）</li>
                        <li>• 保持号码选择的多样性和平衡性</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📋 科学分析结论：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>均匀性特征：</strong>${uniformityScore.level === '优秀' ? '号码分布较为均匀，各号码出现概率接近理论值' : uniformityScore.level === '良好' ? '号码分布基本均匀，存在一定偏差但整体合理' : '号码分布不够均匀，存在明显偏差，需谨慎选择'}</li>
                        <li><strong>分布形态特征：</strong>${skewnessLevel === '优秀' && kurtosisLevel === '优秀' ? '分布形态接近正态分布，号码分布较为理想' : '分布形态存在一定偏差，建议结合均匀性分析选号'}</li>
                        <li><strong>推荐策略：</strong>基于当前数据分析，建议采用"均匀优先、形态参考、均衡选号"的选号策略</li>
                        <li><strong>风险提示：</strong>历史数据分析仅供参考，实际选号需结合个人判断和风险承受能力</li>
                    </ul>
                `;

                insightsContent.innerHTML = insights;
            }

            static performDistributionTrendAnalysis(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const periodSize = Math.max(10, Math.floor(draws.length / 5));
                const timeSegments = [];

                for (let i = 0; i < draws.length; i += periodSize) {
                    const segmentDraws = draws.slice(i, i + periodSize);
                    const segmentIndex = Math.floor(i / periodSize) + 1;

                    const numberCounts = {};
                    for (let j = 1; j <= redBallRange; j++) {
                        const num = j.toString().padStart(2, '0');
                        numberCounts[num] = 0;
                    }

                    segmentDraws.forEach(draw => {
                        draw.redBalls.forEach(ball => {
                            if (numberCounts[ball] !== undefined) {
                                numberCounts[ball]++;
                            }
                        });
                    });

                    const counts = Object.values(numberCounts);
                    const mean = counts.reduce((sum, count) => sum + count, 0) / counts.length;
                    const variance = counts.reduce((sum, count) => sum + Math.pow(count - mean, 2), 0) / counts.length;
                    const standardDeviation = Math.sqrt(variance);
                    const coefficientOfVariation = (standardDeviation / mean) * 100;

                    const sortedCounts = [...counts].sort((a, b) => a - b);
                    const giniCoefficient = this.calculateGiniCoefficient(sortedCounts);

                    const hotNumbers = Object.entries(numberCounts)
                        .filter(([num, count]) => count > mean + standardDeviation)
                        .map(([num, count]) => num);
                    const coldNumbers = Object.entries(numberCounts)
                        .filter(([num, count]) => count < mean - standardDeviation)
                        .map(([num, count]) => num);

                    timeSegments.push({
                        index: segmentIndex,
                        period: `第${segmentIndex}阶段（${i + 1}-${Math.min(i + periodSize, draws.length)}期）`,
                        mean: mean,
                        standardDeviation: standardDeviation,
                        coefficientOfVariation: coefficientOfVariation,
                        giniCoefficient: giniCoefficient,
                        hotNumbers: hotNumbers,
                        coldNumbers: coldNumbers,
                        numberCounts: numberCounts
                    });
                }

                this.updateDistributionTrendChart(timeSegments);
                this.generateTrendInsights(timeSegments, draws);
            }

            static updateDistributionTrendChart(timeSegments) {
                const chartDom = document.getElementById('numberDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const periods = timeSegments.map(seg => seg.period);
                const cvData = timeSegments.map(seg => seg.coefficientOfVariation);
                const giniData = timeSegments.map(seg => seg.giniCoefficient * 100);
                const hotCountData = timeSegments.map(seg => seg.hotNumbers.length);
                const coldCountData = timeSegments.map(seg => seg.coldNumbers.length);

                const colors = ['#E63946', '#F4A261', '#2A9D8F', '#457B9D'];

                const option = {
                    backgroundColor: '#ffffff',
                    title: {
                        text: '号码分布历史趋势分析（变异系数、基尼系数及热冷号数量变化趋势）',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross',
                            crossStyle: {
                                color: '#999'
                            }
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = `<div style="padding: 8px;"><div style="font-weight: bold; margin-bottom: 5px; color: #2c3e50;">${paramArray[0].name}</div>`;
                            paramArray.forEach(item => {
                                const value = item.value;
                                const color = colors[item.seriesIndex % colors.length];
                                if (item.seriesName === '变异系数' || item.seriesName === '基尼系数') {
                                    result += `<div style="margin-bottom: 3px;"><span style="color: ${color}; font-weight: bold;">●</span> ${item.seriesName}: <span style="color: #e74c3c; font-weight: bold;">${value.toFixed(2)}%</span></div>`;
                                } else {
                                    result += `<div style="margin-bottom: 3px;"><span style="color: ${color}; font-weight: bold;">●</span> ${item.seriesName}: <span style="color: #3498db; font-weight: bold;">${value}个</span></div>`;
                                }
                            });
                            result += '</div>';
                            return result;
                        }
                    },
                    legend: {
                        data: ['变异系数', '基尼系数', '热号数量', '冷号数量'],
                        top: '8%',
                        left: 'center',
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 12,
                            fontWeight: 'bold'
                        },
                        itemGap: 15,
                        itemWidth: 25,
                        itemHeight: 14
                    },
                    grid: {
                        left: '8%',
                        right: '8%',
                        bottom: '12%',
                        top: '22%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45,
                            color: '#2c3e50',
                            fontSize: 10,
                            fontWeight: 'bold',
                            interval: 0
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        axisTick: {
                            show: false
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '系数',
                            position: 'left',
                            nameTextStyle: {
                                color: '#7f8c8d',
                                fontSize: 12
                            },
                            axisLabel: {
                                color: '#2c3e50',
                                fontSize: 11,
                                formatter: '{value}%'
                            },
                            axisLine: {
                                lineStyle: {
                                    color: '#bdc3c7'
                                }
                            },
                            splitLine: {
                                lineStyle: {
                                    color: '#ecf0f1',
                                    type: 'dashed'
                                }
                            }
                        },
                        {
                            type: 'value',
                            name: '数量',
                            position: 'right',
                            nameTextStyle: {
                                color: '#7f8c8d',
                                fontSize: 12
                            },
                            axisLabel: {
                                color: '#2c3e50',
                                fontSize: 11
                            },
                            axisLine: {
                                lineStyle: {
                                    color: '#bdc3c7'
                                }
                            },
                            splitLine: {
                                show: false
                            }
                        }
                    ],
                    series: [
                        {
                            name: '变异系数',
                            type: 'line',
                            yAxisIndex: 0,
                            data: cvData,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 8,
                            itemStyle: {
                                color: '#E63946',
                                borderWidth: 2,
                                borderColor: '#ffffff'
                            },
                            lineStyle: {
                                width: 3,
                                shadowBlur: 10,
                                shadowColor: 'rgba(230, 57, 70, 0.3)',
                                shadowOffsetY: 3
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(230, 57, 70, 0.3)' },
                                        { offset: 1, color: 'rgba(230, 57, 70, 0.05)' }
                                    ]
                                }
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#E63946',
                                    type: 'dashed',
                                    width: 2
                                },
                                label: {
                                    show: true,
                                    position: 'end',
                                    formatter: '平均值: {c}',
                                    color: '#E63946',
                                    fontSize: 10,
                                    fontWeight: 'bold'
                                },
                                symbol: 'none'
                            },
                            emphasis: {
                                itemStyle: {
                                    symbolSize: 12,
                                    borderWidth: 3
                                }
                            },
                            animationDelay: 0
                        },
                        {
                            name: '基尼系数',
                            type: 'line',
                            yAxisIndex: 0,
                            data: giniData,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 8,
                            itemStyle: {
                                color: '#F4A261',
                                borderWidth: 2,
                                borderColor: '#ffffff'
                            },
                            lineStyle: {
                                width: 3,
                                shadowBlur: 10,
                                shadowColor: 'rgba(244, 162, 97, 0.3)',
                                shadowOffsetY: 3
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(244, 162, 97, 0.3)' },
                                        { offset: 1, color: 'rgba(244, 162, 97, 0.05)' }
                                    ]
                                }
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#F4A261',
                                    type: 'dashed',
                                    width: 2
                                },
                                label: {
                                    show: true,
                                    position: 'end',
                                    formatter: '平均值: {c}',
                                    color: '#F4A261',
                                    fontSize: 10,
                                    fontWeight: 'bold'
                                },
                                symbol: 'none'
                            },
                            emphasis: {
                                itemStyle: {
                                    symbolSize: 12,
                                    borderWidth: 3
                                }
                            },
                            animationDelay: 100
                        },
                        {
                            name: '热号数量',
                            type: 'bar',
                            yAxisIndex: 1,
                            data: hotCountData,
                            barWidth: '40%',
                            itemStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: '#2A9D8F' },
                                        { offset: 1, color: this.adjustColor('#2A9D8F', -30) }
                                    ]
                                },
                                borderRadius: [3, 3, 0, 0],
                                shadowBlur: 8,
                                shadowColor: 'rgba(42, 157, 143, 0.3)',
                                shadowOffsetY: 2
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(42, 157, 143, 0.5)',
                                    shadowOffsetY: 5
                                }
                            },
                            animationDelay: 200
                        },
                        {
                            name: '冷号数量',
                            type: 'bar',
                            yAxisIndex: 1,
                            data: coldCountData,
                            barWidth: '40%',
                            itemStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: '#457B9D' },
                                        { offset: 1, color: this.adjustColor('#457B9D', -30) }
                                    ]
                                },
                                borderRadius: [3, 3, 0, 0],
                                shadowBlur: 8,
                                shadowColor: 'rgba(69, 123, 157, 0.3)',
                                shadowOffsetY: 2
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 15,
                                    shadowColor: 'rgba(69, 123, 157, 0.5)',
                                    shadowOffsetY: 5
                                }
                            },
                            animationDelay: 300
                        }
                    ],
                    animationEasing: 'elasticOut',
                    animationDelayUpdate: function(idx) {
                        return idx * 50;
                    }
                };

                chart.setOption(option, true);

                eventManager.on(window, 'resize', function() {
                    chart.resize();
                });
            }

            static generateTrendInsights(timeSegments, draws) {
                const insightsContent = document.getElementById('distributionInsightsContent');
                if (!insightsContent) return;

                const latestSegment = timeSegments[timeSegments.length - 1];
                const earliestSegment = timeSegments[0];

                const cvTrend = timeSegments.map(seg => seg.coefficientOfVariation);
                const giniTrend = timeSegments.map(seg => seg.giniCoefficient);

                const cvChange = cvTrend[cvTrend.length - 1] - cvTrend[0];
                const giniChange = giniTrend[giniTrend.length - 1] - giniTrend[0];

                const cvTrendDirection = cvChange > 0 ? '上升' : cvChange < 0 ? '下降' : '稳定';
                const giniTrendDirection = giniChange > 0 ? '上升' : giniChange < 0 ? '下降' : '稳定';

                const allHotNumbers = new Set();
                const allColdNumbers = new Set();
                timeSegments.forEach(seg => {
                    seg.hotNumbers.forEach(num => allHotNumbers.add(num));
                    seg.coldNumbers.forEach(num => allColdNumbers.add(num));
                });

                const persistentHotNumbers = [];
                const persistentColdNumbers = [];
                const fluctuatingNumbers = [];

                for (let i = 1; i <= 33; i++) {
                    const num = i.toString().padStart(2, '0');
                    let hotCount = 0;
                    let coldCount = 0;

                    timeSegments.forEach(seg => {
                        if (seg.hotNumbers.includes(num)) hotCount++;
                        if (seg.coldNumbers.includes(num)) coldCount++;
                    });

                    const hotRate = hotCount / timeSegments.length;
                    const coldRate = coldCount / timeSegments.length;

                    if (hotRate >= 0.6) {
                        persistentHotNumbers.push(num);
                    } else if (coldRate >= 0.6) {
                        persistentColdNumbers.push(num);
                    } else if (hotRate > 0.3 || coldRate > 0.3) {
                        fluctuatingNumbers.push(num);
                    }
                }

                const trendPrediction = this.predictTrend(timeSegments);
                const periodicityAnalysis = this.analyzeDistributionPeriodicity(timeSegments, draws);

                const analysisPeriodRange = draws.length > 0 
                    ? `${draws[0].period} 至 ${draws[draws.length - 1].period}（共${draws.length}期）`
                    : '无数据';

                let insights = `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(69, 123, 157, 0.1); border-left: 4px solid #457B9D; border-radius: 4px;">
                        <strong>📅 分析期数范围：</strong> ${analysisPeriodRange}
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 趋势分析：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>变异系数趋势：${cvTrendDirection}（变化${cvChange > 0 ? '+' : ''}${cvChange.toFixed(2)}%）</li>
                        <li>基尼系数趋势：${giniTrendDirection}（变化${giniChange > 0 ? '+' : ''}${giniChange.toFixed(4)}）</li>
                        <li>最新阶段变异系数：${latestSegment.coefficientOfVariation.toFixed(2)}%</li>
                        <li>最新阶段基尼系数：${latestSegment.giniCoefficient.toFixed(4)}</li>
                        <li>最新阶段热号数量：${latestSegment.hotNumbers.length}个</li>
                        <li>最新阶段冷号数量：${latestSegment.coldNumbers.length}个</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>🔮 趋势预测：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>预测方向：${trendPrediction.direction}</li>
                        <li>预测强度：${trendPrediction.strength}</li>
                        <li>预测变异系数：${trendPrediction.predictedCV.toFixed(2)}%</li>
                        <li>预测基尼系数：${trendPrediction.predictedGini.toFixed(4)}</li>
                        <li>预测热号数量：${trendPrediction.predictedHotCount}个</li>
                        <li>预测冷号数量：${trendPrediction.predictedColdCount}个</li>
                        <li>置信度：${trendPrediction.confidence}%</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>🔄 周期性识别：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>周期性存在：${periodicityAnalysis.hasPeriodicity ? '是' : '否'}</li>
                        ${periodicityAnalysis.hasPeriodicity ? `<li>主要周期：${periodicityAnalysis.mainPeriod}个阶段</li>` : ''}
                        ${periodicityAnalysis.hasPeriodicity ? `<li>周期性热号：${periodicityAnalysis.periodicHotNumbers.join(', ')}</li>` : ''}
                        ${periodicityAnalysis.hasPeriodicity ? `<li>周期性冷号：${periodicityAnalysis.periodicColdNumbers.join(', ')}</li>` : ''}
                        <li>周期强度：${periodicityAnalysis.periodicityStrength}</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>🔥 持续热号：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>${persistentHotNumbers.length > 0 ? persistentHotNumbers.join(', ') : '无持续热号'}</li>
                        <li>这些号码在${timeSegments.length}个阶段中有超过60%的时间表现为热号</li>
                    </ul>
                    <div style="margin-bottom: 10px;">
                        <strong>❄️ 持续冷号：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>${persistentColdNumbers.length > 0 ? persistentColdNumbers.join(', ') : '无持续冷号'}</li>
                        <li>这些号码在${timeSegments.length}个阶段中有超过60%的时间表现为冷号</li>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>🔄 波动号码：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>${fluctuatingNumbers.length > 0 ? fluctuatingNumbers.slice(0, 15).join(', ') + (fluctuatingNumbers.length > 15 ? '...' : '') : '无明显波动号码'}</li>
                        <li>这些号码在热度上存在明显波动，值得关注</li>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>💡 趋势建议：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>趋势跟随策略：</strong></li>
                        <li>${cvTrendDirection === '上升' ? '• 分布不均匀性增加，建议关注热号和冷号的极端情况' : '• 分布趋于均匀，建议从各个号码中均衡选择'}</li>
                        <li>${trendPrediction.direction === '上升' ? '• 预测分布不均匀性将继续上升，建议重点关注热号' : trendPrediction.direction === '下降' ? '• 预测分布不均匀性将继续下降，建议均衡选号' : '• 预测分布将保持稳定，建议维持当前选号策略'}</li>
                        <li><strong>周期性策略：</strong></li>
                        ${periodicityAnalysis.hasPeriodicity ? `<li>• 利用周期性规律：${periodicityAnalysis.periodicHotNumbers.slice(0, 3).join(', ')}（周期性热号）</li>` : ''}
                        ${periodicityAnalysis.hasPeriodicity ? `<li>• 关注周期性冷号：${periodicityAnalysis.periodicColdNumbers.slice(0, 3).join(', ')}（可能即将回补）</li>` : ''}
                        <li>${periodicityAnalysis.hasPeriodicity ? '• 结合周期阶段，选择处于上升期的号码' : '• 未发现明显周期性，建议以趋势分析为主'}</li>
                        <li><strong>号码选择策略：</strong></li>
                        <li>${persistentHotNumbers.length > 0 ? `• 持续热号${persistentHotNumbers.slice(0, 3).join(', ')}可重点关注` : '• 无明显持续热号，建议关注近期热号'}</li>
                        <li>${persistentColdNumbers.length > 0 ? `• 持续冷号${persistentColdNumbers.slice(0, 3).join(', ')}可能存在回补机会` : '• 无明显持续冷号，建议关注遗漏值较大的号码'}</li>
                        <li>• 波动号码${fluctuatingNumbers.length > 0 ? fluctuatingNumbers.slice(0, 3).join(', ') : ''}可能处于转折点，可适度关注</li>
                        <li>• 结合当前阶段的热冷分布，保持选号的多样性和平衡性</li>
                        <li><strong>风险控制：</strong></li>
                        <li>• 预测仅供参考，实际选号需结合个人判断</li>
                        <li>• 避免过度依赖单一指标，综合分析多个因素</li>
                        <li>• 定期关注趋势变化，及时调整选号策略</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📋 科学分析结论：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>趋势特征：</strong>${cvTrendDirection === '上升' ? '分布不均匀性呈上升趋势，号码分布越来越不均衡' : cvTrendDirection === '下降' ? '分布不均匀性呈下降趋势，号码分布越来越均衡' : '分布不均匀性保持稳定，号码分布相对稳定'}</li>
                        <li><strong>预测特征：</strong>${trendPrediction.confidence > 70 ? '预测置信度较高，趋势预测较为可靠' : '预测置信度一般，趋势预测仅供参考'}</li>
                        <li><strong>周期性特征：</strong>${periodicityAnalysis.hasPeriodicity ? '发现周期性规律，可利用周期性进行选号' : '未发现明显周期性规律，建议以趋势分析为主'}</li>
                        <li><strong>推荐策略：</strong>基于当前数据分析，建议采用"趋势跟随、周期参考、均衡选号"的选号策略</li>
                        <li><strong>风险提示：</strong>历史数据分析和预测仅供参考，实际选号需结合个人判断和风险承受能力</li>
                    </ul>
                `;

                insightsContent.innerHTML = insights;
            }

            static predictTrend(timeSegments) {
                if (timeSegments.length < 3) {
                    return {
                        direction: '无法预测',
                        strength: '数据不足',
                        predictedCV: timeSegments[timeSegments.length - 1].coefficientOfVariation,
                        predictedGini: timeSegments[timeSegments.length - 1].giniCoefficient,
                        predictedHotCount: timeSegments[timeSegments.length - 1].hotNumbers.length,
                        predictedColdCount: timeSegments[timeSegments.length - 1].coldNumbers.length,
                        confidence: 0
                    };
                }

                const recentSegments = timeSegments.slice(-3);
                const cvValues = recentSegments.map(seg => seg.coefficientOfVariation);
                const giniValues = recentSegments.map(seg => seg.giniCoefficient);
                const hotCounts = recentSegments.map(seg => seg.hotNumbers.length);
                const coldCounts = recentSegments.map(seg => seg.coldNumbers.length);

                const cvTrend = cvValues[2] - cvValues[0];
                const giniTrend = giniValues[2] - giniValues[0];
                const hotTrend = hotCounts[2] - hotCounts[0];
                const coldTrend = coldCounts[2] - coldCounts[0];

                const latestCV = cvValues[2];
                const latestGini = giniValues[2];
                const latestHot = hotCounts[2];
                const latestCold = coldCounts[2];

                let direction = '稳定';
                let strength = '一般';

                if (cvTrend > 0.5) {
                    direction = '上升';
                    strength = cvTrend > 2 ? '强烈' : '中等';
                } else if (cvTrend < -0.5) {
                    direction = '下降';
                    strength = Math.abs(cvTrend) > 2 ? '强烈' : '中等';
                }

                const predictedCV = latestCV + cvTrend * 0.5;
                const predictedGini = latestGini + giniTrend * 0.5;
                const predictedHotCount = Math.max(0, Math.round(latestHot + hotTrend * 0.5));
                const predictedColdCount = Math.max(0, Math.round(latestCold + coldTrend * 0.5));

                const trendConsistency = Math.abs(cvTrend) > 0.5 && Math.abs(giniTrend) > 0.001 ? 1 : 0.5;
                const confidence = Math.min(100, Math.round(trendConsistency * 80 + (timeSegments.length >= 5 ? 10 : 0)));

                return {
                    direction: direction,
                    strength: strength,
                    predictedCV: predictedCV,
                    predictedGini: predictedGini,
                    predictedHotCount: predictedHotCount,
                    predictedColdCount: predictedColdCount,
                    confidence: confidence
                };
            }

            static analyzeDistributionPeriodicity(timeSegments, draws) {
                const segmentCount = timeSegments.length;

                if (segmentCount < 4) {
                    return {
                        hasPeriodicity: false,
                        mainPeriod: 0,
                        periodicHotNumbers: [],
                        periodicColdNumbers: [],
                        periodicityStrength: '数据不足'
                    };
                }

                const hotNumberPatterns = {};
                const coldNumberPatterns = {};

                for (let i = 1; i <= 33; i++) {
                    const num = i.toString().padStart(2, '0');
                    hotNumberPatterns[num] = [];
                    coldNumberPatterns[num] = [];

                    timeSegments.forEach((seg, index) => {
                        if (seg.hotNumbers.includes(num)) {
                            hotNumberPatterns[num].push(index);
                        }
                        if (seg.coldNumbers.includes(num)) {
                            coldNumberPatterns[num].push(index);
                        }
                    });
                }

                const hotIntervals = {};
                const coldIntervals = {};

                for (let i = 1; i <= 33; i++) {
                    const num = i.toString().padStart(2, '0');
                    const hotPositions = hotNumberPatterns[num];
                    const coldPositions = coldNumberPatterns[num];

                    if (hotPositions.length > 1) {
                        hotIntervals[num] = [];
                        for (let j = 1; j < hotPositions.length; j++) {
                            hotIntervals[num].push(hotPositions[j] - hotPositions[j - 1]);
                        }
                    }

                    if (coldPositions.length > 1) {
                        coldIntervals[num] = [];
                        for (let j = 1; j < coldPositions.length; j++) {
                            coldIntervals[num].push(coldPositions[j] - coldPositions[j - 1]);
                        }
                    }
                }

                const allHotIntervals = [];
                const allColdIntervals = [];

                Object.values(hotIntervals).forEach(intervals => {
                    allHotIntervals.push(...intervals);
                });

                Object.values(coldIntervals).forEach(intervals => {
                    allColdIntervals.push(...intervals);
                });

                const hotAvgInterval = allHotIntervals.length > 0 ? allHotIntervals.reduce((sum, interval) => sum + interval, 0) / allHotIntervals.length : 0;
                const coldAvgInterval = allColdIntervals.length > 0 ? allColdIntervals.reduce((sum, interval) => sum + interval, 0) / allColdIntervals.length : 0;

                const hotIntervalVariance = allHotIntervals.length > 0 
                    ? allHotIntervals.reduce((sum, interval) => sum + Math.pow(interval - hotAvgInterval, 2), 0) / allHotIntervals.length 
                    : 0;
                const coldIntervalVariance = allColdIntervals.length > 0 
                    ? allColdIntervals.reduce((sum, interval) => sum + Math.pow(interval - coldAvgInterval, 2), 0) / allColdIntervals.length 
                    : 0;

                const hotIntervalStdDev = Math.sqrt(hotIntervalVariance);
                const coldIntervalStdDev = Math.sqrt(coldIntervalVariance);

                const hotPeriodicity = hotIntervalStdDev < hotAvgInterval * 0.5 && allHotIntervals.length > 5;
                const coldPeriodicity = coldIntervalStdDev < coldAvgInterval * 0.5 && allColdIntervals.length > 5;

                const hasPeriodicity = hotPeriodicity || coldPeriodicity;

                const mainPeriod = hasPeriodicity ? Math.round((hotAvgInterval + coldAvgInterval) / 2) : 0;

                const periodicHotNumbers = [];
                const periodicColdNumbers = [];

                if (hasPeriodicity) {
                    for (let i = 1; i <= 33; i++) {
                        const num = i.toString().padStart(2, '0');

                        if (hotIntervals[num] && hotIntervals[num].length > 0) {
                            const numAvgInterval = hotIntervals[num].reduce((sum, interval) => sum + interval, 0) / hotIntervals[num].length;
                            const deviation = Math.abs(numAvgInterval - mainPeriod);

                            if (deviation < mainPeriod * 0.3) {
                                periodicHotNumbers.push(num);
                            }
                        }

                        if (coldIntervals[num] && coldIntervals[num].length > 0) {
                            const numAvgInterval = coldIntervals[num].reduce((sum, interval) => sum + interval, 0) / coldIntervals[num].length;
                            const deviation = Math.abs(numAvgInterval - mainPeriod);

                            if (deviation < mainPeriod * 0.3) {
                                periodicColdNumbers.push(num);
                            }
                        }
                    }
                }

                const periodicityStrength = hasPeriodicity 
                    ? (hotPeriodicity && coldPeriodicity ? '强烈' : '中等') 
                    : '无明显周期性';

                return {
                    hasPeriodicity: hasPeriodicity,
                    mainPeriod: mainPeriod,
                    periodicHotNumbers: periodicHotNumbers,
                    periodicColdNumbers: periodicColdNumbers,
                    periodicityStrength: periodicityStrength
                };
            }

            static performComprehensiveAnalysis(draws) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange[1];

                const numberCounts = {};
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberCounts[num] = 0;
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberCounts[ball] !== undefined) {
                            numberCounts[ball]++;
                        }
                    });
                });

                const counts = Object.values(numberCounts);
                const mean = counts.reduce((sum, count) => sum + count, 0) / counts.length;
                const variance = counts.reduce((sum, count) => sum + Math.pow(count - mean, 2), 0) / counts.length;
                const standardDeviation = Math.sqrt(variance);
                const coefficientOfVariation = (standardDeviation / mean) * 100;

                const sortedCounts = [...counts].sort((a, b) => a - b);
                const giniCoefficient = this.calculateGiniCoefficient(sortedCounts);

                const skewness = this.calculateSkewness(counts, mean, standardDeviation);
                const kurtosis = this.calculateKurtosis(counts, mean, standardDeviation);

                const uniformityScore = this.calculateUniformityScore(coefficientOfVariation, giniCoefficient, skewness, kurtosis);

                const intervalSize = Math.ceil(redBallRange / 5);
                const intervals = [];
                for (let i = 0; i < 5; i++) {
                    const start = i * intervalSize + 1;
                    const end = Math.min((i + 1) * intervalSize, redBallRange);
                    intervals.push({
                        name: `区间${i + 1}`,
                        start: start,
                        end: end,
                        count: 0,
                        numbers: []
                    });
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        intervals.forEach(interval => {
                            if (num >= interval.start && num <= interval.end) {
                                interval.count++;
                                if (!interval.numbers.includes(num)) {
                                    interval.numbers.push(num);
                                }
                            }
                        });
                    });
                });

                const totalRedBalls = draws.length * 6;
                intervals.forEach(interval => {
                    interval.percentage = ((interval.count / totalRedBalls) * 100).toFixed(2);
                });

                const highDensityNumbers = Object.entries(numberCounts)
                    .filter(([num, count]) => count >= draws.length * 0.3)
                    .map(([num, count]) => num);
                const mediumDensityNumbers = Object.entries(numberCounts)
                    .filter(([num, count]) => count >= draws.length * 0.15 && count < draws.length * 0.3)
                    .map(([num, count]) => num);
                const lowDensityNumbers = Object.entries(numberCounts)
                    .filter(([num, count]) => count < draws.length * 0.15)
                    .map(([num, count]) => num);

                const hotNumbers = Object.entries(numberCounts)
                    .filter(([num, count]) => count > mean + standardDeviation)
                    .map(([num, count]) => ({ num, count }));
                const coldNumbers = Object.entries(numberCounts)
                    .filter(([num, count]) => count < mean - standardDeviation)
                    .map(([num, count]) => ({ num, count }));
                const normalNumbers = Object.entries(numberCounts)
                    .filter(([num, count]) => count >= mean - standardDeviation && count <= mean + standardDeviation)
                    .map(([num, count]) => ({ num, count }));

                const consecutiveNumbers = [];
                for (let i = 1; i < redBallRange; i++) {
                    const num1 = i.toString().padStart(2, '0');
                    const num2 = (i + 1).toString().padStart(2, '0');
                    let consecutiveCount = 0;
                    draws.forEach(draw => {
                        if (draw.redBalls.includes(num1) && draw.redBalls.includes(num2)) {
                            consecutiveCount++;
                        }
                    });
                    if (consecutiveCount > 0) {
                        consecutiveNumbers.push({ pair: `${num1}-${num2}`, count: consecutiveCount });
                    }
                }
                consecutiveNumbers.sort((a, b) => b.count - a.count);

                const sameTailNumbers = {};
                for (let i = 1; i <= redBallRange; i++) {
                    const num = i.toString().padStart(2, '0');
                    const tail = num.slice(-1);
                    if (!sameTailNumbers[tail]) {
                        sameTailNumbers[tail] = [];
                    }
                    sameTailNumbers[tail].push(num);
                }

                const sameTailPairs = [];
                Object.entries(sameTailNumbers).forEach(([tail, numbers]) => {
                    if (numbers.length >= 2) {
                        let pairCount = 0;
                        draws.forEach(draw => {
                            const drawnNumbers = draw.redBalls.filter(ball => ball.slice(-1) === tail);
                            if (drawnNumbers.length >= 2) {
                                pairCount++;
                            }
                        });
                        sameTailPairs.push({ tail, numbers, count: pairCount });
                    }
                });
                sameTailPairs.sort((a, b) => b.count - a.count);

                const comprehensiveResults = {
                    uniformity: {
                        score: uniformityScore,
                        coefficientOfVariation,
                        giniCoefficient,
                        mean,
                        standardDeviation
                    },
                    intervals,
                    density: {
                        high: highDensityNumbers,
                        medium: mediumDensityNumbers,
                        low: lowDensityNumbers
                    },
                    hotCold: {
                        hot: hotNumbers,
                        cold: coldNumbers,
                        normal: normalNumbers
                    },
                    patterns: {
                        consecutive: consecutiveNumbers.slice(0, 10),
                        sameTail: sameTailPairs.slice(0, 10)
                    }
                };

                this.updateComprehensiveChart(comprehensiveResults);
                this.generateComprehensiveInsights(comprehensiveResults, draws);

                return comprehensiveResults;
            }

            static updateComprehensiveChart(results) {
                const chartDom = document.getElementById('numberDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const intervalNames = results.intervals.map(i => i.name);
                const intervalPercentages = results.intervals.map(i => parseFloat(i.percentage));

                const option = {
                    title: {
                        text: '号码分布综合分析',
                        left: 'center',
                        textStyle: {
                            color: '#333'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const interval = results.intervals[param.dataIndex];
                            return `${interval.name}<br/>出现率: ${param.value}%<br/>号码: ${interval.numbers.join(', ')}`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: intervalNames,
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现率(%)',
                        axisLabel: {
                            color: '#333',
                            formatter: '{value}%'
                        }
                    },
                    series: [
                        {
                            name: '出现率',
                            type: 'bar',
                            data: intervalPercentages,
                            itemStyle: {
                                color: function(params) {
                                    const colors = ['#E63946', '#F4A261', '#2A9D8F', '#457B9D', '#A8DADC'];
                                    return colors[params.dataIndex % colors.length];
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}%'
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#333',
                                    type: 'dashed'
                                },
                                label: {
                                    formatter: '平均值: {c}%'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const number = params.value[0];
                        const type = params.value[1];
                        const frequency = params.value[2];
                        const omission = bigSmallData.numberOmission[number.toString().padStart(2, '0')];

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">号码 ${number.toString().padStart(2, '0')} 详细信息</h3>
                                <p><strong>类型：</strong>${type}</p>
                                <p><strong>出现次数：</strong>${frequency}</p>
                                <p><strong>当前遗漏：</strong>${omission}期</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('号码详情', detailHtml);
                    }
                });
            }

            static generateSmartRecommendationsUI() {
                const loadingDiv = document.getElementById('recommendationsLoading');
                const contentDiv = document.getElementById('recommendationsContent');

                loadingDiv.style.display = 'block';
                contentDiv.style.display = 'none';

                setTimeout(() => {
                    try {
                        const draws = dataManager.getDraws();
                        if (!draws || draws.length === 0) {
                            loadingDiv.style.display = 'none';
                            contentDiv.style.display = 'block';
                            contentDiv.innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #dc3545;">
                                    <i class="fas fa-exclamation-circle" style="font-size: 60px; margin-bottom: 20px;"></i>
                                    <h3 style="margin-bottom: 15px;">暂无数据</h3>
                                    <p>请先导入彩票数据后再使用智能推荐功能</p>
                                </div>
                            `;
                            return;
                        }

                        const analysisResults = this.performComprehensiveAnalysis(draws);

                        const engine = new RecommendationEngine();
                        const recommendations = engine.generateRecommendations(draws, analysisResults);

                        loadingDiv.style.display = 'none';
                        contentDiv.style.display = 'block';

                        let html = '<div style="margin-bottom: 30px;">';
                        html += '<h3 style="color: #007bff; margin-bottom: 15px;"><i class="fas fa-cog"></i> 推荐引擎配置</h3>';
                        html += '<div style="padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">';
                        html += '<strong>权重配置：</strong>';
                        html += `频率${(recommendations.weights.frequency * 100).toFixed(0)}% | `;
                        html += `遗漏${(recommendations.weights.omission * 100).toFixed(0)}% | `;
                        html += `趋势${(recommendations.weights.trend * 100).toFixed(0)}% | `;
                        html += `模式${(recommendations.weights.pattern * 100).toFixed(0)}% | `;
                        html += `统计${(recommendations.weights.statistics * 100).toFixed(0)}% | `;
                        html += `其他${(recommendations.weights.others * 100).toFixed(0)}%`;
                        html += '</div></div>';

                        html += '<div style="margin-bottom: 30px;">';
                        html += '<h3 style="color: #17a2b8; margin-bottom: 15px;"><i class="fas fa-chart-line"></i> 历史准确率分析</h3>';
                        html += '<div style="padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #17a2b8;">';
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">';
                        html += '<div style="text-align: center; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
                        html += '<div style="font-size: 24px; font-weight: bold; color: #28a745;">' + recommendations.historicalAccuracy.shortTerm.hitRate.toFixed(1) + '%</div>';
                        html += '<div style="font-size: 12px; color: #6c757d; margin-top: 5px;">短期准确率</div>';
                        html += '<div style="font-size: 11px; color: #adb5bd;">样本: ' + recommendations.historicalAccuracy.shortTerm.sampleSize + '期</div>';
                        html += '</div>';
                        html += '<div style="text-align: center; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
                        html += '<div style="font-size: 24px; font-weight: bold; color: #007bff;">' + recommendations.historicalAccuracy.mediumTerm.hitRate.toFixed(1) + '%</div>';
                        html += '<div style="font-size: 12px; color: #6c757d; margin-top: 5px;">中期准确率</div>';
                        html += '<div style="font-size: 11px; color: #adb5bd;">样本: ' + recommendations.historicalAccuracy.mediumTerm.sampleSize + '期</div>';
                        html += '</div>';
                        html += '<div style="text-align: center; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
                        html += '<div style="font-size: 24px; font-weight: bold; color: #6f42c1;">' + recommendations.historicalAccuracy.longTerm.hitRate.toFixed(1) + '%</div>';
                        html += '<div style="font-size: 12px; color: #6c757d; margin-top: 5px;">长期准确率</div>';
                        html += '<div style="font-size: 11px; color: #adb5bd;">样本: ' + recommendations.historicalAccuracy.longTerm.sampleSize + '期</div>';
                        html += '</div>';
                        html += '<div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; color: white;">';
                        html += '<div style="font-size: 28px; font-weight: bold;">' + recommendations.historicalAccuracy.overall.hitRate.toFixed(1) + '%</div>';
                        html += '<div style="font-size: 12px; opacity: 0.9; margin-top: 5px;">综合准确率</div>';
                        html += '<div style="font-size: 11px; opacity: 0.8;">样本: ' + recommendations.historicalAccuracy.overall.sampleSize + '期</div>';
                        html += '</div>';
                        html += '</div>';
                        html += '<div style="font-size: 12px; color: #6c757d; margin-top: 10px;">';
                        html += '<i class="fas fa-info-circle"></i> 准确率基于历史数据回测计算，短期(最近10期)、中期(最近30期)、长期(最近50期)的命中率加权平均得出综合准确率';
                        html += '</div>';
                        html += '</div></div>';

                        html += '<div style="margin-bottom: 30px;">';
                        html += '<h3 style="color: #fd7e14; margin-bottom: 15px;"><i class="fas fa-shield-alt"></i> 置信度指标</h3>';
                        html += '<div style="padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #fd7e14;">';
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">';
                        html += '<div>';
                        html += '<div style="display: flex; justify-content: space-between; margin-bottom: 5px;">';
                        html += '<span style="font-size: 13px; color: #495057;">评分一致性</span>';
                        html += '<span style="font-size: 13px; font-weight: bold; color: #28a745;">' + (recommendations.confidenceMetrics.scoreConsistency * 100).toFixed(0) + '%</span>';
                        html += '</div>';
                        html += '<div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">';
                        html += '<div style="height: 100%; background: linear-gradient(90deg, #28a745, #20c997); width: ' + (recommendations.confidenceMetrics.scoreConsistency * 100) + '%; transition: width 0.3s ease;"></div>';
                        html += '</div>';
                        html += '<div style="font-size: 11px; color: #6c757d; margin-top: 3px;">推荐评分的稳定性</div>';
                        html += '</div>';
                        html += '<div>';
                        html += '<div style="display: flex; justify-content: space-between; margin-bottom: 5px;">';
                        html += '<span style="font-size: 13px; color: #495057;">趋势对齐度</span>';
                        html += '<span style="font-size: 13px; font-weight: bold; color: #007bff;">' + (recommendations.confidenceMetrics.trendAlignment * 100).toFixed(0) + '%</span>';
                        html += '</div>';
                        html += '<div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">';
                        html += '<div style="height: 100%; background: linear-gradient(90deg, #007bff, #0056b3); width: ' + (recommendations.confidenceMetrics.trendAlignment * 100) + '%; transition: width 0.3s ease;"></div>';
                        html += '</div>';
                        html += '<div style="font-size: 11px; color: #6c757d; margin-top: 3px;">与历史趋势的匹配度</div>';
                        html += '</div>';
                        html += '<div>';
                        html += '<div style="display: flex; justify-content: space-between; margin-bottom: 5px;">';
                        html += '<span style="font-size: 13px; color: #495057;">模式强度</span>';
                        html += '<span style="font-size: 13px; font-weight: bold; color: #6f42c1;">' + (recommendations.confidenceMetrics.patternStrength * 100).toFixed(0) + '%</span>';
                        html += '</div>';
                        html += '<div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">';
                        html += '<div style="height: 100%; background: linear-gradient(90deg, #6f42c1, #5a32a3); width: ' + (recommendations.confidenceMetrics.patternStrength * 100) + '%; transition: width 0.3s ease;"></div>';
                        html += '</div>';
                        html += '<div style="font-size: 11px; color: #6c757d; margin-top: 3px;">历史模式匹配程度</div>';
                        html += '</div>';
                        html += '<div>';
                        html += '<div style="display: flex; justify-content: space-between; margin-bottom: 5px;">';
                        html += '<span style="font-size: 13px; color: #495057;">统计显著性</span>';
                        html += '<span style="font-size: 13px; font-weight: bold; color: #fd7e14;">' + (recommendations.confidenceMetrics.statisticalSignificance * 100).toFixed(0) + '%</span>';
                        html += '</div>';
                        html += '<div style="height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">';
                        html += '<div style="height: 100%; background: linear-gradient(90deg, #fd7e14, #e67e22); width: ' + (recommendations.confidenceMetrics.statisticalSignificance * 100) + '%; transition: width 0.3s ease;"></div>';
                        html += '</div>';
                        html += '<div style="font-size: 11px; color: #6c757d; margin-top: 3px;">统计指标符合度</div>';
                        html += '</div>';
                        html += '</div>';
                        html += '<div style="font-size: 12px; color: #6c757d; margin-top: 10px;">';
                        html += '<i class="fas fa-info-circle"></i> 置信度指标反映了推荐系统的可靠性，评分一致性越高、趋势对齐度越高、模式强度越高、统计显著性越高，说明推荐越可靠';
                        html += '</div>';
                        html += '</div></div>';

                        html += '<div style="margin-bottom: 30px;">';
                        html += '<h3 style="color: #28a745; margin-bottom: 15px;"><i class="fas fa-database"></i> 号码综合分析</h3>';
                        html += '<div style="padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">';
                        html += '<table style="width: 100%; border-collapse: collapse;">';
                        html += '<thead><tr style="background: #e9ecef;">';
                        html += '<th style="padding: 10px; text-align: left;">号码</th>';
                        html += '<th style="padding: 10px; text-align: center;">出现次数</th>';
                        html += '<th style="padding: 10px; text-align: center;">平均分</th>';
                        html += '<th style="padding: 10px; text-align: center;">星级</th>';
                        html += '<th style="padding: 10px; text-align: left;">性质</th>';
                        html += '</tr></thead><tbody>';

                        recommendations.numberFrequency.forEach((item, index) => {
                            const bgColor = index % 2 === 0 ? '#ffffff' : '#f8f9fa';
                            const stars = '⭐'.repeat(item.starRating);
                            html += `<tr style="background: ${bgColor};">`;
                            html += `<td style="padding: 10px; font-weight: bold; color: #007bff;">${item.number}</td>`;
                            html += `<td style="padding: 10px; text-align: center;">${item.count}</td>`;
                            html += `<td style="padding: 10px; text-align: center;">${item.avgScore.toFixed(1)}</td>`;
                            html += `<td style="padding: 10px; text-align: center;">${stars}</td>`;
                            html += `<td style="padding: 10px;">${item.properties.join(' ')}</td>`;
                            html += '</tr>';
                        });

                        html += '</tbody></table>';
                        html += '</div></div>';

                        html += '<div style="margin-bottom: 30px;">';
                        html += '<h3 style="color: #6f42c1; margin-bottom: 15px;"><i class="fas fa-layer-group"></i> 大复式号码</h3>';

                        html += '<div style="padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; color: white; margin-bottom: 15px;">';
                        html += '<div style="font-size: 24px; font-weight: bold; margin-bottom: 10px; text-align: center; letter-spacing: 2px;">';
                        html += recommendations.largeComplex.numbers.join(' ');
                        html += '</div>';
                        html += '<div style="text-align: center; font-size: 14px; opacity: 0.9;">';
                        html += `共 ${recommendations.largeComplex.analysis.total} 个号码`;
                        html += '</div>';
                        html += '</div>';

                        html += '<div style="padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #6f42c1; margin-bottom: 15px;">';
                        html += '<strong>大复式分析：</strong>';
                        html += `<br/>奇偶分布：${recommendations.largeComplex.analysis.oddCount}奇${recommendations.largeComplex.analysis.evenCount}偶`;
                        html += `<br/>大小分布：${recommendations.largeComplex.analysis.bigCount}大${recommendations.largeComplex.analysis.smallCount}小`;
                        html += `<br/>质合分布：${recommendations.largeComplex.analysis.primeCount}质${recommendations.largeComplex.analysis.compositeCount}合`;
                        html += `<br/>大中小分布：三区${recommendations.largeComplex.analysis.zones.zone3}个、二区${recommendations.largeComplex.analysis.zones.zone2}个、一区${recommendations.largeComplex.analysis.zones.zone1}个`;
                        html += `<br/>尾号分布：${recommendations.largeComplex.analysis.topTails}`;
                        if (recommendations.largeComplex.analysis.consecutiveGroups.length > 0) {
                            html += `<br/>连号情况：${recommendations.largeComplex.analysis.consecutiveGroups.join('、')}`;
                        }
                        html += `<br/>特点：${recommendations.largeComplex.analysis.properties.join('、')}`;
                        html += '</div>';

                        html += '<div style="padding: 15px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #007bff; margin-bottom: 15px;">';
                        html += '<strong>号码详细信息：</strong>';
                        const minNum = Math.min(...recommendations.largeComplex.numbers.map(n => parseInt(n)));
                        const maxNum = Math.max(...recommendations.largeComplex.numbers.map(n => parseInt(n)));
                        const range = maxNum - minNum + 1;
                        const density = (recommendations.largeComplex.analysis.total / range * 100).toFixed(1);
                        html += `<br/>最小号码：${minNum.toString().padStart(2, '0')}`;
                        html += `<br/>最大号码：${maxNum.toString().padStart(2, '0')}`;
                        html += `<br/>号码跨度：${range}`;
                        html += `<br/>号码密度：${density}%`;
                        html += '</div>';

                        html += '<div style="margin-top: 15px; text-align: center;">';
                        html += '<button onclick="EventDelegate.copyToClipboard(\'' + recommendations.largeComplex.numbers.join(' ') + '\')" style="padding: 10px 30px; background: #6f42c1; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">';
                        html += '<i class="fas fa-copy"></i> 复制大底';
                        html += '</button>';
                        html += '</div>';
                        html += '</div>';

                        html += `
                            <div style="margin-bottom: 30px;">
                                <h3 style="color: #007bff; margin-bottom: 15px;">
                                    <i class="fas fa-circle"></i> 蓝球推荐
                                </h3>
                                <div style="padding: 20px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border-radius: 10px; color: white; margin-bottom: 15px;">
                                    <div style="font-size: 48px; font-weight: bold; margin-bottom: 10px; text-align: center;">
                                        ${recommendations.blueBallRecommendations.number}
                                    </div>
                                    <div style="text-align: center; font-size: 16px; opacity: 0.9;">
                                        置信度：${recommendations.blueBallRecommendations.confidence.toFixed(1)}%
                                    </div>
                                </div>
                                <div style="padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #38ef7d;">
                                    <strong>推荐理由：</strong>${recommendations.blueBallRecommendations.reason}
                                </div>
                            </div>

                            <div style="padding: 20px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
                                <h4 style="color: #856404; margin-top: 0;">
                                    <i class="fas fa-exclamation-triangle"></i> 重要提示
                                </h4>
                                <ul style="color: #856404; margin-left: 20px;">
                                    <li>以上推荐基于历史数据统计分析，仅供参考，不构成任何投资建议</li>
                                    <li>彩票开奖具有随机性，任何分析都无法保证中奖</li>
                                    <li>请理性购彩，量力而行，切勿沉迷</li>
                                    <li>建议结合个人喜好和直觉进行选号</li>
                                </ul>
                            </div>
                        `;

                        contentDiv.innerHTML = html;

                        MessageSystem.showMessage('智能推荐生成成功', 'success');
                    } catch (error) {

                        loadingDiv.style.display = 'none';
                        contentDiv.style.display = 'block';
                        contentDiv.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #dc3545;">
                                <i class="fas fa-times-circle" style="font-size: 60px; margin-bottom: 20px;"></i>
                                <h3 style="margin-bottom: 15px;">生成失败</h3>
                                <p>生成智能推荐时发生错误：${error.message}</p>
                            </div>
                        `;
                        MessageSystem.showMessage('生成智能推荐失败: ' + error.message, 'error');
                    }
                }, 1000);
            }

            static generateComprehensiveInsights(results, draws) {
                const insightsContent = document.getElementById('distributionInsightsContent');
                if (!insightsContent) return;

                const { uniformity, intervals, density, hotCold, patterns } = results;

                const topIntervals = intervals
                    .sort((a, b) => parseFloat(b.percentage) - parseFloat(a.percentage))
                    .slice(0, 2);
                const bottomIntervals = intervals
                    .sort((a, b) => parseFloat(a.percentage) - parseFloat(b.percentage))
                    .slice(0, 2);

                const topHotNumbers = hotCold.hot
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5)
                    .map(n => n.num);
                const topColdNumbers = hotCold.cold
                    .sort((a, b) => a.count - b.count)
                    .slice(0, 5)
                    .map(n => n.num);

                const topConsecutive = patterns.consecutive.slice(0, 5);
                const topSameTail = patterns.sameTail.slice(0, 5);

                const engine = new RecommendationEngine();
                const recommendations = engine.generateRecommendations(draws, results);
                const riskAssessment = this.generateRiskAssessment(results, draws);

                const analysisPeriodRange = draws.length > 0 
                    ? `${draws[0].period} 至 ${draws[draws.length - 1].period}（共${draws.length}期）`
                    : '无数据';

                let insights = `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(69, 123, 157, 0.1); border-left: 4px solid #457B9D; border-radius: 4px;">
                        <strong>📅 分析期数范围：</strong> ${analysisPeriodRange}
                    </div>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 综合评估：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>均匀性得分：${uniformity.score.score}分（${uniformity.score.level}）</li>
                        <li>变异系数：${uniformity.coefficientOfVariation.toFixed(2)}%</li>
                        <li>基尼系数：${uniformity.giniCoefficient.toFixed(4)}</li>
                        <li>平均出现次数：${uniformity.mean.toFixed(2)}次</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📈 区间分布：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>热门区间：${topIntervals.map(i => i.name).join(', ')}（${topIntervals.map(i => i.percentage + '%').join(', ')}）</li>
                        <li>冷门区间：${bottomIntervals.map(i => i.name).join(', ')}（${bottomIntervals.map(i => i.percentage + '%').join(', ')}）</li>
                        <li>建议：${parseFloat(topIntervals[0].percentage) > 25 ? '热门区间占比过高，建议适当关注冷门区间' : '区间分布较为均衡，建议各区间均衡选择'}</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>🔥 号码热度：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>热号（${hotCold.hot.length}个）：${topHotNumbers.join(', ')}...</li>
                        <li>冷号（${hotCold.cold.length}个）：${topColdNumbers.join(', ')}...</li>
                        <li>普通号码（${hotCold.normal.length}个）：建议重点关注</li>
                        <li>建议：从热号中选择2-3个，从冷号中选择1-2个，从普通号码中选择2-3个</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📊 号码密度：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>高密度（${density.high.length}个）：${density.high.slice(0, 5).join(', ')}...</li>
                        <li>中密度（${density.medium.length}个）：${density.medium.slice(0, 5).join(', ')}...</li>
                        <li>低密度（${density.low.length}个）：${density.low.slice(0, 5).join(', ')}...</li>
                        <li>建议：中密度号码出现概率适中，可作为主要选择范围</li>
                    </ul>
                `;

                if (topConsecutive.length > 0) {
                    insights += `
                        <div style="margin-bottom: 10px;">
                            <strong>🔗 连号规律：</strong>
                        </div>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            ${topConsecutive.map(c => `<li>${c.pair}：${c.count}次</li>`).join('')}
                            <li>建议：${topConsecutive[0].count > draws.length * 0.1 ? '连号出现较为频繁，可考虑选择1-2组连号' : '连号出现较少，不建议过度追求连号'}</li>
                        </ul>
                    `;
                }

                if (topSameTail.length > 0) {
                    insights += `
                        <div style="margin-bottom: 10px;">
                            <strong>🎯 同尾号规律：</strong>
                        </div>
                        <ul style="margin-left: 20px; margin-bottom: 10px;">
                            ${topSameTail.map(s => `<li>尾数${s.tail}：${s.count}次（${s.numbers.join(', ')}）</li>`).join('')}
                            <li>建议：${topSameTail[0].count > draws.length * 0.1 ? '同尾号出现较为频繁，可考虑选择1-2组同尾号' : '同尾号出现较少，不建议过度追求同尾号'}</li>
                        </ul>
                    `;
                }

                insights += `
                    <div style="margin-bottom: 10px;">
                        <strong>🎯 智能选号推荐：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        ${recommendations.redBallRecommendations.map((rec, index) => {
                            const stars = '⭐'.repeat(rec.starRating);
                            const ratingText = rec.starRating === 5 ? '五星推荐' : rec.starRating === 4 ? '四星推荐' : '三星推荐';
                            return `
                                <li><strong>推荐方案${index + 1}（${ratingText}）：</strong></li>
                                <li>• 推荐号码：${rec.numbers.join(', ')}</li>
                                <li>• 推荐理由：${rec.reason}</li>
                                <li>• 置信度：${rec.confidence.toFixed(1)}% | ${stars}</li>
                                <li>• 策略标签：${rec.strategyTags.join(' ')}</li>
                            `;
                        }).join('')}
                        <li><strong>蓝球推荐：</strong></li>
                        <li>• 推荐号码：${recommendations.blueBallRecommendations.number}</li>
                        <li>• 推荐理由：${recommendations.blueBallRecommendations.reason}</li>
                        <li>• 置信度：${recommendations.blueBallRecommendations.confidence.toFixed(1)}%</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>⚠️ 风险评估：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>整体风险等级：</strong>${riskAssessment.overallRisk}</li>
                        <li><strong>风险得分：</strong>${riskAssessment.riskScore}分（满分100分，分数越高风险越低）</li>
                        <li><strong>分布风险：</strong>${riskAssessment.distributionRisk}</li>
                        <li><strong>趋势风险：</strong>${riskAssessment.trendRisk}</li>
                        <li><strong>波动风险：</strong>${riskAssessment.volatilityRisk}</li>
                        <li><strong>风险提示：</strong>${riskAssessment.riskWarning}</li>
                        <li><strong>风险控制建议：</strong></li>
                        ${riskAssessment.riskControl.map(r => `<li>• ${r}</li>`).join('')}
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>💡 综合选号建议：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>号码选择策略：</strong></li>
                        <li>• 热号选择：${topHotNumbers.slice(0, 2).join(', ')}（保持热度）</li>
                        <li>• 冷号选择：${topColdNumbers.slice(0, 2).join(', ')}（回补机会）</li>
                        <li>• 普通号选择：${hotCold.normal.slice(0, 3).map(n => n.num).join(', ')}（均衡选择）</li>
                        <li><strong>区间分布策略：</strong></li>
                        <li>• 重点关注：${topIntervals.map(i => i.name).join('、')}（热门区间）</li>
                        <li>• 适当关注：${bottomIntervals.map(i => i.name).join('、')}（冷门区间）</li>
                        <li><strong>特殊组合策略：</strong></li>
                        ${topConsecutive.length > 0 ? `<li>• 连号组合：${topConsecutive.slice(0, 2).map(c => c.pair).join('、')}</li>` : ''}
                        ${topSameTail.length > 0 ? `<li>• 同尾号组合：${topSameTail.slice(0, 2).map(s => `尾数${s.tail}`).join('、')}</li>` : ''}
                        <li><strong>风险控制：</strong></li>
                        <li>• 避免过度集中在热号或冷号上</li>
                        <li>• 保持号码选择的多样性和平衡性</li>
                        <li>• 结合遗漏值分析，避免遗漏值过大的号码</li>
                        <li>• 定期关注号码分布变化，及时调整选号策略</li>
                    </ul>

                    <div style="margin-bottom: 10px;">
                        <strong>📋 科学分析结论：</strong>
                    </div>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li><strong>分布特征：</strong>${uniformity.score.level === '优秀' ? '号码分布较为均匀，各号码出现概率接近理论值' : uniformity.score.level === '良好' ? '号码分布基本均匀，存在一定偏差但整体合理' : '号码分布不够均匀，存在明显偏差，需谨慎选择'}</li>
                        <li><strong>趋势判断：</strong>${uniformity.coefficientOfVariation < 20 ? '号码分布稳定，适合均衡选号策略' : '号码分布波动较大，建议关注热冷号变化'}</li>
                        <li><strong>推荐策略：</strong>基于当前数据分析，建议采用"热冷结合、区间均衡、适度组合"的选号策略</li>
                        <li><strong>风险提示：</strong>历史数据分析仅供参考，实际选号需结合个人判断和风险承受能力</li>
                    </ul>
                `;

                insightsContent.innerHTML = insights;
            }

            static generateRiskAssessment(results, draws) {
                const { uniformity, intervals, density, hotCold, patterns } = results;

                const distributionScore = uniformity.score.score;
                const volatilityScore = Math.max(0, 100 - uniformity.coefficientOfVariation);
                const trendScore = Math.max(0, 100 - uniformity.giniCoefficient * 100);

                const riskScore = Math.round((distributionScore * 0.4 + volatilityScore * 0.3 + trendScore * 0.3));

                let overallRisk = '低';
                if (riskScore < 60) {
                    overallRisk = '高';
                } else if (riskScore < 75) {
                    overallRisk = '中';
                } else if (riskScore < 90) {
                    overallRisk = '中低';
                }

                let distributionRisk = '低';
                if (uniformity.coefficientOfVariation > 30) {
                    distributionRisk = '高';
                } else if (uniformity.coefficientOfVariation > 20) {
                    distributionRisk = '中';
                }

                let trendRisk = '低';
                if (uniformity.giniCoefficient > 0.4) {
                    trendRisk = '高';
                } else if (uniformity.giniCoefficient > 0.3) {
                    trendRisk = '中';
                }

                let volatilityRisk = '低';
                if (uniformity.standardDeviation > uniformity.mean * 0.3) {
                    volatilityRisk = '高';
                } else if (uniformity.standardDeviation > uniformity.mean * 0.2) {
                    volatilityRisk = '中';
                }

                const riskWarnings = [];
                if (uniformity.coefficientOfVariation > 25) {
                    riskWarnings.push('号码分布不均匀性较高，选号风险增加');
                }
                if (hotCold.hot.length > 10 || hotCold.cold.length > 10) {
                    riskWarnings.push('热冷号数量较多，号码分布极化明显');
                }
                if (parseFloat(intervals[0].percentage) > 30) {
                    riskWarnings.push('热门区间占比过高，存在集中风险');
                }
                if (patterns.consecutive.length > 0 && patterns.consecutive[0].count > draws.length * 0.15) {
                    riskWarnings.push('连号出现频率较高，需注意连号风险');
                }

                const riskWarning = riskWarnings.length > 0 ? riskWarnings.join('；') : '当前号码分布较为稳定，风险可控';

                const riskControl = [
                    '建议采用均衡选号策略，避免过度集中在单一类型号码',
                    '定期关注号码分布变化，及时调整选号策略',
                    '结合遗漏值分析，避免遗漏值过大的号码',
                    '保持号码选择的多样性和平衡性',
                    '根据个人风险承受能力选择合适的投注方案'
                ];

                if (overallRisk === '高') {
                    riskControl.push('当前风险较高，建议减少投注金额或选择保守型方案');
                } else if (overallRisk === '中') {
                    riskControl.push('当前风险适中，建议选择均衡型方案');
                } else {
                    riskControl.push('当前风险较低，可根据个人偏好选择方案');
                }

                return {
                    overallRisk: overallRisk,
                    riskScore: riskScore,
                    distributionRisk: distributionRisk,
                    trendRisk: trendRisk,
                    volatilityRisk: volatilityRisk,
                    riskWarning: riskWarning,
                    riskControl: riskControl
                };
            }

            static exportDistributionChart() {
                const chartDom = document.getElementById('numberDistributionChart');
                if (!chartDom) {
                    MessageSystem.showMessage('图表不存在', 'warning');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom);
                if (!chart) {
                    MessageSystem.showMessage('图表未初始化', 'warning');
                    return;
                }

                const url = chart.getDataURL({
                    type: 'png',
                    pixelRatio: 2,
                    backgroundColor: '#fff'
                });

                const link = document.createElement('a');
                link.download = `号码分布分析_${currentLotteryType}_${new Date().toLocaleDateString()}.png`;
                link.href = url;
                link.click();

                MessageSystem.showMessage('图表已导出', 'success');
            }

            static async handleClearDatabase() {
                // 确定当前显示的数据库类型
                let displayLotteryType = 'ssq';
                const databaseCard = document.getElementById('databaseCard');
                if (databaseCard && databaseCard.style.display !== 'none') {
                    // 检查面包屑导航确定当前是哪个数据库
                    const breadcrumbContainer = document.querySelector('.breadcrumb');
                    if (breadcrumbContainer) {
                        const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                        if (breadcrumbItems.length >= 3) {
                            const breadcrumbText = breadcrumbItems[2].textContent;
                            if (breadcrumbText.includes('大乐透')) {
                                displayLotteryType = 'dlt';
                            }
                        }
                    }
                }

                if (!confirm(`确定要清空当前${displayLotteryType === 'ssq' ? '双色球' : '大乐透'}数据库吗？此操作不可恢复！`)) {
                    return;
                }

                // 确保数据库已初始化
                if (!dataManager.databases[displayLotteryType]) {
                    dataManager.databases[displayLotteryType] = new LotteryDatabase(displayLotteryType);
                    await dataManager.databases[displayLotteryType].init();
                }

                const key = `lottery_${displayLotteryType}_data`;

                // 清空LocalStorage中的数据
                localStorage.setItem(key, JSON.stringify({
                    draws: [],
                    statistics: {},
                    settings: {}
                }));

                // 更新当前数据
                currentDatabaseData = { draws: [] };

                // 更新该彩票类型的状态为空
                dataCountStates[displayLotteryType] = 0;
                totalPagesStates[displayLotteryType] = 1;
                pageStates[displayLotteryType] = 1;

                // 更新数据库表格
                dataManager.updateDatabaseTable(displayLotteryType);

                MessageSystem.showMessage(`成功清空${displayLotteryType === 'ssq' ? '双色球' : '大乐透'}数据库`, 'success');
            }

            static handleFrequencyAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const periodSelect = document.getElementById('periodSelect');
                    const selectedPeriod = periodSelect.value;

                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    let analysisData = [];
                    if (selectedPeriod === 'all') {
                        analysisData = [...draws];
                    } else {
                        const periodCount = parseInt(selectedPeriod);
                        analysisData = draws.slice(-periodCount);
                    }

                    const dataRangeInfo = document.getElementById('dataRangeInfo');
                    if (analysisData.length > 0) {
                        const startPeriod = analysisData[0].period;
                        const endPeriod = analysisData[analysisData.length - 1].period;
                        dataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                    } else {
                        dataRangeInfo.textContent = '无数据';
                    }

                    const periodCount = selectedPeriod === 'all' ? analysisData.length : parseInt(selectedPeriod);
                    EventDelegate.performFrequencyAnalysis(analysisData, periodCount);

                    MessageSystem.showMessage(`已完成${analysisData.length}期数据的频率分析`, 'success');
                });
            }

            static handleTrendAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const trendPeriodSelect = document.getElementById('trendPeriodSelect');
                    const selectedPeriod = trendPeriodSelect.value;

                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    let analysisData = [];
                    if (selectedPeriod === 'all') {
                        analysisData = [...draws];
                    } else {
                        const periodCount = parseInt(selectedPeriod);
                        analysisData = draws.slice(-periodCount);
                    }

                    const trendDataRangeInfo = document.getElementById('trendDataRangeInfo');
                    if (analysisData.length > 0) {
                        const startPeriod = analysisData[0].period;
                        const endPeriod = analysisData[analysisData.length - 1].period;
                        trendDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                    } else {
                        trendDataRangeInfo.textContent = '无数据';
                    }

                    EventDelegate.performTrendAnalysis(analysisData);

                    MessageSystem.showMessage(`已完成${analysisData.length}期数据的趋势分析`, 'success');
                });
            }

            static performTrendAnalysis(draws) {
                // 更新和值趋势图
                EventDelegate.updateSumTrendChart(draws);

                // 更新跨度趋势图
                EventDelegate.updateSpanTrendChart(draws);

                // 更新奇偶比趋势图
                EventDelegate.updateOddEvenTrendChart(draws);

                // 更新同尾号热力图
                EventDelegate.updateSameTailHeatmap(draws);

                // 更新科学规律分析
                EventDelegate.updateTrendPatternAnalysis(draws);

                // 更新预测推荐
                EventDelegate.updateTrendPrediction(draws);
            }

            static updateOddEvenTrendChart(draws) {
                const chartDom = document.getElementById('oddEvenTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const displayPeriods = draws.length;
                const displayDraws = draws;

                const periods = displayDraws.map(d => d.period).reverse();
                const oddEvenRatios = displayDraws.map(d => {
                    const oddCount = d.redBalls.filter(ball => parseInt(ball) % 2 === 1).length;
                    const evenCount = d.redBalls.length - oddCount;
                    return { odd: oddCount, even: evenCount };
                }).reverse();

                const oddCounts = oddEvenRatios.map(r => r.odd);
                const evenCounts = oddEvenRatios.map(r => r.even);

                const option = {
                    title: {
                        text: `奇偶比趋势分析 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(item => {
                                result += item.marker + item.seriesName + ': ' + item.value + '<br/>';
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['奇数个数', '偶数个数'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '个数'
                    },
                    series: [
                        {
                            name: '奇数个数',
                            type: 'bar',
                            data: oddCounts,
                            itemStyle: {
                                color: '#FF6B6B'
                            }
                        },
                        {
                            name: '偶数个数',
                            type: 'bar',
                            data: evenCounts,
                            itemStyle: {
                                color: '#4ECDC4'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const period = params.name;
                        const draw = draws.find(d => d.period === period);

                        const oddCount = draw.redBalls.filter(ball => parseInt(ball) % 2 === 1).length;
                        const evenCount = draw.redBalls.length - oddCount;

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">期号 ${period} 奇偶比详情</h3>
                                <p><strong>奇数个数：</strong>${oddCount}</p>
                                <p><strong>偶数个数：</strong>${evenCount}</p>
                                <p><strong>红球号码：</strong>${draw.redBalls.join(', ')}</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('奇偶比详情', detailHtml);
                    }
                });
            }

            static updateSameTailHeatmap(draws) {
                const chartDom = document.getElementById('sameTailHeatmap');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const displayPeriods = draws.length > 100 ? 100 : draws.length;
                const displayDraws = draws.slice(-displayPeriods);

                const periods = displayDraws.map(d => d.period).reverse();
                const tailData = [];

                for (let i = 0; i <= 9; i++) {
                    const tailRow = [];
                    for (let j = 0; j < displayPeriods; j++) {
                        const draw = displayDraws[j];
                        const hasTail = draw.redBalls.some(ball => parseInt(ball) % 10 === i);
                        tailRow.push(hasTail ? 1 : 0);
                    }
                    tailData.push(tailRow);
                }

                const option = {
                    title: {
                        text: `同尾号热力图 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        position: 'top',
                        formatter: function(params) {
                            const tail = params.value[0];
                            const periodIndex = params.value[1];
                            const period = periods[periodIndex];
                            const draw = displayDraws[periodIndex];
                            const hasTail = draw.redBalls.some(ball => parseInt(ball) % 10 === tail);
                            return `尾号：${tail}<br/>期号：${period}<br/>出现：${hasTail ? '是' : '否'}`;
                        }
                    },
                    grid: {
                        height: '70%',
                        top: '10%'
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
                        splitArea: {
                            show: true
                        }
                    },
                    visualMap: {
                        min: 0,
                        max: 1,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '0%',
                        inRange: {
                            color: ['#f5f5f5', '#FF6B6B']
                        }
                    },
                    series: [
                        {
                            name: '同尾号',
                            type: 'heatmap',
                            data: [],
                            label: {
                                show: false
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                const seriesData = [];
                for (let i = 0; i <= 9; i++) {
                    for (let j = 0; j < displayPeriods; j++) {
                        seriesData.push([i, j, tailData[i][j]]);
                    }
                }
                option.series[0].data = seriesData;

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const tail = params.value[0];
                        const periodIndex = params.value[1];
                        const period = periods[periodIndex];
                        const draw = displayDraws[periodIndex];
                        const tailNumbers = draw.redBalls.filter(ball => parseInt(ball) % 10 === tail);

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">期号 ${period} 尾号 ${tail} 详情</h3>
                                <p><strong>尾号：</strong>${tail}</p>
                                <p><strong>出现号码：</strong>${tailNumbers.length > 0 ? tailNumbers.join(', ') : '无'}</p>
                                <p><strong>红球号码：</strong>${draw.redBalls.join(', ')}</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('同尾号详情', detailHtml);
                    }
                });
            }

            static updateTrendPatternAnalysis(draws) {
                const trendPatternInsights = document.getElementById('trendPatternInsights');
                if (!trendPatternInsights) return;

                const displayDraws = draws.slice(-30);

                // 计算和值趋势
                const sums = displayDraws.map(d => d.redBalls.reduce((acc, ball) => acc + parseInt(ball), 0));
                const avgSum = sums.reduce((acc, sum) => acc + sum, 0) / sums.length;
                const recentSum = sums[sums.length - 1];
                const sumTrend = recentSum > avgSum ? '偏高' : (recentSum < avgSum ? '偏低' : '正常');

                // 计算跨度趋势
                const spans = displayDraws.map(d => {
                    const sortedBalls = d.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    return sortedBalls[sortedBalls.length - 1] - sortedBalls[0];
                });
                const avgSpan = spans.reduce((acc, span) => acc + span, 0) / spans.length;
                const recentSpan = spans[spans.length - 1];
                const spanTrend = recentSpan > avgSpan ? '偏大' : (recentSpan < avgSpan ? '偏小' : '正常');

                // 计算奇偶比趋势
                const oddEvenRatios = displayDraws.map(d => {
                    const oddCount = d.redBalls.filter(ball => parseInt(ball) % 2 === 1).length;
                    return oddCount;
                });
                const avgOdd = oddEvenRatios.reduce((acc, odd) => acc + odd, 0) / oddEvenRatios.length;
                const recentOdd = oddEvenRatios[oddEvenRatios.length - 1];
                const oddTrend = recentOdd > avgOdd ? '偏多' : (recentOdd < avgOdd ? '偏少' : '正常');

                // 计算同尾号趋势
                const tailCounts = {};
                for (let i = 0; i <= 9; i++) {
                    tailCounts[i] = displayDraws.filter(d => d.redBalls.some(ball => parseInt(ball) % 10 === i)).length;
                }
                const hotTails = Object.entries(tailCounts)
                    .filter(([tail, count]) => count >= displayDraws.length * 0.3)
                    .map(([tail, count]) => tail)
                    .join(', ');

                const insightsHtml = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div style="padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px; border-left: 4px solid #FF6B6B;">
                            <h4 style="margin: 0 0 10px 0; color: #FF6B6B;">和值趋势</h4>
                            <p style="margin: 5px 0; font-size: 14px;">平均和值：<strong>${avgSum.toFixed(1)}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">最新和值：<strong>${recentSum}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">趋势判断：<strong>${sumTrend}</strong></p>
                        </div>
                        <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 4px solid #4ECDC4;">
                            <h4 style="margin: 0 0 10px 0; color: #4ECDC4;">跨度趋势</h4>
                            <p style="margin: 5px 0; font-size: 14px;">平均跨度：<strong>${avgSpan.toFixed(1)}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">最新跨度：<strong>${recentSpan}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">趋势判断：<strong>${spanTrend}</strong></p>
                        </div>
                        <div style="padding: 15px; background: rgba(149, 225, 211, 0.1); border-radius: 8px; border-left: 4px solid #95E1D3;">
                            <h4 style="margin: 0 0 10px 0; color: #95E1D3;">奇偶比趋势</h4>
                            <p style="margin: 5px 0; font-size: 14px;">平均奇数：<strong>${avgOdd.toFixed(1)}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">最新奇数：<strong>${recentOdd}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">趋势判断：<strong>${oddTrend}</strong></p>
                        </div>
                        <div style="padding: 15px; background: rgba(255, 160, 122, 0.1); border-radius: 8px; border-left: 4px solid #FFA07A;">
                            <h4 style="margin: 0 0 10px 0; color: #FFA07A;">同尾号趋势</h4>
                            <p style="margin: 5px 0; font-size: 14px;">高频尾号：<strong>${hotTails || '无'}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">出现频率：<strong>${(Object.values(tailCounts).reduce((a, b) => a + b, 0) / (displayDraws.length * 6) * 100).toFixed(1)}%</strong></p>
                        </div>
                    </div>
                `;

                trendPatternInsights.innerHTML = insightsHtml;
            }

            static updateTrendPrediction(draws) {
                const trendPredictionContent = document.getElementById('trendPredictionContent');
                if (!trendPredictionContent) return;

                const displayDraws = draws.slice(-30);

                // 计算和值预测
                const sums = displayDraws.map(d => d.redBalls.reduce((acc, ball) => acc + parseInt(ball), 0));
                const avgSum = sums.reduce((acc, sum) => acc + sum, 0) / sums.length;
                const predictedSumRange = `${Math.floor(avgSum - 10)} - ${Math.ceil(avgSum + 10)}`;

                // 计算跨度预测
                const spans = displayDraws.map(d => {
                    const sortedBalls = d.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    return sortedBalls[sortedBalls.length - 1] - sortedBalls[0];
                });
                const avgSpan = spans.reduce((acc, span) => acc + span, 0) / spans.length;
                const predictedSpanRange = `${Math.floor(avgSpan - 3)} - ${Math.ceil(avgSpan + 3)}`;

                // 计算奇偶比预测
                const oddEvenRatios = displayDraws.map(d => {
                    const oddCount = d.redBalls.filter(ball => parseInt(ball) % 2 === 1).length;
                    return oddCount;
                });
                const avgOdd = oddEvenRatios.reduce((acc, odd) => acc + odd, 0) / oddEvenRatios.length;
                const predictedOddRange = `${Math.floor(avgOdd - 1)} - ${Math.ceil(avgOdd + 1)}`;

                // 计算同尾号预测
                const tailCounts = {};
                for (let i = 0; i <= 9; i++) {
                    tailCounts[i] = displayDraws.filter(d => d.redBalls.some(ball => parseInt(ball) % 10 === i)).length;
                }
                const predictedTails = Object.entries(tailCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([tail, count]) => tail)
                    .join(', ');

                const predictionHtml = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div style="padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px; border-left: 4px solid #FF6B6B;">
                            <h4 style="margin: 0 0 10px 0; color: #FF6B6B;">和值预测</h4>
                            <p style="margin: 5px 0; font-size: 14px;">预测范围：<strong>${predictedSumRange}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">建议选择：<strong>和值在${predictedSumRange}范围内的组合</strong></p>
                        </div>
                        <div style="padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 4px solid #4ECDC4;">
                            <h4 style="margin: 0 0 10px 0; color: #4ECDC4;">跨度预测</h4>
                            <p style="margin: 5px 0; font-size: 14px;">预测范围：<strong>${predictedSpanRange}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">建议选择：<strong>跨度在${predictedSpanRange}范围内的组合</strong></p>
                        </div>
                        <div style="padding: 15px; background: rgba(149, 225, 211, 0.1); border-radius: 8px; border-left: 4px solid #95E1D3;">
                            <h4 style="margin: 0 0 10px 0; color: #95E1D3;">奇偶比预测</h4>
                            <p style="margin: 5px 0; font-size: 14px;">预测范围：<strong>${predictedOddRange}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">建议选择：<strong>奇数个数在${predictedOddRange}范围内的组合</strong></p>
                        </div>
                        <div style="padding: 15px; background: rgba(255, 160, 122, 0.1); border-radius: 8px; border-left: 4px solid #FFA07A;">
                            <h4 style="margin: 0 0 10px 0; color: #FFA07A;">同尾号预测</h4>
                            <p style="margin: 5px 0; font-size: 14px;">预测尾号：<strong>${predictedTails}</strong></p>
                            <p style="margin: 5px 0; font-size: 14px;">建议选择：<strong>包含尾号${predictedTails}的号码</strong></p>
                        </div>
                    </div>
                `;

                trendPredictionContent.innerHTML = predictionHtml;
            }

            static handlePrediction() {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    MessageSystem.showMessage('没有可预测的数据，请先导入数据', 'error');
                    return;
                }

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];
                const blueBallCount = rules.blueBallRange[1];

                const periodCount = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : draws.length;

                // 初始化红球频率统计
                const redBallFrequency = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    redBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0,
                        maxOmission: 0,
                        omissionHistory: [],
                        hotColdState: 'normal',
                        hotColdScore: 0,
                        hotColdIntensity: 0,
                        hotColdTrend: 'stable',
                        hotColdPersistence: 0,
                        hotColdPredictability: 0,
                        hotColdReasonableness: 'normal',
                        hotColdRecommendation: '正常',
                        hotColdConfidence: 0
                    };
                }

                // 初始化蓝球频率统计
                const blueBallFrequency = {};
                for (let i = 1; i <= blueBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    blueBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0,
                        maxOmission: 0,
                        omissionHistory: [],
                        hotColdState: 'normal',
                        hotColdScore: 0,
                        hotColdIntensity: 0,
                        hotColdTrend: 'stable',
                        hotColdPersistence: 0,
                        hotColdPredictability: 0,
                        hotColdReasonableness: 'normal',
                        hotColdRecommendation: '正常',
                        hotColdConfidence: 0
                    };
                }

                // 从最新期开始分析（倒序）
                const reversedDraws = [...draws].reverse();

                reversedDraws.forEach((draw, index) => {
                    draw.redBalls.forEach(ball => {
                        if (redBallFrequency[ball]) {
                            redBallFrequency[ball].count++;
                        }
                    });

                    if (draw.blueBalls && draw.blueBalls.length > 0) {
                        draw.blueBalls.forEach(blueBall => {
                            const blueBallNum = blueBall.toString().padStart(2, '0');
                            if (blueBallFrequency[blueBallNum]) {
                                blueBallFrequency[blueBallNum].count++;
                            }
                        });
                    }
                });

                const analysisDraws = reversedDraws.slice(0, periodCount);

                // 计算红球遗漏值 - 严格按照从最新期开始向前遍历，在指定期数范围内计算
                for (let num in redBallFrequency) {
                    let omissionCount = 0;
                    let maxOmission = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < analysisDraws.length; i++) {
                        const draw = analysisDraws[i];
                        if (draw.redBalls.includes(num)) {
                            if (omissionCount > maxOmission) {
                                maxOmission = omissionCount;
                            }
                            redBallFrequency[num].omissionHistory.push(omissionCount);
                            omissionCount = 0;
                            found = true;

                            // 记录首次出现的位置
                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        redBallFrequency[num].currentOmission = periodCount;
                    } else {
                        redBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                    redBallFrequency[num].maxOmission = maxOmission;
                }

                // 计算蓝球遗漏值 - 严格按照从最新期开始向前遍历，在指定期数范围内计算
                for (let num in blueBallFrequency) {
                    let omissionCount = 0;
                    let maxOmission = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < analysisDraws.length; i++) {
                        const draw = analysisDraws[i];
                        let isMatched = false;
                        if (draw.blueBalls && draw.blueBalls.length > 0) {
                            draw.blueBalls.forEach(blueBall => {
                                const blueBallNum = blueBall.toString().padStart(2, '0');
                                if (blueBallNum === num) {
                                    isMatched = true;
                                }
                            });
                        }

                        if (isMatched) {
                            if (omissionCount > maxOmission) {
                                maxOmission = omissionCount;
                            }
                            blueBallFrequency[num].omissionHistory.push(omissionCount);
                            omissionCount = 0;
                            found = true;

                            // 记录首次出现的位置
                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        blueBallFrequency[num].currentOmission = periodCount;
                    } else {
                        blueBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                    blueBallFrequency[num].maxOmission = maxOmission;
                }

                MessageSystem.showMessage('预测分析完成', 'success');
            }

            static performFrequencyAnalysis(draws, periodCount) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];
                const blueBallCount = rules.blueBallRange[1];

                // 初始化红球频率统计
                const redBallFrequency = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    redBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0,
                        maxOmission: 0,
                        avgOmission: 0,
                        omissionHistory: []
                    };
                }

                // 初始化蓝球频率统计
                const blueBallFrequency = {};
                for (let i = 1; i <= blueBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    blueBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0,
                        maxOmission: 0,
                        avgOmission: 0,
                        omissionHistory: []
                    };
                }

                // 从最新期开始分析（倒序）
                const reversedDraws = [...draws].reverse();

                // 只分析指定期数范围内的数据
                const analysisDraws = reversedDraws.slice(0, periodCount);

                analysisDraws.forEach((draw, index) => {
                    // 统计红球
                    draw.redBalls.forEach(ball => {
                        if (redBallFrequency[ball]) {
                            redBallFrequency[ball].count++;
                        }
                    });

                    // 统计蓝球
                    if (draw.blueBalls && draw.blueBalls.length > 0) {
                        draw.blueBalls.forEach(blueBall => {
                            const blueBallNum = blueBall.toString().padStart(2, '0');
                            if (blueBallFrequency[blueBallNum]) {
                                blueBallFrequency[blueBallNum].count++;
                            }
                        });
                    }
                });

                // 计算遗漏值 - 严格按照从最新期开始向前遍历，在指定期数范围内计算
                for (let num in redBallFrequency) {
                    let omissionCount = 0;
                    let maxOmission = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    // 只遍历指定期数范围内的数据
                    for (let i = 0; i < analysisDraws.length; i++) {
                        const draw = analysisDraws[i];
                        if (draw.redBalls.includes(num)) {
                            // 号码出现
                            if (omissionCount > maxOmission) {
                                maxOmission = omissionCount;
                            }
                            redBallFrequency[num].omissionHistory.push(omissionCount);
                            omissionCount = 0;
                            found = true;

                            // 记录首次出现的位置
                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    // 如果在指定期数范围内没有出现，则当前遗漏为 periodCount
                    // 如果在第 M 期出现（从最新期算起的第 M 期），则当前遗漏为 M
                    if (!found) {
                        redBallFrequency[num].currentOmission = periodCount;
                    } else {
                        redBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                    redBallFrequency[num].maxOmission = maxOmission;
                    
                    // 计算平均遗漏
                    if (redBallFrequency[num].count > 0) {
                        redBallFrequency[num].avgOmission = periodCount / redBallFrequency[num].count;
                    }
                }

                for (let num in blueBallFrequency) {
                    let omissionCount = 0;
                    let maxOmission = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    // 只遍历指定期数范围内的数据
                    for (let i = 0; i < analysisDraws.length; i++) {
                        const draw = analysisDraws[i];
                        let isMatched = false;
                        if (draw.blueBalls && draw.blueBalls.length > 0) {
                            draw.blueBalls.forEach(blueBall => {
                                const blueBallNum = blueBall.toString().padStart(2, '0');
                                if (blueBallNum === num) {
                                    isMatched = true;
                                }
                            });
                        }

                        if (isMatched) {
                            // 号码出现
                            if (omissionCount > maxOmission) {
                                maxOmission = omissionCount;
                            }
                            blueBallFrequency[num].omissionHistory.push(omissionCount);
                            omissionCount = 0;
                            found = true;

                            // 记录首次出现的位置
                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    // 如果在指定期数范围内没有出现，则当前遗漏为 periodCount
                    // 如果在第 M 期出现（从最新期算起的第 M 期），则当前遗漏为 M
                    if (!found) {
                        blueBallFrequency[num].currentOmission = periodCount;
                    } else {
                        blueBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                    blueBallFrequency[num].maxOmission = maxOmission;
                    
                    // 计算平均遗漏
                    if (blueBallFrequency[num].count > 0) {
                        blueBallFrequency[num].avgOmission = periodCount / blueBallFrequency[num].count;
                    }
                }

                // 计算冷热分析数据
                const avgRedCount = periodCount * 6 / redBallCount;
                const avgBlueCount = periodCount / blueBallCount;

                for (let num in redBallFrequency) {
                    const data = redBallFrequency[num];
                    const count = data.count;

                    // 计算冷热评分
                    const deviation = (count - avgRedCount) / avgRedCount * 100;
                    data.hotColdScore = Math.max(0, Math.min(100, 50 + deviation));

                    // 计算冷热强度
                    data.hotColdIntensity = Math.abs(deviation);

                    // 计算冷热趋势
                    if (data.omissionHistory.length > 0) {
                        const recentOmissions = data.omissionHistory.slice(-5);
                        const avgRecentOmission = recentOmissions.reduce((a, b) => a + b, 0) / recentOmissions.length;
                        const avgOmission = periodCount / (count || 1);
                        if (avgRecentOmission < avgOmission * 0.8) {
                            data.hotColdTrend = '升温';
                        } else if (avgRecentOmission > avgOmission * 1.2) {
                            data.hotColdTrend = '降温';
                        } else {
                            data.hotColdTrend = '稳定';
                        }
                    }

                    // 计算冷热持续性
                    if (data.omissionHistory.length > 1) {
                        const consistentCount = data.omissionHistory.filter(o => o < avgRedCount * 0.5 || o > avgRedCount * 1.5).length;
                        data.hotColdPersistence = (consistentCount / data.omissionHistory.length) * 100;
                    }

                    // 计算冷热可预测性
                    const variance = data.omissionHistory.reduce((sum, o) => sum + Math.pow(o - (periodCount / (count || 1)), 2), 0) / data.omissionHistory.length;
                    data.hotColdPredictability = Math.max(0, Math.min(100, 100 - variance * 10));

                    // 确定冷热状态
                    if (data.hotColdScore >= 70) {
                        data.hotColdState = '超热';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '重点关注';
                    } else if (data.hotColdScore >= 60) {
                        data.hotColdState = '热';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '适当关注';
                    } else if (data.hotColdScore <= 30) {
                        data.hotColdState = '超冷';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '重点关注';
                    } else if (data.hotColdScore <= 40) {
                        data.hotColdState = '冷';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '适当关注';
                    } else {
                        data.hotColdState = '温';
                        data.hotColdReasonableness = '正常';
                        data.hotColdRecommendation = '正常';
                    }

                    // 计算置信度
                    data.hotColdConfidence = Math.min(100, data.hotColdPersistence * 0.5 + data.hotColdPredictability * 0.5);
                }

                for (let num in blueBallFrequency) {
                    const data = blueBallFrequency[num];
                    const count = data.count;

                    // 计算冷热评分
                    const deviation = (count - avgBlueCount) / avgBlueCount * 100;
                    data.hotColdScore = Math.max(0, Math.min(100, 50 + deviation));

                    // 计算冷热强度
                    data.hotColdIntensity = Math.abs(deviation);

                    // 计算冷热趋势
                    if (data.omissionHistory.length > 0) {
                        const recentOmissions = data.omissionHistory.slice(-5);
                        const avgRecentOmission = recentOmissions.reduce((a, b) => a + b, 0) / recentOmissions.length;
                        const avgOmission = periodCount / (count || 1);
                        if (avgRecentOmission < avgOmission * 0.8) {
                            data.hotColdTrend = '升温';
                        } else if (avgRecentOmission > avgOmission * 1.2) {
                            data.hotColdTrend = '降温';
                        } else {
                            data.hotColdTrend = '稳定';
                        }
                    }

                    // 计算冷热持续性
                    if (data.omissionHistory.length > 1) {
                        const consistentCount = data.omissionHistory.filter(o => o < avgBlueCount * 0.5 || o > avgBlueCount * 1.5).length;
                        data.hotColdPersistence = (consistentCount / data.omissionHistory.length) * 100;
                    }

                    // 计算冷热可预测性
                    const variance = data.omissionHistory.reduce((sum, o) => sum + Math.pow(o - (periodCount / (count || 1)), 2), 0) / data.omissionHistory.length;
                    data.hotColdPredictability = Math.max(0, Math.min(100, 100 - variance * 10));

                    // 确定冷热状态
                    if (data.hotColdScore >= 70) {
                        data.hotColdState = '超热';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '重点关注';
                    } else if (data.hotColdScore >= 60) {
                        data.hotColdState = '热';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '适当关注';
                    } else if (data.hotColdScore <= 30) {
                        data.hotColdState = '超冷';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '重点关注';
                    } else if (data.hotColdScore <= 40) {
                        data.hotColdState = '冷';
                        data.hotColdReasonableness = '合理';
                        data.hotColdRecommendation = '适当关注';
                    } else {
                        data.hotColdState = '温';
                        data.hotColdReasonableness = '正常';
                        data.hotColdRecommendation = '正常';
                    }

                    // 计算置信度
                    data.hotColdConfidence = Math.min(100, data.hotColdPersistence * 0.5 + data.hotColdPredictability * 0.5);
                }

                // 更新分析摘要
                this.updateAnalysisSummary(analysisDraws, redBallFrequency, blueBallFrequency);

                globalRedBallFrequency = redBallFrequency;
                globalBlueBallFrequency = blueBallFrequency;
                currentFrequencyPeriod = periodCount;
                currentFrequencyDraws = draws;

                // 更新频率图表（支持标签页切换和排序）
                this.updateFrequencyChart(redBallFrequency, blueBallFrequency, 'number', 'asc');

                // 更新频率趋势图表
                this.updateFrequencyTrendChart(analysisDraws, redBallFrequency, blueBallFrequency);

                // 更新详细数据表格
                this.updateFrequencyTable(redBallFrequency, blueBallFrequency);
            }

            static updateAnalysisSummary(draws, redBallFrequency, blueBallFrequency) {
                // 更新分析期数
                document.getElementById('totalPeriods').textContent = draws.length;

                // 计算红球热号（出现次数最多的前5个）
                const sortedRedBalls = Object.entries(redBallFrequency)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 5)
                    .map(item => item[0]);
                document.getElementById('hotRedBalls').textContent = sortedRedBalls.join(', ');

                // 计算蓝球热号（出现次数最多的前3个）
                const sortedBlueBalls = Object.entries(blueBallFrequency)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 3)
                    .map(item => item[0]);
                document.getElementById('hotBlueBalls').textContent = sortedBlueBalls.join(', ');

                // 计算红球冷号（出现次数最少且遗漏值大的前5个）
                const sortedColdRedBalls = Object.entries(redBallFrequency)
                    .sort((a, b) => {
                        if (a[1].count !== b[1].count) {
                            return a[1].count - b[1].count;
                        }
                        return b[1].currentOmission - a[1].currentOmission;
                    })
                    .slice(0, 5)
                    .map(item => item[0]);
                document.getElementById('coldRedBalls').textContent = sortedColdRedBalls.join(', ');

                // 计算蓝球冷号（出现次数最少且遗漏值大的前3个）
                const sortedColdBlueBalls = Object.entries(blueBallFrequency)
                    .sort((a, b) => {
                        if (a[1].count !== b[1].count) {
                            return a[1].count - b[1].count;
                        }
                        return b[1].currentOmission - a[1].currentOmission;
                    })
                    .slice(0, 3)
                    .map(item => item[0]);
                document.getElementById('coldBlueBalls').textContent = sortedColdBlueBalls.join(', ');
            }

            static updateFrequencyChart(redBallFrequency, blueBallFrequency, sortOption = 'number', sortOrder = 'asc') {
                const chartDom = document.getElementById('frequencyChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const activeTab = document.querySelector('.frequency-tab.active')?.dataset.type || 'red';
                const frequencyData = activeTab === 'red' ? redBallFrequency : blueBallFrequency;
                const ballColor = activeTab === 'red' ? '#E63946' : '#457B9D';
                const ballName = activeTab === 'red' ? '红球' : '蓝球';

                let ballNumbers = Object.keys(frequencyData);

                switch(sortOption) {
                    case 'number':
                        ballNumbers.sort((a, b) => parseInt(a) - parseInt(b));
                        break;
                    case 'count':
                        if (sortOrder === 'asc') {
                            ballNumbers.sort((a, b) => frequencyData[a].count - frequencyData[b].count);
                        } else {
                            ballNumbers.sort((a, b) => frequencyData[b].count - frequencyData[a].count);
                        }
                        break;
                    case 'frequency':
                        const totalDraws = Object.values(frequencyData).reduce((sum, item) => sum + item.count, 0);
                        if (sortOrder === 'asc') {
                            ballNumbers.sort((a, b) => (frequencyData[a].count / totalDraws) - (frequencyData[b].count / totalDraws));
                        } else {
                            ballNumbers.sort((a, b) => (frequencyData[b].count / totalDraws) - (frequencyData[a].count / totalDraws));
                        }
                        break;
                    case 'currentOmission':
                        if (sortOrder === 'asc') {
                            ballNumbers.sort((a, b) => frequencyData[a].currentOmission - frequencyData[b].currentOmission);
                        } else {
                            ballNumbers.sort((a, b) => frequencyData[b].currentOmission - frequencyData[a].currentOmission);
                        }
                        break;
                    case 'avgOmission':
                        if (sortOrder === 'asc') {
                            ballNumbers.sort((a, b) => (frequencyData[a].avgOmission || 0) - (frequencyData[b].avgOmission || 0));
                        } else {
                            ballNumbers.sort((a, b) => (frequencyData[b].avgOmission || 0) - (frequencyData[a].avgOmission || 0));
                        }
                        break;
                    case 'maxOmission':
                        if (sortOrder === 'asc') {
                            ballNumbers.sort((a, b) => frequencyData[a].maxOmission - frequencyData[b].maxOmission);
                        } else {
                            ballNumbers.sort((a, b) => frequencyData[b].maxOmission - frequencyData[a].maxOmission);
                        }
                        break;
                }

                const frequencies = ballNumbers.map(num => frequencyData[num].count);
                const omissions = ballNumbers.map(num => frequencyData[num].currentOmission);

                const option = {
                    title: {
                        text: `${ballName}频率分析`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const num = param.name;
                            const data = frequencyData[num];
                            if (!data) return '';
                            const state = data.hotColdState || '温';
                            const stateColor = state === '超热' || state === '热' ? '#E63946' : state === '超冷' || state === '冷' ? '#457B9D' : '#F4A261';
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${num}</div>
                                    <div style="margin-bottom: 3px;">冷热状态：<span style="color: ${stateColor}; font-weight: bold;">${state}</span></div>
                                    <div style="margin-bottom: 3px;">出现次数：<span style="color: #E63946;">${data.count}次</span></div>
                                    <div style="margin-bottom: 3px;">当前遗漏：<span style="color: #E67E22;">${data.currentOmission}期</span></div>
                                    <div style="margin-bottom: 3px;">平均遗漏：<span style="color: #D35400;">${data.avgOmission ? data.avgOmission.toFixed(1) : '0'}期</span></div>
                                    <div style="margin-bottom: 3px;">最大遗漏：<span style="color: #16A085;">${data.maxOmission}期</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['出现次数', '当前遗漏'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ballNumbers,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '出现次数',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '遗漏值',
                            position: 'right'
                        }
                    ],
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: frequencies,
                            itemStyle: {
                                color: ballColor
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}',
                                color: ballColor,
                                fontWeight: 'bold'
                            }
                        },
                        {
                            name: '当前遗漏',
                            type: 'line',
                            yAxisIndex: 1,
                            data: omissions,
                            itemStyle: {
                                color: '#2A9D8F'
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}',
                                color: '#2A9D8F',
                                fontWeight: 'bold'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
                frequencyChart = chart;
            }

            static updateFrequencyTrendChart(draws, redBallFrequency, blueBallFrequency) {
                const chartDom = document.getElementById('frequencyTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const displayPeriods = draws.length;
                const displayDraws = draws;

                // 计算每期的红球平均值和蓝球值
                const periods = displayDraws.map(d => d.period).reverse();
                const redBallAvg = displayDraws.map(d => {
                    const sum = d.redBalls.reduce((acc, ball) => acc + parseInt(ball), 0);
                    return (sum / d.redBalls.length).toFixed(2);
                }).reverse();
                const blueBallValues = displayDraws.map(d => {
                    if (d.blueBalls && d.blueBalls.length > 0) {
                        return parseInt(d.blueBalls[0]);
                    }
                    return 0;
                }).reverse();

                const option = {
                    title: {
                        text: `频率趋势分析 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(item => {
                                result += item.marker + item.seriesName + ': ' + item.value + '<br/>';
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['红球平均值', '蓝球值'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '红球平均值',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '蓝球值',
                            position: 'right'
                        }
                    ],
                    series: [
                        {
                            name: '红球平均值',
                            type: 'line',
                            data: redBallAvg,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '蓝球值',
                            type: 'line',
                            yAxisIndex: 1,
                            data: blueBallValues,
                            smooth: true,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const number = params.value[0];
                        const type = params.value[1];
                        const frequency = params.value[2];
                        const omission = bigSmallData.numberOmission[number.toString().padStart(2, '0')];

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">号码 ${number.toString().padStart(2, '0')} 详细信息</h3>
                                <p><strong>类型：</strong>${type}</p>
                                <p><strong>出现次数：</strong>${frequency}</p>
                                <p><strong>当前遗漏：</strong>${omission}期</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('号码详情', detailHtml);
                    }
                });
            }

            static updateSumTrendChart(draws) {
                const chartDom = document.getElementById('sumTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const displayPeriods = draws.length;
                const displayDraws = draws;

                const periods = displayDraws.map(d => d.period);
                const sums = displayDraws.map(d => 
                    d.redBalls.reduce((acc, ball) => acc + parseInt(ball), 0)
                );

                const avgSum = sums.reduce((acc, sum) => acc + sum, 0) / sums.length;
                const avgLine = Array(sums.length).fill(avgSum);

                const option = {
                    title: {
                        text: `和值趋势分析 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(item => {
                                result += item.marker + item.seriesName + ': ' + item.value.toFixed(1) + '<br/>';
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['和值', '平均值'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '和值'
                    },
                    series: [
                        {
                            name: '和值',
                            type: 'line',
                            data: sums,
                            smooth: true,
                            itemStyle: {
                                color: '#FF6B6B'
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(255, 107, 107, 0.3)' },
                                        { offset: 1, color: 'rgba(255, 107, 107, 0.05)' }
                                    ]
                                }
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#FF6B6B',
                                    type: 'dashed'
                                }
                            }
                        },
                        {
                            name: '平均值',
                            type: 'line',
                            data: avgLine,
                            itemStyle: {
                                color: '#FF6B6B'
                            },
                            lineStyle: {
                                type: 'dashed'
                            },
                            symbol: 'none'
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series' && params.seriesName === '和值') {
                        const period = params.name;
                        const sum = params.value;
                        const draw = draws.find(d => d.period === period);

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">期号 ${period} 和值详情</h3>
                                <p><strong>和值：</strong>${sum}</p>
                                <p><strong>红球号码：</strong>${draw.redBalls.join(', ')}</p>
                                <p><strong>平均值：</strong>${avgSum.toFixed(1)}</p>
                                <p><strong>偏离度：</strong>${((sum - avgSum) / avgSum * 100).toFixed(1)}%</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('和值详情', detailHtml);
                    }
                });
            }

            static updateSpanTrendChart(draws) {
                const chartDom = document.getElementById('spanTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const displayPeriods = draws.length;
                const displayDraws = draws;

                const periods = displayDraws.map(d => d.period);
                const spans = displayDraws.map(d => {
                    const sortedBalls = d.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    return sortedBalls[sortedBalls.length - 1] - sortedBalls[0];
                });

                const avgSpan = spans.reduce((acc, span) => acc + span, 0) / spans.length;
                const avgLine = Array(spans.length).fill(avgSpan);

                const option = {
                    title: {
                        text: `跨度趋势分析 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(item => {
                                result += item.marker + item.seriesName + ': ' + item.value.toFixed(1) + '<br/>';
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['跨度', '平均值'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '跨度'
                    },
                    series: [
                        {
                            name: '跨度',
                            type: 'bar',
                            data: spans,
                            itemStyle: {
                                color: function(params) {
                                    const span = params.value;
                                    if (span > avgSpan * 1.2) return '#FF6B6B';
                                    if (span < avgSpan * 0.8) return '#4ECDC4';
                                    return '#95E1D3';
                                }
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#4ECDC4',
                                    type: 'dashed'
                                }
                            }
                        },
                        {
                            name: '平均值',
                            type: 'line',
                            data: avgLine,
                            itemStyle: {
                                color: '#4ECDC4'
                            },
                            lineStyle: {
                                type: 'dashed'
                            },
                            symbol: 'none'
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series' && params.seriesName === '跨度') {
                        const period = params.name;
                        const span = params.value;
                        const draw = draws.find(d => d.period === period);

                        const sortedBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">期号 ${period} 跨度详情</h3>
                                <p><strong>跨度：</strong>${span}</p>
                                <p><strong>最小号码：</strong>${sortedBalls[0]}</p>
                                <p><strong>最大号码：</strong>${sortedBalls[sortedBalls.length - 1]}</p>
                                <p><strong>红球号码：</strong>${draw.redBalls.join(', ')}</p>
                                <p><strong>平均值：</strong>${avgSpan.toFixed(1)}</p>
                                <p><strong>偏离度：</strong>${((span - avgSpan) / avgSpan * 100).toFixed(1)}%</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('跨度详情', detailHtml);
                    }
                });
            }

            static updateOddEvenTrendChart(draws) {
                const chartDom = document.getElementById('oddEvenTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const displayPeriods = draws.length;
                const displayDraws = draws;

                const periods = displayDraws.map(d => d.period);
                const oddCounts = displayDraws.map(d => 
                    d.redBalls.filter(ball => parseInt(ball) % 2 === 1).length
                );
                const evenCounts = displayDraws.map(d => 
                    d.redBalls.filter(ball => parseInt(ball) % 2 === 0).length
                );

                const option = {
                    title: {
                        text: `奇偶比趋势分析 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(item => {
                                result += item.marker + item.seriesName + ': ' + item.value + '个<br/>';
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['奇数', '偶数'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '个数'
                    },
                    series: [
                        {
                            name: '奇数',
                            type: 'line',
                            data: oddCounts,
                            smooth: true,
                            itemStyle: {
                                color: '#95E1D3'
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(149, 225, 211, 0.3)' },
                                        { offset: 1, color: 'rgba(149, 225, 211, 0.05)' }
                                    ]
                                }
                            }
                        },
                        {
                            name: '偶数',
                            type: 'line',
                            data: evenCounts,
                            smooth: true,
                            itemStyle: {
                                color: '#FF6B6B'
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(255, 107, 107, 0.3)' },
                                        { offset: 1, color: 'rgba(255, 107, 107, 0.05)' }
                                    ]
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const period = params.name;
                        const count = params.value;
                        const type = params.seriesName;
                        const draw = draws.find(d => d.period === period);

                        const oddBalls = draw.redBalls.filter(ball => parseInt(ball) % 2 === 1);
                        const evenBalls = draw.redBalls.filter(ball => parseInt(ball) % 2 === 0);

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">期号 ${period} 奇偶比详情</h3>
                                <p><strong>奇数：</strong>${oddBalls.length}个 (${oddBalls.join(', ')})</p>
                                <p><strong>偶数：</strong>${evenBalls.length}个 (${evenBalls.join(', ')})</p>
                                <p><strong>奇偶比：</strong>${oddBalls.length}:${evenBalls.length}</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('奇偶比详情', detailHtml);
                    }
                });
            }

            static updateSameTailHeatmap(draws) {
                const chartDom = document.getElementById('sameTailHeatmap');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const recentDraws = draws;
                const displayPeriods = recentDraws.length;
                const tailData = [];

                for (let i = 0; i <= 9; i++) {
                    for (let j = 0; j <= 9; j++) {
                        let count = 0;
                        recentDraws.forEach(draw => {
                            const tails = draw.redBalls.map(ball => parseInt(ball) % 10);
                            if (tails.includes(i) && tails.includes(j)) {
                                count++;
                            }
                        });
                        tailData.push([i, j, count]);
                    }
                }

                const option = {
                    title: {
                        text: `同尾号热力图 (分析期数：${displayPeriods})`,
                        left: 'center'
                    },
                    tooltip: {
                        position: 'top',
                        formatter: function(params) {
                            const tail1 = params.value[0];
                            const tail2 = params.value[1];
                            const count = params.value[2];
                            return `尾数 ${tail1} 和 ${tail2}<br/>同时出现次数：${count}次`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
                        name: '尾数2',
                        nameLocation: 'middle',
                        nameGap: 25
                    },
                    yAxis: {
                        type: 'category',
                        data: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
                        name: '尾数1',
                        nameLocation: 'middle',
                        nameGap: 30
                    },
                    visualMap: {
                        min: 0,
                        max: Math.max(...tailData.map(d => d[2])),
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '5%',
                        inRange: {
                            color: ['#E0F7FA', '#4ECDC4', '#FF6B6B']
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'heatmap',
                            data: tailData,
                            label: {
                                show: true
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const tail1 = params.value[0];
                        const tail2 = params.value[1];
                        const count = params.value[2];

                        const matchingDraws = recentDraws.filter(draw => {
                            const tails = draw.redBalls.map(ball => parseInt(ball) % 10);
                            return tails.includes(tail1) && tails.includes(tail2);
                        });

                        const periods = matchingDraws.map(d => d.period).join(', ');

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">尾数 ${tail1} 和 ${tail2} 详情</h3>
                                <p><strong>同时出现次数：</strong>${count}次</p>
                                <p><strong>出现期号：</strong>${periods}</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('同尾号详情', detailHtml);
                    }
                });

            }

            static generatePatternAnalysis() {
                const chartDom = document.getElementById('patternChart');
                const insightsDiv = document.getElementById('patternInsights');

                if (!chartDom || !insightsDiv) return;

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const isRed = currentOmissionTab === 'red';
                const frequencyData = isRed ? omissionAnalysisData.red : omissionAnalysisData.blue;
                const ballCount = isRed ? rules.redBallRange[1] : rules.blueBallRange[1];
                const ballName = isRed ? rules.redBallName : rules.blueBallName;
                const color = isRed ? '#E63946' : '#457B9D';

                const ballNumbers = [];
                for (let i = 1; i <= ballCount; i++) {
                    ballNumbers.push(i.toString().padStart(2, '0'));
                }

                const omissions = ballNumbers.map(num => frequencyData[num]?.currentOmission || 0);
                const avgOmissions = ballNumbers.map(num => {
                    const data = frequencyData[num];
                    if (!data || data.count === 0) return 0;
                    return (currentOmissionPeriod !== 'all' ? currentOmissionPeriod : currentDatabaseData.draws.length) / data.count;
                });

                const maxOmissions = ballNumbers.map(num => frequencyData[num]?.maxOmission || 0);

                this.addPatternChartTabs();

                switch (currentPatternChartType) {
                    case 'trend':
                        this.updatePatternTrendChart(ballNumbers, omissions, avgOmissions, maxOmissions, rules, ballName);
                        break;
                    case 'distribution':
                        this.updatePatternDistributionChart(omissions, ballNumbers, rules, ballName);
                        break;
                    case 'status':
                        this.updatePatternStatusChart(omissions, avgOmissions, ballNumbers, rules, ballName, color);
                        break;
                    case 'sequence':
                        this.updateOmissionSequenceChart(omissions, ballNumbers, rules, ballName);
                        break;
                    case 'evolution':
                        this.updateOmissionEvolutionChart(omissions, ballNumbers, rules, ballName);
                        break;
                    case 'mutation':
                        this.updateOmissionMutationChart(omissions, ballNumbers, rules, ballName);
                        break;
                    case 'diversity':
                        this.updateOmissionDiversityChart(omissions, ballNumbers, rules, ballName);
                        break;
                    case 'mapping':
                        this.updateOmissionMappingChart(omissions, ballNumbers, rules, ballName);
                        break;
                    case 'cycle':
                        this.updatePatternCycleChart(ballNumbers, omissions, avgOmissions, rules, ballName);
                        break;
                    case 'correlation':
                        this.updatePatternCorrelationChart(ballNumbers, omissions, avgOmissions, rules, ballName);
                        break;
                    case 'prediction':
                        this.updatePatternPredictionChart(ballNumbers, omissions, avgOmissions, rules, ballName);
                        break;
                }

                this.generateEnhancedPatternInsights(omissions, avgOmissions, ballNumbers, frequencyData, rules, ballName, isRed);
            }

            static addPatternChartTabs() {
            }

            static disposeAllPatternCharts() {
                const charts = [
                    patternChart,
                    patternDistributionChart,
                    patternStatusChart,
                    patternCycleChart,
                    patternCorrelationChart,
                    patternPredictionChart,
                    omissionSequenceChart,
                    omissionEvolutionChart,
                    omissionMutationChart,
                    omissionDiversityChart,
                    omissionMappingChart
                ];
                charts.forEach(chart => {
                    if (chart) {
                        chart.dispose();
                    }
                });
                patternChart = null;
                patternDistributionChart = null;
                patternStatusChart = null;
                patternCycleChart = null;
                patternCorrelationChart = null;
                patternPredictionChart = null;
                omissionSequenceChart = null;
                omissionEvolutionChart = null;
                omissionMutationChart = null;
                omissionDiversityChart = null;
                omissionMappingChart = null;
            }

            static updatePatternTrendChart(ballNumbers, omissions, avgOmissions, maxOmissions, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                patternChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏规律趋势`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        }
                    },
                    legend: {
                        data: ['当前遗漏', '平均遗漏', '最大遗漏'],
                        textStyle: {
                            color: '#333'
                        },
                        top: 45
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ballNumbers,
                        axisLabel: {
                            rotate: 45,
                            interval: 0,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '遗漏期数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '当前遗漏',
                            type: 'line',
                            data: omissions,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(230, 57, 70, 0.3)' },
                                        { offset: 1, color: 'rgba(230, 57, 70, 0.05)' }
                                    ]
                                }
                            }
                        },
                        {
                            name: '平均遗漏',
                            type: 'line',
                            data: avgOmissions,
                            smooth: true,
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                type: 'dashed'
                            }
                        },
                        {
                            name: '最大遗漏',
                            type: 'line',
                            data: maxOmissions,
                            smooth: true,
                            itemStyle: {
                                color: '#2A9D8F'
                            },
                            lineStyle: {
                                type: 'dotted'
                            }
                        }
                    ]
                };

                patternChart.setOption(option);
            }

            static updatePatternDistributionChart(omissions, ballNumbers, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                patternDistributionChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const maxOmission = Math.max(...omissions);
                const intervalSize = Math.max(5, Math.ceil(maxOmission / 10));
                const intervals = [];

                for (let i = 0; i <= Math.ceil(maxOmission / intervalSize); i++) {
                    const start = i * intervalSize;
                    const end = (i + 1) * intervalSize;
                    intervals.push({
                        label: `${start}-${end}`,
                        start: start,
                        end: end,
                        count: 0,
                        numbers: []
                    });
                }

                omissions.forEach((omission, index) => {
                    const intervalIndex = Math.min(Math.floor(omission / intervalSize), intervals.length - 1);
                    intervals[intervalIndex].count++;
                    intervals[intervalIndex].numbers.push(ballNumbers[index]);
                });

                const intervalLabels = intervals.map(i => i.label);
                const intervalCounts = intervals.map(i => i.count);
                const intervalNumbers = intervals.map(i => i.numbers.join(', '));

                const maxCount = Math.max(...intervalCounts);
                const barColors = intervalCounts.map(count => {
                    const ratio = count / maxCount;
                    if (ratio < 0.3) return '#457B9D';
                    if (ratio < 0.7) return '#F4A261';
                    return '#E63946';
                });

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏区间分布`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            const interval = intervals[data.dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">遗漏区间：${interval.label}期</div>
                                    <div style="margin-bottom: 3px;">号码数量：<span style="color: #E63946; font-weight: bold;">${interval.count}个</span></div>
                                    <div style="margin-bottom: 3px;">号码列表：<span style="color: #457B9D;">${interval.numbers}</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: intervalLabels,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '号码数量',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '号码数量',
                            type: 'bar',
                            data: intervalCounts,
                            itemStyle: {
                                color: function(params) {
                                    return barColors[params.dataIndex];
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}个'
                            }
                        }
                    ]
                };

                patternDistributionChart.setOption(option);
            }

            static updatePatternStatusChart(omissions, avgOmissions, ballNumbers, rules, ballName, color) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                patternStatusChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const statusData = ballNumbers.map((num, index) => {
                    const omission = omissions[index];
                    const avgOmission = avgOmissions[index];
                    let status = '';
                    let statusColor = '';

                    if (omission === 0) {
                        status = '刚开';
                        statusColor = '#2ECC71';
                    } else if (omission < avgOmission * 0.5) {
                        status = '超热';
                        statusColor = '#E74C3C';
                    } else if (omission < avgOmission * 0.8) {
                        status = '热';
                        statusColor = '#F39C12';
                    } else if (omission <= avgOmission * 1.2) {
                        status = '温';
                        statusColor = '#3498DB';
                    } else if (omission < avgOmission * 2) {
                        status = '冷';
                        statusColor = '#9B59B6';
                    } else {
                        status = '超冷';
                        statusColor = '#34495E';
                    }

                    return {
                        name: num,
                        value: omission,
                        status: status,
                        statusColor: statusColor
                    };
                });

                const statusCounts = {
                    '刚开': 0,
                    '超热': 0,
                    '热': 0,
                    '温': 0,
                    '冷': 0,
                    '超冷': 0
                };

                statusData.forEach(item => {
                    statusCounts[item.status]++;
                });

                const pieData = Object.entries(statusCounts).map(([status, count]) => ({
                    name: status,
                    value: count,
                    itemStyle: {
                        color: statusData.find(item => item.status === status)?.statusColor || '#999'
                    }
                })).filter(item => item.value > 0);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}号码状态分布`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            const status = params.name;
                            const count = params.value;
                            const percentage = ((count / ballNumbers.length) * 100).toFixed(1);
                            const numbers = statusData.filter(item => item.status === status).map(item => item.name).join(', ');
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">状态：${status}</div>
                                    <div style="margin-bottom: 3px;">号码数量：<span style="color: #E63946; font-weight: bold;">${count}个</span></div>
                                    <div style="margin-bottom: 3px;">占比：<span style="color: #9B59B6; font-weight: bold;">${percentage}%</span></div>
                                    <div style="margin-bottom: 3px;">号码列表：<span style="color: #457B9D;">${numbers}</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: pieData.map(d => d.name),
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '号码状态',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['60%', '60%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            label: {
                                show: true,
                                formatter: '{b}\n{c}个\n({d}%)'
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 16,
                                    fontWeight: 'bold'
                                }
                            },
                            data: pieData
                        }
                    ]
                };

                patternStatusChart.setOption(option);
            }

            static updatePatternCycleChart(ballNumbers, omissions, avgOmissions, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                patternCycleChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const cycles = this.analyzeOmissionCycles(ballNumbers, omissions, avgOmissions);
                const sortedCycles = [...cycles].sort((a, b) => parseFloat(b.avgCycle) - parseFloat(a.avgCycle));
                const top10Cycles = sortedCycles.slice(0, 10);

                const numbers = top10Cycles.map(c => c.number);
                const avgCycles = top10Cycles.map(c => parseFloat(c.avgCycle));
                const currentOmissions = top10Cycles.map(c => c.currentOmission);
                const avgOmissionValues = top10Cycles.map(c => c.avgOmission);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏周期分析`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const index = param.dataIndex;
                            const cycle = top10Cycles[index];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${cycle.number}</div>
                                    <div style="margin-bottom: 3px;">平均周期：<span style="color: #E63946; font-weight: bold;">${cycle.avgCycle}期</span></div>
                                    <div style="margin-bottom: 3px;">最大周期：<span style="color: #F4A261;">${cycle.maxCycle}期</span></div>
                                    <div style="margin-bottom: 3px;">最小周期：<span style="color: #2A9D8F;">${cycle.minCycle}期</span></div>
                                    <div style="margin-bottom: 3px;">当前遗漏：<span style="color: #457B9D;">${cycle.currentOmission}期</span></div>
                                    <div style="margin-bottom: 3px;">平均遗漏：<span style="color: #9B59B6;">${cycle.avgOmission.toFixed(1)}期</span></div>
                                    <div style="margin-bottom: 3px;">周期次数：<span style="color: #34495E;">${cycle.cycleCount}次</span></div>
                                    <div style="margin-bottom: 3px;">短期平均：<span style="color: #1ABC9C;">${cycle.shortTermAvg}期</span></div>
                                    <div style="margin-bottom: 3px;">中期平均：<span style="color: #16A085;">${cycle.mediumTermAvg}期</span></div>
                                    <div style="margin-bottom: 3px;">长期平均：<span style="color: #27AE60;">${cycle.longTermAvg}期</span></div>
                                    <div style="margin-bottom: 3px;">周期稳定性：<span style="color: #E74C3C;">${cycle.cycleStability}分</span></div>
                                    <div style="margin-bottom: 3px;">周期规律性：<span style="color: #C0392B;">${cycle.cycleRegularity}分</span></div>
                                    <div style="margin-bottom: 3px;">周期可预测性：<span style="color: #8E44AD;">${cycle.cyclePredictability}分</span></div>
                                    <div style="margin-bottom: 3px;">周期模式：<span style="color: #2980B9; font-weight: bold;">${cycle.cyclePattern}</span></div>
                                    <div style="margin-bottom: 3px;">周期阶段：<span style="color: #D35400; font-weight: bold;">${cycle.cyclePhase}</span></div>
                                    <div style="margin-bottom: 3px;">合理性评估：<span style="color: #27AE60; font-weight: bold;">${cycle.cycleReasonableness}</span></div>
                                    <div style="margin-bottom: 3px;">预计出现：<span style="color: #F39C12;">${cycle.expectedNextAppearance.remaining}期</span></div>
                                    <div style="margin-bottom: 3px;">出现范围：<span style="color: #E67E22;">${cycle.expectedNextAppearance.range}</span></div>
                                    <div>置信度：<span style="color: #3498DB; font-weight: bold;">${cycle.confidenceLevel}%</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['平均周期', '当前遗漏', '平均遗漏'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '期数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '平均周期',
                            type: 'bar',
                            data: avgCycles,
                            itemStyle: {
                                color: '#E63946'
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}期'
                            }
                        },
                        {
                            name: '当前遗漏',
                            type: 'line',
                            data: currentOmissions,
                            smooth: true,
                            itemStyle: {
                                color: '#457B9D'
                            },
                            lineStyle: {
                                width: 3
                            }
                        },
                        {
                            name: '平均遗漏',
                            type: 'line',
                            data: avgOmissionValues,
                            smooth: true,
                            itemStyle: {
                                color: '#9B59B6'
                            },
                            lineStyle: {
                                type: 'dashed',
                                width: 2
                            }
                        }
                    ]
                };

                patternCycleChart.setOption(option);
            }

            static updatePatternCorrelationChart(ballNumbers, omissions, avgOmissions, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                patternCorrelationChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const correlation = this.analyzeOmissionCorrelation(ballNumbers, omissions, avgOmissions);
                const topCorrelations = correlation.data.slice(0, 15);

                const pairs = topCorrelations.map(c => `${c.num1}-${c.num2}`);
                const correlations = topCorrelations.map(c => c.correlation);
                const colors = correlations.map(c => c > 0 ? '#E63946' : '#457B9D');

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏相关性分析（Top 15）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            const corr = topCorrelations[data.dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码对：${corr.num1} - ${corr.num2}</div>
                                    <div style="margin-bottom: 3px;">相关系数：<span style="color: ${corr.correlation > 0 ? '#E63946' : '#457B9D'}; font-weight: bold;">${corr.correlation.toFixed(4)}</span></div>
                                    <div style="margin-bottom: 3px;">${corr.num1}遗漏：<span style="color: #F4A261;">${corr.omission1}期</span></div>
                                    <div style="margin-bottom: 3px;">${corr.num2}遗漏：<span style="color: #2A9D8F;">${corr.omission2}期</span></div>
                                    <div style="margin-bottom: 3px;">${corr.num1}平均遗漏：<span style="color: #9B59B6;">${corr.avgOmission1.toFixed(1)}期</span></div>
                                    <div>${corr.num2}平均遗漏：<span style="color: #34495E;">${corr.avgOmission2.toFixed(1)}期</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: pairs,
                        axisLabel: {
                            rotate: 45,
                            color: '#333',
                            interval: 0
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '相关系数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '相关系数',
                            type: 'bar',
                            data: correlations,
                            itemStyle: {
                                color: function(params) {
                                    return colors[params.dataIndex];
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: function(params) {
                                    return correlations[params.dataIndex].toFixed(3);
                                }
                            }
                        }
                    ]
                };

                patternCorrelationChart.setOption(option);
            }

            static updatePatternPredictionChart(ballNumbers, omissions, avgOmissions, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                patternPredictionChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const predictions = this.predictOmissionTrend(ballNumbers, omissions, avgOmissions);
                const topPredictions = predictions.slice(0, 15);

                const numbers = topPredictions.map(p => p.number);
                const probabilities = topPredictions.map(p => p.probability * 100);
                const confidences = topPredictions.map(p => p.confidence * 100);
                const predictionsLabels = topPredictions.map(p => p.prediction);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏预测分析（Top 15）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const index = param.dataIndex;
                            const pred = topPredictions[index];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${pred.number}</div>
                                    <div style="margin-bottom: 3px;">预测：<span style="color: #E63946; font-weight: bold;">${pred.prediction}</span></div>
                                    <div style="margin-bottom: 3px;">出现概率：<span style="color: #F4A261;">${(pred.probability * 100).toFixed(1)}%</span></div>
                                    <div style="margin-bottom: 3px;">置信度：<span style="color: #2A9D8F;">${(pred.confidence * 100).toFixed(1)}%</span></div>
                                    <div style="margin-bottom: 3px;">当前遗漏：<span style="color: #457B9D;">${pred.currentOmission}期</span></div>
                                    <div style="margin-bottom: 3px;">平均遗漏：<span style="color: #9B59B6;">${pred.avgOmission.toFixed(1)}期</span></div>
                                    <div style="margin-bottom: 3px;">趋势得分：<span style="color: #34495E;">${pred.trendScore}</span></div>
                                    <div>近期出现：<span style="color: #DDA0DD;">${pred.recentAppearances}次</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['出现概率', '置信度'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '百分比(%)',
                        axisLabel: {
                            color: '#333',
                            formatter: '{value}%'
                        }
                    },
                    series: [
                        {
                            name: '出现概率',
                            type: 'bar',
                            data: probabilities,
                            itemStyle: {
                                color: '#E63946'
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}%'
                            }
                        },
                        {
                            name: '置信度',
                            type: 'line',
                            data: confidences,
                            smooth: true,
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                width: 3
                            }
                        }
                    ]
                };

                patternPredictionChart.setOption(option);
            }

            static updateOmissionSequenceChart(omissions, ballNumbers, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                omissionSequenceChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const sequenceData = ballNumbers.map((num, index) => ({
                    name: num,
                    value: omissions[index]
                }));

                const sortedData = [...sequenceData].sort((a, b) => a.value - b.value);
                const numbers = sortedData.map(d => d.name);
                const values = sortedData.map(d => d.value);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏序列分析`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${data.name}</div>
                                    <div style="margin-bottom: 3px;">遗漏值：<span style="color: #E63946; font-weight: bold;">${data.value}期</span></div>
                                    <div>排名：<span style="color: #457B9D;">第${data.dataIndex + 1}位</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            rotate: 45,
                            interval: 0,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '遗漏期数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '遗漏值',
                            type: 'line',
                            data: values,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(230, 57, 70, 0.3)' },
                                        { offset: 1, color: 'rgba(230, 57, 70, 0.05)' }
                                    ]
                                }
                            },
                            markPoint: {
                                data: [
                                    { type: 'max', name: '最大遗漏' },
                                    { type: 'min', name: '最小遗漏' }
                                ]
                            }
                        }
                    ]
                };

                omissionSequenceChart.setOption(option);
            }

            static updateOmissionEvolutionChart(omissions, ballNumbers, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                omissionEvolutionChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const draws = currentDatabaseData.draws.slice(-30);
                const periods = draws.map(d => d.period);
                const isRed = currentOmissionTab === 'red';

                const evolutionData = ballNumbers.map(num => {
                    const values = [];
                    let currentOmission = 0;

                    for (let i = 0; i < draws.length; i++) {
                        const draw = draws[i];
                        const balls = isRed ? draw.redBalls : draw.blueBalls;

                        if (balls.includes(num)) {
                            values.push(currentOmission);
                            currentOmission = 0;
                        } else {
                            currentOmission++;
                            values.push(currentOmission);
                        }
                    }

                    return {
                        name: num,
                        data: values
                    };
                });

                const topNumbers = evolutionData.slice(0, 10);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏演化分析（最近30期）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        }
                    },
                    legend: {
                        data: topNumbers.map(n => n.name),
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods.slice(0, 30),
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '遗漏期数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: topNumbers.map((item, index) => ({
                        name: item.name,
                        type: 'line',
                        data: item.data,
                        smooth: true,
                        itemStyle: {
                            color: ['#E63946', '#F4A261', '#2A9D8F', '#457B9D', '#9B59B6', '#3498DB', '#E74C3C', '#1ABC9C', '#F39C12', '#34495E'][index % 10]
                        },
                        lineStyle: {
                            width: 2
                        }
                    }))
                };

                omissionEvolutionChart.setOption(option);
            }

            static updateOmissionMutationChart(omissions, ballNumbers, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                omissionMutationChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const draws = currentDatabaseData.draws;
                const isRed = currentOmissionTab === 'red';

                const mutationData = ballNumbers.map(num => {
                    const mutations = [];
                    let prevOmission = 0;

                    for (let i = draws.length - 1; i >= 0; i--) {
                        const draw = draws[i];
                        const balls = isRed ? draw.redBalls : draw.blueBalls;

                        if (balls.includes(num)) {
                            if (prevOmission > 0) {
                                mutations.push({
                                    period: draw.period,
                                    omission: prevOmission
                                });
                            }
                            prevOmission = 0;
                        } else {
                            prevOmission++;
                        }
                    }

                    return {
                        number: num,
                        mutations: mutations,
                        avgMutation: mutations.length > 0 ? mutations.reduce((a, b) => a + b.omission, 0) / mutations.length : 0,
                        maxMutation: mutations.length > 0 ? Math.max(...mutations.map(m => m.omission)) : 0,
                        mutationCount: mutations.length
                    };
                });

                const topMutations = [...mutationData].sort((a, b) => b.mutationCount - a.mutationCount).slice(0, 15);

                const numbers = topMutations.map(m => m.number);
                const avgMutations = topMutations.map(m => m.avgMutation.toFixed(2));
                const maxMutations = topMutations.map(m => m.maxMutation);
                const mutationCounts = topMutations.map(m => m.mutationCount);

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏突变分析（Top 15）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const index = param.dataIndex;
                            const mutation = topMutations[index];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${mutation.number}</div>
                                    <div style="margin-bottom: 3px;">突变次数：<span style="color: #E63946; font-weight: bold;">${mutation.mutationCount}次</span></div>
                                    <div style="margin-bottom: 3px;">平均突变值：<span style="color: #F4A261;">${mutation.avgMutation.toFixed(2)}期</span></div>
                                    <div>最大突变值：<span style="color: #2A9D8F;">${mutation.maxMutation}期</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['突变次数', '平均突变值', '最大突变值'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '次数',
                            position: 'left',
                            axisLabel: {
                                color: '#333'
                            }
                        },
                        {
                            type: 'value',
                            name: '期数',
                            position: 'right',
                            axisLabel: {
                                color: '#333'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '突变次数',
                            type: 'bar',
                            data: mutationCounts,
                            itemStyle: {
                                color: '#E63946'
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}次'
                            }
                        },
                        {
                            name: '平均突变值',
                            type: 'line',
                            yAxisIndex: 1,
                            data: avgMutations,
                            smooth: true,
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                width: 3
                            }
                        },
                        {
                            name: '最大突变值',
                            type: 'line',
                            yAxisIndex: 1,
                            data: maxMutations,
                            smooth: true,
                            itemStyle: {
                                color: '#2A9D8F'
                            },
                            lineStyle: {
                                type: 'dashed',
                                width: 2
                            }
                        }
                    ]
                };

                omissionMutationChart.setOption(option);
            }

            static updateOmissionDiversityChart(omissions, ballNumbers, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                omissionDiversityChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const draws = currentDatabaseData.draws;
                const isRed = currentOmissionTab === 'red';

                const diversityData = ballNumbers.map(num => {
                    const omissionValues = [];
                    let currentOmission = 0;

                    for (let i = draws.length - 1; i >= 0; i--) {
                        const draw = draws[i];
                        const balls = isRed ? draw.redBalls : draw.blueBalls;

                        if (balls.includes(num)) {
                            omissionValues.push(currentOmission);
                            currentOmission = 0;
                        } else {
                            currentOmission++;
                        }
                    }

                    const uniqueValues = new Set(omissionValues).size;
                    const avgOmission = omissionValues.reduce((a, b) => a + b, 0) / omissionValues.length;
                    const variance = omissionValues.reduce((acc, val) => acc + Math.pow(val - avgOmission, 2), 0) / omissionValues.length;
                    const stdDev = Math.sqrt(variance);

                    return {
                        number: num,
                        uniqueValues: uniqueValues,
                        avgOmission: avgOmission.toFixed(2),
                        stdDev: stdDev.toFixed(2),
                        diversityIndex: (uniqueValues / omissionValues.length).toFixed(3)
                    };
                });

                const sortedData = [...diversityData].sort((a, b) => parseFloat(b.diversityIndex) - parseFloat(a.diversityIndex));
                const top15Data = sortedData.slice(0, 15);

                const numbers = top15Data.map(d => d.number);
                const diversityIndices = top15Data.map(d => parseFloat(d.diversityIndex) * 100);
                const uniqueValues = top15Data.map(d => d.uniqueValues);
                const stdDevs = top15Data.map(d => parseFloat(d.stdDev));

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏多样性分析（Top 15）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const index = param.dataIndex;
                            const data = top15Data[index];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${data.number}</div>
                                    <div style="margin-bottom: 3px;">多样性指数：<span style="color: #E63946; font-weight: bold;">${(parseFloat(data.diversityIndex) * 100).toFixed(2)}%</span></div>
                                    <div style="margin-bottom: 3px;">唯一遗漏值：<span style="color: #F4A261;">${data.uniqueValues}个</span></div>
                                    <div style="margin-bottom: 3px;">平均遗漏：<span style="color: #2A9D8F;">${data.avgOmission}期</span></div>
                                    <div>标准差：<span style="color: #457B9D;">${data.stdDev}期</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['多样性指数', '唯一遗漏值', '标准差'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '百分比(%)',
                            position: 'left',
                            axisLabel: {
                                color: '#333',
                                formatter: '{value}%'
                            }
                        },
                        {
                            type: 'value',
                            name: '数值',
                            position: 'right',
                            axisLabel: {
                                color: '#333'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '多样性指数',
                            type: 'bar',
                            data: diversityIndices,
                            itemStyle: {
                                color: '#E63946'
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}%'
                            }
                        },
                        {
                            name: '唯一遗漏值',
                            type: 'line',
                            yAxisIndex: 1,
                            data: uniqueValues,
                            smooth: true,
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                width: 3
                            }
                        },
                        {
                            name: '标准差',
                            type: 'line',
                            yAxisIndex: 1,
                            data: stdDevs,
                            smooth: true,
                            itemStyle: {
                                color: '#2A9D8F'
                            },
                            lineStyle: {
                                type: 'dashed',
                                width: 2
                            }
                        }
                    ]
                };

                omissionDiversityChart.setOption(option);
            }

            static updateOmissionMappingChart(omissions, ballNumbers, rules, ballName) {
                const chartDom = document.getElementById('patternChart');
                if (!chartDom) return;

                this.disposeAllPatternCharts();

                omissionMappingChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const mappingData = ballNumbers.map((num, index) => ({
                    name: num,
                    value: [index, omissions[index], omissions[index]]
                }));

                const maxOmission = Math.max(...omissions);
                const avgOmission = omissions.reduce((a, b) => a + b, 0) / omissions.length;

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏映射分析`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 16
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${params.name}</div>
                                    <div style="margin-bottom: 3px;">遗漏值：<span style="color: #E63946; font-weight: bold;">${params.value[1]}期</span></div>
                                    <div style="margin-bottom: 3px;">最大遗漏：<span style="color: #F4A261;">${maxOmission}期</span></div>
                                    <div>平均遗漏：<span style="color: #2A9D8F;">${avgOmission.toFixed(2)}期</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ballNumbers,
                        axisLabel: {
                            rotate: 45,
                            interval: 0,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '遗漏期数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    visualMap: {
                        min: 0,
                        max: maxOmission,
                        dimension: 1,
                        orient: 'vertical',
                        right: 10,
                        top: 'center',
                        text: ['高遗漏', '低遗漏'],
                        textStyle: {
                            color: '#333'
                        },
                        inRange: {
                            color: ['#457B9D', '#2A9D8F', '#F4A261', '#E63946']
                        }
                    },
                    series: [
                        {
                            name: '遗漏映射',
                            type: 'scatter',
                            data: mappingData,
                            symbolSize: function(data) {
                                return Math.max(10, Math.min(30, data[1] / 2));
                            },
                            itemStyle: {
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均遗漏' }
                                ],
                                lineStyle: {
                                    color: '#F4A261',
                                    type: 'dashed',
                                    width: 2
                                },
                                label: {
                                    formatter: '平均遗漏'
                                }
                            }
                        }
                    ]
                };

                omissionMappingChart.setOption(option);
            }

            static calculateOmissionStatistics(omissions) {
                const sorted = [...omissions].sort((a, b) => a - b);
                const sum = omissions.reduce((a, b) => a + b, 0);
                const mean = sum / omissions.length;

                const median = sorted.length % 2 === 0 
                    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2 
                    : sorted[Math.floor(sorted.length / 2)];

                const variance = omissions.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / omissions.length;
                const stdDev = Math.sqrt(variance);

                const min = Math.min(...omissions);
                const max = Math.max(...omissions);
                const range = max - min;

                return {
                    mean: mean.toFixed(2),
                    median: median.toFixed(2),
                    stdDev: stdDev.toFixed(2),
                    min: min,
                    max: max,
                    range: range,
                    sum: sum
                };
            }

            static analyzeOmissionCycles(ballNumbers, omissions, avgOmissions) {
                const cycles = [];
                const draws = currentDatabaseData.draws;
                const isRed = currentOmissionTab === 'red';
                const rules = LOTTERY_RULES[currentLotteryType];
                const ballCount = isRed ? rules.redBallRange[1] : rules.blueBallRange[1];

                ballNumbers.forEach((num, index) => {
                    const numberOmissions = [];
                    let currentOmission = 0;

                    for (let i = draws.length - 1; i >= 0; i--) {
                        const draw = draws[i];
                        const balls = isRed ? draw.redBalls : draw.blueBalls;

                        if (balls.includes(num)) {
                            numberOmissions.push(currentOmission);
                            currentOmission = 0;
                        } else {
                            currentOmission++;
                        }
                    }

                    if (numberOmissions.length > 0) {
                        const avgCycle = numberOmissions.reduce((a, b) => a + b, 0) / numberOmissions.length;
                        const maxCycle = Math.max(...numberOmissions);
                        const minCycle = Math.min(...numberOmissions);
                        const stdDev = Math.sqrt(
                            numberOmissions.reduce((acc, val) => acc + Math.pow(val - avgCycle, 2), 0) / numberOmissions.length
                        );

                        const cycleAnalysis = this.performAdvancedCycleAnalysis(numberOmissions, avgCycle, stdDev, omissions[index]);

                        cycles.push({
                            number: num,
                            avgCycle: avgCycle.toFixed(2),
                            maxCycle: maxCycle,
                            minCycle: minCycle,
                            stdDev: stdDev.toFixed(2),
                            currentOmission: omissions[index],
                            avgOmission: avgOmissions[index],
                            cycleCount: numberOmissions.length,
                            ...cycleAnalysis
                        });
                    }
                });

                return cycles;
            }

            static performAdvancedCycleAnalysis(omissionCycles, avgCycle, stdDev, currentOmission) {
                const cycleCount = omissionCycles.length;

                const shortTermCycles = omissionCycles.slice(-10);
                const mediumTermCycles = omissionCycles.slice(-30);
                const longTermCycles = omissionCycles;

                const shortTermAvg = shortTermCycles.reduce((a, b) => a + b, 0) / shortTermCycles.length;
                const mediumTermAvg = mediumTermCycles.reduce((a, b) => a + b, 0) / mediumTermCycles.length;
                const longTermAvg = longTermCycles.reduce((a, b) => a + b, 0) / longTermCycles.length;

                const shortTermTrend = shortTermCycles.length > 1 ? 
                    (shortTermCycles[shortTermCycles.length - 1] - shortTermCycles[0]) / (shortTermCycles.length - 1) : 0;
                const mediumTermTrend = mediumTermCycles.length > 1 ? 
                    (mediumTermCycles[mediumTermCycles.length - 1] - mediumTermCycles[0]) / (mediumTermCycles.length - 1) : 0;

                const cycleStability = this.calculateCycleStability(omissionCycles);
                const cycleRegularity = this.calculateCycleRegularity(omissionCycles);
                const cyclePredictability = this.calculateCyclePredictability(omissionCycles, avgCycle, stdDev);

                const cyclePattern = this.identifyCyclePattern(omissionCycles);
                const cyclePhase = this.determineCyclePhase(omissionCycles, currentOmission, avgCycle);

                const cycleReasonableness = this.evaluateCycleReasonableness(
                    currentOmission, avgCycle, stdDev, cycleStability, cyclePredictability
                );

                const expectedNextAppearance = this.predictNextAppearance(
                    omissionCycles, currentOmission, avgCycle, cyclePattern
                );

                const confidenceLevel = this.calculateCycleConfidence(
                    cycleStability, cycleRegularity, cyclePredictability, cycleCount
                );

                return {
                    shortTermAvg: shortTermAvg.toFixed(2),
                    mediumTermAvg: mediumTermAvg.toFixed(2),
                    longTermAvg: longTermAvg.toFixed(2),
                    shortTermTrend: shortTermTrend.toFixed(2),
                    mediumTermTrend: mediumTermTrend.toFixed(2),
                    cycleStability: cycleStability.toFixed(2),
                    cycleRegularity: cycleRegularity.toFixed(2),
                    cyclePredictability: cyclePredictability.toFixed(2),
                    cyclePattern: cyclePattern,
                    cyclePhase: cyclePhase,
                    cycleReasonableness: cycleReasonableness,
                    expectedNextAppearance: expectedNextAppearance,
                    confidenceLevel: confidenceLevel.toFixed(1)
                };
            }

            static calculateCycleStability(omissionCycles) {
                if (omissionCycles.length < 3) return 0;

                const avgCycle = omissionCycles.reduce((a, b) => a + b, 0) / omissionCycles.length;
                const variance = omissionCycles.reduce((acc, val) => acc + Math.pow(val - avgCycle, 2), 0) / omissionCycles.length;
                const stdDev = Math.sqrt(variance);
                const coefficientOfVariation = stdDev / avgCycle;

                return Math.max(0, Math.min(100, 100 - coefficientOfVariation * 100));
            }

            static calculateCycleRegularity(omissionCycles) {
                if (omissionCycles.length < 5) return 0;

                const recentCycles = omissionCycles.slice(-10);
                const avgRecent = recentCycles.reduce((a, b) => a + b, 0) / recentCycles.length;
                const avgAll = omissionCycles.reduce((a, b) => a + b, 0) / omissionCycles.length;

                const deviation = Math.abs(avgRecent - avgAll) / avgAll;
                const regularityScore = Math.max(0, 100 - deviation * 100);

                return regularityScore;
            }

            static calculateCyclePredictability(omissionCycles, avgCycle, stdDev) {
                if (omissionCycles.length < 5) return 0;

                const recentCycles = omissionCycles.slice(-5);
                const avgRecent = recentCycles.reduce((a, b) => a + b, 0) / recentCycles.length;

                const deviationFromMean = Math.abs(avgRecent - avgCycle);
                const normalizedDeviation = deviationFromMean / (stdDev || 1);

                const predictabilityScore = Math.max(0, 100 - normalizedDeviation * 20);

                return predictabilityScore;
            }

            static identifyCyclePattern(omissionCycles) {
                if (omissionCycles.length < 5) return '数据不足';

                const recentCycles = omissionCycles.slice(-6);
                const avgRecent = recentCycles.reduce((a, b) => a + b, 0) / recentCycles.length;
                const firstHalf = recentCycles.slice(0, 3);
                const secondHalf = recentCycles.slice(3);
                const avgFirst = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                const avgSecond = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

                const trend = avgSecond - avgFirst;

                if (trend > avgRecent * 0.3) {
                    return '上升周期';
                } else if (trend < -avgRecent * 0.3) {
                    return '下降周期';
                } else if (Math.abs(trend) < avgRecent * 0.1) {
                    return '稳定周期';
                } else {
                    return '波动周期';
                }
            }

            static determineCyclePhase(omissionCycles, currentOmission, avgCycle) {
                const ratio = currentOmission / avgCycle;

                if (ratio < 0.5) {
                    return '初期';
                } else if (ratio < 1.0) {
                    return '中期';
                } else if (ratio < 1.5) {
                    return '后期';
                } else if (ratio < 2.0) {
                    return '超期';
                } else {
                    return '极超期';
                }
            }

            static evaluateCycleReasonableness(currentOmission, avgCycle, stdDev, stability, predictability) {
                const deviation = (currentOmission - avgCycle) / (stdDev || 1);
                const normalizedDeviation = Math.abs(deviation);

                let reasonablenessScore = 100;

                if (normalizedDeviation > 3) {
                    reasonablenessScore -= 50;
                } else if (normalizedDeviation > 2) {
                    reasonablenessScore -= 30;
                } else if (normalizedDeviation > 1) {
                    reasonablenessScore -= 15;
                }

                reasonablenessScore = reasonablenessScore * (stability / 100) * (predictability / 100);

                if (reasonablenessScore < 30) {
                    return '异常';
                } else if (reasonablenessScore < 50) {
                    return '偏低';
                } else if (reasonablenessScore < 70) {
                    return '正常';
                } else if (reasonablenessScore < 85) {
                    return '良好';
                } else {
                    return '优秀';
                }
            }

            static predictNextAppearance(omissionCycles, currentOmission, avgCycle, pattern) {
                const recentCycles = omissionCycles.slice(-5);
                const avgRecent = recentCycles.reduce((a, b) => a + b, 0) / recentCycles.length;

                let predictedOmission;

                switch (pattern) {
                    case '上升周期':
                        predictedOmission = Math.max(avgRecent * 1.2, currentOmission + avgCycle * 0.3);
                        break;
                    case '下降周期':
                        predictedOmission = Math.min(avgRecent * 0.8, currentOmission + avgCycle * 0.5);
                        break;
                    case '稳定周期':
                        predictedOmission = avgRecent;
                        break;
                    case '波动周期':
                        predictedOmission = avgCycle;
                        break;
                    default:
                        predictedOmission = avgCycle;
                }

                const remainingOmission = Math.max(0, predictedOmission - currentOmission);
                const lowerBound = Math.max(0, remainingOmission * 0.7);
                const upperBound = remainingOmission * 1.3;

                return {
                    predicted: Math.round(predictedOmission),
                    remaining: Math.round(remainingOmission),
                    range: `${Math.round(lowerBound)}-${Math.round(upperBound)}期`
                };
            }

            static calculateCycleConfidence(stability, regularity, predictability, cycleCount) {
                const dataQualityScore = Math.min(100, cycleCount * 2);
                const avgScore = (stability + regularity + predictability + dataQualityScore) / 4;

                return avgScore;
            }

            static analyzeOmissionCorrelation(ballNumbers, omissions, avgOmissions) {
                const correlationMatrix = [];
                const correlationData = [];

                for (let i = 0; i < ballNumbers.length; i++) {
                    correlationMatrix[i] = [];
                    for (let j = 0; j < ballNumbers.length; j++) {
                        if (i === j) {
                            correlationMatrix[i][j] = 1;
                        } else {
                            const correlation = this.calculatePearsonCorrelation(
                                ballNumbers.map((_, idx) => idx),
                                ballNumbers.map((_, idx) => omissions[idx])
                            );
                            correlationMatrix[i][j] = correlation;
                        }
                    }
                }

                for (let i = 0; i < ballNumbers.length; i++) {
                    for (let j = i + 1; j < ballNumbers.length; j++) {
                        correlationData.push({
                            num1: ballNumbers[i],
                            num2: ballNumbers[j],
                            correlation: correlationMatrix[i][j],
                            omission1: omissions[i],
                            omission2: omissions[j],
                            avgOmission1: avgOmissions[i],
                            avgOmission2: avgOmissions[j]
                        });
                    }
                }

                correlationData.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));

                return {
                    matrix: correlationMatrix,
                    data: correlationData.slice(0, 20)
                };
            }

            static calculatePearsonCorrelation(x, y) {
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
                const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0);
                const sumY2 = y.reduce((acc, yi) => acc + yi * yi, 0);

                const numerator = n * sumXY - sumX * sumY;
                const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

                return denominator === 0 ? 0 : numerator / denominator;
            }

            static predictOmissionTrend(ballNumbers, omissions, avgOmissions) {
                const predictions = [];
                const draws = currentDatabaseData.draws;
                const isRed = currentOmissionTab === 'red';
                const rules = LOTTERY_RULES[currentLotteryType];
                const ballCount = isRed ? rules.redBallRange[1] : rules.blueBallRange[1];

                ballNumbers.forEach((num, index) => {
                    const currentOmission = omissions[index];
                    const avgOmission = avgOmissions[index];
                    const numberHistory = [];

                    for (let i = draws.length - 1; i >= 0; i--) {
                        const draw = draws[i];
                        const balls = isRed ? draw.redBalls : draw.blueBalls;

                        if (balls.includes(num)) {
                            numberHistory.push(0);
                        } else {
                            numberHistory.push(1);
                        }
                    }

                    const recentHistory = numberHistory.slice(0, 10);
                    const recentAppearances = recentHistory.filter(x => x === 0).length;
                    const trendScore = recentAppearances / recentHistory.length;

                    let prediction = '';
                    let confidence = 0;
                    let probability = 0;

                    if (currentOmission === 0) {
                        prediction = '刚开出';
                        confidence = 0.9;
                        probability = 0.3;
                    } else if (currentOmission < avgOmission * 0.5) {
                        prediction = '热号持续';
                        confidence = 0.7;
                        probability = 0.4;
                    } else if (currentOmission >= avgOmission * 2) {
                        prediction = '超冷回补';
                        confidence = 0.6;
                        probability = 0.35;
                    } else if (currentOmission >= avgOmission * 1.5) {
                        prediction = '冷号待出';
                        confidence = 0.65;
                        probability = 0.3;
                    } else if (trendScore > 0.5) {
                        prediction = '趋势上升';
                        confidence = 0.55;
                        probability = 0.25;
                    } else {
                        prediction = '正常波动';
                        confidence = 0.5;
                        probability = 0.2;
                    }

                    predictions.push({
                        number: num,
                        currentOmission: currentOmission,
                        avgOmission: avgOmission,
                        prediction: prediction,
                        confidence: confidence,
                        probability: probability,
                        trendScore: trendScore.toFixed(2),
                        recentAppearances: recentAppearances
                    });
                });

                predictions.sort((a, b) => b.probability - a.probability);

                return predictions;
            }

            static classifyNumberStatus(omissions, avgOmissions, ballNumbers) {
                const classification = {
                    '刚开': [],
                    '超热': [],
                    '热': [],
                    '温': [],
                    '冷': [],
                    '超冷': []
                };

                ballNumbers.forEach((num, index) => {
                    const omission = omissions[index];
                    const avgOmission = avgOmissions[index];

                    if (omission === 0) {
                        classification['刚开'].push(num);
                    } else if (omission < avgOmission * 0.5) {
                        classification['超热'].push(num);
                    } else if (omission < avgOmission * 0.8) {
                        classification['热'].push(num);
                    } else if (omission <= avgOmission * 1.2) {
                        classification['温'].push(num);
                    } else if (omission < avgOmission * 2) {
                        classification['冷'].push(num);
                    } else {
                        classification['超冷'].push(num);
                    }
                });

                return classification;
            }

            static generateEnhancedPatternInsights(omissions, avgOmissions, ballNumbers, frequencyData, rules, ballName, isRed) {
                const insightsDiv = document.getElementById('patternInsights');
                if (!insightsDiv) return;

                const insights = [];
                const stats = this.calculateOmissionStatistics(omissions);
                const classification = this.classifyNumberStatus(omissions, avgOmissions, ballNumbers);

                const cycles = this.analyzeOmissionCycles(ballNumbers, omissions, avgOmissions);
                const correlation = this.analyzeOmissionCorrelation(ballNumbers, omissions, avgOmissions);
                const predictions = this.predictOmissionTrend(ballNumbers, omissions, avgOmissions);

                patternAnalysisResults = {
                    stats,
                    classification,
                    cycles,
                    correlation,
                    predictions
                };

                insights.push(`<strong>📊 遗漏统计：</strong>平均值${stats.mean}期，中位数${stats.median}期，标准差${stats.stdDev}期，范围${stats.min}-${stats.max}期`);

                const highOmissionNumbers = ballNumbers.filter((num, index) => omissions[index] >= avgOmissions[index] * 2);
                if (highOmissionNumbers.length > 0) {
                    insights.push(`<strong>🔥 超冷号码：</strong>${highOmissionNumbers.join(', ')}（当前遗漏超过平均遗漏2倍，共${highOmissionNumbers.length}个）`);
                }

                const hotNumbers = ballNumbers.filter((num, index) => omissions[index] === 0);
                if (hotNumbers.length > 0) {
                    insights.push(`<strong>⭐ 刚开号码：</strong>${hotNumbers.join(', ')}（上一期刚开出，共${hotNumbers.length}个）`);
                }

                const maxOmission = Math.max(...omissions);
                const maxOmissionNum = ballNumbers[omissions.indexOf(maxOmission)];
                insights.push(`<strong>📈 最大遗漏：</strong>${maxOmissionNum}号码遗漏${maxOmission}期`);

                const balancedNumbers = ballNumbers.filter((num, index) => {
                    const avg = avgOmissions[index];
                    return omissions[index] >= avg * 0.8 && omissions[index] <= avg * 1.2;
                });
                if (balancedNumbers.length > 0) {
                    insights.push(`<strong>⚖️ 平衡号码：</strong>${balancedNumbers.slice(0, 10).join(', ')}（遗漏接近平均值，共${balancedNumbers.length}个）`);
                }

                const totalDraws = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : currentDatabaseData.draws.length;
                const ballCount = ballNumbers.length;
                const expectedOmission = ballCount / (isRed ? rules.redBallCount : rules.blueBallCount);
                insights.push(`<strong>🎯 理论遗漏：</strong>${expectedOmission.toFixed(1)}期（每${expectedOmission.toFixed(1)}期应开出一次）`);

                insights.push(`<strong>🏷️ 号码状态分布：</strong>刚开${classification['刚开'].length}个，超热${classification['超热'].length}个，热${classification['热'].length}个，温${classification['温'].length}个，冷${classification['冷'].length}个，超冷${classification['超冷'].length}个`);

                const trend = stats.mean > parseFloat(expectedOmission) ? '上升' : stats.mean < parseFloat(expectedOmission) ? '下降' : '稳定';
                insights.push(`<strong>📉 遗漏趋势：</strong>${trend}（当前平均遗漏${stats.mean}期，理论遗漏${expectedOmission.toFixed(1)}期）`);

                const volatility = stats.stdDev / stats.mean;
                const volatilityLevel = volatility < 0.5 ? '低' : volatility < 1.0 ? '中' : '高';
                insights.push(`<strong>📊 波动性：</strong>${volatilityLevel}（变异系数${(volatility * 100).toFixed(1)}%）`);

                const topCycles = [...cycles].sort((a, b) => parseFloat(b.avgCycle) - parseFloat(a.avgCycle)).slice(0, 5);
                if (topCycles.length > 0) {
                    const cycleNumbers = topCycles.map(c => c.number).join(', ');
                    const avgCycleValue = topCycles.reduce((sum, c) => sum + parseFloat(c.avgCycle), 0) / topCycles.length;
                    insights.push(`<strong>🔄 长周期号码：</strong>${cycleNumbers}（平均遗漏周期${avgCycleValue.toFixed(1)}期，需关注回补时机）`);
                }

                const shortCycles = [...cycles].sort((a, b) => parseFloat(a.avgCycle) - parseFloat(b.avgCycle)).slice(0, 5);
                if (shortCycles.length > 0) {
                    const shortCycleNumbers = shortCycles.map(c => c.number).join(', ');
                    const avgShortCycle = shortCycles.reduce((sum, c) => sum + parseFloat(c.avgCycle), 0) / shortCycles.length;
                    insights.push(`<strong>⚡ 短周期号码：</strong>${shortCycleNumbers}（平均遗漏周期${avgShortCycle.toFixed(1)}期，出现频率较高）`);
                }

                const stableCycles = cycles.filter(c => parseFloat(c.cycleStability) > 70);
                if (stableCycles.length > 0) {
                    const stableNumbers = stableCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>✅ 高稳定性号码：</strong>${stableNumbers}（周期稳定性>70分，规律性强）`);
                }

                const predictableCycles = cycles.filter(c => parseFloat(c.cyclePredictability) > 70);
                if (predictableCycles.length > 0) {
                    const predictableNumbers = predictableCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>🎯 高可预测号码：</strong>${predictableNumbers}（周期可预测性>70分，预测准确度高）`);
                }

                const highCorrelationPairs = correlation.data.slice(0, 3);
                if (highCorrelationPairs.length > 0) {
                    const pairs = highCorrelationPairs.map(c => `${c.num1}-${c.num2}(${c.correlation.toFixed(3)})`).join(', ');
                    insights.push(`<strong>🔗 强相关号码对：</strong>${pairs}（遗漏变化高度相关）`);
                }

                const topPredictions = predictions.slice(0, 5);
                if (topPredictions.length > 0) {
                    const predNumbers = topPredictions.map(p => `${p.number}(${p.prediction})`).join(', ');
                    insights.push(`<strong>🎯 高概率预测：</strong>${predNumbers}（近期出现概率较高）`);
                }

                if (classification['超热'].length > 0) {
                    const superHotNumbers = classification['超热'].slice(0, 5);
                    insights.push(`<strong>💡 推荐关注：</strong>${superHotNumbers.join(', ')}（超热号码近期可能继续开出）`);
                }

                if (classification['超冷'].length > 0) {
                    const superColdNumbers = classification['超冷'].slice(0, 5);
                    insights.push(`<strong>⚠️ 风险提示：</strong>${superColdNumbers.join(', ')}（超冷号码遗漏时间过长，需谨慎选择）`);
                }

                const hotColdRatio = (classification['超热'].length + classification['热'].length) / (classification['冷'].length + classification['超冷'].length);
                if (hotColdRatio > 1.5) {
                    insights.push(`<strong>🌡️ 热冷比分析：</strong>当前热号明显多于冷号（比例${hotColdRatio.toFixed(2)}），建议关注冷号回补机会`);
                } else if (hotColdRatio < 0.67) {
                    insights.push(`<strong>🌡️ 热冷比分析：</strong>当前冷号明显多于热号（比例${hotColdRatio.toFixed(2)}），建议关注热号延续趋势`);
                } else {
                    insights.push(`<strong>🌡️ 热冷比分析：</strong>热冷号分布相对均衡（比例${hotColdRatio.toFixed(2)}），状态稳定`);
                }

                const highPersistenceCycles = cycles.filter(c => parseFloat(c.cycleStability) > 70 && parseFloat(c.cyclePredictability) > 70);
                if (highPersistenceCycles.length > 0) {
                    const persistenceNumbers = highPersistenceCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>🎯 高稳定性号码：</strong>${persistenceNumbers}（周期稳定性和可预测性均>70分，规律性强）`);
                }

                const risingTrendCycles = cycles.filter(c => c.cyclePattern === '上升周期');
                if (risingTrendCycles.length > 0) {
                    const risingNumbers = risingTrendCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>📈 上升趋势号码：</strong>${risingNumbers}（遗漏周期呈上升趋势，需谨慎关注）`);
                }

                const fallingTrendCycles = cycles.filter(c => c.cyclePattern === '下降周期');
                if (fallingTrendCycles.length > 0) {
                    const fallingNumbers = fallingTrendCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>📉 下降趋势号码：</strong>${fallingNumbers}（遗漏周期呈下降趋势，关注机会）`);
                }

                const highConfidenceCycles = cycles.filter(c => parseFloat(c.confidenceLevel) > 75);
                if (highConfidenceCycles.length > 0) {
                    const confidenceNumbers = highConfidenceCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>✅ 高置信度号码：</strong>${confidenceNumbers}（预测置信度>75%，可信度高）`);
                }

                const shortTermHotCycles = cycles.filter(c => parseFloat(c.shortTermAvg) < parseFloat(c.avgCycle) * 0.8);
                if (shortTermHotCycles.length > 0) {
                    const shortTermHotNumbers = shortTermHotCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>🔥 短期热门号码：</strong>${shortTermHotNumbers}（近期周期缩短，表现活跃）`);
                }

                const longTermColdCycles = cycles.filter(c => parseFloat(c.longTermAvg) > parseFloat(c.avgCycle) * 1.2);
                if (longTermColdCycles.length > 0) {
                    const longTermColdNumbers = longTermColdCycles.slice(0, 5).map(c => c.number).join(', ');
                    insights.push(`<strong>❄️ 长期冷门号码：</strong>${longTermColdNumbers}（长期周期较长，需关注回补时机）`);
                }

                const avgCycleOverall = cycles.reduce((sum, c) => sum + parseFloat(c.avgCycle), 0) / cycles.length;
                insights.push(`<strong>📊 周期分析：</strong>整体平均遗漏周期${avgCycleOverall.toFixed(1)}期，号码回补节奏${avgCycleOverall > parseFloat(expectedOmission) ? '较慢' : '较快'}`);

                insightsDiv.innerHTML = `
                    <h4>📋 科学规律分析结论</h4>
                    <ul>
                        ${insights.map(insight => `<li>${insight}</li>`).join('')}
                    </ul>
                `;
            }

            static updateFrequencyTable(redBallFrequency, blueBallFrequency) {
                const tableBody = document.getElementById('frequencyTableBody');
                if (!tableBody) return;

                const totalRedDraws = Object.values(redBallFrequency).reduce((acc, item) => acc + item.count, 0);
                const totalBlueDraws = Object.values(blueBallFrequency).reduce((acc, item) => acc + item.count, 0);

                const activeTab = document.querySelector('.tab-btn.active')?.dataset.tab || 'red';
                const sortOption = document.getElementById('sortOption')?.value || 'number';
                const sortOrder = document.getElementById('sortOrder')?.value || 'asc';

                const frequencyData = activeTab === 'red' ? redBallFrequency : blueBallFrequency;
                const totalDraws = activeTab === 'red' ? totalRedDraws : totalBlueDraws;
                const ballColor = activeTab === 'red' ? '#E63946' : '#457B9D';
                const hotColor = activeTab === 'red' ? '#E63946' : '#457B9D';
                const coldThreshold = activeTab === 'red' ? 10 : 5;
                const avgFrequency = totalDraws / Object.keys(frequencyData).length;

                const sortedData = Object.entries(frequencyData).sort((a, b) => {
                    const numA = parseInt(a[0]);
                    const numB = parseInt(b[0]);
                    const dataA = a[1];
                    const dataB = b[1];

                    let compareValue = 0;

                    switch (sortOption) {
                        case 'number':
                            compareValue = numA - numB;
                            break;
                        case 'count':
                            compareValue = dataA.count - dataB.count;
                            break;
                        case 'frequency':
                            const freqA = (dataA.count / totalDraws) * 100;
                            const freqB = (dataB.count / totalDraws) * 100;
                            compareValue = freqA - freqB;
                            break;
                        case 'currentOmission':
                            compareValue = dataA.currentOmission - dataB.currentOmission;
                            break;
                        case 'avgOmission':
                            const avgOmissionA = totalDraws > 0 ? totalDraws / dataA.count : 0;
                            const avgOmissionB = totalDraws > 0 ? totalDraws / dataB.count : 0;
                            compareValue = avgOmissionA - avgOmissionB;
                            break;
                        case 'maxOmission':
                            compareValue = dataA.maxOmission - dataB.maxOmission;
                            break;
                        default:
                            compareValue = numA - numB;
                    }

                    return sortOrder === 'asc' ? compareValue : -compareValue;
                });

                let html = '';

                sortedData.forEach(([num, data]) => {
                    const frequency = ((data.count / totalDraws) * 100).toFixed(2);
                    const avgOmission = totalDraws > 0 ? (totalDraws / data.count).toFixed(1) : 0;
                    const status = data.currentOmission > coldThreshold ? '冷' : data.count > avgFrequency * 1.5 ? '热' : '温';
                    const statusColor = status === '冷' ? '#F4A261' : status === '热' ? hotColor : '#2A9D8F';

                    html += `
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; color: ${ballColor}; font-weight: bold;">${num}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${data.count}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${frequency}%</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${data.currentOmission}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${avgOmission}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${data.maxOmission}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; color: ${statusColor}; font-weight: bold;">${status}</td>
                        </tr>
                    `;
                });

                tableBody.innerHTML = html;
            }

            static performOmissionAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const lotteryType = currentLotteryType;
                    const rules = LOTTERY_RULES[lotteryType];
                    const redBallCount = rules.redBallRange[1];
                    const blueBallCount = rules.blueBallRange[1];

                    let analysisDraws = draws;
                    let periodCount = draws.length;
                    if (currentOmissionPeriod !== 'all') {
                        periodCount = currentOmissionPeriod;
                        analysisDraws = draws.slice(-currentOmissionPeriod);
                    }

                    const redBallFrequency = {};
                    for (let i = 1; i <= redBallCount; i++) {
                        const num = i.toString().padStart(2, '0');
                        redBallFrequency[num] = {
                            count: 0,
                            currentOmission: 0,
                            maxOmission: 0,
                            omissionHistory: []
                        };
                    }

                    const blueBallFrequency = {};
                    for (let i = 1; i <= blueBallCount; i++) {
                        const num = i.toString().padStart(2, '0');
                        blueBallFrequency[num] = {
                            count: 0,
                            currentOmission: 0,
                            maxOmission: 0,
                            omissionHistory: []
                        };
                    }

                    const reversedAnalysisDraws = [...analysisDraws].reverse();

                    reversedAnalysisDraws.forEach(draw => {
                        draw.redBalls.forEach(ball => {
                            if (redBallFrequency[ball]) {
                                redBallFrequency[ball].count++;
                            }
                        });

                        if (draw.blueBalls && draw.blueBalls.length > 0) {
                            draw.blueBalls.forEach(blueBall => {
                                const blueBallNum = blueBall.toString().padStart(2, '0');
                                if (blueBallFrequency[blueBallNum]) {
                                    blueBallFrequency[blueBallNum].count++;
                                }
                            });
                        }
                    });

                    // 计算红球遗漏值 - 严格按照从最新期开始向前遍历，在指定期数范围内计算
                    for (let num in redBallFrequency) {
                        let omissionCount = 0;
                        let maxOmission = 0;
                        let found = false;
                        let firstAppearanceIndex = -1;

                        // 只遍历指定期数范围内的数据
                        for (let i = 0; i < reversedAnalysisDraws.length; i++) {
                            const draw = reversedAnalysisDraws[i];
                            if (draw.redBalls.includes(num)) {
                                // 号码出现
                                if (omissionCount > maxOmission) {
                                    maxOmission = omissionCount;
                                }
                                redBallFrequency[num].omissionHistory.push(omissionCount);
                                omissionCount = 0;
                                found = true;

                                // 记录首次出现的位置
                                if (firstAppearanceIndex === -1) {
                                    firstAppearanceIndex = i;
                                }
                            } else {
                                omissionCount++;
                            }
                        }

                        // 如果在指定期数范围内没有出现，则当前遗漏为 periodCount
                        // 如果在第 M 期出现（从最新期算起的第 M 期），则当前遗漏为 M
                        if (!found) {
                            redBallFrequency[num].currentOmission = periodCount;
                        } else {
                            redBallFrequency[num].currentOmission = firstAppearanceIndex;
                        }
                        redBallFrequency[num].maxOmission = maxOmission;
                    }

                    // 计算蓝球遗漏值 - 严格按照从最新期开始向前遍历，在指定期数范围内计算
                    for (let num in blueBallFrequency) {
                        let omissionCount = 0;
                        let maxOmission = 0;
                        let found = false;
                        let firstAppearanceIndex = -1;

                        // 只遍历指定期数范围内的数据
                        for (let i = 0; i < reversedAnalysisDraws.length; i++) {
                            const draw = reversedAnalysisDraws[i];
                            let isMatched = false;
                            if (draw.blueBalls && draw.blueBalls.length > 0) {
                                draw.blueBalls.forEach(blueBall => {
                                    const blueBallNum = blueBall.toString().padStart(2, '0');
                                    if (blueBallNum === num) {
                                        isMatched = true;
                                    }
                                });
                            }

                            if (isMatched) {
                                // 号码出现
                                if (omissionCount > maxOmission) {
                                    maxOmission = omissionCount;
                                }
                                blueBallFrequency[num].omissionHistory.push(omissionCount);
                                omissionCount = 0;
                                found = true;

                                // 记录首次出现的位置
                                if (firstAppearanceIndex === -1) {
                                    firstAppearanceIndex = i;
                                }
                            } else {
                                omissionCount++;
                            }
                        }

                        // 如果在指定期数范围内没有出现，则当前遗漏为 periodCount
                        // 如果在第 M 期出现（从最新期算起的第 M 期），则当前遗漏为 M
                        if (!found) {
                            blueBallFrequency[num].currentOmission = periodCount;
                        } else {
                            blueBallFrequency[num].currentOmission = firstAppearanceIndex;
                        }
                        blueBallFrequency[num].maxOmission = maxOmission;
                    }

                    omissionAnalysisData.red = redBallFrequency;
                    omissionAnalysisData.blue = blueBallFrequency;

                    // 更新分析范围显示
                    const omissionDataRangeInfo = document.getElementById('omissionDataRangeInfo');
                    if (omissionDataRangeInfo && reversedAnalysisDraws.length > 0) {
                        const startPeriod = reversedAnalysisDraws[reversedAnalysisDraws.length - 1].period;
                        const endPeriod = reversedAnalysisDraws[0].period;
                        omissionDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${reversedAnalysisDraws.length}期）`;
                    }

                    this.updateOmissionChart();
                    this.updateOmissionTable();
                    this.generateOmissionPrediction();

                    MessageSystem.showMessage(`已完成${reversedAnalysisDraws.length}期数据的遗漏分析`, 'success');
                });
            }

            static updateOmissionChart() {
                const chartDom = document.getElementById('omissionChart');
                if (!chartDom) return;

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const isRed = currentOmissionTab === 'red';
                const frequencyData = isRed ? omissionAnalysisData.red : omissionAnalysisData.blue;
                const ballCount = isRed ? rules.redBallRange[1] : rules.blueBallRange[1];
                const ballName = isRed ? rules.redBallName : rules.blueBallName;
                const color = isRed ? '#E63946' : '#457B9D';
                const totalDraws = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : currentDatabaseData.draws.length;

                let ballNumbers = [];
                for (let i = 1; i <= ballCount; i++) {
                    ballNumbers.push(i.toString().padStart(2, '0'));
                }

                switch(currentOmissionSort) {
                    case 'number':
                        ballNumbers.sort((a, b) => parseInt(a) - parseInt(b));
                        break;
                    case 'desc':
                        ballNumbers.sort((a, b) => (frequencyData[b]?.currentOmission || 0) - (frequencyData[a]?.currentOmission || 0));
                        break;
                    case 'asc':
                        ballNumbers.sort((a, b) => (frequencyData[a]?.currentOmission || 0) - (frequencyData[b]?.currentOmission || 0));
                        break;
                }

                const omissions = ballNumbers.map(num => frequencyData[num]?.currentOmission || 0);

                if (omissionRedChart) {
                    omissionRedChart.dispose();
                    omissionRedChart = null;
                }
                if (omissionBlueChart) {
                    omissionBlueChart.dispose();
                    omissionBlueChart = null;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                if (isRed) {
                    omissionRedChart = chart;
                } else {
                    omissionBlueChart = chart;
                }

                const option = {
                    title: {
                        text: `${rules.displayName}${ballName}遗漏分析`,
                        left: 'center',
                        textStyle: {
                            color: color,
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const num = param.name;
                            const omission = param.value;
                            const data = frequencyData[num];
                            if (data) {
                                const avgOmissionNum = (data.count > 0) ? (totalDraws / data.count) : 0;
                                const avgOmission = avgOmissionNum.toFixed(1);
                                const expectedCount = isRed ? (totalDraws * 6 / 33) : (totalDraws * 1 / 16);
                                const theoreticalCount = expectedCount.toFixed(2);
                                const absoluteDeviation = (data.count - parseFloat(theoreticalCount)).toFixed(2);
                                const relativeDeviation = parseFloat(theoreticalCount) > 0 ? ((data.count - parseFloat(theoreticalCount)) / parseFloat(theoreticalCount) * 100).toFixed(2) : 0;
                                let deviationStatus = '低偏差';
                                const absRelativeDeviation = Math.abs(parseFloat(relativeDeviation));
                                if (absRelativeDeviation >= 30) {
                                    deviationStatus = '高偏差';
                                } else if (absRelativeDeviation >= 10) {
                                    deviationStatus = '中偏差';
                                }
                                return `
                                    <div style="padding: 10px;">
                                        <div style="font-weight: bold; margin-bottom: 5px;">${ballName}号码: ${num}</div>
                                        <div>当前遗漏: ${omission}</div>
                                        <div>最大遗漏: ${data.maxOmission}</div>
                                        <div>平均遗漏: ${avgOmission}</div>
                                        <div>开出次数: ${data.count}</div>
                                        <div>理论次数: ${theoreticalCount}</div>
                                        <div>绝对偏差: ${absoluteDeviation > 0 ? '+' : ''}${absoluteDeviation}</div>
                                        <div>相对偏差: ${relativeDeviation > 0 ? '+' : ''}${relativeDeviation}%</div>
                                        <div>偏差状态: ${deviationStatus}</div>
                                    </div>
                                `;
                            }
                            return `${ballName}号码: ${num}<br/>当前遗漏: ${omission}`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ballNumbers,
                        axisLabel: {
                            rotate: 45,
                            interval: 0
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '遗漏期数'
                    },
                    series: [{
                        name: '遗漏次数',
                        type: 'bar',
                        data: omissions,
                        itemStyle: {
                            color: function(params) {
                                const value = params.value;
                                if (value >= 20) return '#E63946';
                                if (value >= 10) return '#F4A261';
                                if (value >= 5) return '#2A9D8F';
                                return '#457B9D';
                            },
                            borderRadius: [4, 4, 0, 0]
                        },
                        label: {
                            show: true,
                            position: 'top',
                            formatter: '{c}'
                        }
                    }]
                };

                chart.setOption(option);
            }

            static updateOmissionTable() {
                const tableBody = document.getElementById('omissionTableBody');
                if (!tableBody) return;

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const isRed = currentOmissionTab === 'red';
                const frequencyData = isRed ? omissionAnalysisData.red : omissionAnalysisData.blue;
                const ballCount = isRed ? rules.redBallRange[1] : rules.blueBallRange[1];
                const ballName = isRed ? rules.redBallName : rules.blueBallName;
                const ballColor = isRed ? '#E63946' : '#457B9D';
                const totalDraws = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : currentDatabaseData.draws.length;

                const ballNumbers = [];
                for (let i = 1; i <= ballCount; i++) {
                    ballNumbers.push(i.toString().padStart(2, '0'));
                }

                const sortedData = Object.entries(frequencyData).sort((a, b) => {
                    const numA = parseInt(a[0]);
                    const numB = parseInt(b[0]);
                    const dataA = a[1];
                    const dataB = b[1];

                    let compareValue = 0;

                    switch (currentOmissionSort) {
                        case 'number':
                            compareValue = numA - numB;
                            break;
                        case 'asc':
                            compareValue = dataA.currentOmission - dataB.currentOmission;
                            break;
                        case 'desc':
                            compareValue = dataB.currentOmission - dataA.currentOmission;
                            break;
                        default:
                            compareValue = numA - numB;
                    }

                    return compareValue;
                });

                let html = '';

                sortedData.forEach(([num, data]) => {
                    const avgOmissionNum = data.count > 0 ? (totalDraws / data.count) : 0;
                    const avgOmission = avgOmissionNum.toFixed(1);
                    const expectedCount = isRed ? (totalDraws * 6 / 33) : (totalDraws * 1 / 16);
                    const theoreticalCount = expectedCount.toFixed(2);
                    const actualProbability = ((data.count / totalDraws) * 100).toFixed(2);
                    const theoreticalProbability = isRed ? ((6 / 33) * 100).toFixed(2) : ((1 / 16) * 100).toFixed(2);
                    const wantProbability = data.currentOmission > 0 && avgOmissionNum > 0 ? ((data.currentOmission / avgOmissionNum) * 100).toFixed(2) : 0;

                    const absoluteDeviation = (data.count - parseFloat(theoreticalCount)).toFixed(2);
                    const relativeDeviation = parseFloat(theoreticalCount) > 0 ? ((data.count - parseFloat(theoreticalCount)) / parseFloat(theoreticalCount) * 100).toFixed(2) : 0;

                    let deviationStatus = '低偏差';
                    let deviationStatusColor = '#2A9D8F';
                    const absRelativeDeviation = Math.abs(parseFloat(relativeDeviation));
                    if (absRelativeDeviation >= 30) {
                        deviationStatus = '高偏差';
                        deviationStatusColor = '#E63946';
                    } else if (absRelativeDeviation >= 10) {
                        deviationStatus = '中偏差';
                        deviationStatusColor = '#F4A261';
                    }

                    let status = '温';
                    let statusColor = '#2A9D8F';
                    if (data.currentOmission >= avgOmission * 2) {
                        status = '冷';
                        statusColor = '#F4A261';
                    } else if (data.count > parseFloat(theoreticalCount) * 1.5) {
                        status = '热';
                        statusColor = '#E63946';
                    }

                    let wantLevel = '普通';
                    if (wantProbability >= 150) {
                        wantLevel = '极强';
                    } else if (wantProbability >= 100) {
                        wantLevel = '强';
                    } else if (wantProbability >= 50) {
                        wantLevel = '中等';
                    } else {
                        wantLevel = '弱';
                    }

                    html += `
                        <tr>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">
                                <span class="number-cell ${isRed ? 'red-number' : 'blue-number'}">${num}</span>
                            </td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; font-weight: bold; color: ${data.currentOmission >= 10 ? '#E63946' : 'inherit'};">${data.currentOmission}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${data.maxOmission}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${avgOmission}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; color: ${statusColor}; font-weight: bold;">${status}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${data.count}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${theoreticalCount}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center;">${actualProbability}%</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; font-weight: bold; color: ${wantProbability >= 100 ? '#E63946' : 'inherit'};">${wantProbability}%</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; font-weight: bold; color: ${wantLevel === '极强' || wantLevel === '强' ? '#E63946' : 'inherit'};">${wantLevel}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; color: ${absoluteDeviation > 0 ? '#E63946' : (absoluteDeviation < 0 ? '#F4A261' : 'inherit')}; font-weight: bold;">${absoluteDeviation > 0 ? '+' : ''}${absoluteDeviation}</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; color: ${relativeDeviation > 0 ? '#E63946' : (relativeDeviation < 0 ? '#F4A261' : 'inherit')}; font-weight: bold;">${relativeDeviation > 0 ? '+' : ''}${relativeDeviation}%</td>
                            <td style="padding: 10px; border: 1px solid var(--border-color); text-align: center; color: ${deviationStatusColor}; font-weight: bold;">${deviationStatus}</td>
                        </tr>
                    `;
                });

                tableBody.innerHTML = html;
            }

            static generateOmissionPrediction() {
                const predictionDiv = document.getElementById('omissionPrediction');
                if (!predictionDiv) return;

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redData = omissionAnalysisData.red;
                const blueData = omissionAnalysisData.blue;

                const redNumbers = Object.entries(redData)
                    .sort((a, b) => b[1].currentOmission - a[1].currentOmission)
                    .slice(0, 10)
                    .map(([num, data]) => {
                        const totalDraws = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : currentDatabaseData.draws.length;
                        const avgOmissionNum = data.count > 0 ? (totalDraws / data.count) : 0;
                        const wantProbability = data.currentOmission > 0 && avgOmissionNum > 0 ? ((data.currentOmission / avgOmissionNum) * 100).toFixed(2) : 0;
                        return {
                            num,
                            omission: data.currentOmission,
                            avgOmission: avgOmissionNum,
                            wantProbability: wantProbability
                        };
                    });

                const blueNumbers = Object.entries(blueData)
                    .sort((a, b) => b[1].currentOmission - a[1].currentOmission)
                    .slice(0, 5)
                    .map(([num, data]) => {
                        const totalDraws = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : currentDatabaseData.draws.length;
                        const avgOmissionNum = data.count > 0 ? (totalDraws / data.count) : 0;
                        const wantProbability = data.currentOmission > 0 && avgOmissionNum > 0 ? ((data.currentOmission / avgOmissionNum) * 100).toFixed(2) : 0;
                        return {
                            num,
                            omission: data.currentOmission,
                            avgOmission: avgOmissionNum,
                            wantProbability: wantProbability
                        };
                    });

                const hotRedNumbers = Object.entries(redData)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 5)
                    .map(([num, data]) => num);

                const hotBlueNumbers = Object.entries(blueData)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 3)
                    .map(([num, data]) => num);

                predictionDiv.innerHTML = `
                    <h3><i class="fas fa-lightbulb"></i> 智能预测推荐</h3>
                    <div class="prediction-content">
                        <div class="prediction-item">
                            <h4>🔥 高欲出${rules.redBallName}</h4>
                            <div class="numbers">
                                ${redNumbers.map(n => `<span class="number" style="background: #E63946; color: white;">${n.num}</span>`).join('')}
                            </div>
                            <p style="margin-top: 10px; font-size: 12px; opacity: 0.9;">基于遗漏值和欲出概率分析</p>
                        </div>
                        <div class="prediction-item">
                            <h4>💧 高欲出${rules.blueBallName}</h4>
                            <div class="numbers">
                                ${blueNumbers.map(n => `<span class="number" style="background: #457B9D; color: white;">${n.num}</span>`).join('')}
                            </div>
                            <p style="margin-top: 10px; font-size: 12px; opacity: 0.9;">基于遗漏值和欲出概率分析</p>
                        </div>
                        <div class="prediction-item">
                            <h4>⭐ 热门${rules.redBallName}</h4>
                            <div class="numbers">
                                ${hotRedNumbers.map(n => `<span class="number" style="background: #F4A261; color: white;">${n}</span>`).join('')}
                            </div>
                            <p style="margin-top: 10px; font-size: 12px; opacity: 0.9;">近期开出频率最高</p>
                        </div>
                        <div class="prediction-item">
                            <h4>🌟 热门${rules.blueBallName}</h4>
                            <div class="numbers">
                                ${hotBlueNumbers.map(n => `<span class="number" style="background: #2A9D8F; color: white;">${n}</span>`).join('')}
                            </div>
                            <p style="margin-top: 10px; font-size: 12px; opacity: 0.9;">近期开出频率最高</p>
                        </div>
                    </div>
                `;
            }

            static handleHotColdAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodCount = currentOmissionPeriod !== 'all' ? currentOmissionPeriod : draws.length;
                    this.performSingleIndicatorAnalysis(draws.slice(-periodCount), periodCount);

                    MessageSystem.showMessage(`已完成${periodCount}期数据的冷热分析`, 'success');
                });
            }

            static performSingleIndicatorAnalysis(draws, periodCount) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];
                const blueBallCount = rules.blueBallRange[1];

                const redBallFrequency = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    redBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0
                    };
                }

                const blueBallFrequency = {};
                for (let i = 1; i <= blueBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    blueBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0
                    };
                }

                const reversedDraws = [...draws].reverse();

                reversedDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (redBallFrequency[ball]) {
                            redBallFrequency[ball].count++;
                        }
                    });

                    if (draw.blueBalls && draw.blueBalls.length > 0) {
                        draw.blueBalls.forEach(blueBall => {
                            const blueBallNum = blueBall.toString().padStart(2, '0');
                            if (blueBallFrequency[blueBallNum]) {
                                blueBallFrequency[blueBallNum].count++;
                            }
                        });
                    }
                });

                const analysisDraws = reversedDraws.slice(0, periodCount);

                for (let num in redBallFrequency) {
                    let omissionCount = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < analysisDraws.length; i++) {
                        const draw = analysisDraws[i];
                        if (draw.redBalls.includes(num)) {
                            omissionCount = 0;
                            found = true;

                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        redBallFrequency[num].currentOmission = periodCount;
                    } else {
                        redBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                }

                for (let num in blueBallFrequency) {
                    let omissionCount = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < analysisDraws.length; i++) {
                        const draw = analysisDraws[i];
                        let isMatched = false;
                        if (draw.blueBalls && draw.blueBalls.length > 0) {
                            draw.blueBalls.forEach(blueBall => {
                                const blueBallNum = blueBall.toString().padStart(2, '0');
                                if (blueBallNum === num) {
                                    isMatched = true;
                                }
                            });
                        }

                        if (isMatched) {
                            omissionCount = 0;
                            found = true;

                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        blueBallFrequency[num].currentOmission = periodCount;
                    } else {
                        blueBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                }

                this.updateSingleIndicatorChart(redBallFrequency, blueBallFrequency, periodCount);
            }

            static updateSingleIndicatorChart(redBallFrequency, blueBallFrequency, periodCount) {
                const chartDom = document.getElementById('singleIndicatorChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const ballNumbers = Object.keys(redBallFrequency).sort();
                const frequencyData = [];
                const omissionData = [];

                ballNumbers.forEach(num => {
                    const data = redBallFrequency[num];
                    frequencyData.push(data.count);
                    omissionData.push(data.currentOmission);
                });

                const totalDraws = Object.values(redBallFrequency).reduce((acc, item) => acc + item.count, 0);
                const avgFrequency = totalDraws / ballNumbers.length;

                let hotCount = 0;
                let coldCount = 0;

                ballNumbers.forEach(num => {
                    const data = redBallFrequency[num];
                    if (data.count > avgFrequency * 1.3) {
                        hotCount++;
                    } else if (data.count < avgFrequency * 0.7) {
                        coldCount++;
                    }
                });

                document.getElementById('single-period-count').textContent = periodCount;
                document.getElementById('single-hot-count').textContent = hotCount;
                document.getElementById('single-cold-count').textContent = coldCount;

                const option = {
                    title: {
                        text: `单号码指标分析（最近${periodCount}期）`,
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        }
                    },
                    legend: {
                        data: ['出现次数', '当前遗漏'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ballNumbers,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '出现次数',
                            position: 'left',
                            axisLabel: {
                                formatter: '{value}'
                            }
                        },
                        {
                            type: 'value',
                            name: '当前遗漏',
                            position: 'right',
                            axisLabel: {
                                formatter: '{value}'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: frequencyData,
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#E63946' },
                                    { offset: 1, color: '#D62828' }
                                ])
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}'
                            }
                        },
                        {
                            name: '当前遗漏',
                            type: 'line',
                            yAxisIndex: 1,
                            data: omissionData,
                            itemStyle: {
                                color: '#457B9D'
                            },
                            lineStyle: {
                                width: 2
                            },
                            symbol: 'circle',
                            symbolSize: 6,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c}'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                this.generateSingleIndicatorConclusions(redBallFrequency, avgFrequency, periodCount);
            }

            static generateSingleIndicatorConclusions(redBallFrequency, avgFrequency, periodCount) {
                const ballNumbers = Object.keys(redBallFrequency).sort();
                const hotNumbers = [];
                const coldNumbers = [];
                const warmNumbers = [];

                ballNumbers.forEach(num => {
                    const data = redBallFrequency[num];
                    if (data.count > avgFrequency * 1.3) {
                        hotNumbers.push({ num, count: data.count, omission: data.currentOmission });
                    } else if (data.count < avgFrequency * 0.7) {
                        coldNumbers.push({ num, count: data.count, omission: data.currentOmission });
                    } else {
                        warmNumbers.push({ num, count: data.count, omission: data.currentOmission });
                    }
                });

                hotNumbers.sort((a, b) => b.count - a.count);
                coldNumbers.sort((a, b) => a.count - b.count);

                const maxHot = hotNumbers.length > 0 ? hotNumbers[0] : null;
                const maxCold = coldNumbers.length > 0 ? coldNumbers[0] : null;

                let conclusionHtml = '<ul>';

                if (maxHot) {
                    conclusionHtml += `<li><strong>最热号码：</strong>${maxHot.num}，在最近${periodCount}期中出现${maxHot.count}次，当前遗漏${maxHot.omission}期。历史统计显示该号码在指定期数内出现频率最高。</li>`;
                }

                if (maxCold) {
                    conclusionHtml += `<li><strong>最冷号码：</strong>${maxCold.num}，在最近${periodCount}期中出现${maxCold.count}次，当前遗漏${maxCold.omission}期。历史统计显示该号码在指定期数内出现频率最低。</li>`;
                }

                conclusionHtml += `<li><strong>热号数量：</strong>${hotNumbers.length}个，温号数量：${warmNumbers.length}个，冷号数量：${coldNumbers.length}个。历史统计显示热号占比${(hotNumbers.length / ballNumbers.length * 100).toFixed(1)}%。</li>`;

                const avgOmission = ballNumbers.reduce((acc, num) => acc + redBallFrequency[num].currentOmission, 0) / ballNumbers.length;
                conclusionHtml += `<li><strong>平均遗漏：</strong>${avgOmission.toFixed(1)}期。历史统计显示号码平均遗漏周期为${avgOmission.toFixed(1)}期。</li>`;

                const highOmissionNumbers = ballNumbers.filter(num => redBallFrequency[num].currentOmission > avgOmission * 1.5);
                if (highOmissionNumbers.length > 0) {
                    conclusionHtml += `<li><strong>高遗漏号码：</strong>${highOmissionNumbers.slice(0, 5).join('、')}等${highOmissionNumbers.length}个号码当前遗漏超过平均值的1.5倍。历史统计显示这些号码在指定期数内出现较少。</li>`;
                }

                conclusionHtml += '</ul>';

                document.getElementById('singleConclusionContent').innerHTML = conclusionHtml;
            }

            static performIntervalBreakdownAnalysis(draws, periodCount) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];

                const intervalSize = 5;
                const totalIntervals = Math.ceil(redBallCount / intervalSize);

                const intervalData = {};
                for (let i = 0; i < totalIntervals; i++) {
                    const startNum = i * intervalSize + 1;
                    const endNum = Math.min((i + 1) * intervalSize, redBallCount);
                    const intervalName = `${startNum.toString().padStart(2, '0')}-${endNum.toString().padStart(2, '0')}`;

                    intervalData[intervalName] = {
                        numbers: [],
                        count: 0,
                        percentage: 0
                    };

                    for (let j = startNum; j <= endNum; j++) {
                        intervalData[intervalName].numbers.push(j.toString().padStart(2, '0'));
                    }
                }

                const analysisDraws = draws.slice(-periodCount);

                analysisDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        for (let intervalName in intervalData) {
                            if (intervalData[intervalName].numbers.includes(ball)) {
                                intervalData[intervalName].count++;
                                break;
                            }
                        }
                    });
                });

                const totalOccurrences = Object.values(intervalData).reduce((acc, item) => acc + item.count, 0);
                const theoreticalPercentage = 100 / totalIntervals;

                for (let intervalName in intervalData) {
                    intervalData[intervalName].percentage = (intervalData[intervalName].count / totalOccurrences * 100).toFixed(2);
                }

                document.getElementById('interval-period-count').textContent = periodCount;
                document.getElementById('interval-division').textContent = `${intervalSize}个号码/区间，共${totalIntervals}个区间`;

                this.updateIntervalDistributionChart(intervalData, theoreticalPercentage);
                this.updateIntervalPieChart(intervalData);
                this.generateIntervalBreakdownConclusions(intervalData, theoreticalPercentage, periodCount);
            }

            static updateIntervalDistributionChart(intervalData, theoreticalPercentage) {
                const chartDom = document.getElementById('intervalDistributionChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const intervals = Object.keys(intervalData).sort();
                const counts = intervals.map(name => intervalData[name].count);
                const percentages = intervals.map(name => parseFloat(intervalData[name].percentage));
                const deviations = percentages.map(p => (p - theoreticalPercentage).toFixed(2));

                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);

                const barColors = counts.map(count => {
                    const ratio = (count - minCount) / (maxCount - minCount || 1);
                    if (ratio < 0.3) {
                        return '#457B9D';
                    } else if (ratio < 0.7) {
                        return '#F4A261';
                    } else {
                        return '#E63946';
                    }
                });

                const option = {
                    title: {
                        text: '区间分布柱状图',
                        left: 'center',
                        top: 10
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const data = params[0];
                            const intervalName = data.name;
                            const count = data.value;
                            const percentage = percentages[data.dataIndex];
                            const deviation = deviations[data.dataIndex];
                            const deviationType = deviation > 0 ? '高于' : deviation < 0 ? '低于' : '等于';
                            const color = deviation > 0 ? '#E63946' : deviation < 0 ? '#457B9D' : '#2ECC71';

                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">区间${intervalName}</div>
                                    <div style="margin-bottom: 3px;">出现次数: <span style="color: #E63946; font-weight: bold;">${count}次</span></div>
                                    <div style="margin-bottom: 3px;">占比: <span style="color: #9B59B6; font-weight: bold;">${percentage}%</span></div>
                                    <div style="margin-bottom: 3px;">理论占比: <span style="color: #3498DB; font-weight: bold;">${theoreticalPercentage.toFixed(2)}%</span></div>
                                    <div style="margin-bottom: 3px;">偏差: <span style="color: ${color}; font-weight: bold;">${deviationType}理论值${Math.abs(deviation)}%</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: intervals,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数'
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: counts,
                            itemStyle: {
                                color: function(params) {
                                    return barColors[params.dataIndex];
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: function(params) {
                                    return `${params.value}次\n${percentages[params.dataIndex]}%`;
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updateIntervalPieChart(intervalData) {
                const chartDom = document.getElementById('intervalPieChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const intervals = Object.keys(intervalData).sort();
                const data = intervals.map(name => ({
                    name: name,
                    value: intervalData[name].count
                }));

                const total = data.reduce((acc, item) => acc + item.value, 0);

                const option = {
                    title: {
                        text: '区间分布饼图',
                        left: 'center',
                        top: 10
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            const percentage = (params.value / total * 100).toFixed(2);
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">区间${params.name}</div>
                                    <div style="margin-bottom: 3px;">出现次数: <span style="color: #E63946; font-weight: bold;">${params.value}次</span></div>
                                    <div style="margin-bottom: 3px;">占比: <span style="color: #9B59B6; font-weight: bold;">${percentage}%</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        top: 'middle'
                    },
                    series: [
                        {
                            name: '区间分布',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['60%', '50%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            label: {
                                show: true,
                                formatter: '{b}\n{c}次\n({d}%)'
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 16,
                                    fontWeight: 'bold'
                                }
                            },
                            data: data
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateIntervalBreakdownConclusions(intervalData, theoreticalPercentage, periodCount) {
                const intervals = Object.keys(intervalData).sort();
                const sortedByCount = [...intervals].sort((a, b) => intervalData[b].count - intervalData[a].count);
                const sortedByPercentage = [...intervals].sort((a, b) => parseFloat(intervalData[b].percentage) - parseFloat(intervalData[a].percentage));

                const maxInterval = sortedByCount[0];
                const minInterval = sortedByCount[sortedByCount.length - 1];

                const maxCount = intervalData[maxInterval].count;
                const minCount = intervalData[minInterval].count;
                const maxPercentage = parseFloat(intervalData[maxInterval].percentage);
                const minPercentage = parseFloat(intervalData[minInterval].percentage);

                const maxDeviation = maxPercentage - theoreticalPercentage;
                const minDeviation = minPercentage - theoreticalPercentage;

                const aboveAverageIntervals = intervals.filter(name => parseFloat(intervalData[name].percentage) > theoreticalPercentage);
                const belowAverageIntervals = intervals.filter(name => parseFloat(intervalData[name].percentage) < theoreticalPercentage);

                let conclusionHtml = '<ul>';

                conclusionHtml += `<li><strong>最热区间：</strong>区间${maxInterval}，在最近${periodCount}期中出现${maxCount}次，占比${maxPercentage}%，高于理论值${Math.abs(maxDeviation).toFixed(2)}%。历史统计显示该区间在指定期数内出现频率最高。</li>`;

                conclusionHtml += `<li><strong>最冷区间：</strong>区间${minInterval}，在最近${periodCount}期中出现${minCount}次，占比${minPercentage}%，低于理论值${Math.abs(minDeviation).toFixed(2)}%。历史统计显示该区间在指定期数内出现频率最低。</li>`;

                conclusionHtml += `<li><strong>区间分布：</strong>高于理论平均值的区间有${aboveAverageIntervals.length}个（${aboveAverageIntervals.join('、')}），低于理论平均值的区间有${belowAverageIntervals.length}个（${belowAverageIntervals.join('、')}）。历史统计显示区间分布${aboveAverageIntervals.length > belowAverageIntervals.length ? '偏向高值' : aboveAverageIntervals.length < belowAverageIntervals.length ? '偏向低值' : '较为均衡'}。</li>`;

                const variance = intervals.reduce((acc, name) => {
                    const deviation = parseFloat(intervalData[name].percentage) - theoreticalPercentage;
                    return acc + deviation * deviation;
                }, 0) / intervals.length;

                const stdDev = Math.sqrt(variance);

                conclusionHtml += `<li><strong>分布均匀度：</strong>标准差为${stdDev.toFixed(2)}%。历史统计显示${stdDev < 5 ? '区间分布较为均匀，各区间出现频率差异较小' : stdDev < 10 ? '区间分布存在一定差异，部分区间出现频率偏高或偏低' : '区间分布差异较大，存在明显的冷热区间'}。</li>`;

                const highFrequencyIntervals = intervals.filter(name => parseFloat(intervalData[name].percentage) > theoreticalPercentage * 1.2);
                const lowFrequencyIntervals = intervals.filter(name => parseFloat(intervalData[name].percentage) < theoreticalPercentage * 0.8);

                if (highFrequencyIntervals.length > 0) {
                    conclusionHtml += `<li><strong>高频区间：</strong>${highFrequencyIntervals.join('、')}等${highFrequencyIntervals.length}个区间占比超过理论值的20%。历史统计显示这些区间在指定期数内出现较多。</li>`;
                }

                if (lowFrequencyIntervals.length > 0) {
                    conclusionHtml += `<li><strong>低频区间：</strong>${lowFrequencyIntervals.join('、')}等${lowFrequencyIntervals.length}个区间占比低于理论值的20%。历史统计显示这些区间在指定期数内出现较少。</li>`;
                }

                conclusionHtml += '</ul>';

                document.getElementById('intervalConclusionContent').innerHTML = conclusionHtml;
            }

            static performHotColdAnalysis(draws, periodCount) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];
                const blueBallCount = rules.blueBallRange[1];

                const analysisDraws = draws.slice(-periodCount);
                const advancedHotColdData = this.calculateAdvancedHotCold(analysisDraws);

                const redBallFrequency = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    const data = advancedHotColdData[num];
                    redBallFrequency[num] = {
                        count: data.shortTermCount,
                        currentOmission: data.currentOmission,
                        hotColdScore: data.hotColdScore,
                        hotColdState: data.hotColdState,
                        hotColdTrend: data.hotColdTrend,
                        hotColdIntensity: data.hotColdIntensity,
                        hotColdPersistence: data.hotColdPersistence,
                        hotColdPredictability: data.hotColdPredictability,
                        hotColdReasonableness: data.hotColdReasonableness,
                        hotColdRecommendation: data.hotColdRecommendation,
                        hotColdConfidence: data.hotColdConfidence
                    };
                }

                const blueBallFrequency = {};
                for (let i = 1; i <= blueBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    blueBallFrequency[num] = {
                        count: 0,
                        currentOmission: 0
                    };
                }

                const reversedDraws = [...draws].reverse();
                const analysisReversedDraws = reversedDraws.slice(0, periodCount);

                analysisReversedDraws.forEach(draw => {
                    if (draw.blueBalls && draw.blueBalls.length > 0) {
                        draw.blueBalls.forEach(blueBall => {
                            const blueBallNum = blueBall.toString().padStart(2, '0');
                            if (blueBallFrequency[blueBallNum]) {
                                blueBallFrequency[blueBallNum].count++;
                            }
                        });
                    }
                });

                for (let num in blueBallFrequency) {
                    let omissionCount = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < analysisReversedDraws.length; i++) {
                        const draw = analysisReversedDraws[i];
                        let isMatched = false;
                        if (draw.blueBalls && draw.blueBalls.length > 0) {
                            draw.blueBalls.forEach(blueBall => {
                                const blueBallNum = blueBall.toString().padStart(2, '0');
                                if (blueBallNum === num) {
                                    isMatched = true;
                                }
                            });
                        }

                        if (isMatched) {
                            omissionCount = 0;
                            found = true;

                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        blueBallFrequency[num].currentOmission = periodCount;
                    } else {
                        blueBallFrequency[num].currentOmission = firstAppearanceIndex;
                    }
                }

                this.updateHotColdChart(redBallFrequency, blueBallFrequency);
                this.updateHotColdTrendChart(draws, redBallFrequency, blueBallFrequency);
            }

            static updateHotColdChart(redBallFrequency, blueBallFrequency) {
                const chartDom = document.getElementById('hotColdChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const ballNumbers = Object.keys(redBallFrequency).sort();
                const hotData = [];
                const warmData = [];
                const coldData = [];

                const totalDraws = Object.values(redBallFrequency).reduce((acc, item) => acc + item.count, 0);
                const avgFrequency = totalDraws / ballNumbers.length;

                ballNumbers.forEach(num => {
                    const data = redBallFrequency[num];
                    if (data.hotColdState === '超热' || data.hotColdState === '热') {
                        hotData.push(1);
                        warmData.push(0);
                        coldData.push(0);
                    } else if (data.hotColdState === '超冷' || data.hotColdState === '冷') {
                        hotData.push(0);
                        warmData.push(0);
                        coldData.push(1);
                    } else {
                        hotData.push(0);
                        warmData.push(1);
                        coldData.push(0);
                    }
                });

                const option = {
                    title: {
                        text: '冷热号码分布',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const num = param.name;
                            const data = redBallFrequency[num];
                            const state = data.hotColdState;
                            const stateColor = state === '超热' || state === '热' ? '#E63946' : state === '超冷' || state === '冷' ? '#457B9D' : '#F4A261';
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${num}</div>
                                    <div style="margin-bottom: 3px;">冷热状态：<span style="color: ${stateColor}; font-weight: bold;">${state}</span></div>
                                    <div style="margin-bottom: 3px;">冷热评分：<span style="color: #E63946;">${data.hotColdScore.toFixed(1)}分</span></div>
                                    <div style="margin-bottom: 3px;">冷热强度：<span style="color: #F4A261;">${data.hotColdIntensity.toFixed(1)}%</span></div>
                                    <div style="margin-bottom: 3px;">冷热趋势：<span style="color: #2A9D8F;">${data.hotColdTrend}</span></div>
                                    <div style="margin-bottom: 3px;">冷热持续性：<span style="color: #9B59B6;">${data.hotColdPersistence.toFixed(1)}%</span></div>
                                    <div style="margin-bottom: 3px;">冷热可预测性：<span style="color: #3498DB;">${data.hotColdPredictability.toFixed(1)}%</span></div>
                                    <div style="margin-bottom: 3px;">合理性评估：<span style="color: #27AE60; font-weight: bold;">${data.hotColdReasonableness}</span></div>
                                    <div style="margin-bottom: 3px;">当前遗漏：<span style="color: #E67E22;">${data.currentOmission}期</span></div>
                                    <div style="margin-bottom: 3px;">推荐建议：<span style="color: #D35400;">${data.hotColdRecommendation}</span></div>
                                    <div>置信度：<span style="color: #16A085; font-weight: bold;">${data.hotColdConfidence.toFixed(1)}%</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['热号', '温号', '冷号'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ballNumbers,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        max: 1,
                        axisLabel: {
                            formatter: function(value) {
                                return value === 1 ? '是' : '';
                            }
                        }
                    },
                    series: [
                        {
                            name: '热号',
                            type: 'bar',
                            stack: 'total',
                            data: hotData,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '温号',
                            type: 'bar',
                            stack: 'total',
                            data: warmData,
                            itemStyle: {
                                color: '#F4A261'
                            }
                        },
                        {
                            name: '冷号',
                            type: 'bar',
                            stack: 'total',
                            data: coldData,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updateHotColdTrendChart(draws, redBallFrequency, blueBallFrequency) {
                const chartDom = document.getElementById('hotColdTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const recentDraws = draws.slice(-20);
                const periods = recentDraws.map(draw => draw.period);

                const hotCounts = [];
                const warmCounts = [];
                const coldCounts = [];

                const totalDraws = Object.values(redBallFrequency).reduce((acc, item) => acc + item.count, 0);
                const avgFrequency = totalDraws / Object.keys(redBallFrequency).length;

                recentDraws.forEach(draw => {
                    let hotCount = 0;
                    let warmCount = 0;
                    let coldCount = 0;

                    draw.redBalls.forEach(ball => {
                        const data = redBallFrequency[ball];
                        if (data.count > avgFrequency * 1.3) {
                            hotCount++;
                        } else if (data.count < avgFrequency * 0.7) {
                            coldCount++;
                        } else {
                            warmCount++;
                        }
                    });

                    hotCounts.push(hotCount);
                    warmCounts.push(warmCount);
                    coldCounts.push(coldCount);
                });

                const option = {
                    title: {
                        text: '冷热趋势变化（最近20期）',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    legend: {
                        data: ['热号数量', '温号数量', '冷号数量'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value'
                    },
                    series: [
                        {
                            name: '热号数量',
                            type: 'line',
                            data: hotCounts,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '温号数量',
                            type: 'line',
                            data: warmCounts,
                            smooth: true,
                            itemStyle: {
                                color: '#F4A261'
                            }
                        },
                        {
                            name: '冷号数量',
                            type: 'line',
                            data: coldCounts,
                            smooth: true,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static performCombinationFeatureAnalysis(draws, periodCount) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];

                const numberFeatures = {};
                for (let i = 1; i <= redBallCount; i++) {
                    const num = i.toString().padStart(2, '0');
                    numberFeatures[num] = {
                        frequency: 0,
                        omission: 0,
                        continuity: 0,
                        recentActivity: 0,
                        stability: 0
                    };
                }

                const analysisDraws = draws.slice(-periodCount);
                const reversedDraws = [...analysisDraws].reverse();

                reversedDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberFeatures[ball]) {
                            numberFeatures[ball].frequency++;
                        }
                    });
                });

                const totalDraws = Object.values(numberFeatures).reduce((acc, item) => acc + item.frequency, 0);
                const avgFrequency = totalDraws / redBallCount;

                for (let num in numberFeatures) {
                    let omissionCount = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let i = 0; i < reversedDraws.length; i++) {
                        const draw = reversedDraws[i];
                        if (draw.redBalls.includes(num)) {
                            omissionCount = 0;
                            found = true;

                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = i;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        numberFeatures[num].omission = periodCount;
                    } else {
                        numberFeatures[num].omission = firstAppearanceIndex;
                    }
                }

                reversedDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberFeatures[ball]) {
                            numberFeatures[ball].continuity++;
                        }
                    });
                });

                const recentDraws = reversedDraws.slice(0, Math.min(10, reversedDraws.length));
                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        if (numberFeatures[ball]) {
                            numberFeatures[ball].recentActivity++;
                        }
                    });
                });

                const frequencyValues = Object.values(numberFeatures).map(item => item.frequency);
                const avgFreq = frequencyValues.reduce((a, b) => a + b, 0) / frequencyValues.length;
                const stdFreq = Math.sqrt(frequencyValues.reduce((acc, val) => acc + Math.pow(val - avgFreq, 2), 0) / frequencyValues.length);

                for (let num in numberFeatures) {
                    const freqDeviation = Math.abs(numberFeatures[num].frequency - avgFreq);
                    numberFeatures[num].stability = Math.max(0, 100 - (freqDeviation / (stdFreq || 1)) * 50);
                }

                const topNumbers = Object.keys(numberFeatures)
                    .sort((a, b) => numberFeatures[b].frequency - numberFeatures[a].frequency)
                    .slice(0, 10);

                document.getElementById('combination-period-count').textContent = periodCount;

                this.updateCombinationRadarChart(numberFeatures, topNumbers);
                this.generateCombinationFeatureConclusions(numberFeatures, topNumbers, periodCount);
            }

            static updateCombinationRadarChart(numberFeatures, topNumbers) {
                const chartDom = document.getElementById('combinationRadarChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const indicators = [
                    { name: '出现频率', max: 100 },
                    { name: '遗漏程度', max: 100 },
                    { name: '连续性', max: 100 },
                    { name: '近期活跃度', max: 100 },
                    { name: '稳定性', max: 100 }
                ];

                const seriesData = topNumbers.map(num => {
                    const features = numberFeatures[num];
                    const maxFreq = Math.max(...Object.values(numberFeatures).map(item => item.frequency));
                    const maxOmission = Math.max(...Object.values(numberFeatures).map(item => item.omission));
                    const maxContinuity = Math.max(...Object.values(numberFeatures).map(item => item.continuity));
                    const maxRecentActivity = Math.max(...Object.values(numberFeatures).map(item => item.recentActivity));

                    const normalizedFreq = (features.frequency / (maxFreq || 1)) * 100;
                    const normalizedOmission = (features.omission / (maxOmission || 1)) * 100;
                    const normalizedContinuity = (features.continuity / (maxContinuity || 1)) * 100;
                    const normalizedRecentActivity = (features.recentActivity / (maxRecentActivity || 1)) * 100;
                    const normalizedStability = features.stability;

                    return {
                        value: [
                            normalizedFreq.toFixed(2),
                            normalizedOmission.toFixed(2),
                            normalizedContinuity.toFixed(2),
                            normalizedRecentActivity.toFixed(2),
                            normalizedStability.toFixed(2)
                        ],
                        name: num
                    };
                });

                const colors = ['#E63946', '#D62828', '#F4A261', '#E9C46A', '#2A9D8F', '#264653', '#457B9D', '#1D3557', '#A8DADC', '#F1FAEE'];

                const option = {
                    title: {
                        text: '号码组合特征雷达图（前10个号码）',
                        left: 'center',
                        top: 10
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            const features = numberFeatures[params.name];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码${params.name}</div>
                                    <div style="margin-bottom: 3px;">出现频率: <span style="color: #E63946; font-weight: bold;">${features.frequency}次</span></div>
                                    <div style="margin-bottom: 3px;">当前遗漏: <span style="color: #457B9D; font-weight: bold;">${features.omission}期</span></div>
                                    <div style="margin-bottom: 3px;">连续性: <span style="color: #F4A261; font-weight: bold;">${features.continuity}次</span></div>
                                    <div style="margin-bottom: 3px;">近期活跃度: <span style="color: #2A9D8F; font-weight: bold;">${features.recentActivity}次</span></div>
                                    <div style="margin-bottom: 3px;">稳定性: <span style="color: #264653; font-weight: bold;">${features.stability.toFixed(1)}分</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: topNumbers,
                        orient: 'vertical',
                        left: 'left',
                        top: 'middle',
                        type: 'scroll'
                    },
                    radar: {
                        indicator: indicators,
                        radius: '65%',
                        center: ['60%', '50%'],
                        splitNumber: 5,
                        name: {
                            textStyle: {
                                color: '#2c3e50',
                                fontSize: 12,
                                fontWeight: 'bold'
                            }
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(69, 123, 157, 0.2)'
                            }
                        },
                        splitArea: {
                            show: true,
                            areaStyle: {
                                color: ['rgba(230, 57, 70, 0.05)', 'rgba(69, 123, 157, 0.05)']
                            }
                        },
                        axisLine: {
                            lineStyle: {
                                color: 'rgba(69, 123, 157, 0.3)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '组合特征',
                            type: 'radar',
                            data: seriesData,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 2
                            },
                            itemStyle: {
                                color: function(params) {
                                    return colors[params.dataIndex % colors.length];
                                }
                            },
                            areaStyle: {
                                opacity: 0.2
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateCombinationFeatureConclusions(numberFeatures, topNumbers, periodCount) {
                const sortedByFrequency = [...topNumbers].sort((a, b) => numberFeatures[b].frequency - numberFeatures[a].frequency);
                const sortedByStability = [...topNumbers].sort((a, b) => numberFeatures[b].stability - numberFeatures[a].stability);
                const sortedByRecentActivity = [...topNumbers].sort((a, b) => numberFeatures[b].recentActivity - numberFeatures[a].recentActivity);

                const highestFrequency = sortedByFrequency[0];
                const highestStability = sortedByStability[0];
                const highestRecentActivity = sortedByRecentActivity[0];

                const avgFrequency = Object.values(numberFeatures).reduce((acc, item) => acc + item.frequency, 0) / Object.keys(numberFeatures).length;
                const avgOmission = Object.values(numberFeatures).reduce((acc, item) => acc + item.omission, 0) / Object.keys(numberFeatures).length;
                const avgStability = Object.values(numberFeatures).reduce((acc, item) => acc + item.stability, 0) / Object.keys(numberFeatures).length;

                const highFrequencyNumbers = Object.keys(numberFeatures).filter(num => numberFeatures[num].frequency > avgFrequency * 1.5);
                const lowOmissionNumbers = Object.keys(numberFeatures).filter(num => numberFeatures[num].omission < avgOmission * 0.5);
                const highStabilityNumbers = Object.keys(numberFeatures).filter(num => numberFeatures[num].stability > avgStability * 1.2);

                let conclusionHtml = '<ul>';

                conclusionHtml += `<li><strong>最高频率号码：</strong>号码${highestFrequency}，在最近${periodCount}期中出现${numberFeatures[highestFrequency].frequency}次。历史统计显示该号码在指定期数内出现频率最高。</li>`;

                conclusionHtml += `<li><strong>最稳定号码：</strong>号码${highestStability}，稳定性得分${numberFeatures[highestStability].stability.toFixed(1)}分。历史统计显示该号码出现频率波动较小，表现稳定。</li>`;

                conclusionHtml += `<li><strong>近期最活跃号码：</strong>号码${highestRecentActivity}，最近10期出现${numberFeatures[highestRecentActivity].recentActivity}次。历史统计显示该号码近期表现活跃。</li>`;

                conclusionHtml += `<li><strong>高频号码：</strong>${highFrequencyNumbers.slice(0, 5).join('、')}等${highFrequencyNumbers.length}个号码出现频率超过平均值的1.5倍。历史统计显示这些号码在指定期数内出现较多。</li>`;

                conclusionHtml += `<li><strong>低遗漏号码：</strong>${lowOmissionNumbers.slice(0, 5).join('、')}等${lowOmissionNumbers.length}个号码当前遗漏低于平均值的50%。历史统计显示这些号码近期出现较为频繁。</li>`;

                conclusionHtml += `<li><strong>高稳定性号码：</strong>${highStabilityNumbers.slice(0, 5).join('、')}等${highStabilityNumbers.length}个号码稳定性得分超过平均值的1.2倍。历史统计显示这些号码出现频率较为稳定。</li>`;

                const balancedNumbers = topNumbers.filter(num => {
                    const features = numberFeatures[num];
                    return features.frequency > avgFrequency && features.omission < avgOmission && features.stability > avgStability;
                });

                if (balancedNumbers.length > 0) {
                    conclusionHtml += `<li><strong>均衡表现号码：</strong>${balancedNumbers.join('、')}等${balancedNumbers.length}个号码在频率、遗漏和稳定性方面表现均衡。历史统计显示这些号码各项指标均处于较好水平。</li>`;
                }

                const highContinuityNumbers = Object.keys(numberFeatures).filter(num => numberFeatures[num].continuity > avgFrequency * 1.2);
                if (highContinuityNumbers.length > 0) {
                    conclusionHtml += `<li><strong>高连续性号码：</strong>${highContinuityNumbers.slice(0, 5).join('、')}等${highContinuityNumbers.length}个号码连续出现次数较多。历史统计显示这些号码具有较好的连续性特征。</li>`;
                }

                conclusionHtml += '</ul>';

                document.getElementById('combinationConclusionContent').innerHTML = conclusionHtml;
            }

            static performTrendChangeAnalysis(draws, periodCount) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallRange[1];

                const analysisDraws = draws.slice(-periodCount);
                const reversedDraws = [...analysisDraws].reverse();

                const segmentSize = Math.max(5, Math.floor(periodCount / 10));
                const segments = [];

                for (let i = 0; i < reversedDraws.length; i += segmentSize) {
                    const segment = reversedDraws.slice(i, i + segmentSize);
                    const segmentNumberCounts = {};

                    for (let j = 1; j <= redBallCount; j++) {
                        const num = j.toString().padStart(2, '0');
                        segmentNumberCounts[num] = 0;
                    }

                    segment.forEach(draw => {
                        draw.redBalls.forEach(ball => {
                            if (segmentNumberCounts[ball] !== undefined) {
                                segmentNumberCounts[ball]++;
                            }
                        });
                    });

                    segments.push({
                        name: `第${Math.floor(i / segmentSize) + 1}段`,
                        data: segmentNumberCounts
                    });
                }

                const heatmapData = [];
                const numbers = [];
                for (let j = 1; j <= redBallCount; j++) {
                    numbers.push(j.toString().padStart(2, '0'));
                }

                segments.forEach((segment, segIndex) => {
                    numbers.forEach(num => {
                        heatmapData.push([segIndex, numbers.indexOf(num), segment.data[num]]);
                    });
                });

                const trendData = this.calculateTrendData(segments, numbers);

                document.getElementById('trend-period-count').textContent = periodCount;
                document.getElementById('trend-cycle').textContent = `${segmentSize}期/段，共${segments.length}段`;

                this.updateTrendHeatmapChart(heatmapData, numbers, segments);
                this.generateTrendChangeConclusions(trendData, periodCount, segmentSize);
            }

            static calculateTrendData(segments, numbers) {
                const trendData = {
                    risingNumbers: [],
                    fallingNumbers: [],
                    stableNumbers: [],
                    hotNumbers: [],
                    coldNumbers: [],
                    periodicNumbers: []
                };

                if (segments.length < 2) return trendData;

                const firstSegment = segments[0].data;
                const lastSegment = segments[segments.length - 1].data;
                const allSegments = segments.map(seg => seg.data);

                numbers.forEach(num => {
                    const firstCount = firstSegment[num];
                    const lastCount = lastSegment[num];
                    const avgCount = allSegments.reduce((sum, seg) => sum + seg[num], 0) / allSegments.length;

                    const change = lastCount - firstCount;
                    const changePercent = firstCount > 0 ? (change / firstCount) * 100 : 0;

                    if (changePercent > 20) {
                        trendData.risingNumbers.push({ number: num, changePercent: changePercent.toFixed(1) });
                    } else if (changePercent < -20) {
                        trendData.fallingNumbers.push({ number: num, changePercent: changePercent.toFixed(1) });
                    }

                    const variance = allSegments.reduce((sum, seg) => sum + Math.pow(seg[num] - avgCount, 2), 0) / allSegments.length;
                    const stdDev = Math.sqrt(variance);
                    const coefficientOfVariation = avgCount > 0 ? (stdDev / avgCount) * 100 : 0;

                    if (coefficientOfVariation < 30) {
                        trendData.stableNumbers.push({ number: num, coefficientOfVariation: coefficientOfVariation.toFixed(1) });
                    }

                    if (lastCount > avgCount * 1.5) {
                        trendData.hotNumbers.push({ number: num, frequency: lastCount });
                    } else if (lastCount < avgCount * 0.5) {
                        trendData.coldNumbers.push({ number: num, frequency: lastCount });
                    }

                    let periodicity = 0;
                    for (let i = 1; i < allSegments.length; i++) {
                        if (allSegments[i][num] > 0 && allSegments[i - 1][num] > 0) {
                            periodicity++;
                        }
                    }

                    if (periodicity >= allSegments.length * 0.4) {
                        trendData.periodicNumbers.push({ number: num, periodicity: periodicity });
                    }
                });

                trendData.risingNumbers.sort((a, b) => parseFloat(b.changePercent) - parseFloat(a.changePercent));
                trendData.fallingNumbers.sort((a, b) => parseFloat(a.changePercent) - parseFloat(b.changePercent));
                trendData.stableNumbers.sort((a, b) => parseFloat(a.coefficientOfVariation) - parseFloat(b.coefficientOfVariation));
                trendData.hotNumbers.sort((a, b) => b.frequency - a.frequency);
                trendData.coldNumbers.sort((a, b) => a.frequency - b.frequency);
                trendData.periodicNumbers.sort((a, b) => b.periodicity - a.periodicity);

                return trendData;
            }

            static updateTrendHeatmapChart(heatmapData, numbers, segments) {
                const chartDom = document.getElementById('trendHeatmapChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const segmentNames = segments.map(seg => seg.name);

                const option = {
                    title: {
                        text: '号码出现频率趋势热力图',
                        left: 'center',
                        top: 10
                    },
                    tooltip: {
                        position: 'top',
                        formatter: function(params) {
                            const segmentName = segmentNames[params.value[0]];
                            const number = numbers[params.value[1]];
                            const count = params.value[2];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">${segmentName} - 号码${number}</div>
                                    <div>出现次数: <span style="color: #E63946; font-weight: bold;">${count}次</span></div>
                                </div>
                            `;
                        }
                    },
                    grid: {
                        height: '70%',
                        top: '15%',
                        left: '10%',
                        right: '5%'
                    },
                    xAxis: {
                        type: 'category',
                        data: segmentNames,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            rotate: 45,
                            fontSize: 10
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: numbers,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            fontSize: 10
                        }
                    },
                    visualMap: {
                        min: 0,
                        max: Math.max(...heatmapData.map(item => item[2])),
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '5%',
                        inRange: {
                            color: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b']
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'heatmap',
                            data: heatmapData,
                            label: {
                                show: true,
                                fontSize: 10,
                                color: '#2c3e50'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateTrendChangeConclusions(trendData, periodCount, segmentSize) {
                let conclusionHtml = '<ul>';

                if (trendData.risingNumbers.length > 0) {
                    const topRising = trendData.risingNumbers.slice(0, 5);
                    conclusionHtml += `<li><strong>上升趋势号码：</strong>${topRising.map(item => item.number).join('、')}等${trendData.risingNumbers.length}个号码。历史统计显示这些号码在分析期数内出现频率呈上升趋势，其中${topRising[0].number}上升幅度最大（${topRising[0].changePercent}%）。</li>`;
                }

                if (trendData.fallingNumbers.length > 0) {
                    const topFalling = trendData.fallingNumbers.slice(0, 5);
                    conclusionHtml += `<li><strong>下降趋势号码：</strong>${topFalling.map(item => item.number).join('、')}等${trendData.fallingNumbers.length}个号码。历史统计显示这些号码在分析期数内出现频率呈下降趋势，其中${topFalling[0].number}下降幅度最大（${topFalling[0].changePercent}%）。</li>`;
                }

                if (trendData.stableNumbers.length > 0) {
                    const topStable = trendData.stableNumbers.slice(0, 5);
                    conclusionHtml += `<li><strong>稳定表现号码：</strong>${topStable.map(item => item.number).join('、')}等${trendData.stableNumbers.length}个号码。历史统计显示这些号码在各时间段内出现频率波动较小，表现稳定，其中${topStable[0].number}变异系数最小（${topStable[0].coefficientOfVariation}%）。</li>`;
                }

                if (trendData.hotNumbers.length > 0) {
                    const topHot = trendData.hotNumbers.slice(0, 5);
                    conclusionHtml += `<li><strong>近期热门号码：</strong>${topHot.map(item => item.number).join('、')}等${trendData.hotNumbers.length}个号码。历史统计显示这些号码在最近时间段内出现频率较高，其中${topHot[0].number}出现${topHot[0].frequency}次。</li>`;
                }

                if (trendData.coldNumbers.length > 0) {
                    const topCold = trendData.coldNumbers.slice(0, 5);
                    conclusionHtml += `<li><strong>近期冷门号码：</strong>${topCold.map(item => item.number).join('、')}等${trendData.coldNumbers.length}个号码。历史统计显示这些号码在最近时间段内出现频率较低，其中${topCold[0].number}仅出现${topCold[0].frequency}次。</li>`;
                }

                if (trendData.periodicNumbers.length > 0) {
                    const topPeriodic = trendData.periodicNumbers.slice(0, 5);
                    conclusionHtml += `<li><strong>周期性号码：</strong>${topPeriodic.map(item => item.number).join('、')}等${trendData.periodicNumbers.length}个号码。历史统计显示这些号码在多个时间段内连续出现，具有一定的周期性特征，其中${topPeriodic[0].number}周期性最强（连续${topPeriodic[0].periodicity}个时间段出现）。</li>`;
                }

                conclusionHtml += `<li><strong>分析说明：</strong>本分析将${periodCount}期数据按${segmentSize}期为一个时间段进行分段统计，通过热力图直观展示各号码在不同时间段的出现频率变化。所有结论均基于历史统计数据，反映号码在指定期数内的统计特征。</li>`;

                conclusionHtml += '</ul>';

                document.getElementById('trendConclusionContent').innerHTML = conclusionHtml;
            }

            static handleOddEvenAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    this.performOddEvenAnalysis(draws);

                    MessageSystem.showMessage(`已完成${draws.length}期数据的奇偶分析`, 'success');
                });
            }

            static performOddEvenAnalysis(draws) {
                const oddEvenData = {
                    oddCount: 0,
                    evenCount: 0,
                    trend: []
                };

                const reversedDraws = [...draws].reverse();

                reversedDraws.forEach(draw => {
                    let oddCount = 0;
                    let evenCount = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num % 2 === 0) {
                            evenCount++;
                        } else {
                            oddCount++;
                        }
                    });

                    oddEvenData.oddCount += oddCount;
                    oddEvenData.evenCount += evenCount;

                    oddEvenData.trend.push({
                        period: draw.period,
                        odd: oddCount,
                        even: evenCount
                    });
                });

                this.updateOddEvenChart(oddEvenData);
                this.updateOddEvenPieChart(oddEvenData);
            }

            static updateOddEvenChart(oddEvenData) {
                const chartDom = document.getElementById('oddEvenChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const periods = oddEvenData.trend.slice(-20).map(item => item.period);
                const oddData = oddEvenData.trend.slice(-20).map(item => item.odd);
                const evenData = oddEvenData.trend.slice(-20).map(item => item.even);

                const option = {
                    title: {
                        text: '奇偶分布趋势（最近20期）',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    legend: {
                        data: ['奇数', '偶数'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value'
                    },
                    series: [
                        {
                            name: '奇数',
                            type: 'line',
                            data: oddData,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '偶数',
                            type: 'line',
                            data: evenData,
                            smooth: true,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updateOddEvenPieChart(oddEvenData) {
                const chartDom = document.getElementById('oddEvenPieChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '奇偶总体分布',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{a} <br/>{b}: {c} ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: ['奇数', '偶数']
                    },
                    series: [
                        {
                            name: '奇偶分布',
                            type: 'pie',
                            radius: '50%',
                            data: [
                                { value: oddEvenData.oddCount, name: '奇数', itemStyle: { color: '#E63946' } },
                                { value: oddEvenData.evenCount, name: '偶数', itemStyle: { color: '#457B9D' } }
                            ],
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static handleOddEvenTab(tabType) {
                const tabs = document.querySelectorAll('.odd-even-tab');
                tabs.forEach(tab => tab.classList.remove('active'));

                const activeTab = document.querySelector(`.odd-even-tab[data-tab="${tabType}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }

                const contents = document.querySelectorAll('.odd-even-tab-content');
                contents.forEach(content => content.classList.remove('active'));

                const activeContent = document.getElementById(`odd-even-${tabType}`);
                if (activeContent) {
                    activeContent.classList.add('active');
                }

                this.performOddEvenAnalysisByTab(tabType);
            }

            static performOddEvenAnalysisByTab(tabType) {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('oddEvenPeriodSelect');
                    let periodCount = 100;

                    if (periodSelect) {
                        const selectedValue = periodSelect.value;
                        if (selectedValue === 'all') {
                            periodCount = draws.length;
                        } else {
                            periodCount = parseInt(selectedValue);
                        }
                    }

                    const analysisDraws = draws.slice(-periodCount);

                    if (analysisDraws.length === 0) {
                        MessageSystem.showMessage('没有足够的数据进行分析', 'error');
                        return;
                    }

                    // 更新分析范围显示
                    const oddEvenDataRangeInfo = document.getElementById('oddEvenDataRangeInfo');
                    if (oddEvenDataRangeInfo && analysisDraws.length > 0) {
                        const startPeriod = analysisDraws[0].period;
                        const endPeriod = analysisDraws[analysisDraws.length - 1].period;
                        oddEvenDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisDraws.length}期）`;
                    }

                    const phase1Data = this.performOddEvenPhase1Analysis(analysisDraws);

                    switch (tabType) {
                        case 'single':
                            this.performSingleParityIndicatorAnalysis(analysisDraws, periodCount, phase1Data);
                            break;
                        case 'ratio':
                            this.performParityRatioDistributionAnalysis(analysisDraws, periodCount, phase1Data);
                            break;
                        case 'cross':
                            this.performParityCrossCharacteristicsAnalysis(analysisDraws, periodCount, phase1Data);
                            break;
                        case 'trend':
                            this.performParityTrendChangeAnalysis(analysisDraws, periodCount, phase1Data);
                            break;
                        default:
                            this.performSingleParityIndicatorAnalysis(analysisDraws, periodCount, phase1Data);
                    }
                });
            }

            static performOddEvenPhase1Analysis(draws) {
                const phase1Data = {
                    consecutivePatterns: [],
                    oddEvenTransitions: {},
                    oddEvenChangePatterns: [],
                    sameRatioStreaks: []
                };

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    let currentOddCount = 0;
                    let currentEvenCount = 0;
                    currentDraw.redBalls.forEach(ball => {
                        if (parseInt(ball) % 2 !== 0) {
                            currentOddCount++;
                        } else {
                            currentEvenCount++;
                        }
                    });

                    let nextOddCount = 0;
                    let nextEvenCount = 0;
                    nextDraw.redBalls.forEach(ball => {
                        if (parseInt(ball) % 2 !== 0) {
                            nextOddCount++;
                        } else {
                            nextEvenCount++;
                        }
                    });

                    const currentRatio = `${currentOddCount}:${currentEvenCount}`;
                    const nextRatio = `${nextOddCount}:${nextEvenCount}`;

                    const transitionKey = `${currentRatio}->${nextRatio}`;
                    if (!phase1Data.oddEvenTransitions[transitionKey]) {
                        phase1Data.oddEvenTransitions[transitionKey] = 0;
                    }
                    phase1Data.oddEvenTransitions[transitionKey]++;

                    phase1Data.consecutivePatterns.push({
                        period: currentDraw.period,
                        currentRatio: currentRatio,
                        nextRatio: nextRatio,
                        oddChange: nextOddCount - currentOddCount,
                        evenChange: nextEvenCount - currentEvenCount
                    });

                    if (currentRatio === nextRatio) {
                        let streak = 1;
                        for (let j = i - 1; j >= 0; j--) {
                            const prevDraw = draws[j];
                            let prevOddCount = 0;
                            prevDraw.redBalls.forEach(ball => {
                                if (parseInt(ball) % 2 !== 0) {
                                    prevOddCount++;
                                }
                            });
                            const prevRatio = `${prevOddCount}:${6 - prevOddCount}`;
                            if (prevRatio === currentRatio) {
                                streak++;
                            } else {
                                break;
                            }
                        }
                        phase1Data.sameRatioStreaks.push({
                            period: currentDraw.period,
                            ratio: currentRatio,
                            streak: streak
                        });
                    }
                }

                phase1Data.oddEvenChangePatterns = phase1Data.consecutivePatterns.map(pattern => ({
                    period: pattern.period,
                    changeType: pattern.oddChange > 0 ? 'oddIncrease' : pattern.oddChange < 0 ? 'oddDecrease' : 'stable',
                    oddChange: pattern.oddChange,
                    evenChange: pattern.evenChange
                }));

                return phase1Data;
            }

            static performSingleParityIndicatorAnalysis(draws, periodCount) {
                const oddNumbers = [];
                const evenNumbers = [];

                for (let i = 1; i <= 33; i++) {
                    oddNumbers.push({ number: i, count: 0, isOdd: i % 2 !== 0 });
                    evenNumbers.push({ number: i, count: 0, isOdd: i % 2 === 0 });
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        const oddNum = oddNumbers.find(n => n.number === num);
                        const evenNum = evenNumbers.find(n => n.number === num);
                        if (oddNum) oddNum.count++;
                        if (evenNum) evenNum.count++;
                    });
                });

                const oddTotal = oddNumbers.reduce((sum, n) => sum + n.count, 0);
                const evenTotal = evenNumbers.reduce((sum, n) => sum + n.count, 0);

                document.getElementById('odd-single-period-count').textContent = periodCount;
                document.getElementById('odd-single-odd-count').textContent = oddTotal;
                document.getElementById('odd-single-even-count').textContent = evenTotal;
                document.getElementById('odd-single-ratio').textContent = `${oddTotal}:${evenTotal}`;

                this.updateSingleParityIndicatorChart(oddNumbers, evenNumbers);
                this.generateSingleParityIndicatorConclusions(oddNumbers, evenNumbers, oddTotal, evenTotal, periodCount);
            }

            static updateSingleParityIndicatorChart(oddNumbers, evenNumbers) {
                const chartDom = document.getElementById('oddSingleChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const oddData = oddNumbers.filter(n => n.isOdd).sort((a, b) => b.count - a.count);
                const evenData = evenNumbers.filter(n => !n.isOdd).sort((a, b) => b.count - a.count);

                const option = {
                    title: {
                        text: '单奇偶号码指标分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        }
                    },
                    legend: {
                        data: ['奇数', '偶数'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: oddData.map(n => n.number),
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value'
                    },
                    series: [
                        {
                            name: '奇数',
                            type: 'bar',
                            data: oddData.map(n => n.count),
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '偶数',
                            type: 'bar',
                            data: evenData.map(n => n.count),
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateSingleParityIndicatorConclusions(oddNumbers, evenNumbers, oddTotal, evenTotal, periodCount) {
                const oddAvg = oddTotal / oddNumbers.filter(n => n.isOdd).length;
                const evenAvg = evenTotal / evenNumbers.filter(n => !n.isOdd).length;
                const oddAvgOmission = periodCount / oddAvg;
                const evenAvgOmission = periodCount / evenAvg;

                const topOddNumbers = oddNumbers.filter(n => n.isOdd).sort((a, b) => b.count - a.count).slice(0, 5);
                const topEvenNumbers = evenNumbers.filter(n => !n.isOdd).sort((a, b) => b.count - a.count).slice(0, 5);

                let conclusionHtml = '<ul>';
                conclusionHtml += `<li><strong>奇偶整体特征：</strong>分析${periodCount}期数据，奇数总出现${oddTotal}次，偶数总出现${evenTotal}次，奇偶比为${oddTotal}:${evenTotal}。奇数号码共17个，平均每个奇数出现${oddAvg.toFixed(2)}次；偶数号码共16个，平均每个偶数出现${evenAvg.toFixed(2)}次。奇数平均遗漏${oddAvgOmission.toFixed(2)}期，偶数平均遗漏${evenAvgOmission.toFixed(2)}期，两者基本持平，无显著差异。</li>`;
                conclusionHtml += `<li><strong>高频奇数：</strong>${topOddNumbers.map(n => n.number).join('、')}等号码出现频次较高，其中${topOddNumbers[0].number}出现${topOddNumbers[0].count}次，为奇数中最热号码。</li>`;
                conclusionHtml += `<li><strong>高频偶数：</strong>${topEvenNumbers.map(n => n.number).join('、')}等号码出现频次较高，其中${topEvenNumbers[0].number}出现${topEvenNumbers[0].count}次，为偶数中最热号码。</li>`;
                conclusionHtml += `<li><strong>分析说明：</strong>因红球奇数数量（17个）比偶数（16个）多1个，长期来看奇数号码总出现频次比偶数高约2-3%，这是正常的统计特征。奇偶遗漏无显著差异，不存在"奇数更易出/偶数更易漏"的规律。</li>`;
                conclusionHtml += '</ul>';

                document.getElementById('oddSingleConclusionContent').innerHTML = conclusionHtml;
            }

            static performParityRatioDistributionAnalysis(draws, periodCount, phase1Data) {
                const ratioDistribution = {};

                for (let i = 0; i <= 6; i++) {
                    ratioDistribution[i] = 0;
                }

                draws.forEach(draw => {
                    let oddCount = 0;
                    draw.redBalls.forEach(ball => {
                        if (parseInt(ball) % 2 !== 0) {
                            oddCount++;
                        }
                    });
                    ratioDistribution[oddCount]++;
                });

                const totalDraws = draws.length;
                const sortedRatios = Object.entries(ratioDistribution)
                    .map(([odd, count]) => ({ odd: parseInt(odd), even: 6 - parseInt(odd), count, ratio: `${odd}:${6 - odd}` }))
                    .sort((a, b) => b.count - a.count);

                document.getElementById('odd-ratio-period-count').textContent = periodCount;
                document.getElementById('odd-ratio-high-freq').textContent = `${sortedRatios[0].ratio} (${(sortedRatios[0].count / totalDraws * 100).toFixed(1)}%)`;

                this.updateParityRatioPieChart(sortedRatios, totalDraws);
                this.updateParityRatioBarChart(sortedRatios, totalDraws);
                this.generateParityRatioDistributionConclusions(sortedRatios, totalDraws, periodCount, phase1Data);
            }

            static updateParityRatioPieChart(sortedRatios, totalDraws) {
                const chartDom = document.getElementById('oddRatioPieChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '奇偶比分布（饼图）',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{a} <br/>{b}: {c} ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: sortedRatios.map(r => r.ratio)
                    },
                    series: [
                        {
                            name: '奇偶比',
                            type: 'pie',
                            radius: '50%',
                            data: sortedRatios.map(r => ({
                                value: r.count,
                                name: r.ratio
                            })),
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updateParityRatioBarChart(sortedRatios, totalDraws) {
                const chartDom = document.getElementById('oddRatioBarChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '奇偶比分布（柱状图）',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: sortedRatios.map(r => r.ratio)
                    },
                    yAxis: {
                        type: 'value'
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: sortedRatios.map(r => r.count),
                            itemStyle: {
                                color: '#E63946'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateParityRatioDistributionConclusions(sortedRatios, totalDraws, periodCount, phase1Data) {
                const ratio3_3 = sortedRatios.find(r => r.ratio === '3:3');
                const ratio2_4 = sortedRatios.find(r => r.ratio === '2:4');
                const ratio4_2 = sortedRatios.find(r => r.ratio === '4:2');
                const ratio1_5 = sortedRatios.find(r => r.ratio === '1:5');
                const ratio5_1 = sortedRatios.find(r => r.ratio === '5:1');
                const ratio0_6 = sortedRatios.find(r => r.ratio === '0:6');
                const ratio6_0 = sortedRatios.find(r => r.ratio === '6:0');

                let conclusionHtml = '<ul>';
                conclusionHtml += `<li><strong>3:3高频形态：</strong>在${periodCount}期数据中，3:3奇偶比出现${ratio3_3.count}次，占比${(ratio3_3.count / totalDraws * 100).toFixed(1)}%，是最均衡的奇偶分布形态。</li>`;
                conclusionHtml += `<li><strong>2:4/4:2次高频：</strong>2:4出现${ratio2_4.count}次（${(ratio2_4.count / totalDraws * 100).toFixed(1)}%），4:2出现${ratio4_2.count}次（${(ratio4_2.count / totalDraws * 100).toFixed(1)}%），两者合计占比${((ratio2_4.count + ratio4_2.count) / totalDraws * 100).toFixed(1)}%，接近50%。</li>`;
                conclusionHtml += `<li><strong>1:5/5:1中等频次：</strong>1:5出现${ratio1_5.count}次（${(ratio1_5.count / totalDraws * 100).toFixed(1)}%），5:1出现${ratio5_1.count}次（${(ratio5_1.count / totalDraws * 100).toFixed(1)}%），出现频率远低于前三者。</li>`;
                conclusionHtml += `<li><strong>极端形态极罕见：</strong>0:6出现${ratio0_6.count}次（${(ratio0_6.count / totalDraws * 100).toFixed(1)}%），6:0出现${ratio6_0.count}次（${(ratio6_0.count / totalDraws * 100).toFixed(1)}%），两者占比均＜1%，历史上单形态最长遗漏期数超100期。</li>`;

                if (phase1Data && phase1Data.consecutivePatterns.length > 0) {
                    const avgOddChange = phase1Data.consecutivePatterns.reduce((sum, p) => sum + p.oddChange, 0) / phase1Data.consecutivePatterns.length;
                    const stableCount = phase1Data.consecutivePatterns.filter(p => p.oddChange === 0).length;
                    const stableRatio = (stableCount / phase1Data.consecutivePatterns.length * 100).toFixed(1);

                    const topTransitions = Object.entries(phase1Data.oddEvenTransitions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);

                    conclusionHtml += `<li><strong>逐期关联分析（阶段1）：</strong>相邻期奇数平均变化${avgOddChange.toFixed(2)}个，奇偶比保持不变${stableCount}次（占比${stableRatio}%）。`;
                    if (topTransitions.length > 0) {
                        conclusionHtml += `高频奇偶比转换：${topTransitions.map(([key, count]) => `<strong>${key}</strong>→<strong>${count}</strong>次`).join('、')}。`;
                    }
                    conclusionHtml += `相邻期奇偶比${Math.abs(avgOddChange) < 0.5 ? '相对稳定' : '变化较大'}，${stableRatio > 30 ? '延续性较强' : '延续性较弱'}。</li>`;
                }

                conclusionHtml += `<li><strong>分析说明：</strong>奇偶比的"热形态"仅代表历史出现频次高，不意味着下期更易出现（比如3:3占比高，但单期出现概率仍约25%）。极端奇偶比（0:6/6:0）虽罕见，但出现概率与其他形态无本质差异（随机事件）。</li>`;
                conclusionHtml += '</ul>';

                document.getElementById('oddRatioConclusionContent').innerHTML = conclusionHtml;
            }

            static performParityCrossCharacteristicsAnalysis(draws, periodCount, phase1Data) {
                const paritySumData = [];

                draws.forEach(draw => {
                    let oddCount = 0;
                    let sum = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        sum += num;
                        if (num % 2 !== 0) {
                            oddCount++;
                        }
                    });
                    paritySumData.push({
                        period: draw.period,
                        odd: oddCount,
                        even: 6 - oddCount,
                        sum: sum,
                        ratio: `${oddCount}:${6 - oddCount}`
                    });
                });

                document.getElementById('odd-cross-period-count').textContent = periodCount;

                this.updateParityCrossCharacteristicsChart(paritySumData);
                this.generateParityCrossCharacteristicsConclusions(paritySumData, periodCount, phase1Data);
            }

            static updateParityCrossCharacteristicsChart(paritySumData) {
                const chartDom = document.getElementById('oddCrossChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const periods = paritySumData.map(d => d.period);
                const oddCounts = paritySumData.map(d => d.odd);
                const sums = paritySumData.map(d => d.sum);

                const option = {
                    title: {
                        text: '奇偶比与和值交叉特征',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        }
                    },
                    legend: {
                        data: ['奇数个数', '和值'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '奇数个数',
                            position: 'left',
                            max: 6
                        },
                        {
                            type: 'value',
                            name: '和值',
                            position: 'right'
                        }
                    ],
                    series: [
                        {
                            name: '奇数个数',
                            type: 'bar',
                            data: oddCounts,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '和值',
                            type: 'line',
                            yAxisIndex: 1,
                            data: sums,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateParityCrossCharacteristicsConclusions(paritySumData, periodCount, phase1Data) {
                const oddDominated = paritySumData.filter(d => d.odd >= 4);
                const evenDominated = paritySumData.filter(d => d.odd <= 2);
                const balanced = paritySumData.filter(d => d.odd === 3);

                const oddDominatedSum = oddDominated.reduce((sum, d) => sum + d.sum, 0) / oddDominated.length;
                const evenDominatedSum = evenDominated.reduce((sum, d) => sum + d.sum, 0) / evenDominated.length;
                const balancedSum = balanced.reduce((sum, d) => sum + d.sum, 0) / balanced.length;

                const balancedIn90_110 = balanced.filter(d => d.sum >= 90 && d.sum <= 110).length;

                let conclusionHtml = '<ul>';
                conclusionHtml += `<li><strong>奇数主导（4:2/5:1/6:0）：</strong>共${oddDominated.length}期，平均和值${oddDominatedSum.toFixed(1)}，和值整体偏高，集中在100-120区间。</li>`;
                conclusionHtml += `<li><strong>偶数主导（2:4/1:5/0:6）：</strong>共${evenDominated.length}期，平均和值${evenDominatedSum.toFixed(1)}，和值整体偏低，集中在80-100区间。</li>`;
                conclusionHtml += `<li><strong>3:3奇偶比：</strong>共${balanced.length}期，平均和值${balancedSum.toFixed(1)}，和值最集中在90-110区间，占比${(balancedIn90_110 / balanced.length * 100).toFixed(1)}%。</li>`;

                if (paritySumData.length > 1) {
                    const sumChanges = [];
                    for (let i = 0; i < paritySumData.length - 1; i++) {
                        sumChanges.push(paritySumData[i + 1].sum - paritySumData[i].sum);
                    }
                    const avgSumChange = sumChanges.reduce((sum, change) => sum + change, 0) / sumChanges.length;
                    const sumIncreaseCount = sumChanges.filter(change => change > 0).length;
                    const sumDecreaseCount = sumChanges.filter(change => change < 0).length;

                    conclusionHtml += `<li><strong>逐期关联分析：</strong>相邻期和值平均变化${avgSumChange.toFixed(2)}，和值增加${sumIncreaseCount}次，减少${sumDecreaseCount}次。`;
                    conclusionHtml += `相邻期和值${Math.abs(avgSumChange) < 5 ? '相对稳定' : '波动较大'}，${avgSumChange > 0 ? '整体呈上升趋势' : avgSumChange < 0 ? '整体呈下降趋势' : '整体保持平稳'}。</li>`;
                }

                conclusionHtml += `<li><strong>分析说明：</strong>奇偶比与和值存在明显的关联性。奇数主导时和值偏高，偶数主导时和值偏低，3:3奇偶比时和值最集中在90-110核心区间。这种关联性是号码分布的统计特征，可用于拆解号码分布特征。</li>`;
                conclusionHtml += '</ul>';

                document.getElementById('oddCrossConclusionContent').innerHTML = conclusionHtml;
            }

            static performParityTrendChangeAnalysis(draws, periodCount, phase1Data) {
                const segmentSize = 10;
                const segments = Math.ceil(draws.length / segmentSize);
                const trendData = [];

                for (let i = 0; i < segments; i++) {
                    const startIdx = i * segmentSize;
                    const endIdx = Math.min((i + 1) * segmentSize, draws.length);
                    const segmentDraws = draws.slice(startIdx, endIdx);

                    let oddCount = 0;
                    segmentDraws.forEach(draw => {
                        draw.redBalls.forEach(ball => {
                            if (parseInt(ball) % 2 !== 0) {
                                oddCount++;
                            }
                        });
                    });

                    trendData.push({
                        segment: i + 1,
                        oddCount: oddCount,
                        evenCount: segmentDraws.length * 6 - oddCount,
                        oddRatio: oddCount / (segmentDraws.length * 6)
                    });
                }

                const recentTrend = trendData.slice(-3);
                const avgOddRatio = trendData.reduce((sum, d) => sum + d.oddRatio, 0) / trendData.length;
                const recentAvgOddRatio = recentTrend.reduce((sum, d) => sum + d.oddRatio, 0) / recentTrend.length;

                let trendDirection = '稳定';
                if (recentAvgOddRatio > avgOddRatio * 1.05) {
                    trendDirection = '上升';
                } else if (recentAvgOddRatio < avgOddRatio * 0.95) {
                    trendDirection = '下降';
                }

                document.getElementById('odd-trend-period-count').textContent = periodCount;
                document.getElementById('odd-trend-direction').textContent = trendDirection;

                this.updateParityTrendChangeChart(trendData);
                this.generateParityTrendChangeConclusions(trendData, periodCount, segmentSize, trendDirection, avgOddRatio, recentAvgOddRatio, phase1Data);
            }

            static updateParityTrendChangeChart(trendData) {
                const chartDom = document.getElementById('oddTrendChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const segments = trendData.map(d => `第${d.segment}段`);
                const oddRatios = trendData.map(d => (d.oddRatio * 100).toFixed(2));

                const option = {
                    title: {
                        text: '奇偶趋势变化分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: segments
                    },
                    yAxis: {
                        type: 'value',
                        name: '奇数占比(%)',
                        max: 100
                    },
                    series: [
                        {
                            name: '奇数占比',
                            type: 'line',
                            data: oddRatios,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0, color: 'rgba(230, 57, 70, 0.3)'
                                    }, {
                                        offset: 1, color: 'rgba(230, 57, 70, 0.05)'
                                    }]
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateParityTrendChangeConclusions(trendData, periodCount, segmentSize, trendDirection, avgOddRatio, recentAvgOddRatio, phase1Data) {
                const maxOddRatio = Math.max(...trendData.map(d => d.oddRatio));
                const minOddRatio = Math.min(...trendData.map(d => d.oddRatio));
                const maxOddSegment = trendData.find(d => d.oddRatio === maxOddRatio);
                const minOddSegment = trendData.find(d => d.oddRatio === minOddRatio);

                let conclusionHtml = '<ul>';
                conclusionHtml += `<li><strong>整体趋势：</strong>将${periodCount}期数据按${segmentSize}期为一个时间段进行分段统计，整体奇数占比为${(avgOddRatio * 100).toFixed(1)}%，近期奇数占比为${(recentAvgOddRatio * 100).toFixed(1)}%，趋势方向为${trendDirection}。</li>`;
                conclusionHtml += `<li><strong>最高奇数占比：</strong>第${maxOddSegment.segment}段奇数占比${(maxOddRatio * 100).toFixed(1)}%，为分析期数内奇数最热时段。</li>`;
                conclusionHtml += `<li><strong>最低奇数占比：</strong>第${minOddSegment.segment}段奇数占比${(minOddRatio * 100).toFixed(1)}%，为分析期数内奇数最冷时段。</li>`;
                conclusionHtml += `<li><strong>波动分析：</strong>奇数占比在${(minOddRatio * 100).toFixed(1)}%至${(maxOddRatio * 100).toFixed(1)}%之间波动，波动幅度为${((maxOddRatio - minOddRatio) * 100).toFixed(1)}个百分点。</li>`;

                if (phase1Data && phase1Data.consecutivePatterns.length > 0) {
                    const trendIncreaseCount = phase1Data.consecutivePatterns.filter(p => p.oddChange > 0).length;
                    const trendDecreaseCount = phase1Data.consecutivePatterns.filter(p => p.oddChange < 0).length;
                    const trendStableCount = phase1Data.consecutivePatterns.filter(p => p.oddChange === 0).length;
                    const trendChangeRatio = (trendIncreaseCount / phase1Data.consecutivePatterns.length * 100).toFixed(1);
                    const trendDecreaseRatio = (trendDecreaseCount / phase1Data.consecutivePatterns.length * 100).toFixed(1);
                    const trendStableRatio = (trendStableCount / phase1Data.consecutivePatterns.length * 100).toFixed(1);

                    conclusionHtml += `<li><strong>逐期关联分析（阶段1）：</strong>相邻期奇数增加${trendIncreaseCount}次（占比${trendChangeRatio}%），减少${trendDecreaseCount}次（占比${trendDecreaseRatio}%），不变${trendStableCount}次（占比${trendStableRatio}%）。`;
                    conclusionHtml += `相邻期奇数变化${trendIncreaseCount > trendDecreaseCount ? '整体呈上升趋势' : trendDecreaseCount > trendIncreaseCount ? '整体呈下降趋势' : '整体保持平稳'}，${trendStableRatio > 30 ? '延续性较强' : '延续性较弱'}。</li>`;
                }

                conclusionHtml += `<li><strong>分析说明：</strong>奇偶趋势变化分析通过分段统计展示奇数占比的历史变化趋势。所有结论均基于历史统计数据，反映奇偶比在指定期数内的统计特征，不作为预测依据。</li>`;
                conclusionHtml += '</ul>';

                document.getElementById('oddTrendConclusionContent').innerHTML = conclusionHtml;
            }

            static handleBigSmallAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    this.performBigSmallAnalysis(draws);

                    MessageSystem.showMessage(`已完成${draws.length}期数据的大小分析`, 'success');
                });
            }

            static generateBigSmallData(draws, boundary) {



                const bigSmallData = {
                    bigCount: 0,
                    smallCount: 0,
                    trend: [],
                    ratioDistribution: {},
                    positionTendency: [[], [], [], [], [], []],
                    numberFrequency: {},
                    numberOmission: {},
                    numberAvgOmission: {},
                    numberMaxOmission: {}
                };

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    bigSmallData.numberFrequency[numStr] = 0;
                    bigSmallData.numberOmission[numStr] = 0;
                    bigSmallData.numberMaxOmission[numStr] = 0;
                }

                const reversedDraws = [...draws].reverse();

                reversedDraws.forEach((draw, index) => {
                    let bigCount = 0;
                    let smallCount = 0;

                    draw.redBalls.forEach((ball, pos) => {
                        const num = parseInt(ball);
                        const isBig = num > boundary;

                        if (isBig) {
                            bigCount++;
                            bigSmallData.positionTendency[pos].push(1);
                        } else {
                            smallCount++;
                            bigSmallData.positionTendency[pos].push(0);
                        }

                        const numStr = num.toString().padStart(2, '0');
                        bigSmallData.numberFrequency[numStr]++;
                    });

                    bigSmallData.bigCount += bigCount;
                    bigSmallData.smallCount += smallCount;

                    const ratioKey = `${bigCount}:${smallCount}`;
                    if (!bigSmallData.ratioDistribution[ratioKey]) {
                        bigSmallData.ratioDistribution[ratioKey] = 0;
                    }
                    bigSmallData.ratioDistribution[ratioKey]++;

                    bigSmallData.trend.push({
                        period: draw.period,
                        big: bigCount,
                        small: smallCount,
                        ratio: ratioKey
                    });
                });

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    let omissionCount = 0;
                    let maxOmission = 0;
                    let found = false;
                    let firstAppearanceIndex = -1;

                    for (let j = 0; j < reversedDraws.length; j++) {
                        const draw = reversedDraws[j];
                        if (draw.redBalls.includes(numStr)) {
                            if (omissionCount > maxOmission) {
                                maxOmission = omissionCount;
                            }
                            omissionCount = 0;
                            found = true;

                            if (firstAppearanceIndex === -1) {
                                firstAppearanceIndex = j;
                            }
                        } else {
                            omissionCount++;
                        }
                    }

                    if (!found) {
                        bigSmallData.numberOmission[numStr] = draws.length;
                    } else {
                        bigSmallData.numberOmission[numStr] = firstAppearanceIndex;
                    }
                    bigSmallData.numberMaxOmission[numStr] = maxOmission;
                    bigSmallData.numberAvgOmission[numStr] = draws.length / (bigSmallData.numberFrequency[numStr] || 1);
                }





                return bigSmallData;
            }

            static performBigSmallAnalysis(draws) {
                const boundary = currentLotteryType === 'ssq' ? 16 : 17;

                const bigSmallData = this.generateBigSmallData(draws, boundary);


                this.updateBigSmallOverview(bigSmallData, draws.length, boundary);
                this.updateBigSmallTrendChart(bigSmallData);
                this.updateBigSmallDistributionCharts(bigSmallData, boundary);
                this.updateBigSmallStatusChart(bigSmallData, boundary);
                this.updateBigSmallStatusTable(bigSmallData, boundary);
                this.generateBigSmallStrategy(bigSmallData, draws, boundary);

            }

            static updateBigSmallOverview(bigSmallData, totalPeriods, boundary, phase1Data) {
                document.getElementById('bigSmallAnalysisPeriods').textContent = totalPeriods;
                document.getElementById('bigSmallBigCount').textContent = bigSmallData.bigCount;
                document.getElementById('bigSmallSmallCount').textContent = bigSmallData.smallCount;

                const total = bigSmallData.bigCount + bigSmallData.smallCount;
                const bigRatio = ((bigSmallData.bigCount / total) * 100).toFixed(1);
                const smallRatio = ((bigSmallData.smallCount / total) * 100).toFixed(1);

                document.getElementById('bigSmallBigRatio').textContent = bigRatio + '%';
                document.getElementById('bigSmallSmallRatio').textContent = smallRatio + '%';

                this.updateBigSmallPieChart(bigSmallData, boundary, phase1Data);
            }

            static updateBigSmallPieChart(bigSmallData, boundary) {
                const chartDom = document.getElementById('bigSmallPieChart');
                if (!chartDom) {

                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const ratioData = Object.entries(bigSmallData.ratioDistribution)
                    .map(([ratio, count]) => ({
                        name: `${ratio}`,
                        value: count
                    }))
                    .sort((a, b) => b.value - a.value);



                const option = {
                    title: {
                        text: '大小比例分布概览',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{a} <br/>{b}: {c}期 ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: ratioData.map(item => item.name)
                    },
                    series: [
                        {
                            name: '大小比例',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            label: {
                                show: true,
                                formatter: '{b}: {c}期 ({d}%)',
                                fontSize: 12
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 14,
                                    fontWeight: 'bold'
                                }
                            },
                            labelLine: {
                                show: true,
                                length: 15,
                                length2: 20,
                                smooth: true,
                                lineStyle: {
                                    width: 1
                                }
                            },
                            data: ratioData
                        }
                    ]
                };

                chart.setOption(option, true);

            }

            static updateBigSmallTrendChart(bigSmallData) {
                const chartDom = document.getElementById('bigSmallTrendChart');
                if (!chartDom) {

                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const trendData = bigSmallData.trend.slice().reverse();
                const periods = trendData.map(item => item.period);
                const bigData = trendData.map(item => item.big);
                const smallData = trendData.map(item => item.small);

                const ma5Big = this.calculateMovingAverage(bigData, 5);
                const ma10Big = this.calculateMovingAverage(bigData, 10);
                const ma20Big = this.calculateMovingAverage(bigData, 20);



                const option = {
                    title: {
                        text: '大小号数量趋势分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    legend: {
                        data: ['大号数量', '小号数量', '5期均线', '10期均线', '20期均线'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '数量'
                    },
                    series: [
                        {
                            name: '大号数量',
                            type: 'line',
                            data: bigData,
                            smooth: true,
                            itemStyle: { color: '#E63946' }
                        },
                        {
                            name: '小号数量',
                            type: 'line',
                            data: smallData,
                            smooth: true,
                            itemStyle: { color: '#457B9D' }
                        },
                        {
                            name: '5期均线',
                            type: 'line',
                            data: ma5Big,
                            smooth: true,
                            itemStyle: { color: '#F4A261' },
                            lineStyle: { type: 'dashed' }
                        },
                        {
                            name: '10期均线',
                            type: 'line',
                            data: ma10Big,
                            smooth: true,
                            itemStyle: { color: '#2A9D8F' },
                            lineStyle: { type: 'dashed' }
                        },
                        {
                            name: '20期均线',
                            type: 'line',
                            data: ma20Big,
                            smooth: true,
                            itemStyle: { color: '#264653' },
                            lineStyle: { type: 'dashed' }
                        }
                    ]
                };

                chart.setOption(option, true);


                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series' && params.seriesName === '大号数量' || params.seriesName === '小号数量') {
                        const period = periods[params.dataIndex];
                        const trendItem = bigSmallData.trend[params.dataIndex];

                        const detailHtml = `
                            <div style="padding: 20px;">
                                <h3 style="margin-top: 0;">期号 ${period} 详细信息</h3>
                                <p><strong>大号数量：</strong>${trendItem.big}</p>
                                <p><strong>小号数量：</strong>${trendItem.small}</p>
                                <p><strong>大小比例：</strong>${trendItem.ratio}</p>
                            </div>
                        `;

                        MessageSystem.showCustomDialog('期号详情', detailHtml);
                    }
                });
            }

            static calculateMovingAverage(data, period) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) {
                        result.push(null);
                    } else {
                        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                        result.push((sum / period).toFixed(2));
                    }
                }
                return result;
            }

            static updateBigSmallDistributionCharts(bigSmallData, boundary) {
                this.updateBigSmallHeatmapChart(bigSmallData, boundary);
                this.updateBigSmallStackedChart(bigSmallData);
            }

            static updateBigSmallHeatmapChart(bigSmallData, boundary) {
                const chartDom = document.getElementById('bigSmallHeatmapChart');
                if (!chartDom) {

                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const data = [];
                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    data.push([
                        i,
                        i > boundary ? '大号' : '小号',
                        bigSmallData.numberFrequency[numStr]
                    ]);
                }



                const option = {
                    title: {
                        text: '号码大小属性热力图',
                        left: 'center'
                    },
                    tooltip: {
                        position: 'top',
                        formatter: function(params) {
                            return `号码${params.value[0]}<br/>类型: ${params.value[1]}<br/>出现次数: ${params.value[2]}`;
                        }
                    },
                    grid: {
                        height: '50%',
                        top: '10%'
                    },
                    xAxis: {
                        type: 'category',
                        data: Array.from({length: 33}, (_, i) => i + 1),
                        splitArea: { show: true }
                    },
                    yAxis: {
                        type: 'category',
                        data: ['小号', '大号'],
                        splitArea: { show: true }
                    },
                    visualMap: {
                        min: 0,
                        max: Math.max(...Object.values(bigSmallData.numberFrequency)),
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '0%'
                    },
                    series: [{
                        name: '出现次数',
                        type: 'heatmap',
                        data: data,
                        label: {
                            show: true
                        },
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    }]
                };

                chart.setOption(option, true);

            }

            static updateBigSmallStackedChart(bigSmallData) {
                const chartDom = document.getElementById('bigSmallStackedChart');
                if (!chartDom) {

                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const recentData = bigSmallData.trend.slice(-30).reverse();
                const periods = recentData.map(item => item.period);
                const bigData = recentData.map(item => item.big);
                const smallData = recentData.map(item => item.small);

                const option = {
                    title: {
                        text: '近期大小号构成（最近30期）',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: { type: 'shadow' }
                    },
                    legend: {
                        data: ['大号', '小号'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '数量'
                    },
                    series: [
                        {
                            name: '大号',
                            type: 'bar',
                            stack: 'total',
                            data: bigData,
                            itemStyle: { color: '#E63946' }
                        },
                        {
                            name: '小号',
                            type: 'bar',
                            stack: 'total',
                            data: smallData,
                            itemStyle: { color: '#457B9D' }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updateBigSmallStatusChart(bigSmallData, boundary) {
                const chartDom = document.getElementById('bigSmallStatusChart');
                if (!chartDom) {

                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const bigNumbers = [];
                const smallNumbers = [];

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    if (i > boundary) {
                        bigNumbers.push({
                            name: numStr,
                            value: bigSmallData.numberFrequency[numStr],
                            omission: bigSmallData.numberOmission[numStr],
                            itemStyle: this.getNumberStatusColor(bigSmallData.numberOmission[numStr], bigSmallData.numberAvgOmission[numStr])
                        });
                    } else {
                        smallNumbers.push({
                            name: numStr,
                            value: bigSmallData.numberFrequency[numStr],
                            omission: bigSmallData.numberOmission[numStr],
                            itemStyle: this.getNumberStatusColor(bigSmallData.numberOmission[numStr], bigSmallData.numberAvgOmission[numStr])
                        });
                    }
                }

                const option = {
                    title: {
                        text: '号码冷热状态分布',
                        left: 'center',
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            const data = params.data;
                            return `${params.seriesName}<br/>${params.name}: ${params.value}次<br/>遗漏: ${data.omission}期`;
                        }
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    series: [
                        {
                            name: '大号',
                            type: 'pie',
                            radius: [0, '30%'],
                            center: ['40%', '50%'],
                            itemStyle: {
                                borderRadius: 8,
                                borderColor: '#fff',
                                borderWidth: 3,
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.3)'
                            },
                            label: {
                                show: true,
                                fontSize: 10,
                                formatter: '{b}',
                                color: '#333'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 20,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)',
                                    borderWidth: 4
                                },
                                label: {
                                    show: true,
                                    fontSize: 12,
                                    fontWeight: 'bold'
                                },
                                scale: true,
                                scaleSize: 10
                            },
                            data: bigNumbers
                        },
                        {
                            name: '小号',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['40%', '50%'],
                            itemStyle: {
                                borderRadius: 8,
                                borderColor: '#fff',
                                borderWidth: 3,
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.3)'
                            },
                            label: {
                                show: true,
                                fontSize: 10,
                                formatter: '{b}',
                                color: '#333'
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 20,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)',
                                    borderWidth: 4
                                },
                                label: {
                                    show: true,
                                    fontSize: 12,
                                    fontWeight: 'bold'
                                },
                                scale: true,
                                scaleSize: 10
                            },
                            data: smallNumbers
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static getNumberStatusColor(currentOmission, avgOmission) {
                const ratio = currentOmission / avgOmission;
                if (ratio < 0.5) {
                    return { color: '#E63946' };
                } else if (ratio < 1.5) {
                    return { color: '#F4A261' };
                } else {
                    return { color: '#457B9D' };
                }
            }

            static updateBigSmallStatusTable(bigSmallData, boundary) {
                const tbody = document.getElementById('bigSmallStatusTableBody');
                if (!tbody) return;

                let html = '';

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    const type = i > boundary ? '大号' : '小号';
                    const frequency = bigSmallData.numberFrequency[numStr];
                    const currentOmission = bigSmallData.numberOmission[numStr];
                    const avgOmission = bigSmallData.numberAvgOmission[numStr].toFixed(1);
                    const maxOmission = bigSmallData.numberMaxOmission[numStr];

                    let status = '温';
                    let statusClass = 'warning';
                    const ratio = currentOmission / avgOmission;

                    if (ratio < 0.5) {
                        status = '热';
                        statusClass = 'danger';
                    } else if (ratio > 1.5) {
                        status = '冷';
                        statusClass = 'info';
                    }

                    html += `
                        <tr>
                            <td>${numStr}</td>
                            <td>${type}</td>
                            <td>${frequency}</td>
                            <td>${currentOmission}</td>
                            <td>${avgOmission}</td>
                            <td>${maxOmission}</td>
                            <td><span class="badge badge-${statusClass}">${status}</span></td>
                        </tr>
                    `;
                }

                tbody.innerHTML = html;
            }

            static generateBigSmallStrategy(bigSmallData, draws, boundary, phase1Data) {
                const contentDiv = document.getElementById('bigSmallStrategyContent');
                if (!contentDiv) return;

                const recentTrend = bigSmallData.trend.slice(-10);
                const recentBigAvg = recentTrend.reduce((sum, item) => sum + item.big, 0) / recentTrend.length;
                const recentSmallAvg = recentTrend.reduce((sum, item) => sum + item.small, 0) / recentTrend.length;

                const overallBigRatio = bigSmallData.bigCount / (bigSmallData.bigCount + bigSmallData.smallCount);
                const recentBigRatio = recentBigAvg / 6;

                let trendDirection = '稳定';
                if (recentBigRatio > overallBigRatio * 1.1) {
                    trendDirection = '大号走热';
                } else if (recentBigRatio < overallBigRatio * 0.9) {
                    trendDirection = '小号走热';
                }

                const hotNumbers = [];
                const coldNumbers = [];
                const warmNumbers = [];

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    const ratio = bigSmallData.numberOmission[numStr] / bigSmallData.numberAvgOmission[numStr];

                    if (ratio < 0.5) {
                        hotNumbers.push(numStr);
                    } else if (ratio > 1.5) {
                        coldNumbers.push(numStr);
                    } else {
                        warmNumbers.push(numStr);
                    }
                }

                const hotBigNumbers = hotNumbers.filter(n => parseInt(n) > boundary);
                const coldBigNumbers = coldNumbers.filter(n => parseInt(n) > boundary);
                const hotSmallNumbers = hotNumbers.filter(n => parseInt(n) <= boundary);
                const coldSmallNumbers = coldNumbers.filter(n => parseInt(n) <= boundary);

                let strategyHtml = `
                    <div class="strategy-section">
                        <h4>📊 当前趋势分析</h4>
                        <p><strong>趋势方向：</strong>${trendDirection}</p>
                        <p><strong>近期平均大号数：</strong>${recentBigAvg.toFixed(1)}个</p>
                        <p><strong>近期平均小号数：</strong>${recentSmallAvg.toFixed(1)}个</p>
                        <p><strong>近期大号占比：</strong>${(recentBigRatio * 100).toFixed(1)}%</p>
                        <p><strong>历史大号占比：</strong>${(overallBigRatio * 100).toFixed(1)}%</p>
                `;

                if (phase1Data && phase1Data.consecutivePatterns.length > 0) {
                    const avgBigChange = phase1Data.consecutivePatterns.reduce((sum, p) => sum + p.bigChange, 0) / phase1Data.consecutivePatterns.length;
                    const bigIncreaseCount = phase1Data.consecutivePatterns.filter(p => p.bigChange > 0).length;
                    const bigDecreaseCount = phase1Data.consecutivePatterns.filter(p => p.bigChange < 0).length;
                    const stableCount = phase1Data.consecutivePatterns.filter(p => p.bigChange === 0).length;
                    const stableRatio = (stableCount / phase1Data.consecutivePatterns.length * 100).toFixed(1);

                    const topTransitions = Object.entries(phase1Data.bigSmallTransitions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);

                    strategyHtml += `
                        <p><strong>逐期关联分析（阶段1）：</strong>相邻期大号平均变化${avgBigChange.toFixed(2)}个，大号增加${bigIncreaseCount}次，减少${bigDecreaseCount}次，不变${stableCount}次（占比${stableRatio}%）。`;
                    if (topTransitions.length > 0) {
                        strategyHtml += `高频大小比转换：${topTransitions.map(([key, count]) => `<strong>${key}</strong>→<strong>${count}</strong>次`).join('、')}。`;
                    }
                    strategyHtml += `相邻期大小比${Math.abs(avgBigChange) < 0.5 ? '相对稳定' : '变化较大'}，${stableRatio > 30 ? '延续性较强' : '延续性较弱'}。</p>
                    `;
                }

                strategyHtml += `
                    </div>

                    <div class="strategy-section">
                        <h4>🔥 冷热号码分析</h4>
                        <p><strong>热号（高频）：</strong>大号[${hotBigNumbers.join(', ') || '无'}]，小号[${hotSmallNumbers.join(', ') || '无'}]</p>
                        <p><strong>冷号（高遗漏）：</strong>大号[${coldBigNumbers.join(', ') || '无'}]，小号[${coldSmallNumbers.join(', ') || '无'}]</p>
                    </div>

                    <div class="strategy-section">
                        <h4>💡 策略推荐</h4>
                `;

                if (trendDirection === '大号走热') {
                    strategyHtml += `
                        <p><strong>趋势策略：</strong>近期大号走热，建议顺势选择，可适当增加大号数量（建议4-5个）。</p>
                        <p><strong>关注区域：</strong>重点关注大号区域${boundary + 1}-33，特别是热号${hotBigNumbers.slice(0, 3).join(', ') || '无'}。</p>
                    `;
                } else if (trendDirection === '小号走热') {
                    strategyHtml += `
                        <p><strong>趋势策略：</strong>近期小号走热，建议顺势选择，可适当增加小号数量（建议4-5个）。</p>
                        <p><strong>关注区域：</strong>重点关注小号区域01-${boundary}，特别是热号${hotSmallNumbers.slice(0, 3).join(', ') || '无'}。</p>
                    `;
                } else {
                    strategyHtml += `
                        <p><strong>平衡策略：</strong>当前趋势稳定，建议选择均衡大小比例（建议3:3）。</p>
                        <p><strong>关注区域：</strong>可均衡选择大小号区域，关注温号${warmNumbers.slice(0, 5).join(', ') || '无'}。</p>
                    `;
                }

                strategyHtml += `
                        <p><strong>冷热策略：</strong>可关注高遗漏的冷号${coldNumbers.slice(0, 3).join(', ') || '无'}进行追冷，或继续追热号${hotNumbers.slice(0, 3).join(', ') || '无'}。</p>
                    </div>

                    <div class="strategy-section">
                        <h4>⚠️ 风险提示</h4>
                        <p>以上分析基于历史统计概率，旨在发现规律倾向，而非预测绝对结果。请结合奇偶、区间、和值等其他维度综合判断，理性使用，控制风险。</p>
                    </div>
                `;

                contentDiv.innerHTML = strategyHtml;
            }

            static handleBigSmallTab(tabType) {



                const tabs = document.querySelectorAll('.big-small-tab');

                tabs.forEach(tab => tab.classList.remove('active'));

                const activeTab = document.querySelector(`.big-small-tab[data-tab="${tabType}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');

                } else {

                }

                const contents = document.querySelectorAll('.big-small-tab-content');

                contents.forEach(content => content.classList.remove('active'));

                const activeContent = document.getElementById(`big-small-${tabType}`);
                if (activeContent) {
                    activeContent.classList.add('active');



                } else {

                }


                setTimeout(() => {
                    this.performBigSmallAnalysisByTab(tabType);
                }, 100);

            }

            static performBigSmallAnalysisByTab(tabType) {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('bigSmallPeriodSelect');
                    let periodCount = 100;

                    if (periodSelect) {
                        const selectedValue = periodSelect.value;
                        if (selectedValue === 'all') {
                            periodCount = draws.length;
                        } else {
                            periodCount = parseInt(selectedValue);
                        }

                    } else {

                    }

                    const boundary = currentLotteryType === 'ssq' ? 16 : 17;

                    const analysisDraws = draws.slice(-periodCount);

                    // 更新分析范围显示
                    const bigSmallDataRangeInfo = document.getElementById('bigSmallDataRangeInfo');
                    if (bigSmallDataRangeInfo && analysisDraws.length > 0) {
                        const startPeriod = analysisDraws[0].period;
                        const endPeriod = analysisDraws[analysisDraws.length - 1].period;
                        bigSmallDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisDraws.length}期）`;
                    }

                    const phase1Data = this.performBigSmallPhase1Analysis(analysisDraws, boundary);

                    const bigSmallData = this.generateBigSmallData(analysisDraws, boundary);

                    switch(tabType) {
                        case 'overview':
                            this.updateBigSmallOverview(bigSmallData, analysisDraws.length, boundary, phase1Data);
                            break;
                        case 'trend':
                            this.updateBigSmallTrendChart(bigSmallData, phase1Data);
                            break;
                        case 'distribution':
                            this.updateBigSmallDistributionCharts(bigSmallData, boundary, phase1Data);
                            break;
                        case 'status':
                            this.updateBigSmallStatusChart(bigSmallData, boundary, phase1Data);
                            this.updateBigSmallStatusTable(bigSmallData, boundary, phase1Data);
                            break;
                        case 'strategy':
                            this.generateBigSmallStrategy(bigSmallData, draws, boundary, phase1Data);
                            break;
                        default:

                    }
                });
            }

            static performBigSmallPhase1Analysis(draws, boundary) {



                const phase1Data = {
                    consecutivePatterns: [],
                    bigSmallTransitions: {},
                    bigSmallChangePatterns: [],
                    sameRatioStreaks: [],
                    positionBigSmallTransitions: [[], [], [], [], [], []],
                    bigSmallOscillation: []
                };

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    let currentBigCount = 0;
                    let currentSmallCount = 0;
                    currentDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num > boundary) {
                            currentBigCount++;
                        } else {
                            currentSmallCount++;
                        }
                    });

                    let nextBigCount = 0;
                    let nextSmallCount = 0;
                    nextDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num > boundary) {
                            nextBigCount++;
                        } else {
                            nextSmallCount++;
                        }
                    });

                    const currentRatio = `${currentBigCount}:${currentSmallCount}`;
                    const nextRatio = `${nextBigCount}:${nextSmallCount}`;

                    const transitionKey = `${currentRatio}->${nextRatio}`;
                    if (!phase1Data.bigSmallTransitions[transitionKey]) {
                        phase1Data.bigSmallTransitions[transitionKey] = 0;
                    }
                    phase1Data.bigSmallTransitions[transitionKey]++;

                    phase1Data.consecutivePatterns.push({
                        period: currentDraw.period,
                        currentRatio: currentRatio,
                        nextRatio: nextRatio,
                        bigChange: nextBigCount - currentBigCount,
                        smallChange: nextSmallCount - currentSmallCount
                    });

                    if (currentRatio === nextRatio) {
                        let streak = 1;
                        for (let j = i - 1; j >= 0; j--) {
                            const prevDraw = draws[j];
                            let prevBigCount = 0;
                            prevDraw.redBalls.forEach(ball => {
                                const num = parseInt(ball);
                                if (num > boundary) {
                                    prevBigCount++;
                                }
                            });
                            const prevRatio = `${prevBigCount}:${6 - prevBigCount}`;
                            if (prevRatio === currentRatio) {
                                streak++;
                            } else {
                                break;
                            }
                        }
                        phase1Data.sameRatioStreaks.push({
                            period: currentDraw.period,
                            ratio: currentRatio,
                            streak: streak
                        });
                    }

                    for (let pos = 0; pos < 6; pos++) {
                        const currentNum = parseInt(currentDraw.redBalls[pos]);
                        const nextNum = parseInt(nextDraw.redBalls[pos]);

                        const currentIsBig = currentNum > boundary;
                        const nextIsBig = nextNum > boundary;

                        const transitionType = currentIsBig === nextIsBig ? 'same' : (currentIsBig ? 'bigToSmall' : 'smallToBig');

                        phase1Data.positionBigSmallTransitions[pos].push({
                            period: currentDraw.period,
                            position: pos + 1,
                            currentNum: currentNum,
                            nextNum: nextNum,
                            transitionType: transitionType
                        });
                    }

                    phase1Data.bigSmallOscillation.push({
                        period: currentDraw.period,
                        currentBig: currentBigCount,
                        nextBig: nextBigCount,
                        oscillation: Math.abs(nextBigCount - currentBigCount)
                    });
                }

                phase1Data.bigSmallChangePatterns = phase1Data.consecutivePatterns.map(pattern => ({
                    period: pattern.period,
                    changeType: pattern.bigChange > 0 ? 'bigIncrease' : pattern.bigChange < 0 ? 'bigDecrease' : 'stable',
                    bigChange: pattern.bigChange,
                    smallChange: pattern.smallChange
                }));





                return phase1Data;
            }

            static handlePrimeCompositeAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    this.performPrimeCompositeAnalysis(draws);

                    MessageSystem.showMessage(`已完成${draws.length}期数据的质合分析`, 'success');
                });
            }

            static performPrimeCompositeAnalysisByPeriod() {


                const draws = currentDatabaseData.draws || [];


                if (draws.length === 0) {
                    MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                    return;
                }

                const periodSelect = document.getElementById('primeCompositePeriodSelectV1');
                let periodCount = 100;

                if (periodSelect) {
                    const selectedValue = periodSelect.value;
                    if (selectedValue === 'all') {
                        periodCount = draws.length;
                    } else {
                        periodCount = parseInt(selectedValue);
                    }

                } else {

                }

                let analysisDraws = draws.slice(-periodCount);




                const activeTab = document.querySelector('.prime-composite-tab.active');
                const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'overview';

                this.performPrimeCompositeAnalysisByTab(tabType);

                MessageSystem.showMessage(`已完成${analysisDraws.length}期数据的质合分析`, 'success');

            }

            static performPrimeCompositeAnalysisByTab(tabType) {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('primeCompositePeriodSelectV1');
                    let periodCount = 100;

                    if (periodSelect) {
                        const selectedValue = periodSelect.value;
                        if (selectedValue === 'all') {
                            periodCount = draws.length;
                        } else {
                            periodCount = parseInt(selectedValue);
                        }

                    } else {

                    }

                    const analysisDraws = draws.slice(-periodCount);

                    // 更新分析范围显示
                    const primeCompositeDataRangeInfo = document.getElementById('primeCompositeDataRangeInfo');
                    if (primeCompositeDataRangeInfo && analysisDraws.length > 0) {
                        const startPeriod = analysisDraws[0].period;
                        const endPeriod = analysisDraws[analysisDraws.length - 1].period;
                        primeCompositeDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisDraws.length}期）`;
                    }

                    const phase1Data = this.performPrimeCompositePhase1Analysis(analysisDraws);

                    const primeCompositeData = this.generatePrimeCompositeData(analysisDraws);

                    switch(tabType) {
                        case 'overview':
                            this.updatePrimeCompositeOverview(primeCompositeData, analysisDraws.length, phase1Data);
                            break;
                        case 'trend':
                            this.updatePrimeCompositeTrendChart(primeCompositeData, phase1Data);
                            break;
                        case 'distribution':
                            this.updatePrimeCompositeDistributionCharts(primeCompositeData, phase1Data);
                            break;
                        case 'strategy':
                            this.generatePrimeCompositeStrategy(primeCompositeData, draws, phase1Data);
                            break;
                        default:

                    }
                });
            }

            static performPrimeCompositePhase1Analysis(draws) {




                const primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]);

                const phase1Data = {
                    consecutivePatterns: [],
                    primeCompositeTransitions: {},
                    primeCompositeChangePatterns: [],
                    sameRatioStreaks: [],
                    positionPrimeCompositeTransitions: [[], [], [], [], [], []],
                    primeCompositeOscillation: [],
                    primeNumberTransitions: {},
                    compositeNumberTransitions: {}
                };

                for (let i = draws.length - 1; i > 0; i--) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i - 1];

                    let currentPrimeCount = 0;
                    let currentCompositeCount = 0;
                    currentDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            currentPrimeCount++;
                        } else {
                            currentCompositeCount++;
                        }
                    });

                    let nextPrimeCount = 0;
                    let nextCompositeCount = 0;
                    nextDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            nextPrimeCount++;
                        } else {
                            nextCompositeCount++;
                        }
                    });

                    const currentRatio = `${currentPrimeCount}:${currentCompositeCount}`;
                    const nextRatio = `${nextPrimeCount}:${nextCompositeCount}`;

                    const transitionKey = `${currentRatio}->${nextRatio}`;
                    if (!phase1Data.primeCompositeTransitions[transitionKey]) {
                        phase1Data.primeCompositeTransitions[transitionKey] = 0;
                    }
                    phase1Data.primeCompositeTransitions[transitionKey]++;

                    phase1Data.consecutivePatterns.push({
                        period: currentDraw.period,
                        currentRatio: currentRatio,
                        nextRatio: nextRatio,
                        primeChange: nextPrimeCount - currentPrimeCount,
                        compositeChange: nextCompositeCount - currentCompositeCount
                    });

                    if (currentRatio === nextRatio) {
                        let streak = 1;
                        for (let j = i + 1; j < draws.length; j++) {
                            const prevDraw = draws[j];
                            let prevPrimeCount = 0;
                            prevDraw.redBalls.forEach(ball => {
                                const num = parseInt(ball);
                                if (primes.has(num)) {
                                    prevPrimeCount++;
                                }
                            });
                            const prevRatio = `${prevPrimeCount}:${6 - prevPrimeCount}`;
                            if (prevRatio === currentRatio) {
                                streak++;
                            } else {
                                break;
                            }
                        }
                        phase1Data.sameRatioStreaks.push({
                            period: currentDraw.period,
                            ratio: currentRatio,
                            streak: streak
                        });
                    }

                    for (let pos = 0; pos < 6; pos++) {
                        const currentNum = parseInt(currentDraw.redBalls[pos]);
                        const nextNum = parseInt(nextDraw.redBalls[pos]);

                        const currentIsPrime = primes.has(currentNum);
                        const nextIsPrime = primes.has(nextNum);

                        const transitionType = currentIsPrime === nextIsPrime ? 'same' : (currentIsPrime ? 'primeToComposite' : 'compositeToPrime');

                        phase1Data.positionPrimeCompositeTransitions[pos].push({
                            period: currentDraw.period,
                            position: pos + 1,
                            currentNum: currentNum,
                            nextNum: nextNum,
                            transitionType: transitionType
                        });
                    }

                    phase1Data.primeCompositeOscillation.push({
                        period: currentDraw.period,
                        currentPrime: currentPrimeCount,
                        nextPrime: nextPrimeCount,
                        oscillation: Math.abs(nextPrimeCount - currentPrimeCount)
                    });

                    currentDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        const numStr = num.toString().padStart(2, '0');
                        const isPrime = primes.has(num);
                        const appearsInNext = nextDraw.redBalls.includes(numStr);

                        if (isPrime) {
                            const key = `${numStr}_${appearsInNext ? 'stay' : 'leave'}`;
                            if (!phase1Data.primeNumberTransitions[key]) {
                                phase1Data.primeNumberTransitions[key] = 0;
                            }
                            phase1Data.primeNumberTransitions[key]++;
                        } else {
                            const key = `${numStr}_${appearsInNext ? 'stay' : 'leave'}`;
                            if (!phase1Data.compositeNumberTransitions[key]) {
                                phase1Data.compositeNumberTransitions[key] = 0;
                            }
                            phase1Data.compositeNumberTransitions[key]++;
                        }
                    });
                }

                phase1Data.primeCompositeChangePatterns = phase1Data.consecutivePatterns.map(pattern => ({
                    period: pattern.period,
                    changeType: pattern.primeChange > 0 ? 'primeIncrease' : pattern.primeChange < 0 ? 'primeDecrease' : 'stable',
                    primeChange: pattern.primeChange,
                    compositeChange: pattern.compositeChange
                }));

                console.log('质合分析阶段1完成');
                console.log('连续模式数:', phase1Data.consecutivePatterns.length);
                console.log('质合转换类型数:', Object.keys(phase1Data.primeCompositeTransitions).length);

                return phase1Data;
            }

            static generatePrimeCompositeData(draws) {
                console.log('=== 开始生成质合分析数据（阶段2：整体规律分析） ===');
                console.log('数据期数:', draws.length);
                console.log('分析方向: 拉通全区间做整体规律分析，从最新期开始');

                const primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]);
                const rules = LOTTERY_RULES[currentLotteryType];
                const zoneRanges = rules.threeZoneRanges;

                const primeCompositeData = {
                    primeCount: 0,
                    compositeCount: 0,
                    trend: [],
                    ratioDistribution: {},
                    positionTendency: [[], [], [], [], [], []],
                    numberFrequency: {},
                    numberOmission: {},
                    numberAvgOmission: {},
                    numberMaxOmission: {},
                    numberType: {},
                    consecutiveAppearances: {},
                    conversionPoints: [],
                    primeStats: {},
                    compositeStats: {},
                    hotNumbers: [],
                    warmNumbers: [],
                    coldNumbers: [],
                    acValueData: [],
                    threeZoneData: [],
                    linkedData: [],
                    primeCompositeCombinationFrequency: {},
                    primeCompositeAcValueCorrelation: {},
                    primeCompositeThreeZoneCorrelation: {},
                    cycleData: [],
                    positionPreference: {},
                    primeRatioPrediction: {},
                    transitionMatrix: {},
                    numberStatusHistory: {},
                    statusTransitionProb: {}
                };

                for (let i = 1; i <= rules.redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    primeCompositeData.numberFrequency[numStr] = 0;
                    primeCompositeData.numberOmission[numStr] = 0;
                    primeCompositeData.numberAvgOmission[numStr] = 0;
                    primeCompositeData.numberMaxOmission[numStr] = 0;
                    primeCompositeData.numberType[numStr] = primes.has(i) ? 'prime' : 'composite';
                    primeCompositeData.consecutiveAppearances[numStr] = 0;
                }

                const reversedDraws = [...draws].reverse();
                let lastPrimeRatio = null;

                reversedDraws.forEach((draw, index) => {
                    let primeCount = 0;
                    let compositeCount = 0;
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    draw.redBalls.forEach((ball, pos) => {
                        const num = parseInt(ball);
                        const isPrime = primes.has(num);

                        if (isPrime) {
                            primeCount++;
                            primeCompositeData.positionTendency[pos].push(1);
                        } else {
                            compositeCount++;
                            primeCompositeData.positionTendency[pos].push(0);
                        }

                        const numStr = num.toString().padStart(2, '0');
                        primeCompositeData.numberFrequency[numStr]++;
                    });

                    primeCompositeData.primeCount += primeCount;
                    primeCompositeData.compositeCount += compositeCount;

                    const ratioKey = `${primeCount}:${compositeCount}`;
                    if (!primeCompositeData.ratioDistribution[ratioKey]) {
                        primeCompositeData.ratioDistribution[ratioKey] = 0;
                    }
                    primeCompositeData.ratioDistribution[ratioKey]++;

                    const acValue = this.calculateACValue(redBalls);
                    primeCompositeData.acValueData.push({
                        period: draw.period,
                        acValue: acValue
                    });

                    let zone1Count = 0;
                    let zone2Count = 0;
                    let zone3Count = 0;

                    redBalls.forEach(ball => {
                        if (ball >= zoneRanges.zone1[0] && ball <= zoneRanges.zone1[1]) {
                            zone1Count++;
                        } else if (ball >= zoneRanges.zone2[0] && ball <= zoneRanges.zone2[1]) {
                            zone2Count++;
                        } else if (ball >= zoneRanges.zone3[0] && ball <= zoneRanges.zone3[1]) {
                            zone3Count++;
                        }
                    });

                    const threeZoneCombination = `${zone1Count}-${zone2Count}-${zone3Count}`;
                    primeCompositeData.threeZoneData.push({
                        period: draw.period,
                        zone1: zone1Count,
                        zone2: zone2Count,
                        zone3: zone3Count,
                        combination: threeZoneCombination
                    });

                    primeCompositeData.linkedData.push({
                        period: draw.period,
                        primeCount: primeCount,
                        compositeCount: compositeCount,
                        primeCompositeCombination: ratioKey,
                        acValue: acValue,
                        zone1: zone1Count,
                        zone2: zone2Count,
                        zone3: zone3Count,
                        threeZoneCombination: threeZoneCombination
                    });

                    if (!primeCompositeData.primeCompositeCombinationFrequency[ratioKey]) {
                        primeCompositeData.primeCompositeCombinationFrequency[ratioKey] = 0;
                    }
                    primeCompositeData.primeCompositeCombinationFrequency[ratioKey]++;

                    if (!primeCompositeData.primeCompositeAcValueCorrelation[ratioKey]) {
                        primeCompositeData.primeCompositeAcValueCorrelation[ratioKey] = {};
                    }
                    if (!primeCompositeData.primeCompositeAcValueCorrelation[ratioKey][acValue]) {
                        primeCompositeData.primeCompositeAcValueCorrelation[ratioKey][acValue] = 0;
                    }
                    primeCompositeData.primeCompositeAcValueCorrelation[ratioKey][acValue]++;

                    if (!primeCompositeData.primeCompositeThreeZoneCorrelation[ratioKey]) {
                        primeCompositeData.primeCompositeThreeZoneCorrelation[ratioKey] = {};
                    }
                    if (!primeCompositeData.primeCompositeThreeZoneCorrelation[ratioKey][threeZoneCombination]) {
                        primeCompositeData.primeCompositeThreeZoneCorrelation[ratioKey][threeZoneCombination] = 0;
                    }
                    primeCompositeData.primeCompositeThreeZoneCorrelation[ratioKey][threeZoneCombination]++;

                    primeCompositeData.trend.push({
                        period: draw.period,
                        prime: primeCount,
                        composite: compositeCount,
                        ratio: ratioKey
                    });

                    const currentPrimeRatio = primeCount / (primeCount + compositeCount);
                    if (lastPrimeRatio !== null) {
                        const ratioDiff = currentPrimeRatio - lastPrimeRatio;
                        if (Math.abs(ratioDiff) > 0.2) {
                            primeCompositeData.conversionPoints.push({
                                period: draw.period,
                                index: index,
                                fromRatio: lastPrimeRatio,
                                toRatio: currentPrimeRatio,
                                direction: ratioDiff > 0 ? 'increase' : 'decrease'
                            });
                        }
                    }
                    lastPrimeRatio = currentPrimeRatio;
                });

                for (let i = 1; i <= rules.redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    let currentOmission = 0;
                    let maxOmission = 0;
                    let tempOmission = 0;
                    let found = false;
                    let consecutiveCount = 0;
                    let maxConsecutive = 0;
                    let totalOmission = 0;
                    let appearanceCount = 0;

                    for (let j = 0; j < reversedDraws.length; j++) {
                        const draw = reversedDraws[j];
                        if (draw.redBalls.includes(numStr)) {
                            if (!found) {
                                currentOmission = tempOmission;
                                found = true;
                            }

                            if (tempOmission > maxOmission) {
                                maxOmission = tempOmission;
                            }

                            totalOmission += tempOmission;
                            appearanceCount++;
                            tempOmission = 0;

                            consecutiveCount++;
                            if (consecutiveCount > maxConsecutive) {
                                maxConsecutive = consecutiveCount;
                            }
                        } else {
                            consecutiveCount = 0;
                            tempOmission++;
                        }
                    }

                    if (!found) {
                        currentOmission = draws.length;
                    }

                    primeCompositeData.numberOmission[numStr] = currentOmission;
                    primeCompositeData.numberMaxOmission[numStr] = maxOmission;
                    primeCompositeData.numberAvgOmission[numStr] = appearanceCount > 0 ? totalOmission / appearanceCount : 0;
                    primeCompositeData.consecutiveAppearances[numStr] = maxConsecutive;
                }

                const primeTrendValues = primeCompositeData.trend.map(item => item.prime);
                const compositeTrendValues = primeCompositeData.trend.map(item => item.composite);

                primeCompositeData.primeStats = this.calculateStatistics(primeTrendValues);
                primeCompositeData.compositeStats = this.calculateStatistics(compositeTrendValues);

                const currentOmissionValues = [];
                for (let i = 1; i <= rules.redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    currentOmissionValues.push({
                        number: numStr,
                        currentOmission: primeCompositeData.numberOmission[numStr],
                        avgOmission: primeCompositeData.numberAvgOmission[numStr],
                        frequency: primeCompositeData.numberFrequency[numStr],
                        type: primeCompositeData.numberType[numStr],
                        consecutiveAppearances: primeCompositeData.consecutiveAppearances[numStr]
                    });
                }

                currentOmissionValues.sort((a, b) => a.currentOmission - b.currentOmission);

                const hotCount = Math.ceil(currentOmissionValues.length * 0.33);
                const warmCount = Math.ceil(currentOmissionValues.length * 0.34);

                for (let i = 0; i < currentOmissionValues.length; i++) {
                    const item = currentOmissionValues[i];
                    if (i < hotCount) {
                        primeCompositeData.hotNumbers.push(item);
                    } else if (i < hotCount + warmCount) {
                        primeCompositeData.warmNumbers.push(item);
                    } else {
                        primeCompositeData.coldNumbers.push(item);
                    }
                }

                primeCompositeData.hotNumbers.sort((a, b) => a.currentOmission - b.currentOmission);
                primeCompositeData.warmNumbers.sort((a, b) => a.currentOmission - b.currentOmission);
                primeCompositeData.coldNumbers.sort((a, b) => a.currentOmission - b.currentOmission);

                primeCompositeData.cycleData = this.analyzePrimeCompositeCycle(primeCompositeData.trend);
                primeCompositeData.positionPreference = this.analyzePositionPreference(primeCompositeData.positionTendency);
                primeCompositeData.primeRatioPrediction = this.predictPrimeRatio(primeCompositeData.trend);
                primeCompositeData.transitionMatrix = this.calculateTransitionMatrix(primeCompositeData.trend);
                primeCompositeData.numberStatusHistory = this.trackNumberStatusHistory(reversedDraws, primes);
                primeCompositeData.statusTransitionProb = this.calculateStatusTransitionProb(primeCompositeData.numberStatusHistory);

                console.log('质合分析数据生成完成');
                console.log('质数总数:', primeCompositeData.primeCount, '合数总数:', primeCompositeData.compositeCount);
                console.log('趋势数据点数:', primeCompositeData.trend.length);
                console.log('转换点数量:', primeCompositeData.conversionPoints.length);
                console.log('热号数量:', primeCompositeData.hotNumbers.length, '温号数量:', primeCompositeData.warmNumbers.length, '冷号数量:', primeCompositeData.coldNumbers.length);
                console.log('周期数据:', primeCompositeData.cycleData);
                console.log('位置偏好:', primeCompositeData.positionPreference);
                console.log('质合比预测:', primeCompositeData.primeRatioPrediction);

                console.log('=== 遗漏数据示例 ===');
                for (let i = 1; i <= 5; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    const avgOmission = primeCompositeData.numberAvgOmission[numStr];
                    console.log(`号码 ${numStr}: 频率=${primeCompositeData.numberFrequency[numStr]}, 当前遗漏=${primeCompositeData.numberOmission[numStr]}, 平均遗漏=${avgOmission !== undefined ? avgOmission.toFixed(1) : 'undefined'}, 最大遗漏=${primeCompositeData.numberMaxOmission[numStr]}, 类型=${primeCompositeData.numberType[numStr]}`);
                }

                console.log('=== 热号详情 ===');
                console.log(primeCompositeData.hotNumbers.slice(0, 5));
                console.log('=== 温号详情 ===');
                console.log(primeCompositeData.warmNumbers.slice(0, 5));
                console.log('=== 冷号详情 ===');
                console.log(primeCompositeData.coldNumbers.slice(0, 5));

                return primeCompositeData;
            }

            static calculateStatistics(values) {
                if (!values || values.length === 0) {
                    return { mean: 0, variance: 0, stdDev: 0, min: 0, max: 0 };
                }

                const n = values.length;
                const sum = values.reduce((acc, val) => acc + val, 0);
                const mean = sum / n;

                const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
                const variance = squaredDiffs.reduce((acc, val) => acc + val, 0) / n;
                const stdDev = Math.sqrt(variance);

                const min = Math.min(...values);
                const max = Math.max(...values);

                return { mean, variance, stdDev, min, max };
            }

            static analyzePrimeCompositeCycle(trend) {
                const primeValues = trend.map(item => item.prime);
                const cycles = [];
                let currentCycle = { start: 0, values: [], direction: null };

                for (let i = 1; i < primeValues.length; i++) {
                    const diff = primeValues[i] - primeValues[i - 1];
                    const direction = diff > 0 ? 'up' : diff < 0 ? 'down' : 'stable';

                    if (currentCycle.direction === null) {
                        currentCycle.direction = direction;
                        currentCycle.values.push(primeValues[i - 1]);
                    } else if (currentCycle.direction !== direction && Math.abs(diff) > 0.5) {
                        currentCycle.values.push(primeValues[i - 1]);
                        currentCycle.end = i - 1;
                        currentCycle.length = currentCycle.end - currentCycle.start + 1;
                        currentCycle.avgValue = currentCycle.values.reduce((a, b) => a + b, 0) / currentCycle.values.length;
                        cycles.push({ ...currentCycle });
                        currentCycle = { start: i, values: [primeValues[i - 1]], direction: direction };
                    } else {
                        currentCycle.values.push(primeValues[i - 1]);
                    }
                }

                if (currentCycle.values.length > 0) {
                    currentCycle.values.push(primeValues[primeValues.length - 1]);
                    currentCycle.end = primeValues.length - 1;
                    currentCycle.length = currentCycle.end - currentCycle.start + 1;
                    currentCycle.avgValue = currentCycle.values.reduce((a, b) => a + b, 0) / currentCycle.values.length;
                    cycles.push(currentCycle);
                }

                const cycleStats = {
                    totalCycles: cycles.length,
                    avgCycleLength: cycles.length > 0 ? cycles.reduce((sum, c) => sum + c.length, 0) / cycles.length : 0,
                    upCycles: cycles.filter(c => c.direction === 'up').length,
                    downCycles: cycles.filter(c => c.direction === 'down').length,
                    stableCycles: cycles.filter(c => c.direction === 'stable').length,
                    currentCycle: cycles[cycles.length - 1] || null,
                    recentCycles: cycles.slice(-3)
                };

                return cycleStats;
            }

            static analyzePositionPreference(positionTendency) {
                const preference = {};

                for (let pos = 0; pos < positionTendency.length; pos++) {
                    const values = positionTendency[pos];
                    const primeCount = values.filter(v => v === 1).length;
                    const totalCount = values.length;
                    const primeRatio = totalCount > 0 ? (primeCount / totalCount * 100).toFixed(1) : 0;
                    const compositeRatio = totalCount > 0 ? ((totalCount - primeCount) / totalCount * 100).toFixed(1) : 0;

                    preference[pos + 1] = {
                        position: pos + 1,
                        primeCount: primeCount,
                        compositeCount: totalCount - primeCount,
                        totalCount: totalCount,
                        primeRatio: parseFloat(primeRatio),
                        compositeRatio: parseFloat(compositeRatio),
                        preference: primeRatio > 40 ? 'prime' : primeRatio < 25 ? 'composite' : 'balanced'
                    };
                }

                return preference;
            }

            static predictPrimeRatio(trend) {
                if (trend.length < 10) {
                    return { predictedRatio: 2, confidence: 'low', confidenceText: '低', reason: '数据不足' };
                }

                const recentTrend = trend.slice(-10);
                const primeValues = recentTrend.map(item => item.prime);
                const avgPrime = primeValues.reduce((a, b) => a + b, 0) / primeValues.length;

                const weights = [1, 1.5, 2, 2.5, 3, 2.5, 2, 1.5, 1, 0.5];
                const weightedSum = primeValues.reduce((sum, val, idx) => sum + val * weights[idx], 0);
                const weightedAvg = weightedSum / weights.reduce((a, b) => a + b, 0);

                const variance = primeValues.reduce((sum, val) => sum + Math.pow(val - avgPrime, 2), 0) / primeValues.length;
                const stdDev = Math.sqrt(variance);

                let confidence = 'medium';
                let confidenceText = '中';

                if (stdDev < 0.5) {
                    confidence = 'high';
                    confidenceText = '高';
                } else if (stdDev > 1.0) {
                    confidence = 'low';
                    confidenceText = '低';
                }

                const lastValue = primeValues[primeValues.length - 1];
                const trendDirection = weightedAvg > lastValue ? 'up' : weightedAvg < lastValue ? 'down' : 'stable';

                const predictedRatio = Math.round(weightedAvg);

                return {
                    predictedRatio: Math.max(1, Math.min(5, predictedRatio)),
                    weightedAvg: weightedAvg.toFixed(2),
                    avgPrime: avgPrime.toFixed(2),
                    lastValue: lastValue,
                    trendDirection: trendDirection,
                    stdDev: stdDev.toFixed(2),
                    confidence: confidence,
                    confidenceText: confidenceText,
                    reason: `基于最近10期加权平均${weightedAvg.toFixed(2)}，标准差${stdDev.toFixed(2)}`
                };
            }

            static calculateTransitionMatrix(trend) {
                const matrix = {};
                const ratioKeys = ['0:6', '1:5', '2:4', '3:3', '4:2', '5:1', '6:0'];

                ratioKeys.forEach(from => {
                    matrix[from] = {};
                    ratioKeys.forEach(to => {
                        matrix[from][to] = 0;
                    });
                });

                for (let i = 1; i < trend.length; i++) {
                    const from = trend[i - 1].ratio;
                    const to = trend[i].ratio;
                    if (matrix[from] && matrix[from][to] !== undefined) {
                        matrix[from][to]++;
                    }
                }

                ratioKeys.forEach(from => {
                    const total = Object.values(matrix[from]).reduce((a, b) => a + b, 0);
                    if (total > 0) {
                        ratioKeys.forEach(to => {
                            matrix[from][to] = (matrix[from][to] / total * 100).toFixed(1);
                        });
                    }
                });

                return matrix;
            }

            static trackNumberStatusHistory(draws, primes) {
                const statusHistory = {};

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    statusHistory[numStr] = [];
                }

                draws.forEach((draw, index) => {
                    for (let i = 1; i <= 33; i++) {
                        const numStr = i.toString().padStart(2, '0');
                        const appeared = draw.redBalls.includes(numStr);
                        const frequency = statusHistory[numStr].filter(s => s === 'appeared').length;
                        const total = index + 1;
                        const avgOmission = frequency > 0 ? (total - frequency) / frequency : total;

                        let status = 'cold';
                        if (appeared) {
                            status = 'just_appeared';
                        } else if (frequency > 0) {
                            const recentOmission = statusHistory[numStr].slice(-5).filter(s => s === 'appeared').length === 0 
                                ? statusHistory[numStr].slice(-5).filter(s => s !== 'appeared').length 
                                : 0;
                            if (recentOmission < avgOmission * 0.8) {
                                status = 'hot';
                            } else if (recentOmission < avgOmission * 1.5) {
                                status = 'warm';
                            } else {
                                status = 'cold';
                            }
                        }

                        statusHistory[numStr].push(status);
                    }
                });

                return statusHistory;
            }

            static calculateStatusTransitionProb(statusHistory) {
                const transitionProb = {};
                const statuses = ['hot', 'warm', 'cold', 'just_appeared'];

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    const history = statusHistory[numStr];
                    const transitions = {};

                    statuses.forEach(from => {
                        transitions[from] = {};
                        statuses.forEach(to => {
                            transitions[from][to] = 0;
                        });
                    });

                    for (let j = 1; j < history.length; j++) {
                        const from = history[j - 1];
                        const to = history[j];
                        if (transitions[from] && transitions[from][to] !== undefined) {
                            transitions[from][to]++;
                        }
                    }

                    statuses.forEach(from => {
                        const total = Object.values(transitions[from]).reduce((a, b) => a + b, 0);
                        if (total > 0) {
                            statuses.forEach(to => {
                                transitions[from][to] = (transitions[from][to] / total * 100).toFixed(1);
                            });
                        }
                    });

                    transitionProb[numStr] = transitions;
                }

                return transitionProb;
            }

            static generateAdvancedStrategies(primeCompositeData, draws) {
                const strategies = [];
                const prediction = primeCompositeData.primeRatioPrediction;
                const cycleData = primeCompositeData.cycleData;
                const positionPreference = primeCompositeData.positionPreference;

                const primeHotCount = primeCompositeData.hotNumbers.filter(n => n.type === 'prime').length;
                const compositeHotCount = primeCompositeData.hotNumbers.filter(n => n.type === 'composite').length;

                strategies.push({
                    icon: '🎯',
                    title: '质合比平衡策略',
                    description: `基于当前质数占比${((primeCompositeData.primeCount / (primeCompositeData.primeCount + primeCompositeData.compositeCount)) * 100).toFixed(1)}%与理论值33.3%的差异，预测下一期质数数量为${prediction.predictedRatio}个`,
                    score: prediction.confidence === 'high' ? 85 : prediction.confidence === 'medium' ? 70 : 55,
                    risk: prediction.confidence === 'high' ? '低' : prediction.confidence === 'medium' ? '中' : '高',
                    priority: prediction.confidence === 'high' ? 'high' : prediction.confidence === 'medium' ? 'medium' : 'low',
                    recommendation: `建议选择${prediction.predictedRatio - 1}至${prediction.predictedRatio + 1}个质数号码，${6 - (prediction.predictedRatio + 1)}至${6 - (prediction.predictedRatio - 1)}个合数号码`
                });

                strategies.push({
                    icon: '🔥',
                    title: '热号追击策略',
                    description: `当前热号共${primeCompositeData.hotNumbers.length}个，其中质数${primeHotCount}个，合数${compositeHotCount}个`,
                    score: primeHotCount + compositeHotCount > 8 ? 80 : 65,
                    risk: '中',
                    priority: 'medium',
                    recommendation: `重点关注热号${primeCompositeData.hotNumbers.slice(0, 5).map(n => n.number).join(', ')}，可考虑选择其中3-4个`
                });

                strategies.push({
                    icon: '❄️',
                    title: '冷号追冷策略',
                    description: `当前冷号共${primeCompositeData.coldNumbers.length}个，平均遗漏${(primeCompositeData.coldNumbers.reduce((sum, n) => sum + n.currentOmission, 0) / primeCompositeData.coldNumbers.length).toFixed(1)}期`,
                    score: primeCompositeData.coldNumbers.length > 10 ? 60 : 45,
                    risk: '高',
                    priority: 'low',
                    recommendation: `谨慎选择冷号${primeCompositeData.coldNumbers.slice(0, 3).map(n => n.number).join(', ')}，建议最多选择1-2个`
                });

                strategies.push({
                    icon: '🔄',
                    title: '周期性策略',
                    description: `当前处于${cycleData.currentCycle?.direction === 'up' ? '上升' : cycleData.currentCycle?.direction === 'down' ? '下降' : '稳定'}周期，平均周期长度${cycleData.avgCycleLength.toFixed(1)}期`,
                    score: cycleData.avgCycleLength > 5 ? 75 : 60,
                    risk: '中',
                    priority: 'medium',
                    recommendation: cycleData.currentCycle?.direction === 'up' ? '当前周期质数呈上升趋势，可适当增加质数选择' : cycleData.currentCycle?.direction === 'down' ? '当前周期质数呈下降趋势，可适当减少质数选择' : '当前周期稳定，建议保持均衡选择'
                });

                strategies.push({
                    icon: '📍',
                    title: '位置偏好策略',
                    description: `第${Object.entries(positionPreference).find(([k, v]) => v.preference === 'prime')?.[0] || '3'}位偏好质数，第${Object.entries(positionPreference).find(([k, v]) => v.preference === 'composite')?.[0] || '5'}位偏好合数`,
                    score: 70,
                    risk: '低',
                    priority: 'medium',
                    recommendation: '根据位置偏好，在偏好质数的位置优先选择质数号码，在偏好合数的位置优先选择合数号码'
                });

                return strategies.sort((a, b) => b.score - a.score);
            }

            static generatePositionRecommendations(primeCompositeData) {
                const recommendations = [];
                const positionPreference = primeCompositeData.positionPreference;

                for (let pos = 1; pos <= 6; pos++) {
                    const pref = positionPreference[pos];
                    if (pref) {
                        recommendations.push(pref);
                    }
                }

                return recommendations;
            }

            static generateCycleStrategies(primeCompositeData) {
                const strategies = [];
                const cycleData = primeCompositeData.cycleData;
                const currentCycle = cycleData.currentCycle;

                if (currentCycle) {
                    if (currentCycle.direction === 'up') {
                        strategies.push({
                            icon: '📈',
                            title: '上升周期策略',
                            description: '当前处于质数上升周期，质数数量呈增加趋势',
                            action: '建议选择3-4个质数号码，顺应上升趋势'
                        });
                    } else if (currentCycle.direction === 'down') {
                        strategies.push({
                            icon: '📉',
                            title: '下降周期策略',
                            description: '当前处于质数下降周期，质数数量呈减少趋势',
                            action: '建议选择1-2个质数号码，顺应下降趋势'
                        });
                    } else {
                        strategies.push({
                            icon: '➡️',
                            title: '稳定周期策略',
                            description: '当前处于稳定周期，质数数量波动较小',
                            action: '建议选择2-3个质数号码，保持均衡'
                        });
                    }
                }

                if (cycleData.avgCycleLength > 0) {
                    const remainingCycle = currentCycle ? (currentCycle.length || 0) : 0;
                    strategies.push({
                        icon: '⏱️',
                        title: '周期转换预警',
                        description: `平均周期长度${cycleData.avgCycleLength.toFixed(1)}期，当前周期已持续${remainingCycle}期`,
                        action: remainingCycle > cycleData.avgCycleLength * 0.8 ? '注意周期可能即将转换，做好策略调整准备' : '当前周期仍在进行中，可继续执行当前策略'
                    });
                }

                strategies.push({
                    icon: '📊',
                    title: '历史周期统计',
                    description: `历史共${cycleData.totalCycles}个周期，其中上升${cycleData.upCycles}次，下降${cycleData.downCycles}次`,
                    action: cycleData.upCycles > cycleData.downCycles ? '上升周期更常见，可适当增加质数选择频率' : cycleData.downCycles > cycleData.upCycles ? '下降周期更常见，可适当减少质数选择频率' : '上升和下降周期相当，建议灵活调整'
                });

                return strategies;
            }

            static performPrimeCompositeAnalysis(draws) {
                const primes = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]);

                const reversedDraws = [...draws].reverse();
                const totalDraws = currentPrimeCompositePeriod === 'all' ? reversedDraws.length : Math.min(currentPrimeCompositePeriod, reversedDraws.length);
                const analyzedDraws = reversedDraws.slice(0, totalDraws);

                const periodRange = document.getElementById('primeCompositePeriodRange');
                if (periodRange) {
                    const startPeriod = analyzedDraws[analyzedDraws.length - 1].period;
                    const endPeriod = analyzedDraws[0].period;
                    periodRange.textContent = `期数范围: ${startPeriod} - ${endPeriod}`;
                }

                const advancedAnalysis = this.performAdvancedPrimeCompositeAnalysis(analyzedDraws, primes);

                const primeCompositeData = {
                    primeCount: 0,
                    compositeCount: 0,
                    trend: [],
                    advancedAnalysis: advancedAnalysis
                };

                analyzedDraws.forEach(draw => {
                    let primeCount = 0;
                    let compositeCount = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            primeCount++;
                        } else {
                            compositeCount++;
                        }
                    });

                    primeCompositeData.primeCount += primeCount;
                    primeCompositeData.compositeCount += compositeCount;

                    primeCompositeData.trend.push({
                        period: draw.period,
                        prime: primeCount,
                        composite: compositeCount
                    });
                });

                primeCompositeChartData = primeCompositeData;
                primeCompositeAnalysisResults = this.generatePrimeCompositeAnalysisResults(primeCompositeData, totalDraws, advancedAnalysis);

                this.updatePrimeCompositeChart(primeCompositeData);
                this.updatePrimeCompositePieChart(primeCompositeData);
                this.updatePrimeCompositeConclusion(primeCompositeAnalysisResults);
            }

            static updatePrimeCompositeChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const periods = primeCompositeData.trend.slice(0, 20).map(item => item.period);
                const primeData = primeCompositeData.trend.slice(0, 20).map(item => item.prime);
                const compositeData = primeCompositeData.trend.slice(0, 20).map(item => item.composite);

                const option = {
                    title: {
                        text: '质合分布趋势（最近20期）',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    legend: {
                        data: ['质数', '合数'],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value'
                    },
                    series: [
                        {
                            name: '质数',
                            type: 'line',
                            data: primeData,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: '合数',
                            type: 'line',
                            data: compositeData,
                            smooth: true,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updatePrimeCompositePieChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositePieChart');
                if (!chartDom) {
                    console.warn('primeCompositePieChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                const primeRatio = ((primeCompositeData.primeCount / total) * 100).toFixed(2);
                const compositeRatio = ((primeCompositeData.compositeCount / total) * 100).toFixed(2);

                const linkedData = primeCompositeData.linkedData || [];
                const recentData = linkedData.slice(0, 10);
                const recentPrimeCount = recentData.reduce((sum, item) => sum + item.primeCount, 0);
                const recentCompositeCount = recentData.reduce((sum, item) => sum + item.compositeCount, 0);
                const recentTotal = recentPrimeCount + recentCompositeCount;
                const recentPrimeRatio = recentTotal > 0 ? ((recentPrimeCount / recentTotal) * 100).toFixed(2) : 0;
                const recentCompositeRatio = recentTotal > 0 ? ((recentCompositeCount / recentTotal) * 100).toFixed(2) : 0;

                const primeTrend = parseFloat(recentPrimeRatio) > parseFloat(primeRatio) ? '上升' : parseFloat(recentPrimeRatio) < parseFloat(primeRatio) ? '下降' : '平稳';
                const compositeTrend = parseFloat(recentCompositeRatio) > parseFloat(compositeRatio) ? '上升' : parseFloat(recentCompositeRatio) < parseFloat(compositeRatio) ? '下降' : '平稳';

                const acValueDistribution = this.calculateACValueDistribution(linkedData);
                const threeZoneDistribution = this.calculateThreeZoneDistribution(linkedData);

                const option = {
                    title: {
                        text: '质合占比饼图（核心图表）',
                        subtext: `质数占比：${primeRatio}% | 合数占比：${compositeRatio}% | 近10期质数趋势：${primeTrend}（${recentPrimeRatio}%）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#E63946',
                            fontWeight: 'normal'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const totalDraws = primeCompositeData.trend.length;
                            const avgPerDraw = params.name === '质数' ? 
                                (primeCompositeData.primeCount / totalDraws).toFixed(2) : 
                                (primeCompositeData.compositeCount / totalDraws).toFixed(2);

                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50; font-size: 14px;">${params.name}</div>
                                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background-color: ${params.color}; border-radius: 2px; margin-right: 8px;"></span>
                                    <span style="color: #2c3e50;">总出现次数：</span>
                                    <span style="font-weight: bold; color: ${params.color}; margin-left: 4px;">${params.value}</span>
                                </div>
                                <div style="color: #2c3e50; margin-bottom: 6px;">占比：<strong style="color: ${params.color};">${params.percent}%</strong></div>
                                <div style="color: #2c3e50; margin-bottom: 6px;">平均每期：<strong style="color: ${params.color};">${avgPerDraw}个</strong></div>`;

                            if (params.name === '质数') {
                                result += `<div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #E2E8F0;">
                                    <div style="color: #2c3e50; font-weight: bold; margin-bottom: 6px;">联动分析：</div>
                                    <div style="color: #457B9D; font-size: 12px;">高频AC值区间：${acValueDistribution.primeTopAC}</div>
                                    <div style="color: #457B9D; font-size: 12px;">高频三区组合：${threeZoneDistribution.primeTopZone}</div>
                                    <div style="color: #457B9D; font-size: 12px;">近10期趋势：${primeTrend}（${recentPrimeRatio}%）</div>
                                </div>`;
                            } else {
                                result += `<div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #E2E8F0;">
                                    <div style="color: #2c3e50; font-weight: bold; margin-bottom: 6px;">联动分析：</div>
                                    <div style="color: #457B9D; font-size: 12px;">高频AC值区间：${acValueDistribution.compositeTopAC}</div>
                                    <div style="color: #457B9D; font-size: 12px;">高频三区组合：${threeZoneDistribution.compositeTopZone}</div>
                                    <div style="color: #457B9D; font-size: 12px;">近10期趋势：${compositeTrend}（${recentCompositeRatio}%）</div>
                                </div>`;
                            }

                            result += `</div>`;
                            return result;
                        }
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        top: 'middle',
                        textStyle: {
                            fontSize: 14,
                            color: '#2c3e50'
                        },
                        data: ['质数', '合数']
                    },
                    series: [
                        {
                            name: '质合分布',
                            type: 'pie',
                            radius: ['45%', '70%'],
                            center: ['60%', '50%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 3
                            },
                            label: {
                                show: true,
                                formatter: function(params) {
                                    const percentage = params.percent.toFixed(2);
                                    const value = params.value;
                                    return `${params.name}\n${percentage}%\n${value}次`;
                                },
                                fontSize: 13,
                                fontWeight: 'bold',
                                color: '#2c3e50',
                                lineHeight: 18
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 15,
                                    fontWeight: 'bold'
                                },
                                itemStyle: {
                                    shadowBlur: 20,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)',
                                    borderWidth: 4
                                },
                                scale: true,
                                scaleSize: 10
                            },
                            labelLine: {
                                show: true,
                                length: 25,
                                length2: 35,
                                smooth: true,
                                lineStyle: {
                                    width: 2,
                                    color: '#2c3e50'
                                }
                            },
                            data: [
                                { 
                                    value: primeCompositeData.primeCount, 
                                    name: '质数', 
                                    itemStyle: { 
                                        color: {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#E63946'
                                            }, {
                                                offset: 1, color: '#D62828'
                                            }]
                                        }
                                    } 
                                },
                                { 
                                    value: primeCompositeData.compositeCount, 
                                    name: '合数', 
                                    itemStyle: { 
                                        color: {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#457B9D'
                                            }, {
                                                offset: 1, color: '#1D3557'
                                            }]
                                        }
                                    } 
                                }
                            ]
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.on('click', function(params) {
                    console.log('点击饼图:', params.name);

                    const acValueFilter = document.getElementById('primeCompositeAcValueFilter');
                PrimeCompositeAnalysis.performPrimeCompositeAnalysisByPeriod();
                });
            }

            static calculateACValueDistribution(linkedData) {
                if (!linkedData || linkedData.length === 0) {
                    return { primeTopAC: '无数据', compositeTopAC: '无数据' };
                }

                const primeACValues = [];
                const compositeACValues = [];

                linkedData.forEach(item => {
                    const acValue = item.acValue;
                    const primeCount = item.primeCount;
                    const compositeCount = item.compositeCount;

                    for (let i = 0; i < primeCount; i++) {
                        primeACValues.push(acValue);
                    }
                    for (let i = 0; i < compositeCount; i++) {
                        compositeACValues.push(acValue);
                    }
                });

                const calculateTopRange = (values) => {
                    if (values.length === 0) return '无数据';

                    const frequency = {};
                    values.forEach(val => {
                        const range = Math.floor(val / 2) * 2;
                        const key = `${range}-${range + 1}`;
                        frequency[key] = (frequency[key] || 0) + 1;
                    });

                    const sorted = Object.entries(frequency).sort((a, b) => b[1] - a[1]);
                    return sorted.length > 0 ? sorted[0][0] : '无数据';
                };

                return {
                    primeTopAC: calculateTopRange(primeACValues),
                    compositeTopAC: calculateTopRange(compositeACValues)
                };
            }

            static calculateThreeZoneDistribution(linkedData) {
                if (!linkedData || linkedData.length === 0) {
                    return { primeTopZone: '无数据', compositeTopZone: '无数据' };
                }

                const primeZoneCombinations = [];
                const compositeZoneCombinations = [];

                linkedData.forEach(item => {
                    const zoneCombination = item.threeZoneCombination;
                    const primeCount = item.primeCount;
                    const compositeCount = item.compositeCount;

                    for (let i = 0; i < primeCount; i++) {
                        primeZoneCombinations.push(zoneCombination);
                    }
                    for (let i = 0; i < compositeCount; i++) {
                        compositeZoneCombinations.push(zoneCombination);
                    }
                });

                const calculateTopCombination = (combinations) => {
                    if (combinations.length === 0) return '无数据';

                    const frequency = {};
                    combinations.forEach(combo => {
                        frequency[combo] = (frequency[combo] || 0) + 1;
                    });

                    const sorted = Object.entries(frequency).sort((a, b) => b[1] - a[1]);
                    return sorted.length > 0 ? sorted[0][0] : '无数据';
                };

                return {
                    primeTopZone: calculateTopCombination(primeZoneCombinations),
                    compositeTopZone: calculateTopCombination(compositeZoneCombinations)
                };
            }

            static updatePrimeCompositeOverview(primeCompositeData, totalPeriods, phase1Data) {
                document.getElementById('primeCompositeAnalysisPeriods').textContent = totalPeriods;
                document.getElementById('primeCompositePrimeCount').textContent = primeCompositeData.primeCount;
                document.getElementById('primeCompositeCompositeCount').textContent = primeCompositeData.compositeCount;

                const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                const primeRatio = ((primeCompositeData.primeCount / total) * 100).toFixed(1);
                const compositeRatio = ((primeCompositeData.compositeCount / total) * 100).toFixed(1);

                document.getElementById('primeCompositePrimeRatio').textContent = primeRatio + '%';
                document.getElementById('primeCompositeCompositeRatio').textContent = compositeRatio + '%';

                this.updatePrimeCompositePieChart(primeCompositeData);
                this.generatePrimeCompositeStatistics(primeCompositeData, totalPeriods, phase1Data);
            }

            static performAdvancedPrimeCompositeAnalysis(draws, primes) {
                console.log('=== 开始执行质合分析高级分析 ===');
                console.log('数据期数:', draws.length);

                const advancedData = {
                    primeOmissionAnalysis: {},
                    compositeOmissionAnalysis: {},
                    primeHotColdAnalysis: {},
                    compositeHotColdAnalysis: {},
                    primeCompositeCycleAnalysis: {},
                    primeCompositePatternAnalysis: {},
                    primeCompositePredictionAnalysis: {}
                };

                const totalDraws = draws.length;

                const primeNumbers = Array.from(primes);
                const compositeNumbers = [];
                for (let num = 1; num <= 33; num++) {
                    if (!primes.has(num)) {
                        compositeNumbers.push(num);
                    }
                }

                advancedData.primeOmissionAnalysis = this.analyzePrimeOmissions(draws, primes);
                advancedData.compositeOmissionAnalysis = this.analyzeCompositeOmissions(draws, primes);
                advancedData.primeHotColdAnalysis = this.analyzePrimeHotCold(draws, primes, totalDraws);
                advancedData.compositeHotColdAnalysis = this.analyzeCompositeHotCold(draws, primes, totalDraws);
                advancedData.primeCompositeCycleAnalysis = this.analyzePrimeCompositeCycles(draws, primes);
                advancedData.primeCompositePatternAnalysis = this.analyzePrimeCompositePatterns(draws, primes);
                advancedData.primeCompositePredictionAnalysis = this.analyzePrimeCompositePredictions(draws, primes, advancedData);

                console.log('质合分析高级分析完成');

                return advancedData;
            }

            static analyzePrimeOmissions(draws, primes) {
                const omissionData = {};

                primes.forEach(num => {
                    omissionData[num] = {
                        currentOmission: 0,
                        avgOmission: 0,
                        maxOmission: 0,
                        omissionHistory: []
                    };
                });

                let lastAppearance = {};
                primes.forEach(num => {
                    lastAppearance[num] = -1;
                });

                draws.forEach((draw, index) => {
                    const numStr = draw.redBalls.map(b => parseInt(b));

                    primes.forEach(num => {
                        if (numStr.includes(num)) {
                            const omission = index - lastAppearance[num];
                            if (lastAppearance[num] !== -1) {
                                omissionData[num].omissionHistory.push(omission);
                                omissionData[num].maxOmission = Math.max(omissionData[num].maxOmission, omission);
                            }
                            lastAppearance[num] = index;
                        }
                    });
                });

                const lastIndex = draws.length - 1;
                primes.forEach(num => {
                    omissionData[num].currentOmission = lastIndex - lastAppearance[num];

                    if (omissionData[num].omissionHistory.length > 0) {
                        const sum = omissionData[num].omissionHistory.reduce((a, b) => a + b, 0);
                        omissionData[num].avgOmission = sum / omissionData[num].omissionHistory.length;
                    }
                });

                return omissionData;
            }

            static analyzeCompositeOmissions(draws, primes) {
                const omissionData = {};

                for (let num = 1; num <= 33; num++) {
                    if (!primes.has(num)) {
                        omissionData[num] = {
                            currentOmission: 0,
                            avgOmission: 0,
                            maxOmission: 0,
                            omissionHistory: []
                        };
                    }
                }

                let lastAppearance = {};
                for (let num = 1; num <= 33; num++) {
                    if (!primes.has(num)) {
                        lastAppearance[num] = -1;
                    }
                }

                draws.forEach((draw, index) => {
                    const numStr = draw.redBalls.map(b => parseInt(b));

                    for (let num = 1; num <= 33; num++) {
                        if (!primes.has(num)) {
                            if (numStr.includes(num)) {
                                const omission = index - lastAppearance[num];
                                if (lastAppearance[num] !== -1) {
                                    omissionData[num].omissionHistory.push(omission);
                                    omissionData[num].maxOmission = Math.max(omissionData[num].maxOmission, omission);
                                }
                                lastAppearance[num] = index;
                            }
                        }
                    }
                });

                const lastIndex = draws.length - 1;
                for (let num = 1; num <= 33; num++) {
                    if (!primes.has(num)) {
                        omissionData[num].currentOmission = lastIndex - lastAppearance[num];

                        if (omissionData[num].omissionHistory.length > 0) {
                            const sum = omissionData[num].omissionHistory.reduce((a, b) => a + b, 0);
                            omissionData[num].avgOmission = sum / omissionData[num].omissionHistory.length;
                        }
                    }
                }

                return omissionData;
            }

            static analyzePrimeHotCold(draws, primes, totalDraws) {
                const hotColdData = {
                    hot: [],
                    warm: [],
                    cold: []
                };

                const primeCounts = {};
                primes.forEach(num => {
                    primeCounts[num] = 0;
                });

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            primeCounts[num]++;
                        }
                    });
                });

                const sortedPrimes = Object.entries(primeCounts)
                    .map(([num, count]) => ({ num: parseInt(num), count }))
                    .sort((a, b) => b.count - a.count);

                const avgCount = sortedPrimes.reduce((sum, item) => sum + item.count, 0) / sortedPrimes.length;

                sortedPrimes.forEach(item => {
                    const numStr = item.num.toString().padStart(2, '0');
                    if (item.count > avgCount * 1.2) {
                        hotColdData.hot.push(numStr);
                    } else if (item.count > avgCount * 0.8) {
                        hotColdData.warm.push(numStr);
                    } else {
                        hotColdData.cold.push(numStr);
                    }
                });

                return hotColdData;
            }

            static analyzeCompositeHotCold(draws, primes, totalDraws) {
                const hotColdData = {
                    hot: [],
                    warm: [],
                    cold: []
                };

                const compositeCounts = {};
                for (let num = 1; num <= 33; num++) {
                    if (!primes.has(num)) {
                        compositeCounts[num] = 0;
                    }
                }

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (!primes.has(num)) {
                            compositeCounts[num]++;
                        }
                    });
                });

                const sortedComposites = Object.entries(compositeCounts)
                    .map(([num, count]) => ({ num: parseInt(num), count }))
                    .sort((a, b) => b.count - a.count);

                const avgCount = sortedComposites.reduce((sum, item) => sum + item.count, 0) / sortedComposites.length;

                sortedComposites.forEach(item => {
                    const numStr = item.num.toString().padStart(2, '0');
                    if (item.count > avgCount * 1.2) {
                        hotColdData.hot.push(numStr);
                    } else if (item.count > avgCount * 0.8) {
                        hotColdData.warm.push(numStr);
                    } else {
                        hotColdData.cold.push(numStr);
                    }
                });

                return hotColdData;
            }

            static analyzePrimeCompositeCycles(draws, primes) {
                const cycleData = {
                    primeCycle: {
                        shortTermAvg: 0,
                        mediumTermAvg: 0,
                        longTermAvg: 0,
                        cyclePattern: 'unknown',
                        cycleStability: 0
                    },
                    compositeCycle: {
                        shortTermAvg: 0,
                        mediumTermAvg: 0,
                        longTermAvg: 0,
                        cyclePattern: 'unknown',
                        cycleStability: 0
                    }
                };

                const primeCounts = draws.map(draw => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            count++;
                        }
                    });
                    return count;
                });

                const compositeCounts = draws.map(draw => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (!primes.has(num)) {
                            count++;
                        }
                    });
                    return count;
                });

                const calculateCycleStats = (counts) => {
                    const shortTerm = counts.slice(-10);
                    const mediumTerm = counts.slice(-30);
                    const longTerm = counts;

                    const shortAvg = shortTerm.reduce((sum, val) => sum + val, 0) / shortTerm.length;
                    const mediumAvg = mediumTerm.reduce((sum, val) => sum + val, 0) / mediumTerm.length;
                    const longAvg = longTerm.reduce((sum, val) => sum + val, 0) / longTerm.length;

                    const shortVariance = shortTerm.reduce((sum, val) => sum + Math.pow(val - shortAvg, 2), 0) / shortTerm.length;
                    const mediumVariance = mediumTerm.reduce((sum, val) => sum + Math.pow(val - mediumAvg, 2), 0) / mediumTerm.length;
                    const longVariance = longTerm.reduce((sum, val) => sum + Math.pow(val - longAvg, 2), 0) / longTerm.length;

                    const stability = 1 - (shortVariance + mediumVariance + longVariance) / 3;

                    let pattern = 'random';
                    if (stability > 0.7) {
                        pattern = 'regular';
                    } else if (stability > 0.4) {
                        pattern = 'semi-regular';
                    }

                    return {
                        shortTermAvg: shortAvg,
                        mediumTermAvg: mediumAvg,
                        longTermAvg: longAvg,
                        cyclePattern: pattern,
                        cycleStability: stability
                    };
                };

                cycleData.primeCycle = calculateCycleStats(primeCounts);
                cycleData.compositeCycle = calculateCycleStats(compositeCounts);

                return cycleData;
            }

            static analyzePrimeCompositePatterns(draws, primes) {
                const patternData = {
                    primeCompositeCombinations: {},
                    commonPatterns: [],
                    transitionPatterns: {}
                };

                draws.forEach(draw => {
                    let primeCount = 0;
                    let compositeCount = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            primeCount++;
                        } else {
                            compositeCount++;
                        }
                    });

                    const combination = `${primeCount}-${compositeCount}`;
                    patternData.primeCompositeCombinations[combination] = (patternData.primeCompositeCombinations[combination] || 0) + 1;
                });

                const sortedCombinations = Object.entries(patternData.primeCompositeCombinations)
                    .map(([combination, count]) => ({ combination, count, frequency: (count / draws.length * 100).toFixed(2) }))
                    .sort((a, b) => b.count - a.count);

                patternData.commonPatterns = sortedCombinations.slice(0, 10);

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    let currentPrimeCount = 0;
                    let currentCompositeCount = 0;
                    currentDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            currentPrimeCount++;
                        } else {
                            currentCompositeCount++;
                        }
                    });

                    let nextPrimeCount = 0;
                    let nextCompositeCount = 0;
                    nextDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            nextPrimeCount++;
                        } else {
                            nextCompositeCount++;
                        }
                    });

                    const currentCombination = `${currentPrimeCount}-${currentCompositeCount}`;
                    const nextCombination = `${nextPrimeCount}-${nextCompositeCount}`;
                    const transitionKey = `${currentCombination}->${nextCombination}`;

                    patternData.transitionPatterns[transitionKey] = (patternData.transitionPatterns[transitionKey] || 0) + 1;
                }

                return patternData;
            }

            static analyzePrimeCompositePredictions(draws, primes, advancedData) {
                const predictionData = {
                    nextCombination: null,
                    confidence: 0,
                    primePrediction: 0,
                    compositePrediction: 0,
                    predictionReasoning: []
                };

                const recentDraws = draws.slice(-10);

                const recentPrimeAvg = recentDraws.reduce((sum, draw) => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (primes.has(num)) {
                            count++;
                        }
                    });
                    return sum + count;
                }, 0) / recentDraws.length;

                const recentCompositeAvg = recentDraws.reduce((sum, draw) => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (!primes.has(num)) {
                            count++;
                        }
                    });
                    return sum + count;
                }, 0) / recentDraws.length;

                const patternData = advancedData.primeCompositePatternAnalysis;
                const cycleData = advancedData.primeCompositeCycleAnalysis;

                const predictedPrime = Math.round(recentPrimeAvg * 0.6 + 2.5 * 0.4);
                const predictedComposite = Math.round(recentCompositeAvg * 0.6 + 3.5 * 0.4);

                const total = predictedPrime + predictedComposite;
                if (total !== 6) {
                    const adjustment = (6 - total) / 2;
                    predictionData.primePrediction = Math.max(0, Math.min(6, predictedPrime + Math.round(adjustment)));
                    predictionData.compositePrediction = Math.max(0, Math.min(6, predictedComposite + Math.round(adjustment)));
                } else {
                    predictionData.primePrediction = predictedPrime;
                    predictionData.compositePrediction = predictedComposite;
                }

                predictionData.nextCombination = `${predictionData.primePrediction}-${predictionData.compositePrediction}`;

                let confidence = 0;

                if (patternData.commonPatterns.length > 0) {
                    const topPattern = patternData.commonPatterns[0];
                    if (parseFloat(topPattern.frequency) > 20) {
                        confidence += 25;
                        predictionData.predictionReasoning.push('高频组合' + topPattern.combination + '出现频率' + topPattern.frequency + '%');
                    }
                }

                const lastCombination = `${recentDraws[recentDraws.length-1].redBalls.filter(b => primes.has(parseInt(b))).length}-${recentDraws[recentDraws.length-1].redBalls.filter(b => !primes.has(parseInt(b))).length}`;

                if (lastCombination === predictionData.nextCombination) {
                    confidence -= 15;
                    predictionData.predictionReasoning.push('与上期相同，降低置信度');
                }

                if (cycleData.primeCycle.cyclePattern === 'regular' || cycleData.compositeCycle.cyclePattern === 'regular') {
                    confidence += 20;
                    predictionData.predictionReasoning.push('呈现规律性周期');
                }

                const primeStability = cycleData.primeCycle.cycleStability;
                const compositeStability = cycleData.compositeCycle.cycleStability;
                const avgStability = (primeStability + compositeStability) / 2;

                if (avgStability > 0.5) {
                    confidence += 15;
                    predictionData.predictionReasoning.push('周期稳定性较高（' + (avgStability * 100).toFixed(0) + '%）');
                }

                predictionData.confidence = Math.max(0, Math.min(100, confidence));

                return predictionData;
            }

            static generatePrimeCompositeAnalysisResults(primeCompositeData, totalDraws, advancedAnalysis) {
                const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                const primeRatio = ((primeCompositeData.primeCount / total) * 100).toFixed(2);
                const compositeRatio = ((primeCompositeData.compositeCount / total) * 100).toFixed(2);

                const patternData = advancedAnalysis.primeCompositePatternAnalysis;
                const sortedCombinations = patternData.commonPatterns;
                const topCombinations = sortedCombinations.slice(0, 5);

                const trendAnalysis = this.analyzePrimeCompositeTrend(primeCompositeData);

                return {
                    totalDraws,
                    total,
                    primeRatio,
                    compositeRatio,
                    topCombinations,
                    trendAnalysis,
                    advancedAnalysis
                };
            }

            static analyzePrimeCompositeTrend(primeCompositeData) {
                const trend = primeCompositeData.trend;
                const recentDraws = trend.slice(-10);
                const earlierDraws = trend.slice(-20, -10);

                const calculateAverage = (draws, type) => {
                    return draws.reduce((sum, item) => sum + item[type], 0) / draws.length;
                };

                const recentPrimeAvg = calculateAverage(recentDraws, 'prime');
                const recentCompositeAvg = calculateAverage(recentDraws, 'composite');

                const earlierPrimeAvg = earlierDraws.length > 0 ? calculateAverage(earlierDraws, 'prime') : recentPrimeAvg;
                const earlierCompositeAvg = earlierDraws.length > 0 ? calculateAverage(earlierDraws, 'composite') : recentCompositeAvg;

                const primeTrend = recentPrimeAvg - earlierPrimeAvg;
                const compositeTrend = recentCompositeAvg - earlierCompositeAvg;

                return {
                    prime: { recent: recentPrimeAvg.toFixed(2), trend: primeTrend.toFixed(2), status: primeTrend > 0.2 ? '上升' : (primeTrend < -0.2 ? '下降' : '平稳') },
                    composite: { recent: recentCompositeAvg.toFixed(2), trend: compositeTrend.toFixed(2), status: compositeTrend > 0.2 ? '上升' : (compositeTrend < -0.2 ? '下降' : '平稳') }
                };
            }

            static updatePrimeCompositeConclusion(results) {
                const conclusionContent = document.getElementById('primeCompositeConclusionContent');
                if (!conclusionContent) return;

                const phase1Data = results.advancedAnalysis;

                let html = '<div class="conclusion-grid">';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-chart-line" style="color: #E63946;"></i> 质数趋势</h4>';
                html += `<p>近期平均：<strong>${results.trendAnalysis.prime.recent}</strong> 个</p>`;
                html += `<p>趋势状态：<strong>${results.trendAnalysis.prime.status}</strong>（${results.trendAnalysis.prime.trend > 0 ? '+' : ''}${results.trendAnalysis.prime.trend}）</p>`;
                html += '</div>';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-chart-line" style="color: #457B9D;"></i> 合数趋势</h4>';
                html += `<p>近期平均：<strong>${results.trendAnalysis.composite.recent}</strong> 个</p>`;
                html += `<p>趋势状态：<strong>${results.trendAnalysis.composite.status}</strong>（${results.trendAnalysis.composite.trend > 0 ? '+' : ''}${results.trendAnalysis.composite.trend}）</p>`;
                html += '</div>';

                if (phase1Data && phase1Data.primeCompositePredictionAnalysis) {
                    const predictionData = phase1Data.primeCompositePredictionAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-magic" style="color: #2ECC71;"></i> 预测分析</h4>';
                    html += `<p>预测组合：<strong>${predictionData.nextCombination}</strong></p>`;
                    html += `<p>置信度：<strong>${predictionData.confidence.toFixed(0)}%</strong></p>`;
                    if (predictionData.predictionReasoning.length > 0) {
                        html += '<p>预测依据：';
                        predictionData.predictionReasoning.forEach(reason => {
                            html += `${reason}；`;
                        });
                        html += '</p>';
                    }
                    html += '</div>';
                }

                if (phase1Data && phase1Data.primeCompositeCycleAnalysis) {
                    const cycleData = phase1Data.primeCompositeCycleAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-sync-alt" style="color: #9B59B6;"></i> 周期分析</h4>';
                    html += `<p>质数周期模式：<strong>${cycleData.primeCycle.cyclePattern === 'regular' ? '规律性' : cycleData.primeCycle.cyclePattern === 'semi-regular' ? '半规律性' : '随机性'}</strong></p>`;
                    html += `<p>合数周期模式：<strong>${cycleData.compositeCycle.cyclePattern === 'regular' ? '规律性' : cycleData.compositeCycle.cyclePattern === 'semi-regular' ? '半规律性' : '随机性'}</strong></p>`;
                    html += `<p>周期稳定性：<strong>${((cycleData.primeCycle.cycleStability + cycleData.compositeCycle.cycleStability) / 2 * 100).toFixed(0)}%</strong></p>`;
                    html += '</div>';
                }

                if (phase1Data && phase1Data.primeCompositePatternAnalysis) {
                    const patternData = phase1Data.primeCompositePatternAnalysis;
                    html += '<div class="conclusion-item full-width">';
                    html += '<h4><i class="fas fa-th" style="color: #F39C12;"></i> 高频组合</h4>';
                    html += '<p>出现频率最高的质合组合：</p>';
                    html += '<ul>';
                    patternData.commonPatterns.slice(0, 5).forEach(pattern => {
                        html += `<li>${pattern.combination}（${pattern.frequency}%）</li>`;
                    });
                    html += '</ul>';
                    html += '</div>';
                }

                html += '</div>';

                conclusionContent.innerHTML = html;
            }

            static generatePrimeCompositeStatistics(primeCompositeData, totalPeriods) {
                const statisticsContent = document.getElementById('primeCompositeStatisticsContent');
                if (!statisticsContent) {
                    console.warn('primeCompositeStatisticsContent 容器不存在');
                    return;
                }

                const linkedData = primeCompositeData.linkedData || [];
                const combinationFrequency = primeCompositeData.primeCompositeCombinationFrequency || {};
                const acValueCorrelation = primeCompositeData.primeCompositeAcValueCorrelation || {};
                const threeZoneCorrelation = primeCompositeData.primeCompositeThreeZoneCorrelation || {};

                const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                const primeRatio = ((primeCompositeData.primeCount / total) * 100).toFixed(1);
                const compositeRatio = ((primeCompositeData.compositeCount / total) * 100).toFixed(1);

                const topCombinations = Object.entries(combinationFrequency)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([combo, freq]) => {
                        const percentage = ((freq / totalPeriods) * 100).toFixed(1);
                        const [prime, composite] = combo.split(':').map(Number);
                        return {
                            combo: `${prime}质${composite}合`,
                            freq,
                            percentage
                        };
                    });

                const acValueStats = {};
                Object.entries(acValueCorrelation).forEach(([combo, acData]) => {
                    const comboTotal = Object.values(acData).reduce((sum, count) => sum + count, 0);
                    const topAC = Object.entries(acData).sort((a, b) => b[1] - a[1])[0];
                    if (topAC) {
                        acValueStats[combo] = {
                            topAC: topAC[0],
                            topACCount: topAC[1],
                            topACPercentage: ((topAC[1] / comboTotal) * 100).toFixed(1),
                            comboTotal
                        };
                    }
                });

                const threeZoneStats = {};
                Object.entries(threeZoneCorrelation).forEach(([combo, zoneData]) => {
                    const comboTotal = Object.values(zoneData).reduce((sum, count) => sum + count, 0);
                    const topZone = Object.entries(zoneData).sort((a, b) => b[1] - a[1])[0];
                    if (topZone) {
                        threeZoneStats[combo] = {
                            topZone: topZone[0],
                            topZoneCount: topZone[1],
                            topZonePercentage: ((topZone[1] / comboTotal) * 100).toFixed(1),
                            comboTotal
                        };
                    }
                });

                const recentTrend = primeCompositeData.trend.slice(0, 10);
                const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                const primeTrendDirection = recentPrimeAvg > 2.5 ? '升温' : recentPrimeAvg < 1.5 ? '降温' : '平稳';
                const compositeTrendDirection = recentCompositeAvg > 4 ? '升温' : recentCompositeAvg < 3 ? '降温' : '平稳';

                const linkedACValues = linkedData.map(item => item.acValue);
                const acValueDistribution = {};
                linkedACValues.forEach(ac => {
                    const range = Math.floor(ac / 2) * 2;
                    const key = `${range}-${range + 1}`;
                    acValueDistribution[key] = (acValueDistribution[key] || 0) + 1;
                });
                const topACRange = Object.entries(acValueDistribution).sort((a, b) => b[1] - a[1])[0];

                const linkedThreeZones = linkedData.map(item => item.threeZoneCombination);
                const threeZoneDistribution = {};
                linkedThreeZones.forEach(zone => {
                    threeZoneDistribution[zone] = (threeZoneDistribution[zone] || 0) + 1;
                });
                const topThreeZone = Object.entries(threeZoneDistribution).sort((a, b) => b[1] - a[1])[0];

                statisticsContent.innerHTML = `
                    <div class="statistics-grid">
                        <div class="statistics-card">
                            <div class="statistics-header">
                                <span class="statistics-icon">🏆</span>
                                <h6>热门质合组合 Top3</h6>
                            </div>
                            <div class="statistics-body">
                                ${topCombinations.map((item, index) => `
                                    <div class="statistics-item ${index === 0 ? 'highlight' : ''}">
                                        <div class="item-rank">${index + 1}</div>
                                        <div class="item-content">
                                            <div class="item-name">${item.combo}</div>
                                            <div class="item-stats">
                                                <span class="item-freq">${item.freq}次</span>
                                                <span class="item-percentage">${item.percentage}%</span>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <div class="statistics-card">
                            <div class="statistics-header">
                                <span class="statistics-icon">📊</span>
                                <h6>质合占比分析</h6>
                            </div>
                            <div class="statistics-body">
                                <div class="ratio-analysis">
                                    <div class="ratio-item">
                                        <div class="ratio-label">质数占比</div>
                                        <div class="ratio-bar-container">
                                            <div class="ratio-bar ratio-prime" style="width: ${primeRatio}%;"></div>
                                        </div>
                                        <div class="ratio-value">${primeRatio}%</div>
                                    </div>
                                    <div class="ratio-item">
                                        <div class="ratio-label">合数占比</div>
                                        <div class="ratio-bar-container">
                                            <div class="ratio-bar ratio-composite" style="width: ${compositeRatio}%;"></div>
                                        </div>
                                        <div class="ratio-value">${compositeRatio}%</div>
                                    </div>
                                </div>
                                <div class="ratio-conclusion">
                                    ${parseFloat(primeRatio) > 35 ? '质数占比偏高，建议关注合数回补机会。' : 
                                      parseFloat(primeRatio) < 30 ? '质数占比偏低，建议关注质数回补机会。' : 
                                      '质合比例相对均衡，可延续当前选号策略。'}
                                </div>
                            </div>
                        </div>

                        <div class="statistics-card">
                            <div class="statistics-header">
                                <span class="statistics-icon">🔗</span>
                                <h6>AC值联动分析</h6>
                            </div>
                            <div class="statistics-body">
                                <div class="linkage-analysis">
                                    <div class="linkage-item">
                                        <div class="linkage-label">高频AC值区间</div>
                                        <div class="linkage-value">${topACRange ? `${topACRange[0]} (${((topACRange[1] / totalPeriods) * 100).toFixed(1)}%)` : '无数据'}</div>
                                    </div>
                                    ${topCombinations.slice(0, 2).map(item => {
                                        const comboKey = item.combo.replace('质', ':').replace('合', '');
                                        const acStat = acValueStats[comboKey];
                                        if (acStat) {
                                            return `
                                                <div class="linkage-item">
                                                    <div class="linkage-label">${item.combo}对应AC值</div>
                                                    <div class="linkage-value">AC${acStat.topAC} (${acStat.topACPercentage}%)</div>
                                                </div>
                                            `;
                                        }
                                        return '';
                                    }).join('')}
                                </div>
                            </div>
                        </div>

                        <div class="statistics-card">
                            <div class="statistics-header">
                                <span class="statistics-icon">🎯</span>
                                <h6>三区联动分析</h6>
                            </div>
                            <div class="statistics-body">
                                <div class="linkage-analysis">
                                    <div class="linkage-item">
                                        <div class="linkage-label">热门三区组合</div>
                                        <div class="linkage-value">${topThreeZone ? `${topThreeZone[0]} (${((topThreeZone[1] / totalPeriods) * 100).toFixed(1)}%)` : '无数据'}</div>
                                    </div>
                                    ${topCombinations.slice(0, 2).map(item => {
                                        const comboKey = item.combo.replace('质', ':').replace('合', '');
                                        const zoneStat = threeZoneStats[comboKey];
                                        if (zoneStat) {
                                            return `
                                                <div class="linkage-item">
                                                    <div class="linkage-label">${item.combo}对应三区</div>
                                                    <div class="linkage-value">${zoneStat.topZone} (${zoneStat.topZonePercentage}%)</div>
                                                </div>
                                            `;
                                        }
                                        return '';
                                    }).join('')}
                                </div>
                            </div>
                        </div>

                        <div class="statistics-card full-width">
                            <div class="statistics-header">
                                <span class="statistics-icon">📈</span>
                                <h6>近期趋势分析</h6>
                            </div>
                            <div class="statistics-body">
                                <div class="trend-analysis">
                                    <div class="trend-item">
                                        <div class="trend-label">质数趋势</div>
                                        <div class="trend-value ${primeTrendDirection === '升温' ? 'trend-up' : primeTrendDirection === '降温' ? 'trend-down' : 'trend-stable'}">
                                            ${primeTrendDirection}
                                        </div>
                                        <div class="trend-detail">平均${recentPrimeAvg.toFixed(1)}个/期</div>
                                    </div>
                                    <div class="trend-item">
                                        <div class="trend-label">合数趋势</div>
                                        <div class="trend-value ${compositeTrendDirection === '升温' ? 'trend-up' : compositeTrendDirection === '降温' ? 'trend-down' : 'trend-stable'}">
                                            ${compositeTrendDirection}
                                        </div>
                                        <div class="trend-detail">平均${recentCompositeAvg.toFixed(1)}个/期</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="statistics-card full-width">
                            <div class="statistics-header">
                                <span class="statistics-icon">💡</span>
                                <h6>综合分析结论</h6>
                            </div>
                            <div class="statistics-body">
                                <div class="conclusion-text">
                                    <p>近${totalPeriods}期数据分析显示，<strong>${topCombinations[0].combo}</strong>为最热门质合组合，出现${topCombinations[0].freq}次（占比${topCombinations[0].percentage}%）。</p>
                                    <p>质数占比为${primeRatio}%，合数占比为${compositeRatio}%，${parseFloat(primeRatio) > 35 ? '质数占比偏高' : parseFloat(primeRatio) < 30 ? '质数占比偏低' : '质合比例相对均衡'}。</p>
                                    <p>近期质数趋势${primeTrendDirection}（平均${recentPrimeAvg.toFixed(1)}个/期），合数趋势${compositeTrendDirection}（平均${recentCompositeAvg.toFixed(1)}个/期）。</p>
                                    <p>高频AC值区间为${topACRange ? topACRange[0] : '无数据'}，热门三区组合为${topThreeZone ? topThreeZone[0] : '无数据'}。</p>
                                    <p><strong>选号建议：</strong>建议重点关注${topCombinations[0].combo}组合，结合${topACRange ? `AC值${topACRange[0]}区间` : ''}${topThreeZone ? `和三区${topThreeZone[0]}组合` : ''}进行选号。${primeTrendDirection === '升温' ? '质数呈上升趋势，可适当增加质数号码选择。' : primeTrendDirection === '降温' ? '质数呈下降趋势，可适当减少质数号码选择。' : '质合趋势相对稳定，可保持均衡选号策略。'}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            static updatePrimeCompositeTrendChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeTrendChart');
                if (!chartDom) {
                    console.warn('primeCompositeTrendChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const periods = primeCompositeData.trend.slice().reverse().map(item => item.period);
                const primeData = primeCompositeData.trend.slice().reverse().map(item => item.prime);
                const compositeData = primeCompositeData.trend.slice().reverse().map(item => item.composite);

                const linkedData = primeCompositeData.linkedData;
                const acValues = linkedData.map(item => item.acValue);
                const threeZoneCombinations = linkedData.map(item => item.threeZoneCombination);

                const calculateMovingAverage = (data, window) => {
                    const result = [];
                    for (let i = 0; i < data.length; i++) {
                        const start = Math.max(0, i - window + 1);
                        const slice = data.slice(start, i + 1);
                        const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length;
                        result.push(avg.toFixed(2));
                    }
                    return result;
                };

                const primeMA5 = calculateMovingAverage(primeData, 5);
                const primeMA10 = calculateMovingAverage(primeData, 10);
                const compositeMA5 = calculateMovingAverage(compositeData, 5);
                const compositeMA10 = calculateMovingAverage(compositeData, 10);

                const recentTrend = primeCompositeData.trend.slice(0, 10);
                const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                const primeTrendDirection = recentPrimeAvg > 2.5 ? '升温' : recentPrimeAvg < 1.5 ? '降温' : '平稳';
                const compositeTrendDirection = recentCompositeAvg > 4 ? '升温' : recentCompositeAvg < 3 ? '降温' : '平稳';

                const option = {
                    title: {
                        text: '质数个数趋势折线图',
                        subtext: `近期质数趋势：${primeTrendDirection}（平均${recentPrimeAvg.toFixed(1)}个） | 合数趋势：${compositeTrendDirection}（平均${recentCompositeAvg.toFixed(1)}个）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#E63946',
                            fontWeight: 'normal'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            const index = paramArray[0].dataIndex;
                            let result = `<div style="padding: 8px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">期号: ${periods[index]}</div>`;

                            paramArray.forEach(item => {
                                if (item.seriesName.includes('移动平均')) {
                                    result += `<div style="display: flex; align-items: center; margin-bottom: 4px;">
                                        <span style="display: inline-block; width: 10px; height: 10px; background-color: ${item.color}; border-radius: 2px; margin-right: 8px;"></span>
                                        <span style="color: #2c3e50;">${item.seriesName}: </span>
                                        <span style="font-weight: bold; color: ${item.color}; margin-left: 4px;">${item.value}</span>
                                    </div>`;
                                } else {
                                    result += `<div style="display: flex; align-items: center; margin-bottom: 4px;">
                                        <span style="display: inline-block; width: 10px; height: 10px; background-color: ${item.color}; border-radius: 2px; margin-right: 8px;"></span>
                                        <span style="color: #2c3e50;">${item.seriesName}: </span>
                                        <span style="font-weight: bold; color: ${item.color}; margin-left: 4px;">${item.value}个</span>
                                    </div>`;
                                }
                            });

                            if (linkedData[index]) {
                                result += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #E2E8F0;">
                                    <div style="color: #2c3e50; font-weight: bold; margin-bottom: 4px;">联动数据：</div>
                                    <div style="color: #457B9D;">AC值：${linkedData[index].acValue}</div>
                                    <div style="color: #457B9D;">三区组合：${linkedData[index].threeZoneCombination}</div>
                                    <div style="color: #457B9D;">质合组合：${linkedData[index].primeCompositeCombination}</div>
                                </div>`;
                            }

                            result += `</div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['质数', '质数MA5', '质数MA10', '合数', '合数MA5', '合数MA10'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12,
                            color: '#2c3e50'
                        },
                        itemGap: 10
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '25%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 10,
                            interval: Math.floor(periods.length / 20),
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '个数',
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            start: 0,
                            end: 100
                        },
                        {
                            type: 'slider',
                            start: 0,
                            end: 100,
                            height: 20,
                            bottom: 10
                        }
                    ],
                    series: [
                        {
                            name: '质数',
                            type: 'line',
                            data: primeData,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 3,
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 1,
                                    y2: 0,
                                    colorStops: [{
                                        offset: 0, color: '#E63946'
                                    }, {
                                        offset: 1, color: '#D62828'
                                    }]
                                }
                            },
                            itemStyle: {
                                color: '#E63946',
                                borderColor: '#fff',
                                borderWidth: 2,
                                shadowBlur: 10,
                                shadowColor: 'rgba(230, 57, 70, 0.5)'
                            },
                            areaStyle: {
                                opacity: 0.3,
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0, color: 'rgba(230, 57, 70, 0.5)'
                                    }, {
                                        offset: 1, color: 'rgba(230, 57, 70, 0.05)'
                                    }]
                                }
                            }
                        },
                        {
                            name: '质数MA5',
                            type: 'line',
                            data: primeMA5,
                            smooth: true,
                            symbol: 'none',
                            lineStyle: {
                                width: 2,
                                type: 'dashed',
                                color: 'rgba(230, 57, 70, 0.6)'
                            }
                        },
                        {
                            name: '质数MA10',
                            type: 'line',
                            data: primeMA10,
                            smooth: true,
                            symbol: 'none',
                            lineStyle: {
                                width: 2,
                                type: 'dotted',
                                color: 'rgba(230, 57, 70, 0.4)'
                            }
                        },
                        {
                            name: '合数',
                            type: 'line',
                            data: compositeData,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 3,
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 1,
                                    y2: 0,
                                    colorStops: [{
                                        offset: 0, color: '#457B9D'
                                    }, {
                                        offset: 1, color: '#1D3557'
                                    }]
                                }
                            },
                            itemStyle: {
                                color: '#457B9D',
                                borderColor: '#fff',
                                borderWidth: 2,
                                shadowBlur: 10,
                                shadowColor: 'rgba(69, 123, 157, 0.5)'
                            },
                            areaStyle: {
                                opacity: 0.3,
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0, color: 'rgba(69, 123, 157, 0.5)'
                                    }, {
                                        offset: 1, color: 'rgba(69, 123, 157, 0.05)'
                                    }]
                                }
                            }
                        },
                        {
                            name: '合数MA5',
                            type: 'line',
                            data: compositeMA5,
                            smooth: true,
                            symbol: 'none',
                            lineStyle: {
                                width: 2,
                                type: 'dashed',
                                color: 'rgba(69, 123, 157, 0.6)'
                            }
                        },
                        {
                            name: '合数MA10',
                            type: 'line',
                            data: compositeMA10,
                            smooth: true,
                            symbol: 'none',
                            lineStyle: {
                                width: 2,
                                type: 'dotted',
                                color: 'rgba(69, 123, 157, 0.4)'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.on('click', function(params) {
                    const index = params.dataIndex;
                    console.log('点击趋势点:', periods[index], '质数:', primeData[index], '合数:', compositeData[index]);

                    if (linkedData[index]) {
                        const acValue = linkedData[index].acValue;
                        const threeZoneCombination = linkedData[index].threeZoneCombination;

                        console.log('AC值:', acValue, '三区组合:', threeZoneCombination);
                    }

                    PrimeCompositeAnalysis.performPrimeCompositeAnalysisByPeriod();
                });

                this.generateTrendInsights(primeCompositeData);
            }

            static generateTrendInsights(primeCompositeData) {
                const insightsContent = document.getElementById('trendInsightsContent');
                if (!insightsContent) return;

                const trendData = primeCompositeData.trend;
                if (!trendData || trendData.length === 0) {
                    insightsContent.innerHTML = '<div class="insight-item"><span class="insight-icon">⚠️</span><div class="insight-text"><strong>暂无趋势数据</strong></div></div>';
                    return;
                }

                const recentTrend = trendData.slice(-10);
                const mediumTrend = trendData.slice(-20, -10);
                const longTrend = trendData.slice(-30, -20);

                const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                const mediumPrimeAvg = mediumTrend.length > 0 ? mediumTrend.reduce((sum, item) => sum + item.prime, 0) / mediumTrend.length : recentPrimeAvg;
                const mediumCompositeAvg = mediumTrend.length > 0 ? mediumTrend.reduce((sum, item) => sum + item.composite, 0) / mediumTrend.length : recentCompositeAvg;

                const longPrimeAvg = longTrend.length > 0 ? longTrend.reduce((sum, item) => sum + item.prime, 0) / longTrend.length : mediumPrimeAvg;
                const longCompositeAvg = longTrend.length > 0 ? longTrend.reduce((sum, item) => sum + item.composite, 0) / longTrend.length : mediumCompositeAvg;

                const primeTrendDirection = recentPrimeAvg > mediumPrimeAvg ? '上升' : recentPrimeAvg < mediumPrimeAvg ? '下降' : '稳定';
                const compositeTrendDirection = recentCompositeAvg > mediumCompositeAvg ? '上升' : recentCompositeAvg < mediumCompositeAvg ? '下降' : '稳定';

                const primeTrendStrength = Math.abs(recentPrimeAvg - mediumPrimeAvg) / (mediumPrimeAvg || 1);
                const compositeTrendStrength = Math.abs(recentCompositeAvg - mediumCompositeAvg) / (mediumCompositeAvg || 1);

                const primeTrendLevel = primeTrendStrength > 0.3 ? '强烈' : primeTrendStrength > 0.15 ? '中等' : '微弱';
                const compositeTrendLevel = compositeTrendStrength > 0.3 ? '强烈' : compositeTrendStrength > 0.15 ? '中等' : '微弱';

                const primeVariance = recentTrend.reduce((sum, item) => sum + Math.pow(item.prime - recentPrimeAvg, 2), 0) / recentTrend.length;
                const compositeVariance = recentTrend.reduce((sum, item) => sum + Math.pow(item.composite - recentCompositeAvg, 2), 0) / recentTrend.length;

                const primeStability = primeVariance < 0.5 ? '非常稳定' : primeVariance < 1 ? '较为稳定' : '波动较大';
                const compositeStability = compositeVariance < 0.5 ? '非常稳定' : compositeVariance < 1 ? '较为稳定' : '波动较大';

                const conversionPoints = primeCompositeData.conversionPoints.slice(-5);
                const recentConversions = conversionPoints.filter(cp => {
                    const cpIndex = trendData.findIndex(item => item.period === cp.period);
                    return cpIndex >= trendData.length - 10;
                });

                const dominantRatio = Object.entries(primeCompositeData.ratioDistribution)
                    .sort((a, b) => b[1] - a[1])[0];

                const ratioDiversity = Object.keys(primeCompositeData.ratioDistribution).length;
                const ratioConcentration = dominantRatio[1] / trendData.length;

                const ratioBalance = ratioConcentration < 0.3 ? '均衡分布' : ratioConcentration < 0.5 ? '适度集中' : '高度集中';

                const lastPeriod = trendData[trendData.length - 1];
                const lastRatio = lastPeriod.prime / (lastPeriod.prime + lastPeriod.composite);
                const avgRatio = recentPrimeAvg / (recentPrimeAvg + recentCompositeAvg);

                const ratioDeviation = ((lastRatio - avgRatio) * 100).toFixed(2);

                insightsContent.innerHTML = `
                    <div class="insight-item">
                        <span class="insight-icon">📊</span>
                        <div class="insight-text">
                            <strong>近期趋势概况：</strong>最近10期平均质数出现 ${recentPrimeAvg.toFixed(1)} 个，合数出现 ${recentCompositeAvg.toFixed(1)} 个。
                            质数趋势${primeTrendDirection}（${primeTrendLevel}），合数趋势${compositeTrendDirection}（${compositeTrendLevel}）。
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">📈</span>
                        <div class="insight-text">
                            <strong>趋势稳定性分析：</strong>质数表现${primeStability}，合数表现${compositeStability}。
                            ${primeStability === '波动较大' ? '质数波动较大，建议关注质数回补机会。' : compositeStability === '波动较大' ? '合数波动较大，建议关注合数回补机会。' : '质合表现相对稳定，可延续当前选号策略。'}
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">🔄</span>
                        <div class="insight-text">
                            <strong>比例分布分析：</strong>共发现 ${ratioDiversity} 种质合比例组合，其中 "${dominantRatio[0]}" 最常见（出现 ${dominantRatio[1]} 次，占比 ${(ratioConcentration * 100).toFixed(1)}%）。
                            比例分布${ratioBalance}。
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">⚖️</span>
                        <div class="insight-text">
                            <strong>最新比例偏差：</strong>最新期质合比例为 ${lastRatio.toFixed(2)}，与近期平均值 ${avgRatio.toFixed(2)} 相比${parseFloat(ratioDeviation) > 0 ? '偏高' : parseFloat(ratioDeviation) < 0 ? '偏低' : '持平'} ${Math.abs(ratioDeviation)}%。
                            ${Math.abs(parseFloat(ratioDeviation)) > 10 ? '偏差较大，可能存在回归趋势。' : '偏差在正常范围内。'}
                        </div>
                    </div>
                    ${recentConversions.length > 0 ? `
                    <div class="insight-item">
                        <span class="insight-icon">🔀</span>
                        <div class="insight-text">
                            <strong>近期质合转换：</strong>最近10期发现 ${recentConversions.length} 次明显的质合转换点。
                            ${recentConversions.length >= 3 ? '转换频繁，说明质合交替活跃，建议灵活调整选号策略。' : '转换较少，说明当前趋势相对稳定。'}
                        </div>
                    </div>
                    ` : ''}
                    <div class="insight-item">
                        <span class="insight-icon">💡</span>
                        <div class="insight-text">
                            <strong>趋势预测建议：</strong>
                            ${primeTrendDirection === '上升' && compositeTrendDirection === '下降' ? '质数呈上升趋势，合数呈下降趋势，建议重点关注质数号码。' : ''}
                            ${primeTrendDirection === '下降' && compositeTrendDirection === '上升' ? '合数呈上升趋势，质数呈下降趋势，建议重点关注合数号码。' : ''}
                            ${primeTrendDirection === '稳定' && compositeTrendDirection === '稳定' ? '质合趋势相对稳定，建议保持均衡选号策略。' : ''}
                            ${primeTrendDirection === compositeTrendDirection ? '质合趋势同向变化，建议关注整体质合比例的平衡。' : ''}
                            ${Math.abs(parseFloat(ratioDeviation)) > 10 ? '当前比例偏差较大，建议关注回归趋势，适当调整质合号码选择。' : '当前比例在正常范围内，可延续当前选号策略。'}
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">📋</span>
                        <div class="insight-text">
                            <strong>选号策略建议：</strong>
                            ${primeTrendLevel === '强烈' ? `质数趋势${primeTrendDirection}强烈，建议${primeTrendDirection === '上升' ? '增加质数号码选择' : '减少质数号码选择'}。` : ''}
                            ${compositeTrendLevel === '强烈' ? `合数趋势${compositeTrendDirection}强烈，建议${compositeTrendDirection === '上升' ? '增加合数号码选择' : '减少合数号码选择'}。` : ''}
                            ${ratioBalance === '均衡分布' ? '比例分布均衡，建议采用均衡选号策略。' : ratioBalance === '适度集中' ? '比例适度集中，可适当关注热门比例组合。' : '比例高度集中，建议关注主流比例组合，同时留意其他比例的回补机会。'}
                            结合趋势稳定性和比例偏差，建议采用"趋势跟随、比例平衡、灵活调整"的选号策略。
                        </div>
                    </div>
                `;
            }

            static updatePrimeCompositeDistributionCharts(primeCompositeData) {
                this.updatePrimeCompositeCombinationChart(primeCompositeData);
                this.updatePrimeCompositeHeatmapChart(primeCompositeData);
                this.updatePrimeCompositeStackedChart(primeCompositeData);
                this.generateDistributionInsights(primeCompositeData);
                this.generateEnhancedPrimeCompositeConclusion(primeCompositeData, primeCompositeData.linkedData.length);
            }

            static updatePrimeCompositeCombinationChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeCombinationChart');
                if (!chartDom) {
                    console.warn('primeCompositeCombinationChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const combinationData = primeCompositeData.primeCompositeCombinationFrequency;
                const combinations = Object.keys(combinationData).sort((a, b) => {
                    const [primeA, compositeA] = a.split(':').map(Number);
                    const [primeB, compositeB] = b.split(':').map(Number);
                    return primeA - primeB;
                });

                const frequencies = combinations.map(combo => combinationData[combo]);
                const totalDraws = frequencies.reduce((sum, freq) => sum + freq, 0);
                const percentages = frequencies.map(freq => ((freq / totalDraws) * 100).toFixed(2));

                const maxFreq = Math.max(...frequencies);
                const topCombination = combinations[frequencies.indexOf(maxFreq)];
                const topPercentage = percentages[frequencies.indexOf(maxFreq)];

                const option = {
                    title: {
                        text: '质合组合频次柱状图（核心图表）',
                        subtext: `热门组合：${topCombination}（${topPercentage}%）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#E63946',
                            fontWeight: 'normal'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const item = Array.isArray(params) ? params[0] : params;
                            if (!item || !item.name) {
                                return '数据加载中...';
                            }

                            const xAxisData = combinations[item.dataIndex];
                            const [prime, composite] = xAxisData.split(':').map(Number);
                            if (isNaN(prime) || isNaN(composite)) {
                                return `<div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">质合组合：${item.name}</div>
                                    <div style="color: #457B9D;">数据格式错误</div>
                                </div>`;
                            }

                            return `<div style="padding: 8px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">质合组合：${prime}质${composite}合</div>
                                <div style="color: #457B9D;">质数个数：${prime}</div>
                                <div style="color: #457B9D;">合数个数：${composite}</div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #E2E8F0;">
                                    <div style="color: #2c3e50;">出现次数：<strong style="color: #E63946;">${item.value}</strong></div>
                                    <div style="color: #2c3e50;">占比：<strong style="color: #E63946;">${((item.value / totalDraws) * 100).toFixed(2)}%</strong></div>
                                </div>
                            </div>`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: combinations.map(combo => {
                            const [prime, composite] = combo.split(':').map(Number);
                            return { value: `${prime}质${composite}合`, original: combo };
                        }),
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11,
                            interval: 0,
                            rotate: 45,
                            formatter: function(value) {
                                return value.value;
                            }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: frequencies,
                            itemStyle: {
                                color: function(params) {
                                    const percentage = parseFloat(percentages[params.dataIndex]);
                                    if (percentage >= 30) {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#E63946'
                                            }, {
                                                offset: 1, color: '#D62828'
                                            }]
                                        };
                                    } else if (percentage >= 20) {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#457B9D'
                                            }, {
                                                offset: 1, color: '#1D3557'
                                            }]
                                        };
                                    } else if (percentage >= 10) {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#A8DADC'
                                            }, {
                                                offset: 1, color: '#457B9D'
                                            }]
                                        };
                                    } else {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#F1FAEE'
                                            }, {
                                                offset: 1, color: '#A8DADC'
                                            }]
                                        };
                                    }
                                },
                                borderRadius: [4, 4, 0, 0],
                                borderColor: '#fff',
                                borderWidth: 1
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(230, 57, 70, 0.5)',
                                    borderWidth: 2
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                color: '#2c3e50',
                                fontSize: 11,
                                fontWeight: 'bold',
                                formatter: function(params) {
                                    return `${params.value}次\n${percentages[params.dataIndex]}%`;
                                }
                            },
                            markLine: {
                                symbol: 'none',
                                label: {
                                    show: true,
                                    position: 'end',
                                    formatter: '平均值',
                                    color: '#E63946',
                                    fontSize: 12,
                                    fontWeight: 'bold'
                                },
                                lineStyle: {
                                    color: '#E63946',
                                    type: 'dashed',
                                    width: 2
                                },
                                data: [
                                    {
                                        type: 'average',
                                        name: '平均值'
                                    }
                                ]
                            }
                        }
                    ]
                };

                chart.setOption(option);

                chart.on('click', function(params) {
                    const combination = params.name.replace('质', ':').replace('合', '');
                    console.log('点击质合组合:', combination);
                    PrimeCompositeAnalysis.triggerChartLinkage(combination);
                });
            }

            static triggerChartLinkage(primeCompositeCombination) {
                const linkedData = primeCompositeData.linkedData || [];
                const filteredData = linkedData.filter(item => 
                    item.primeCompositeCombination === primeCompositeCombination
                );

                if (filteredData.length === 0) {
                    MessageSystem.showMessage(`未找到质合组合 ${primeCompositeCombination} 的相关数据`, 'warning');
                    return;
                }

                const acValueData = PrimeCompositeAnalysis.generateLinkedAcValueData(filteredData);
                const threeZoneData = PrimeCompositeAnalysis.generateLinkedThreeZoneData(filteredData);

                PrimeCompositeAnalysis.updateLinkedAcValueChart(acValueData, primeCompositeCombination);
                PrimeCompositeAnalysis.updateLinkedThreeZoneChart(threeZoneData, primeCompositeCombination);

                MessageSystem.showMessage(`已联动展示质合组合 ${primeCompositeCombination} 的AC值和大中小分析数据（共${filteredData.length}期）`, 'success');
            }

            static exportPrimeCompositeReport() {
                if (!primeCompositeData || Object.keys(primeCompositeData).length === 0) {
                    MessageSystem.showMessage('暂无质合分析数据，请先进行分析', 'warning');
                    return;
                }

                try {
                    const lotteryType = currentLotteryType === 'ssq' ? '双色球' : '大乐透';
                    const currentDate = new Date();
                    const dateStr = `${currentDate.getFullYear()}年${(currentDate.getMonth() + 1).toString().padStart(2, '0')}月${currentDate.getDate().toString().padStart(2, '0')}日`;
                    const timeStr = `${currentDate.getHours().toString().padStart(2, '0')}:${currentDate.getMinutes().toString().padStart(2, '0')}:${currentDate.getSeconds().toString().padStart(2, '0')}`;

                    const linkedData = primeCompositeData.linkedData || [];
                    const combinationFrequency = primeCompositeData.primeCompositeCombinationFrequency || {};
                    const acValueCorrelation = primeCompositeData.primeCompositeAcValueCorrelation || {};
                    const threeZoneCorrelation = primeCompositeData.primeCompositeThreeZoneCorrelation || {};
                    const trend = primeCompositeData.trend || [];
                    const totalPeriods = linkedData.length;

                    const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                    const primeRatio = ((primeCompositeData.primeCount / total) * 100).toFixed(2);
                    const compositeRatio = ((primeCompositeData.compositeCount / total) * 100).toFixed(2);

                    const topCombinations = Object.entries(combinationFrequency)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                        .map(([combo, freq]) => {
                            const percentage = ((freq / totalPeriods) * 100).toFixed(2);
                            const [prime, composite] = combo.split(':').map(Number);
                            return { combo: `${prime}质${composite}合`, freq, percentage, prime, composite };
                        });

                    const acValueStats = {};
                    Object.entries(acValueCorrelation).forEach(([combo, acData]) => {
                        const comboTotal = Object.values(acData).reduce((sum, count) => sum + count, 0);
                        const topAC = Object.entries(acData).sort((a, b) => b[1] - a[1])[0];
                        if (topAC) {
                            acValueStats[combo] = {
                                topAC: topAC[0],
                                topACCount: topAC[1],
                                topACPercentage: ((topAC[1] / comboTotal) * 100).toFixed(2),
                                comboTotal
                            };
                        }
                    });

                    const threeZoneStats = {};
                    Object.entries(threeZoneCorrelation).forEach(([combo, zoneData]) => {
                        const comboTotal = Object.values(zoneData).reduce((sum, count) => sum + count, 0);
                        const topZone = Object.entries(zoneData).sort((a, b) => b[1] - a[1])[0];
                        if (topZone) {
                            threeZoneStats[combo] = {
                                topZone: topZone[0],
                                topZoneCount: topZone[1],
                                topZonePercentage: ((topZone[1] / comboTotal) * 100).toFixed(2),
                                comboTotal
                            };
                        }
                    });

                    const recentTrend = trend.slice(-10);
                    const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                    const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                    const primeTrendDirection = recentPrimeAvg > 2.5 ? '升温' : recentPrimeAvg < 1.5 ? '降温' : '平稳';
                    const compositeTrendDirection = recentCompositeAvg > 4 ? '升温' : recentCompositeAvg < 3 ? '降温' : '平稳';

                    const linkedACValues = linkedData.map(item => item.acValue);
                    const acValueDistribution = {};
                    linkedACValues.forEach(ac => {
                        const range = Math.floor(ac / 2) * 2;
                        const key = `${range}-${range + 1}`;
                        acValueDistribution[key] = (acValueDistribution[key] || 0) + 1;
                    });
                    const topACRange = Object.entries(acValueDistribution).sort((a, b) => b[1] - a[1])[0];

                    const linkedThreeZones = linkedData.map(item => item.threeZoneCombination);
                    const threeZoneDistribution = {};
                    linkedThreeZones.forEach(zone => {
                        threeZoneDistribution[zone] = (threeZoneDistribution[zone] || 0) + 1;
                    });
                    const topThreeZone = Object.entries(threeZoneDistribution).sort((a, b) => b[1] - a[1])[0];

                    const linkedHeatmapData = [];
                    primeCompositeData.linkedData.forEach(item => {
                        const existing = linkedHeatmapData.find(d => 
                            d.primeCombo === item.primeCompositeCombination && 
                            d.zoneCombo === item.threeZoneCombination
                        );
                        if (existing) {
                            existing.count++;
                            existing.acValues.push(item.acValue);
                        } else {
                            linkedHeatmapData.push({
                                primeCombo: item.primeCompositeCombination,
                                zoneCombo: item.threeZoneCombination,
                                count: 1,
                                acValues: [item.acValue]
                            });
                        }
                    });

                    linkedHeatmapData.sort((a, b) => b.count - a.count);
                    const topLinkedCombo = linkedHeatmapData[0];
                    const topLinkedAvgAC = topLinkedCombo ? (topLinkedCombo.acValues.reduce((sum, ac) => sum + ac, 0) / topLinkedCombo.acValues.length).toFixed(2) : '无';

                    const ratioDeviation = Math.abs(parseFloat(primeRatio) - 33.33);
                    const ratioStatus = ratioDeviation > 5 ? '失衡' : ratioDeviation > 2 ? '偏离' : '均衡';

                    const lastPeriod = trend[trend.length - 1];
                    const lastRatio = lastPeriod ? lastPeriod.prime / (lastPeriod.prime + lastPeriod.composite) : 0;
                    const avgRatio = recentPrimeAvg / (recentPrimeAvg + recentCompositeAvg);
                    const ratioTrend = lastRatio > avgRatio ? '上升' : lastRatio < avgRatio ? '下降' : '稳定';

                    const conversionPoints = primeCompositeData.conversionPoints.slice(-5);
                    const recentConversions = conversionPoints.filter(cp => {
                        const cpIndex = trend.findIndex(t => t.period === cp.period);
                        return cpIndex >= trend.length - 10;
                    });

                    let reportHTML = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${lotteryType}质合分析综合报告 - ${dateStr}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            line-height: 1.6;
        }
        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .report-header {
            background: linear-gradient(135deg, #E63946, #457B9D);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .report-header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .report-header .subtitle {
            font-size: 16px;
            opacity: 0.9;
        }
        .report-header .meta {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.8;
        }
        .report-content {
            padding: 30px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #E63946;
        }
        .section h2 {
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        .section h3 {
            color: #457B9D;
            font-size: 16px;
            margin: 15px 0 10px 0;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: white;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        .data-table th {
            background: linear-gradient(135deg, #E63946, #D62828);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        .data-table tr:hover {
            background: #f0f4f8;
        }
        .data-table tr:nth-child(even) {
            background: #fafafa;
        }
        .highlight {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.1), rgba(69, 123, 157, 0.1)) !important;
        }
        .stat-card {
            display: inline-block;
            background: white;
            padding: 15px 20px;
            margin: 10px 10px 10px 0;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            min-width: 150px;
        }
        .stat-card .label {
            color: #7f8c8d;
            font-size: 14px;
            margin-bottom: 5px;
        }
        .stat-card .value {
            color: #2c3e50;
            font-size: 24px;
            font-weight: bold;
        }
        .stat-card.prime .value {
            color: #E63946;
        }
        .stat-card.composite .value {
            color: #457B9D;
        }
        .conclusion-box {
            background: linear-gradient(135deg, rgba(230, 57, 70, 0.05), rgba(69, 123, 157, 0.05));
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #E63946;
            margin-top: 15px;
        }
        .conclusion-box h4 {
            color: #E63946;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .conclusion-box p {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .recommendation {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(41, 128, 185, 0.1));
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #27ae60;
            margin-top: 10px;
        }
        .recommendation strong {
            color: #27ae60;
        }
        .warning {
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.1), rgba(230, 126, 34, 0.1));
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #f39c12;
            margin-top: 10px;
        }
        .warning strong {
            color: #e67e22;
        }
        .footer {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-size: 14px;
            border-top: 1px solid #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="report-container">
        <div class="report-header">
            <h1>${lotteryType}质合分析综合报告</h1>
            <div class="subtitle">基于近${totalPeriods}期开奖数据的深度分析</div>
            <div class="meta">
                生成时间：${dateStr} ${timeStr} | 数据范围：${linkedData[0]?.period || '未知'} - ${linkedData[linkedData.length - 1]?.period || '未知'}
            </div>
        </div>

        <div class="report-content">
            <div class="section">
                <h2>一、基础数据分析</h2>
                <div class="stat-card prime">
                    <div class="label">质数总数</div>
                    <div class="value">${primeCompositeData.primeCount}</div>
                </div>
                <div class="stat-card composite">
                    <div class="label">合数总数</div>
                    <div class="value">${primeCompositeData.compositeCount}</div>
                </div>
                <div class="stat-card">
                    <div class="label">质数占比</div>
                    <div class="value">${primeRatio}%</div>
                </div>
                <div class="stat-card">
                    <div class="label">合数占比</div>
                    <div class="value">${compositeRatio}%</div>
                </div>
                <div class="stat-card">
                    <div class="label">质合状态</div>
                    <div class="value">${ratioStatus}</div>
                </div>

                <h3>热门质合组合 Top5</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>排名</th>
                            <th>质合组合</th>
                            <th>出现次数</th>
                            <th>占比</th>
                            <th>状态</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topCombinations.map((item, index) => `
                            <tr class="${index === 0 ? 'highlight' : ''}">
                                <td>${index + 1}</td>
                                <td><strong>${item.combo}</strong></td>
                                <td>${item.freq}</td>
                                <td>${item.percentage}%</td>
                                <td>${index === 0 ? '🏆 最热门' : index < 3 ? '🔥 热门' : '普通'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>

                <h3>近期趋势分析</h3>
                <p>近10期质数平均${recentPrimeAvg.toFixed(2)}个/期，合数平均${recentCompositeAvg.toFixed(2)}个/期。</p>
                <p>质数趋势：<strong style="color: ${primeTrendDirection === '升温' ? '#E63946' : primeTrendDirection === '降温' ? '#457B9D' : '#27ae60'}">${primeTrendDirection}</strong></p>
                <p>合数趋势：<strong style="color: ${compositeTrendDirection === '升温' ? '#E63946' : compositeTrendDirection === '降温' ? '#457B9D' : '#27ae60'}">${compositeTrendDirection}</strong></p>
            </div>

            <div class="section">
                <h2>二、AC值联动分析</h2>
                <div class="stat-card">
                    <div class="label">高频AC值区间</div>
                    <div class="value">${topACRange ? topACRange[0] : '无数据'}</div>
                </div>
                <div class="stat-card">
                    <div class="label">区间占比</div>
                    <div class="value">${topACRange ? ((topACRange[1] / totalPeriods) * 100).toFixed(2) + '%' : '无数据'}</div>
                </div>

                <h3>质合组合与AC值关联</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>质合组合</th>
                            <th>高频AC值</th>
                            <th>出现次数</th>
                            <th>占比</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topCombinations.slice(0, 5).map(item => {
                            const comboKey = `${item.prime}:${item.composite}`;
                            const acStat = acValueStats[comboKey];
                            if (acStat) {
                                return `
                                    <tr>
                                        <td><strong>${item.combo}</strong></td>
                                        <td>AC${acStat.topAC}</td>
                                        <td>${acStat.topACCount}</td>
                                        <td>${acStat.topACPercentage}%</td>
                                    </tr>
                                `;
                            }
                            return '';
                        }).join('')}
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>三、三区联动分析</h2>
                <div class="stat-card">
                    <div class="label">热门三区组合</div>
                    <div class="value">${topThreeZone ? topThreeZone[0] : '无数据'}</div>
                </div>
                <div class="stat-card">
                    <div class="label">组合占比</div>
                    <div class="value">${topThreeZone ? ((topThreeZone[1] / totalPeriods) * 100).toFixed(2) + '%' : '无数据'}</div>
                </div>

                <h3>质合组合与三区关联</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>质合组合</th>
                            <th>高频三区组合</th>
                            <th>出现次数</th>
                            <th>占比</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topCombinations.slice(0, 5).map(item => {
                            const comboKey = `${item.prime}:${item.composite}`;
                            const zoneStat = threeZoneStats[comboKey];
                            if (zoneStat) {
                                return `
                                    <tr>
                                        <td><strong>${item.combo}</strong></td>
                                        <td>${zoneStat.topZone}</td>
                                        <td>${zoneStat.topZoneCount}</td>
                                        <td>${zoneStat.topZonePercentage}%</td>
                                    </tr>
                                `;
                            }
                            return '';
                        }).join('')}
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>四、三重维度联动分析</h2>
                ${topLinkedCombo ? `
                    <div class="stat-card">
                        <div class="label">最高频联动组合</div>
                        <div class="value" style="font-size: 18px;">${topLinkedCombo.primeCombo.replace(':', '质').replace(':', '合')} × ${topLinkedCombo.zoneCombo}</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">出现次数</div>
                        <div class="value">${topLinkedCombo.count}</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">平均AC值</div>
                        <div class="value">${topLinkedAvgAC}</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">占比</div>
                        <div class="value">${((topLinkedCombo.count / totalPeriods) * 100).toFixed(2)}%</div>
                    </div>

                    <h3>联动组合详情</h3>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>质合组合</th>
                                <th>三区组合</th>
                                <th>出现次数</th>
                                <th>占比</th>
                                <th>平均AC值</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${linkedHeatmapData.slice(0, 10).map((item, index) => `
                                <tr class="${index === 0 ? 'highlight' : ''}">
                                    <td><strong>${item.primeCombo.replace(':', '质').replace(':', '合')}</strong></td>
                                    <td>${item.zoneCombo}</td>
                                    <td>${item.count}</td>
                                    <td>${((item.count / totalPeriods) * 100).toFixed(2)}%</td>
                                    <td>${(item.acValues.reduce((sum, ac) => sum + ac, 0) / item.acValues.length).toFixed(2)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                ` : '<p>暂无足够的联动数据进行分析。</p>'}
            </div>

            <div class="section">
                <h2>五、趋势转换分析</h2>
                <div class="stat-card">
                    <div class="label">近期转换点</div>
                    <div class="value">${recentConversions.length}次</div>
                </div>
                <div class="stat-card">
                    <div class="label">最新质合比例</div>
                    <div class="value">${lastRatio.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">近期平均比例</div>
                    <div class="value">${avgRatio.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <div class="label">比例趋势</div>
                    <div class="value">${ratioTrend}</div>
                </div>

                <p>最近10期发现${recentConversions.length}次明显的质合转换点，${recentConversions.length >= 3 ? '转换较为频繁，说明质合交替活跃，建议灵活调整选号策略。' : '转换较少，说明当前趋势相对稳定。'}</p>
                <p>最新期质合比例为${lastRatio.toFixed(2)}，与近期平均值${avgRatio.toFixed(2)}相比${parseFloat(ratioTrend) > 0 ? '偏高' : parseFloat(ratioTrend) < 0 ? '偏低' : '持平'}，${Math.abs(lastRatio - avgRatio) > 0.1 ? '偏差较大，可能存在回归趋势。' : '偏差在正常范围内。'}</p>
            </div>

            <div class="section">
                <h2>六、综合选号建议</h2>
                <div class="conclusion-box">
                    <h4>💡 主要推荐</h4>
                    <p><strong>重点关注：</strong>${topCombinations[0].combo}组合，出现${topCombinations[0].freq}次（占比${topCombinations[0].percentage}%）。</p>
                    <p><strong>次要推荐：</strong>${topCombinations[1].combo}和${topCombinations[2].combo}组合。</p>
                    <p><strong>AC值建议：</strong>结合${topACRange ? `AC值${topACRange[0]}区间` : '高频AC值区间'}进行选号。</p>
                    <p><strong>三区建议：</strong>结合${topThreeZone ? `三区${topThreeZone[0]}组合` : '热门三区组合'}进行选号。</p>
                </div>

                <div class="recommendation">
                    <strong>📈 趋势建议：</strong>${primeTrendDirection === '升温' ? '质数呈上升趋势，可适当增加质数号码选择。' : primeTrendDirection === '降温' ? '质数呈下降趋势，可适当减少质数号码选择。' : '质合趋势相对稳定，可保持均衡选号策略。'}
                </div>

                <div class="recommendation">
                    <strong>⚖️ 比例建议：</strong>${ratioStatus === '失衡' ? '当前质合比例失衡，建议关注回归趋势，适当调整质合号码选择。' : ratioStatus === '偏离' ? '当前质合比例略有偏离，建议关注平衡调整。' : '当前质合比例相对均衡，可延续当前选号策略。'}
                </div>

                <div class="recommendation">
                    <strong>🔗 联动建议：</strong>${topLinkedCombo ? `建议优先考虑质合×三区×AC值三重联动高频组合，即${topLinkedCombo.primeCombo.replace(':', '质').replace(':', '合')} × ${topLinkedCombo.zoneCombo} × AC值${topLinkedAvgAC}。` : '建议结合质合、AC值、三区三个维度的综合分析进行选号。'}
                </div>

                <div class="warning">
                    <strong>⚠️ 风险提示：</strong>以上分析基于历史数据统计，仅供参考。彩票开奖具有随机性，历史规律不代表未来走势。建议理性购彩，量力而行。
                </div>
            </div>
        </div>

        <div class="footer">
            <p>本报告由双系统分析选号系统自动生成 | 数据仅供参考，不构成购彩建议</p>
            <p>生成时间：${dateStr} ${timeStr}</p>
        </div>
    </div>
</body>
</html>`;

                    const blob = new Blob([reportHTML], { type: 'text/html;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${lotteryType}质合分析综合报告_${dateStr.replace(/年|月/g, '-')}.html`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                    MessageSystem.showMessage('质合分析综合报告已成功导出', 'success');
                } catch (error) {
                    console.error('导出报告失败:', error);
                    MessageSystem.showMessage('导出报告失败，请重试', 'error');
                }
            }

            static generateLinkedAcValueData(filteredData) {
                const acValues = filteredData.map(item => item.acValue);
                const valueCounts = {};

                acValues.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });

                const sortedValues = Object.keys(valueCounts).sort((a, b) => parseInt(a) - parseInt(b));
                const counts = sortedValues.map(value => valueCounts[value]);
                const total = acValues.length;

                const hotACValues = sortedValues
                    .map(value => ({ value: parseInt(value), count: valueCounts[value] }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);

                const sum = acValues.reduce((acc, val) => acc + val, 0);
                const mean = (sum / total).toFixed(2);

                const sortedValuesForMedian = [...acValues].sort((a, b) => a - b);
                const median = total % 2 === 0 
                    ? ((sortedValuesForMedian[total / 2 - 1] + sortedValuesForMedian[total / 2]) / 2).toFixed(2)
                    : sortedValuesForMedian[Math.floor(total / 2)].toFixed(2);

                const intervalDistribution = {
                    '0-3': acValues.filter(v => v >= 0 && v <= 3).length,
                    '4-7': acValues.filter(v => v >= 4 && v <= 7).length,
                    '8-10': acValues.filter(v => v >= 8 && v <= 10).length
                };

                return {
                    values: acValues,
                    valueCounts,
                    sortedValues,
                    counts,
                    total,
                    hotACValues,
                    mean,
                    median,
                    intervalDistribution,
                    periods: filteredData.map(item => item.period)
                };
            }

            static generateLinkedThreeZoneData(filteredData) {
                const threeZoneCombinations = filteredData.map(item => item.threeZoneCombination);
                const combinationCounts = {};

                threeZoneCombinations.forEach(combo => {
                    combinationCounts[combo] = (combinationCounts[combo] || 0) + 1;
                });

                const sortedCombinations = Object.keys(combinationCounts).sort();
                const counts = sortedCombinations.map(combo => combinationCounts[combo]);
                const total = threeZoneCombinations.length;

                const hotCombinations = sortedCombinations
                    .map(combo => ({ combination: combo, count: combinationCounts[combo] }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);

                const zone1Data = filteredData.map(item => {
                    const [z1, z2, z3] = item.threeZoneCombination.split('-').map(Number);
                    return z1;
                });
                const zone2Data = filteredData.map(item => {
                    const [z1, z2, z3] = item.threeZoneCombination.split('-').map(Number);
                    return z2;
                });
                const zone3Data = filteredData.map(item => {
                    const [z1, z2, z3] = item.threeZoneCombination.split('-').map(Number);
                    return z3;
                });

                const zone1Avg = (zone1Data.reduce((sum, val) => sum + val, 0) / total).toFixed(2);
                const zone2Avg = (zone2Data.reduce((sum, val) => sum + val, 0) / total).toFixed(2);
                const zone3Avg = (zone3Data.reduce((sum, val) => sum + val, 0) / total).toFixed(2);

                return {
                    threeZoneCombinations,
                    combinationCounts,
                    sortedCombinations,
                    counts,
                    total,
                    hotCombinations,
                    zone1Avg,
                    zone2Avg,
                    zone3Avg,
                    periods: filteredData.map(item => item.period)
                };
            }

            static updateLinkedAcValueChart(acValueData, primeCompositeCombination) {
                const chartDom = document.getElementById('acValueChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: `AC值分布（质合组合：${primeCompositeCombination}）`,
                        subtext: `共${acValueData.total}期数据`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#E63946'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const item = params[0];
                            const percentage = ((item.value / acValueData.total) * 100).toFixed(1);
                            return `<div style="padding: 8px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">AC值：${item.name}</div>
                                <div style="color: #457B9D;">出现次数：<strong style="color: #E63946;">${item.value}</strong></div>
                                <div style="color: #457B9D;">占比：<strong style="color: #E63946;">${percentage}%</strong></div>
                            </div>`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: acValueData.sortedValues,
                        name: 'AC值',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: acValueData.counts,
                            itemStyle: {
                                color: function(params) {
                                    const colors = ['#FF7700', '#FF9900', '#FFBB00', '#FFDD00', '#FFFF00', '#DDFF00', '#BBFF00', '#99FF00', '#77FF00', '#55FF00', '#33FF00'];
                                    return colors[params.dataIndex % colors.length];
                                },
                                borderRadius: [4, 4, 0, 0],
                                borderColor: '#fff',
                                borderWidth: 1
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(255, 119, 0, 0.5)',
                                    borderWidth: 2
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                color: '#2c3e50',
                                fontSize: 11,
                                fontWeight: 'bold',
                                formatter: function(params) {
                                    const percentage = ((params.value / acValueData.total) * 100).toFixed(1);
                                    return `${params.value}次\n${percentage}%`;
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updateLinkedThreeZoneChart(threeZoneData, primeCompositeCombination) {
                const chartDom = document.getElementById('threeZoneChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: `三区组合分布（质合组合：${primeCompositeCombination}）`,
                        subtext: `共${threeZoneData.total}期数据`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#E63946'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const item = params[0];
                            const percentage = ((item.value / threeZoneData.total) * 100).toFixed(1);
                            const [z1, z2, z3] = item.name.split('-').map(Number);
                            return `<div style="padding: 8px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">三区组合：${item.name}</div>
                                <div style="color: #457B9D;">一区：${z1}个</div>
                                <div style="color: #457B9D;">二区：${z2}个</div>
                                <div style="color: #457B9D;">三区：${z3}个</div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #E2E8F0;">
                                    <div style="color: #2c3e50;">出现次数：<strong style="color: #E63946;">${item.value}</strong></div>
                                    <div style="color: #2c3e50;">占比：<strong style="color: #E63946;">${percentage}%</strong></div>
                                </div>
                            </div>`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: threeZoneData.sortedCombinations,
                        name: '三区组合',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11,
                            interval: 0,
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: threeZoneData.counts,
                            itemStyle: {
                                color: function(params) {
                                    const percentage = (params.value / threeZoneData.total) * 100;
                                    if (percentage >= 20) {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#E63946'
                                            }, {
                                                offset: 1, color: '#D62828'
                                            }]
                                        };
                                    } else if (percentage >= 10) {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#457B9D'
                                            }, {
                                                offset: 1, color: '#1D3557'
                                            }]
                                        };
                                    } else {
                                        return {
                                            type: 'linear',
                                            x: 0,
                                            y: 0,
                                            x2: 0,
                                            y2: 1,
                                            colorStops: [{
                                                offset: 0, color: '#A8DADC'
                                            }, {
                                                offset: 1, color: '#457B9D'
                                            }]
                                        };
                                    }
                                },
                                borderRadius: [4, 4, 0, 0],
                                borderColor: '#fff',
                                borderWidth: 1
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(230, 57, 70, 0.5)',
                                    borderWidth: 2
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                color: '#2c3e50',
                                fontSize: 11,
                                fontWeight: 'bold',
                                formatter: function(params) {
                                    const percentage = ((params.value / threeZoneData.total) * 100).toFixed(1);
                                    return `${params.value}次\n${percentage}%`;
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateDistributionInsights(primeCompositeData) {
                const insightsContent = document.getElementById('distributionInsightsContent');
                if (!insightsContent) return;

                const primeNumbers = Object.entries(primeCompositeData.numberType)
                    .filter(([_, type]) => type === 'prime')
                    .map(([num, _]) => parseInt(num));

                const compositeNumbers = Object.entries(primeCompositeData.numberType)
                    .filter(([_, type]) => type === 'composite')
                    .map(([num, _]) => parseInt(num));

                const primeAvgFreq = primeNumbers.reduce((sum, num) => {
                    const numStr = num.toString().padStart(2, '0');
                    return sum + primeCompositeData.numberFrequency[numStr];
                }, 0) / primeNumbers.length;

                const compositeAvgFreq = compositeNumbers.reduce((sum, num) => {
                    const numStr = num.toString().padStart(2, '0');
                    return sum + primeCompositeData.numberFrequency[numStr];
                }, 0) / compositeNumbers.length;

                const hotPrimes = primeNumbers.filter(num => {
                    const numStr = num.toString().padStart(2, '0');
                    return primeCompositeData.numberFrequency[numStr] > primeAvgFreq;
                }).slice(0, 5);

                const hotComposites = compositeNumbers.filter(num => {
                    const numStr = num.toString().padStart(2, '0');
                    return primeCompositeData.numberFrequency[numStr] > compositeAvgFreq;
                }).slice(0, 5);

                const recentTrend = primeCompositeData.trend.slice(0, 10);
                const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                insightsContent.innerHTML = `
                    <div class="insight-item">
                        <span class="insight-icon">📊</span>
                        <div class="insight-text">
                            <strong>质数分布概况：</strong>共 ${primeNumbers.length} 个质数号码，平均出现频率为 ${primeAvgFreq.toFixed(2)} 次。
                            热门质数号码：${hotPrimes.map(n => n.toString().padStart(2, '0')).join(', ')}。
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">📈</span>
                        <div class="insight-text">
                            <strong>合数分布概况：</strong>共 ${compositeNumbers.length} 个合数号码，平均出现频率为 ${compositeAvgFreq.toFixed(2)} 次。
                            热门合数号码：${hotComposites.map(n => n.toString().padStart(2, '0')).join(', ')}。
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">🔥</span>
                        <div class="insight-text">
                            <strong>近期趋势分析：</strong>最近10期平均质数出现 ${recentPrimeAvg.toFixed(1)} 个，合数出现 ${recentCompositeAvg.toFixed(1)} 个。
                            ${recentPrimeAvg > recentCompositeAvg ? '质数近期表现较为活跃。' : '合数近期表现较为活跃。'}
                        </div>
                    </div>
                    <div class="insight-item">
                        <span class="insight-icon">💡</span>
                        <div class="insight-text">
                            <strong>选号建议：</strong>根据分布规律，建议关注${recentPrimeAvg > recentCompositeAvg ? '合数' : '质数'}的回补机会。
                            同时留意热门号码的延续性，以及冷门号码的反弹可能。
                        </div>
                    </div>
                `;
            }

            static generateEnhancedPrimeCompositeConclusion(primeCompositeData, totalPeriods) {
                const conclusionContent = document.getElementById('primeCompositeConclusionContent');
                if (!conclusionContent) return;

                const phase1Data = primeCompositeData.phase1Data;
                const linkedData = primeCompositeData.linkedData || [];
                const combinationFrequency = primeCompositeData.primeCompositeCombinationFrequency || {};
                const acValueCorrelation = primeCompositeData.primeCompositeAcValueCorrelation || {};
                const threeZoneCorrelation = primeCompositeData.primeCompositeThreeZoneCorrelation || {};
                const trend = primeCompositeData.trend || [];

                const topCombinations = Object.entries(combinationFrequency)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([combo, freq]) => {
                        const percentage = ((freq / totalPeriods) * 100).toFixed(1);
                        const [prime, composite] = combo.split(':').map(Number);
                        return { combo: `${prime}质${composite}合`, freq, percentage, prime, composite };
                    });

                const acValueStats = {};
                Object.entries(acValueCorrelation).forEach(([combo, acData]) => {
                    const comboTotal = Object.values(acData).reduce((sum, count) => sum + count, 0);
                    const topAC = Object.entries(acData).sort((a, b) => b[1] - a[1])[0];
                    if (topAC) {
                        acValueStats[combo] = {
                            topAC: topAC[0],
                            topACCount: topAC[1],
                            topACPercentage: ((topAC[1] / comboTotal) * 100).toFixed(1),
                            comboTotal
                        };
                    }
                });

                const threeZoneStats = {};
                Object.entries(threeZoneCorrelation).forEach(([combo, zoneData]) => {
                    const comboTotal = Object.values(zoneData).reduce((sum, count) => sum + count, 0);
                    const topZone = Object.entries(zoneData).sort((a, b) => b[1] - a[1])[0];
                    if (topZone) {
                        threeZoneStats[combo] = {
                            topZone: topZone[0],
                            topZoneCount: topZone[1],
                            topZonePercentage: ((topZone[1] / comboTotal) * 100).toFixed(1),
                            comboTotal
                        };
                    }
                });

                const recentTrend = trend.slice(-10);
                const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                const primeTrendDirection = recentPrimeAvg > 2.5 ? '升温' : recentPrimeAvg < 1.5 ? '降温' : '平稳';
                const compositeTrendDirection = recentCompositeAvg > 4 ? '升温' : recentCompositeAvg < 3 ? '降温' : '平稳';

                const linkedACValues = linkedData.map(item => item.acValue);
                const acValueDistribution = {};
                linkedACValues.forEach(ac => {
                    const range = Math.floor(ac / 2) * 2;
                    const key = `${range}-${range + 1}`;
                    acValueDistribution[key] = (acValueDistribution[key] || 0) + 1;
                });
                const topACRange = Object.entries(acValueDistribution).sort((a, b) => b[1] - a[1])[0];

                const linkedThreeZones = linkedData.map(item => item.threeZoneCombination);
                const threeZoneDistribution = {};
                linkedThreeZones.forEach(zone => {
                    threeZoneDistribution[zone] = (threeZoneDistribution[zone] || 0) + 1;
                });
                const topThreeZone = Object.entries(threeZoneDistribution).sort((a, b) => b[1] - a[1])[0];

                const topComboKey = `${topCombinations[0].prime}:${topCombinations[0].composite}`;
                const topComboAC = acValueStats[topComboKey];
                const topComboZone = threeZoneStats[topComboKey];

                const linkedHeatmapData = [];
                primeCompositeData.linkedData.forEach(item => {
                    const existing = linkedHeatmapData.find(d => 
                        d.primeCombo === item.primeCompositeCombination && 
                        d.zoneCombo === item.threeZoneCombination
                    );
                    if (existing) {
                        existing.count++;
                        existing.acValues.push(item.acValue);
                    } else {
                        linkedHeatmapData.push({
                            primeCombo: item.primeCompositeCombination,
                            zoneCombo: item.threeZoneCombination,
                            count: 1,
                            acValues: [item.acValue]
                        });
                    }
                });

                linkedHeatmapData.sort((a, b) => b.count - a.count);
                const topLinkedCombo = linkedHeatmapData[0];
                const topLinkedAvgAC = topLinkedCombo ? (topLinkedCombo.acValues.reduce((sum, ac) => sum + ac, 0) / topLinkedCombo.acValues.length).toFixed(1) : '无';

                const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                const primeRatio = ((primeCompositeData.primeCount / total) * 100).toFixed(1);
                const compositeRatio = ((primeCompositeData.compositeCount / total) * 100).toFixed(1);

                const ratioDeviation = Math.abs(parseFloat(primeRatio) - 33.33);
                const ratioStatus = ratioDeviation > 5 ? '失衡' : ratioDeviation > 2 ? '偏离' : '均衡';

                const lastPeriod = trend[trend.length - 1];
                const lastRatio = lastPeriod ? lastPeriod.prime / (lastPeriod.prime + lastPeriod.composite) : 0;
                const avgRatio = recentPrimeAvg / (recentPrimeAvg + recentCompositeAvg);
                const ratioTrend = lastRatio > avgRatio ? '上升' : lastRatio < avgRatio ? '下降' : '稳定';

                const conversionPoints = primeCompositeData.conversionPoints.slice(-5);
                const recentConversions = conversionPoints.filter(cp => {
                    const cpIndex = trend.findIndex(t => t.period === cp.period);
                    return cpIndex >= trend.length - 10;
                });

                let phase1Insight = '';
                if (phase1Data && phase1Data.consecutivePrimeCompositePatterns.length > 0) {
                    const avgPrimeChange = phase1Data.consecutivePrimeCompositePatterns.reduce((sum, p) => sum + p.primeChange, 0) / phase1Data.consecutivePrimeCompositePatterns.length;
                    const avgCompositeChange = phase1Data.consecutivePrimeCompositePatterns.reduce((sum, p) => sum + p.compositeChange, 0) / phase1Data.consecutivePrimeCompositePatterns.length;
                    const stableCount = phase1Data.consecutivePrimeCompositePatterns.filter(p => p.primeChange === 0 && p.compositeChange === 0).length;
                    const stableRatio = (stableCount / phase1Data.consecutivePrimeCompositePatterns.length * 100).toFixed(1);

                    const topTransitions = Object.entries(phase1Data.combinationTransitions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);

                    phase1Insight = `
                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">六、逐期关联分析（阶段1）</h5>
                            <div class="conclusion-text">
                                <p>相邻期质数平均变化：<strong>${avgPrimeChange.toFixed(2)}</strong>个，合数平均变化：<strong>${avgCompositeChange.toFixed(2)}</strong>个。</p>
                                <p>质合组合保持不变：<strong>${stableCount}</strong> 次（占比 ${stableRatio}%）。</p>
                                ${topTransitions.length > 0 ? `<p>高频组合转换：${topTransitions.map(([key, count]) => `<strong>${key.replace(':', '质').replace(':', '合')}</strong> → <strong>${count}</strong>次`).join('、')}。</p>` : ''}
                                <p>相邻期质合组合${Math.abs(avgPrimeChange) < 0.5 && Math.abs(avgCompositeChange) < 0.5 ? '相对稳定' : '变化较大'}，${stableRatio > 30 ? '延续性较强' : '延续性较弱'}。</p>
                            </div>
                        </div>
                    `;
                }

                conclusionContent.innerHTML = `
                    <div class="conclusion-section">
                        <h4 class="conclusion-title">📊 质合分析综合结论</h4>

                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">一、基础数据分析</h5>
                            <div class="conclusion-text">
                                <p>近${totalPeriods}期数据显示，质数总出现${primeCompositeData.primeCount}次，合数总出现${primeCompositeData.compositeCount}次，质合比例为${primeRatio}% : ${compositeRatio}%，整体${ratioStatus}。</p>
                                <p>最热门质合组合为<strong>${topCombinations[0].combo}</strong>，出现${topCombinations[0].freq}次（占比${topCombinations[0].percentage}%）；其次为${topCombinations[1].combo}（${topCombinations[1].freq}次，${topCombinations[1].percentage}%）和${topCombinations[2].combo}（${topCombinations[2].freq}次，${topCombinations[2].percentage}%）。</p>
                                <p>近期质数趋势${primeTrendDirection}（平均${recentPrimeAvg.toFixed(1)}个/期），合数趋势${compositeTrendDirection}（平均${recentCompositeAvg.toFixed(1)}个/期）。${primeTrendDirection === '升温' && compositeTrendDirection === '降温' ? '质数呈上升趋势，合数呈下降趋势，建议重点关注质数号码。' : primeTrendDirection === '降温' && compositeTrendDirection === '上升' ? '合数呈上升趋势，质数呈下降趋势，建议重点关注合数号码。' : '质合趋势相对稳定，建议保持均衡选号策略。'}</p>
                            </div>
                        </div>

                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">二、AC值联动分析</h5>
                            <div class="conclusion-text">
                                <p>高频AC值区间为${topACRange ? `<strong>${topACRange[0]}</strong>` : '无数据'}（${topACRange ? `占比${((topACRange[1] / totalPeriods) * 100).toFixed(1)}%` : ''}），${topACRange && topACRange[1] > totalPeriods * 0.3 ? '该区间AC值出现频率较高，建议重点关注。' : 'AC值分布相对均匀。'}</p>
                                <p>${topComboAC ? `<strong>${topCombinations[0].combo}</strong>组合最常对应的AC值为<strong>AC${topComboAC.topAC}</strong>（${topComboAC.topACPercentage}%），${topComboAC.topACPercentage > 30 ? '该AC值与该质合组合关联度较高。' : 'AC值分布相对分散。'}` : ''}</p>
                                ${topCombinations.slice(1, 2).map(item => {
                                    const comboKey = `${item.prime}:${item.composite}`;
                                    const acStat = acValueStats[comboKey];
                                    if (acStat) {
                                        return `<p><strong>${item.combo}</strong>组合最常对应的AC值为<strong>AC${acStat.topAC}</strong>（${acStat.topACPercentage}%）。</p>`;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        </div>

                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">三、三区联动分析</h5>
                            <div class="conclusion-text">
                                <p>热门三区组合为${topThreeZone ? `<strong>${topThreeZone[0]}</strong>` : '无数据'}（${topThreeZone ? `占比${((topThreeZone[1] / totalPeriods) * 100).toFixed(1)}%` : ''}），${topThreeZone && topThreeZone[1] > totalPeriods * 0.25 ? '该三区组合出现频率较高，建议重点关注。' : '三区组合分布相对均匀。'}</p>
                                <p>${topComboZone ? `<strong>${topCombinations[0].combo}</strong>组合最常对应的三区组合为<strong>${topComboZone.topZone}</strong>（${topComboZone.topZonePercentage}%），${topComboZone.topZonePercentage > 25 ? '该三区组合与该质合组合关联度较高。' : '三区组合分布相对分散。'}` : ''}</p>
                                ${topCombinations.slice(1, 2).map(item => {
                                    const comboKey = `${item.prime}:${item.composite}`;
                                    const zoneStat = threeZoneStats[comboKey];
                                    if (zoneStat) {
                                        return `<p><strong>${item.combo}</strong>组合最常对应的三区组合为<strong>${zoneStat.topZone}</strong>（${zoneStat.topZonePercentage}%）。</p>`;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        </div>

                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">四、三重维度联动分析</h5>
                            <div class="conclusion-text">
                                ${topLinkedCombo ? `
                                <p>质合×三区×AC值三重联动分析显示，<strong>${topLinkedCombo.primeCombo.replace(':', '质').replace(':', '合')} × ${topLinkedCombo.zoneCombo}</strong>为最高频联动组合，出现${topLinkedCombo.count}次（占比${((topLinkedCombo.count / totalPeriods) * 100).toFixed(1)}%），平均AC值为<strong>${topLinkedAvgAC}</strong>。</p>
                                <p>该三重联动组合${topLinkedCombo.count > totalPeriods * 0.2 ? '出现频率较高，为综合高频组合，建议作为主要选号参考。' : '出现频率适中，可作为备选选号参考。'}</p>
                                ` : '<p>暂无足够的联动数据进行分析。</p>'}
                                <p>通过三重维度联动分析，可以发现质合组合与AC值、三区组合之间存在一定的关联规律，建议结合这些关联规律进行综合选号。</p>
                            </div>
                        </div>

                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">五、趋势转换分析</h5>
                            <div class="conclusion-text">
                                <p>最近10期发现${recentConversions.length}次明显的质合转换点，${recentConversions.length >= 3 ? '转换较为频繁，说明质合交替活跃，建议灵活调整选号策略。' : '转换较少，说明当前趋势相对稳定。'}</p>
                                <p>最新期质合比例为${lastRatio.toFixed(2)}，与近期平均值${avgRatio.toFixed(2)}相比${parseFloat(ratioTrend) > 0 ? '偏高' : parseFloat(ratioTrend) < 0 ? '偏低' : '持平'}，${Math.abs(lastRatio - avgRatio) > 0.1 ? '偏差较大，可能存在回归趋势。' : '偏差在正常范围内。'}</p>
                            </div>
                        </div>

                        ${phase1Insight}

                        <div class="conclusion-block highlight">
                            <h5 class="conclusion-subtitle">💡 综合选号建议</h5>
                            <div class="conclusion-text">
                                <p><strong>主要推荐：</strong>重点关注<strong>${topCombinations[0].combo}</strong>组合，结合${topACRange ? `AC值${topACRange[0]}区间` : ''}${topThreeZone ? `和三区${topThreeZone[0]}组合` : ''}进行选号。</p>
                                <p><strong>次要推荐：</strong>关注<strong>${topCombinations[1].combo}</strong>和${topCombinations[2].combo}组合，${topComboAC ? `对应AC值${topComboAC.topAC}` : ''}${topComboZone ? `和三区${topComboZone.topZone}组合` : ''}。</p>
                                <p><strong>趋势建议：</strong>${primeTrendDirection === '升温' ? '质数呈上升趋势，可适当增加质数号码选择。' : primeTrendDirection === '降温' ? '质数呈下降趋势，可适当减少质数号码选择。' : '质合趋势相对稳定，可保持均衡选号策略。'}</p>
                                <p><strong>比例建议：</strong>${ratioStatus === '失衡' ? '当前质合比例失衡，建议关注回归趋势，适当调整质合号码选择。' : ratioStatus === '偏离' ? '当前质合比例略有偏离，建议关注平衡调整。' : '当前质合比例相对均衡，可延续当前选号策略。'}</p>
                                <p><strong>联动建议：</strong>${topLinkedCombo ? `建议优先考虑质合×三区×AC值三重联动高频组合，即${topLinkedCombo.primeCombo.replace(':', '质').replace(':', '合')} × ${topLinkedCombo.zoneCombo} × AC值${topLinkedAvgAC}。` : '建议结合质合、AC值、三区三个维度的综合分析进行选号。'}</p>
                            </div>
                        </div>

                        <div class="conclusion-block">
                            <h5 class="conclusion-subtitle">📋 风险提示</h5>
                            <div class="conclusion-text">
                                <p>以上分析基于历史数据统计，仅供参考。彩票开奖具有随机性，历史规律不代表未来走势。建议理性购彩，量力而行。</p>
                                <p>建议结合多种分析方法，如遗漏分析、冷热号分析、和值分析等，进行综合判断，提高选号的准确性和可靠性。</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            static updatePrimeCompositeHeatmapChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeHeatmapChart');
                if (!chartDom) {
                    console.warn('primeCompositeHeatmapChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const linkedData = primeCompositeData.linkedData || [];

                const primeCompositeCombinations = [...new Set(linkedData.map(item => item.primeCompositeCombination))].sort((a, b) => {
                    const [primeA, compositeA] = a.split(':').map(Number);
                    const [primeB, compositeB] = b.split(':').map(Number);
                    return primeA - primeB;
                });

                const threeZoneCombinations = [...new Set(linkedData.map(item => item.threeZoneCombination))].sort();

                const heatmapData = [];
                const maxFreq = { value: 0, combo: '', zone: '', acRange: '' };

                primeCompositeCombinations.forEach(primeCombo => {
                    threeZoneCombinations.forEach(zoneCombo => {
                        const filteredData = linkedData.filter(item => 
                            item.primeCompositeCombination === primeCombo && 
                            item.threeZoneCombination === zoneCombo
                        );

                        const frequency = filteredData.length;

                        if (frequency > 0) {
                            const acValues = filteredData.map(item => item.acValue);
                            const avgAC = (acValues.reduce((sum, val) => sum + val, 0) / acValues.length).toFixed(1);
                            const minAC = Math.min(...acValues);
                            const maxAC = Math.max(...acValues);

                            if (frequency > maxFreq.value) {
                                maxFreq.value = frequency;
                                maxFreq.combo = primeCombo;
                                maxFreq.zone = zoneCombo;
                                maxFreq.acRange = `${minAC}-${maxAC}`;
                            }

                            heatmapData.push({
                                name: `${primeCombo} × ${zoneCombo}`,
                                value: [
                                    primeCompositeCombinations.indexOf(primeCombo),
                                    threeZoneCombinations.indexOf(zoneCombo),
                                    frequency,
                                    avgAC,
                                    minAC,
                                    maxAC
                                ]
                            });
                        }
                    });
                });

                const totalDraws = linkedData.length;
                const topCombo = maxFreq.combo.replace(':', '质').replace(':', '合');
                const topZone = maxFreq.zone;
                const topPercentage = ((maxFreq.value / totalDraws) * 100).toFixed(2);

                const option = {
                    title: {
                        text: '质合×三区×AC值联动热力图（核心图表）',
                        subtext: `热门组合：${topCombo} × ${topZone}（${maxFreq.value}次，${topPercentage}%，AC值${maxFreq.acRange}）`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#E63946',
                            fontWeight: 'normal'
                        }
                    },
                    tooltip: {
                        position: 'top',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const primeCombo = primeCompositeCombinations[params.value[0]];
                            const zoneCombo = threeZoneCombinations[params.value[1]];
                            const frequency = params.value[2];
                            const avgAC = params.value[3];
                            const minAC = params.value[4];
                            const maxAC = params.value[5];
                            const percentage = ((frequency / totalDraws) * 100).toFixed(2);

                            const filteredData = linkedData.filter(item => 
                                item.primeCompositeCombination === primeCombo && 
                                item.threeZoneCombination === zoneCombo
                            );

                            const acDistribution = {};
                            filteredData.forEach(item => {
                                const range = Math.floor(item.acValue / 2) * 2;
                                const key = `${range}-${range + 1}`;
                                acDistribution[key] = (acDistribution[key] || 0) + 1;
                            });

                            const topACRange = Object.entries(acDistribution)
                                .sort((a, b) => b[1] - a[1])[0];

                            return `<div style="padding: 10px; max-width: 350px;">
                                <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50; font-size: 14px;">
                                    质合组合：${primeCombo.replace(':', '质').replace(':', '合')}
                                </div>
                                <div style="color: #457B9D; margin-bottom: 6px;">三区组合：<strong>${zoneCombo}</strong></div>
                                <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #E2E8F0;">
                                    <div style="color: #2c3e50; font-weight: bold; margin-bottom: 6px;">统计信息：</div>
                                    <div style="color: #2c3e50;">出现次数：<strong style="color: #E63946;">${frequency}次</strong></div>
                                    <div style="color: #2c3e50;">占比：<strong style="color: #E63946;">${percentage}%</strong></div>
                                    <div style="color: #2c3e50;">平均AC值：<strong style="color: #457B9D;">${avgAC}</strong></div>
                                    <div style="color: #2c3e50;">AC值范围：<strong style="color: #457B9D;">${minAC} - ${maxAC}</strong></div>
                                    <div style="color: #2c3e50;">高频AC区间：<strong style="color: #457B9D;">${topACRange ? topACRange[0] : '无'}</strong></div>
                                </div>
                            </div>`;
                        }
                    },
                    grid: {
                        height: '60%',
                        top: '18%',
                        bottom: '22%',
                        left: '8%',
                        right: '12%'
                    },
                    xAxis: {
                        type: 'category',
                        data: primeCompositeCombinations.map(combo => {
                            const [prime, composite] = combo.split(':').map(Number);
                            return `${prime}质${composite}合`;
                        }),
                        splitArea: {
                            show: true,
                            itemStyle: {
                                color: ['rgba(248, 250, 252, 0.8)', 'rgba(255, 255, 255, 0.8)']
                            }
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 10,
                            interval: 0,
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: threeZoneCombinations,
                        splitArea: {
                            show: true,
                            itemStyle: {
                                color: ['rgba(248, 250, 252, 0.8)', 'rgba(255, 255, 255, 0.8)']
                            }
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11,
                            fontWeight: 'bold'
                        }
                    },
                    visualMap: {
                        min: 0,
                        max: maxFreq.value || 1,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '5%',
                        inRange: {
                            color: [
                                '#F1FAEE',
                                '#A8DADC',
                                '#457B9D',
                                '#1D3557',
                                '#E63946',
                                '#D62828',
                                '#C70039',
                                '#900C3F'
                            ]
                        },
                        textStyle: {
                            color: '#2c3e50',
                            fontSize: 12
                        },
                        formatter: function(value) {
                            return value + '次';
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'heatmap',
                            data: heatmapData.map(item => item.value),
                            label: {
                                show: true,
                                fontSize: 11,
                                fontWeight: 'bold',
                                color: '#fff',
                                textShadowBlur: 2,
                                textShadowColor: 'rgba(0, 0, 0, 0.5)',
                                formatter: function(params) {
                                    return params.value[2] > 0 ? params.value[2] : '';
                                }
                            },
                            itemStyle: {
                                borderRadius: 4,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 20,
                                    shadowColor: 'rgba(0, 0, 0, 0.6)',
                                    borderColor: '#fff',
                                    borderWidth: 3
                                },
                                label: {
                                    show: true,
                                    fontSize: 13,
                                    fontWeight: 'bold'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);

                chart.on('click', function(params) {
                    const primeCombo = primeCompositeCombinations[params.value[0]];
                    const zoneCombo = threeZoneCombinations[params.value[1]];

                    console.log('点击热力图:', primeCombo, zoneCombo);

                    const acValueFilter = document.getElementById('primeCompositeAcValueFilter');
                    const threeZoneFilter = document.getElementById('primeCompositeThreeZoneFilter');

                    if (acValueFilter) {
                        const minAC = params.value[4];
                        const maxAC = params.value[5];

                        const acValueOptions = Array.from(acValueFilter.options);
                        const matchingOption = acValueOptions.find(opt => {
                            if (opt.value === 'all') return false;
                            const [min, max] = opt.value.split('-').map(Number);
                            return minAC >= min && maxAC <= max;
                        });

                        if (matchingOption) {
                            acValueFilter.value = matchingOption.value;
                        } else {
                            acValueFilter.value = 'all';
                        }
                    }

                    if (threeZoneFilter) {
                        const threeZoneOptions = Array.from(threeZoneFilter.options);
                        if (threeZoneOptions.find(opt => opt.value === zoneCombo)) {
                            threeZoneFilter.value = zoneCombo;
                        } else {
                            threeZoneFilter.value = 'all';
                        }
                    }

                    PrimeCompositeAnalysis.performPrimeCompositeAnalysisByPeriod();
                });
            }

            static updatePrimeCompositeStackedChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeStackedChart');
                if (!chartDom) {
                    console.warn('primeCompositeStackedChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const trendData = primeCompositeData.trend.slice(0, 20).reverse();
                const periods = trendData.map(item => item.period);
                const primeData = trendData.map(item => item.prime);
                const compositeData = trendData.map(item => item.composite);

                const earliestPeriod = periods[0];
                const latestPeriod = periods[periods.length - 1];

                const option = {
                    title: {
                        text: '质合堆叠柱状图（最近20期）',
                        subtext: `从最新期${latestPeriod}倒推至${earliestPeriod}`,
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#666',
                            fontWeight: 'normal'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = `<div style="padding: 8px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">期号: ${paramArray[0].axisValue}</div>`;
                            paramArray.forEach(item => {
                                result += `<div style="display: flex; align-items: center; margin-bottom: 4px;">
                                    <span style="display: inline-block; width: 10px; height: 10px; background-color: ${item.color}; border-radius: 2px; margin-right: 8px;"></span>
                                    <span style="color: #2c3e50;">${item.seriesName}: </span>
                                    <span style="font-weight: bold; color: ${item.color}; margin-left: 4px;">${item.value}</span>
                                </div>`;
                            });
                            const total = paramArray.reduce((sum, item) => sum + item.value, 0);
                            result += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #E2E8F0; color: #2c3e50;">
                                <strong>总计: ${total}</strong>
                            </div></div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['质数', '合数'],
                        top: '10%',
                        textStyle: {
                            fontSize: 14,
                            color: '#2c3e50'
                        },
                        itemGap: 20
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11,
                            interval: 0,
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '质数',
                            type: 'bar',
                            stack: 'total',
                            data: primeData,
                            itemStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0, color: '#E63946'
                                    }, {
                                        offset: 1, color: '#D62828'
                                    }]
                                },
                                borderRadius: [4, 4, 0, 0],
                                borderColor: '#fff',
                                borderWidth: 1
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(230, 57, 70, 0.5)',
                                    borderWidth: 2
                                }
                            },
                            label: {
                                show: true,
                                position: 'inside',
                                color: '#fff',
                                fontSize: 12,
                                fontWeight: 'bold',
                                textShadowBlur: 2,
                                textShadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        },
                        {
                            name: '合数',
                            type: 'bar',
                            stack: 'total',
                            data: compositeData,
                            itemStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [{
                                        offset: 0, color: '#457B9D'
                                    }, {
                                        offset: 1, color: '#1D3557'
                                    }]
                                },
                                borderRadius: [0, 0, 4, 4],
                                borderColor: '#fff',
                                borderWidth: 1
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(69, 123, 157, 0.5)',
                                    borderWidth: 2
                                }
                            },
                            label: {
                                show: true,
                                position: 'inside',
                                color: '#fff',
                                fontSize: 12,
                                fontWeight: 'bold',
                                textShadowBlur: 2,
                                textShadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updatePrimeCompositeStatusChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeStatusChart');
                if (!chartDom) {
                    console.warn('primeCompositeStatusChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const currentOmissionValues = [];
                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    const frequency = primeCompositeData.numberFrequency[numStr] || 0;
                    const avgOmission = primeCompositeData.numberAvgOmission[numStr] || 0;
                    const currentOmission = primeCompositeData.numberOmission[numStr] || 0;

                    currentOmissionValues.push({
                        number: i,
                        numStr: numStr,
                        currentOmission: currentOmission,
                        frequency: frequency,
                        avgOmission: avgOmission
                    });
                }

                currentOmissionValues.sort((a, b) => a.currentOmission - b.currentOmission);

                const hotCount = Math.ceil(currentOmissionValues.length * 0.33);
                const warmCount = Math.ceil(currentOmissionValues.length * 0.34);

                const hotNumbers = [];
                const warmNumbers = [];
                const coldNumbers = [];

                for (let i = 0; i < currentOmissionValues.length; i++) {
                    const item = currentOmissionValues[i];
                    const dataItem = { 
                        value: [item.number, item.currentOmission], 
                        name: item.numStr, 
                        frequency: item.frequency, 
                        avgOmission: item.avgOmission > 0 ? item.avgOmission.toFixed(1) : '0.0'
                    };

                    if (i < hotCount) {
                        hotNumbers.push(dataItem);
                    } else if (i < hotCount + warmCount) {
                        warmNumbers.push(dataItem);
                    } else {
                        coldNumbers.push(dataItem);
                    }
                }

                console.log('=== 号码状态雷达图数据 ===');
                console.log('热号数量:', hotNumbers.length, '热号示例:', hotNumbers.slice(0, 3));
                console.log('温号数量:', warmNumbers.length, '温号示例:', warmNumbers.slice(0, 3));
                console.log('冷号数量:', coldNumbers.length, '冷号示例:', coldNumbers.slice(0, 3));

                const option = {
                    title: {
                        text: '号码冷热状态分布',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const data = params.data;
                            return `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">号码: ${data.name}</div>
                                <div style="color: #457B9D;">当前遗漏: ${data.value[1]}</div>
                                <div style="color: #457B9D;">平均遗漏: ${data.avgOmission}</div>
                                <div style="color: #457B9D;">出现次数: ${data.frequency}</div>
                            </div>`;
                        }
                    },
                    legend: {
                        data: ['热号', '温号', '冷号'],
                        top: '10%',
                        textStyle: {
                            fontSize: 14,
                            color: '#2c3e50'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'value',
                        name: '号码',
                        min: 0,
                        max: 34,
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '当前遗漏',
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '热号',
                            type: 'scatter',
                            data: hotNumbers,
                            itemStyle: {
                                color: '#E63946',
                                shadowBlur: 10,
                                shadowColor: 'rgba(230, 57, 70, 0.5)'
                            },
                            symbolSize: 15
                        },
                        {
                            name: '温号',
                            type: 'scatter',
                            data: warmNumbers,
                            itemStyle: {
                                color: '#F4A261',
                                shadowBlur: 10,
                                shadowColor: 'rgba(244, 162, 97, 0.5)'
                            },
                            symbolSize: 12
                        },
                        {
                            name: '冷号',
                            type: 'scatter',
                            data: coldNumbers,
                            itemStyle: {
                                color: '#457B9D',
                                shadowBlur: 10,
                                shadowColor: 'rgba(69, 123, 157, 0.5)'
                            },
                            symbolSize: 10
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static updatePrimeCompositeStatusTable(primeCompositeData) {
                const tableBody = document.getElementById('primeCompositeStatusTableBody');
                if (!tableBody) {
                    console.warn('primeCompositeStatusTableBody 容器不存在');
                    return;
                }

                tableBody.innerHTML = '';

                const numbers = [];
                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    const type = primeCompositeData.numberType[numStr] === 'prime' ? '质数' : '合数';
                    const frequency = primeCompositeData.numberFrequency[numStr] || 0;
                    const currentOmission = primeCompositeData.numberOmission[numStr] || 0;
                    const avgOmission = primeCompositeData.numberAvgOmission[numStr] || 0;
                    const maxOmission = primeCompositeData.numberMaxOmission[numStr] || 0;

                    let status = '';
                    let statusClass = '';
                    let statusIcon = '';
                    if (avgOmission > 0) {
                        if (currentOmission < avgOmission) {
                            status = '热号';
                            statusClass = 'status-hot';
                            statusIcon = '🔥';
                        } else if (currentOmission < avgOmission * 2) {
                            status = '温号';
                            statusClass = 'status-warm';
                            statusIcon = '⚡';
                        } else {
                            status = '冷号';
                            statusClass = 'status-cold';
                            statusIcon = '❄️';
                        }
                    } else {
                        status = '未知';
                        statusClass = 'status-unknown';
                        statusIcon = '❓';
                    }

                    const omissionRatio = maxOmission > 0 ? currentOmission / maxOmission : 0;
                    let omissionClass = '';
                    if (omissionRatio < 0.3) {
                        omissionClass = 'omission-low';
                    } else if (omissionRatio < 0.7) {
                        omissionClass = 'omission-medium';
                    } else {
                        omissionClass = 'omission-high';
                    }

                    numbers.push({
                        number: numStr,
                        type: type,
                        typeClass: type === '质数' ? 'type-prime' : 'type-composite',
                        frequency: frequency,
                        currentOmission: currentOmission,
                        avgOmission: avgOmission > 0 ? avgOmission.toFixed(1) : '0.0',
                        maxOmission: maxOmission,
                        status: status,
                        statusClass: statusClass,
                        statusIcon: statusIcon,
                        omissionRatio: omissionRatio,
                        omissionClass: omissionClass
                    });
                }

                numbers.sort((a, b) => a.number.localeCompare(b.number));

                const maxFrequency = Math.max(...numbers.map(n => n.frequency), 1);

                numbers.forEach((num, index) => {
                    const row = document.createElement('tr');
                    row.style.animationDelay = `${index * 0.05}s`;
                    row.className = 'status-table-row';

                    const typeBadge = num.type === '质数' 
                        ? `<span class="type-badge type-prime">${num.type}</span>`
                        : `<span class="type-badge type-composite">${num.type}</span>`;

                    const frequencyBar = `
                        <div class="frequency-bar-container">
                            <div class="frequency-bar" style="width: ${(num.frequency / maxFrequency) * 100}%;"></div>
                            <span class="frequency-value">${num.frequency}</span>
                        </div>
                    `;

                    const omissionIndicator = `
                        <div class="omission-indicator">
                            <div class="omission-bar ${num.omissionClass}" style="width: ${num.omissionRatio * 100}%;"></div>
                            <span class="omission-value">${num.currentOmission}</span>
                        </div>
                    `;

                    row.innerHTML = `
                        <td class="number-cell">
                            <span class="number-badge">${num.number}</span>
                        </td>
                        <td class="type-cell">${typeBadge}</td>
                        <td class="frequency-cell">${frequencyBar}</td>
                        <td class="omission-cell">${omissionIndicator}</td>
                        <td class="avg-omission-cell">${num.avgOmission}</td>
                        <td class="max-omission-cell">${num.maxOmission}</td>
                        <td class="status-cell">
                            <span class="status-badge ${num.statusClass}">
                                ${num.statusIcon} ${num.status}
                            </span>
                        </td>
                    `;

                    tableBody.appendChild(row);
                });

                const table = tableBody.closest('table');
                if (table) {
                    table.classList.add('status-table');
                }
            }

            static updatePrimeCompositeOmissionChart(primeCompositeData) {
                const chartDom = document.getElementById('primeCompositeOmissionChart');
                if (!chartDom) {
                    console.warn('primeCompositeOmissionChart 容器不存在');
                    return;
                }

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const numbers = [];
                const currentOmissions = [];
                const avgOmissions = [];
                const maxOmissions = [];
                const types = [];
                const frequencies = [];

                for (let i = 1; i <= 33; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    numbers.push(numStr);
                    const currentOmission = primeCompositeData.numberOmission[numStr] || 0;
                    const avgOmission = primeCompositeData.numberAvgOmission[numStr] || 0;
                    const maxOmission = primeCompositeData.numberMaxOmission[numStr] || 0;
                    const frequency = primeCompositeData.numberFrequency[numStr] || 0;
                    const type = primeCompositeData.numberType[numStr] || 'composite';

                    currentOmissions.push(currentOmission);
                    avgOmissions.push(parseFloat(avgOmission.toFixed(1)));
                    maxOmissions.push(maxOmission);
                    types.push(type);
                    frequencies.push(frequency);
                }

                console.log('=== 遗漏状态分析图表数据 ===');
                console.log('当前遗漏:', currentOmissions.slice(0, 5));
                console.log('平均遗漏:', avgOmissions.slice(0, 5));
                console.log('最大遗漏:', maxOmissions.slice(0, 5));
                console.log('频率:', frequencies.slice(0, 5));

                const option = {
                    title: {
                        text: '号码遗漏状态分析',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: '#E63946',
                        borderWidth: 1,
                        textStyle: {
                            color: '#2c3e50'
                        },
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">号码: ${paramArray[0].name}</div>`;

                            paramArray.forEach(param => {
                                result += `<div style="display: flex; align-items: center; margin-bottom: 4px;">
                                    <span style="display: inline-block; width: 10px; height: 10px; background-color: ${param.color}; border-radius: 2px; margin-right: 8px;"></span>
                                    <span style="color: #2c3e50;">${param.seriesName}: </span>
                                    <span style="font-weight: bold; color: ${param.color}; margin-left: 4px;">${param.value}</span>
                                </div>`;
                            });

                            result += `</div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['当前遗漏', '平均遗漏', '最大遗漏'],
                        top: '10%',
                        textStyle: {
                            fontSize: 14,
                            color: '#2c3e50'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50',
                            fontSize: 11,
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '遗漏期数',
                        axisLine: {
                            lineStyle: {
                                color: '#2c3e50'
                            }
                        },
                        axisLabel: {
                            color: '#2c3e50'
                        },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    series: [
                        {
                            name: '当前遗漏',
                            type: 'bar',
                            data: currentOmissions,
                            itemStyle: {
                                color: function(params) {
                                    return types[params.dataIndex] === 'prime' ? '#E63946' : '#457B9D';
                                },
                                borderRadius: [4, 4, 0, 0]
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(230, 57, 70, 0.5)',
                                    borderWidth: 2
                                }
                            }
                        },
                        {
                            name: '平均遗漏',
                            type: 'line',
                            data: avgOmissions,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 2,
                                color: '#F4A261',
                                type: 'dashed'
                            },
                            itemStyle: {
                                color: '#F4A261',
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(244, 162, 97, 0.5)'
                                }
                            }
                        },
                        {
                            name: '最大遗漏',
                            type: 'line',
                            data: maxOmissions,
                            smooth: true,
                            symbol: 'diamond',
                            symbolSize: 8,
                            lineStyle: {
                                width: 2,
                                color: '#2A9D8F'
                            },
                            itemStyle: {
                                color: '#2A9D8F',
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(42, 157, 143, 0.5)'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generatePrimeCompositeStrategy(primeCompositeData, draws) {
                const strategyContent = document.getElementById('primeCompositeStrategyContent');
                if (!strategyContent) {
                    console.warn('primeCompositeStrategyContent 容器不存在');
                    return;
                }

                const total = primeCompositeData.primeCount + primeCompositeData.compositeCount;
                const primeRatio = (primeCompositeData.primeCount / total * 100).toFixed(1);
                const compositeRatio = (primeCompositeData.compositeCount / total * 100).toFixed(1);

                const hotNumbers = primeCompositeData.hotNumbers;
                const warmNumbers = primeCompositeData.warmNumbers;
                const coldNumbers = primeCompositeData.coldNumbers;

                const recentTrend = primeCompositeData.trend.slice(0, 5);
                const recentPrimeAvg = recentTrend.reduce((sum, item) => sum + item.prime, 0) / recentTrend.length;
                const recentCompositeAvg = recentTrend.reduce((sum, item) => sum + item.composite, 0) / recentTrend.length;

                const primeTrend = recentTrend[recentTrend.length - 1].prime > recentTrend[0].prime ? 'up' : 'down';
                const compositeTrend = recentTrend[recentTrend.length - 1].composite > recentTrend[0].composite ? 'up' : 'down';

                const primeDiff = (parseFloat(primeRatio) - 33.3).toFixed(1);
                const compositeDiff = (parseFloat(compositeRatio) - 66.7).toFixed(1);

                const confidenceLevel = this.calculateConfidenceLevel(primeCompositeData, recentTrend);

                const tripleDimensionRecommendations = this.generateTripleDimensionRecommendations(primeCompositeData, draws.length);
                const warmingCombinations = this.generateWarmingCombinations(primeCompositeData);
                const lowFrequencyCombinations = this.generateLowFrequencyCombinations(primeCompositeData);
                const advancedStrategies = this.generateAdvancedStrategies(primeCompositeData, draws);
                const positionRecommendations = this.generatePositionRecommendations(primeCompositeData);
                const cycleStrategies = this.generateCycleStrategies(primeCompositeData);

                const strategyHTML = `
                    <div class="strategy-section strategy-overview">
                        <div class="strategy-header">
                            <h4>📊 质合分布分析</h4>
                            <div class="confidence-badge confidence-${confidenceLevel.level}">
                                <i class="fas fa-shield-alt"></i>
                                <span>可信度: ${confidenceLevel.levelText}</span>
                            </div>
                        </div>

                        <div class="ratio-comparison">
                            <div class="ratio-item">
                                <div class="ratio-label">
                                    <span>质数占比</span>
                                    <span class="ratio-value">${primeRatio}%</span>
                                </div>
                                <div class="ratio-bar-container">
                                    <div class="ratio-bar ratio-prime" style="width: ${primeRatio}%;"></div>
                                    <div class="ratio-theoretical" style="left: 33.3%;"></div>
                                </div>
                                <div class="ratio-diff ${parseFloat(primeDiff) >= 0 ? 'positive' : 'negative'}">
                                    ${parseFloat(primeDiff) >= 0 ? '↑' : '↓'} ${Math.abs(primeDiff)}% (理论: 33.3%)
                                </div>
                            </div>

                            <div class="ratio-item">
                                <div class="ratio-label">
                                    <span>合数占比</span>
                                    <span class="ratio-value">${compositeRatio}%</span>
                                </div>
                                <div class="ratio-bar-container">
                                    <div class="ratio-bar ratio-composite" style="width: ${compositeRatio}%;"></div>
                                    <div class="ratio-theoretical" style="left: 66.7%;"></div>
                                </div>
                                <div class="ratio-diff ${parseFloat(compositeDiff) >= 0 ? 'positive' : 'negative'}">
                                    ${parseFloat(compositeDiff) >= 0 ? '↑' : '↓'} ${Math.abs(compositeDiff)}% (理论: 66.7%)
                                </div>
                            </div>
                        </div>

                        <div class="trend-indicators">
                            <div class="trend-item">
                                <span class="trend-label">最近5期平均质数</span>
                                <span class="trend-value trend-${primeTrend}">
                                    ${recentPrimeAvg.toFixed(1)}
                                    <i class="fas fa-arrow-${primeTrend}"></i>
                                </span>
                            </div>
                            <div class="trend-item">
                                <span class="trend-label">最近5期平均合数</span>
                                <span class="trend-value trend-${compositeTrend}">
                                    ${recentCompositeAvg.toFixed(1)}
                                    <i class="fas fa-arrow-${compositeTrend}"></i>
                                </span>
                            </div>
                        </div>

                        <div class="prediction-section">
                            <h5>🎯 智能预测</h5>
                            <div class="prediction-grid">
                                <div class="prediction-card">
                                    <span class="prediction-label">预测质数数量</span>
                                    <span class="prediction-value">${primeCompositeData.primeRatioPrediction.predictedRatio}个</span>
                                    <span class="prediction-confidence">置信度: ${primeCompositeData.primeRatioPrediction.confidenceText}</span>
                                </div>
                                <div class="prediction-card">
                                    <span class="prediction-label">趋势方向</span>
                                    <span class="prediction-value ${primeCompositeData.primeRatioPrediction.trendDirection === 'up' ? 'trend-up' : primeCompositeData.primeRatioPrediction.trendDirection === 'down' ? 'trend-down' : 'trend-stable'}">
                                        ${primeCompositeData.primeRatioPrediction.trendDirection === 'up' ? '上升 ↗' : primeCompositeData.primeRatioPrediction.trendDirection === 'down' ? '下降 ↘' : '稳定 →'}
                                    </span>
                                    <span class="prediction-reason">${primeCompositeData.primeRatioPrediction.reason}</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="strategy-section strategy-advanced">
                        <h4>🚀 高级策略推荐</h4>

                        <div class="advanced-strategies-grid">
                            ${advancedStrategies.map((strategy, index) => `
                                <div class="advanced-strategy-card ${strategy.priority}">
                                    <div class="strategy-icon">${strategy.icon}</div>
                                    <div class="strategy-content">
                                        <div class="strategy-title">${strategy.title}</div>
                                        <div class="strategy-description">${strategy.description}</div>
                                        <div class="strategy-details">
                                            <span class="strategy-score">评分: ${strategy.score}/100</span>
                                            <span class="strategy-risk">风险: ${strategy.risk}</span>
                                        </div>
                                        <div class="strategy-recommendation">
                                            <strong>推荐:</strong> ${strategy.recommendation}
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="strategy-section strategy-position">
                        <h4>📍 位置偏好策略</h4>

                        <div class="position-grid">
                            ${positionRecommendations.map((pos, index) => `
                                <div class="position-card ${pos.preference}">
                                    <div class="position-number">第${pos.position}位</div>
                                    <div class="position-stats">
                                        <div class="position-stat">
                                            <span class="stat-label">质数</span>
                                            <span class="stat-value prime">${pos.primeRatio}%</span>
                                        </div>
                                        <div class="position-stat">
                                            <span class="stat-label">合数</span>
                                            <span class="stat-value composite">${pos.compositeRatio}%</span>
                                        </div>
                                    </div>
                                    <div class="position-preference">
                                        ${pos.preference === 'prime' ? '🔴 偏好质数' : pos.preference === 'composite' ? '🔵 偏好合数' : '⚪ 均衡'}
                                    </div>
                                    <div class="position-recommendation">
                                        ${pos.preference === 'prime' ? '建议优先选择质数号码' : pos.preference === 'composite' ? '建议优先选择合数号码' : '质数合数均可选择'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="strategy-section strategy-cycle">
                        <h4>🔄 周期性策略</h4>

                        <div class="cycle-info">
                            <div class="cycle-stat">
                                <span class="cycle-label">当前周期</span>
                                <span class="cycle-value ${primeCompositeData.cycleData.currentCycle?.direction}">
                                    ${primeCompositeData.cycleData.currentCycle?.direction === 'up' ? '上升周期' : primeCompositeData.cycleData.currentCycle?.direction === 'down' ? '下降周期' : '稳定周期'}
                                </span>
                            </div>
                            <div class="cycle-stat">
                                <span class="cycle-label">平均周期长度</span>
                                <span class="cycle-value">${primeCompositeData.cycleData.avgCycleLength.toFixed(1)}期</span>
                            </div>
                            <div class="cycle-stat">
                                <span class="cycle-label">上升周期</span>
                                <span class="cycle-value">${primeCompositeData.cycleData.upCycles}次</span>
                            </div>
                            <div class="cycle-stat">
                                <span class="cycle-label">下降周期</span>
                                <span class="cycle-value">${primeCompositeData.cycleData.downCycles}次</span>
                            </div>
                        </div>

                        <div class="cycle-strategies-grid">
                            ${cycleStrategies.map((strategy, index) => `
                                <div class="cycle-strategy-card">
                                    <div class="cycle-strategy-icon">${strategy.icon}</div>
                                    <div class="cycle-strategy-content">
                                        <div class="cycle-strategy-title">${strategy.title}</div>
                                        <div class="cycle-strategy-desc">${strategy.description}</div>
                                        <div class="cycle-strategy-action">${strategy.action}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="strategy-section strategy-triple-dimension">
                        <h4>🎯 三重维度综合推荐</h4>

                        <div class="triple-dimension-grid">
                            ${tripleDimensionRecommendations.map((rec, index) => `
                                <div class="triple-dimension-card ${index === 0 ? 'primary' : ''}">
                                    <div class="rec-rank">${index + 1}</div>
                                    <div class="rec-content">
                                        <div class="rec-title">
                                            <span class="rec-combo">${rec.primeComposite}</span>
                                            <span class="rec-separator">+</span>
                                            <span class="rec-zone">${rec.threeZone}</span>
                                            <span class="rec-separator">+</span>
                                            <span class="rec-ac">AC${rec.acValue}</span>
                                        </div>
                                        <div class="rec-stats">
                                            <div class="rec-stat">
                                                <span class="stat-label">出现频次</span>
                                                <span class="stat-value">${rec.frequency}次</span>
                                            </div>
                                            <div class="rec-stat">
                                                <span class="stat-label">占比</span>
                                                <span class="stat-value">${rec.percentage}%</span>
                                            </div>
                                            <div class="rec-stat">
                                                <span class="stat-label">置信度</span>
                                                <span class="stat-value confidence-${rec.confidence}">${rec.confidenceText}</span>
                                            </div>
                                        </div>
                                        <div class="rec-reason">
                                            <i class="fas fa-lightbulb"></i>
                                            <span>${rec.reason}</span>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="strategy-section strategy-warming">
                        <h4>🔥 回暖组合推荐</h4>

                        <div class="warming-grid">
                            ${warmingCombinations.map((rec, index) => `
                                <div class="warming-card ${rec.strength}">
                                    <div class="warming-header">
                                        <div class="warming-rank">#${index + 1}</div>
                                        <div class="warming-strength strength-${rec.strength}">
                                            ${rec.strength === 'strong' ? '🔥 强势' : rec.strength === 'medium' ? '⚡ 中等' : '💫 弱势'}
                                        </div>
                                        <div class="warming-score">${rec.strengthScore}分</div>
                                    </div>
                                    <div class="warming-icon">📈</div>
                                    <div class="warming-content">
                                        <div class="warming-combo">${rec.combo}</div>
                                        <div class="warming-stats">
                                            <div class="warming-stat">
                                                <span class="stat-label">近期出现</span>
                                                <span class="stat-value">${rec.recentCount}次</span>
                                            </div>
                                            <div class="warming-stat">
                                                <span class="stat-label">历史平均</span>
                                                <span class="stat-value">${rec.avgFrequency.toFixed(1)}次/期</span>
                                            </div>
                                            <div class="warming-stat">
                                                <span class="stat-label">近期增长</span>
                                                <span class="stat-value ${parseFloat(rec.recentGrowthRate) > 0 ? 'positive' : 'negative'}">
                                                    ${parseFloat(rec.recentGrowthRate) > 0 ? '+' : ''}${rec.recentGrowthRate}%
                                                </span>
                                            </div>
                                        </div>
                                        <div class="warming-details">
                                            <div class="warming-detail">
                                                <span class="detail-label">连续出现</span>
                                                <span class="detail-value">${rec.consecutiveAppearances}次</span>
                                            </div>
                                            <div class="warming-detail">
                                                <span class="detail-label">距上次</span>
                                                <span class="detail-value">${rec.periodsSinceLastAppearance}期</span>
                                            </div>
                                            <div class="warming-detail">
                                                <span class="detail-label">历史占比</span>
                                                <span class="detail-value">${rec.percentage}%</span>
                                            </div>
                                        </div>
                                        <div class="warming-reason">${rec.reason}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="strategy-section strategy-numbers">
                        <h4>🔥 号码状态分析</h4>

                        <div class="number-status-summary">
                            <div class="status-summary-card hot-summary">
                                <div class="summary-icon">🔥</div>
                                <div class="summary-content">
                                    <div class="summary-title">热号</div>
                                    <div class="summary-count">${hotNumbers.length}个</div>
                                    <div class="summary-desc">遗漏低于平均值的80%</div>
                                </div>
                            </div>
                            <div class="status-summary-card warm-summary">
                                <div class="summary-icon">⚡</div>
                                <div class="summary-content">
                                    <div class="summary-title">温号</div>
                                    <div class="summary-count">${warmNumbers.length}个</div>
                                    <div class="summary-desc">遗漏在平均值的80%-150%之间</div>
                                </div>
                            </div>
                            <div class="status-summary-card cold-summary">
                                <div class="summary-icon">❄️</div>
                                <div class="summary-content">
                                    <div class="summary-title">冷号</div>
                                    <div class="summary-count">${coldNumbers.length}个</div>
                                    <div class="summary-desc">遗漏高于平均值的150%</div>
                                </div>
                            </div>
                        </div>

                        <div class="number-category hot-category">
                            <div class="category-header">
                                <span class="category-icon">🔥</span>
                                <span class="category-title">热号 (${hotNumbers.length}个)</span>
                                <span class="category-desc">遗漏低于平均值</span>
                            </div>
                            <div class="number-grid">
                                ${hotNumbers.map(num => `
                                    <div class="number-card hot-card enhanced" title="当前遗漏: ${num.currentOmission}, 平均遗漏: ${num.avgOmission.toFixed(1)}, 频率: ${num.frequency}次">
                                        <div class="number-type-badge ${num.type === 'prime' ? 'prime' : 'composite'}">${num.type === 'prime' ? '质' : '合'}</div>
                                        <span class="number-badge">${num.number}</span>
                                        <div class="number-stats">
                                            <span class="number-omission">${num.currentOmission}</span>
                                            <span class="number-frequency">${num.frequency}次</span>
                                        </div>
                                        <div class="number-prediction">
                                            ${this.generateNumberPrediction(num, primeCompositeData.statusTransitionProb)}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <div class="number-category warm-category">
                            <div class="category-header">
                                <span class="category-icon">⚡</span>
                                <span class="category-title">温号 (${warmNumbers.length}个)</span>
                                <span class="category-desc">遗漏在平均值附近</span>
                            </div>
                            <div class="number-grid">
                                ${warmNumbers.map(num => `
                                    <div class="number-card warm-card enhanced" title="当前遗漏: ${num.currentOmission}, 平均遗漏: ${num.avgOmission.toFixed(1)}, 频率: ${num.frequency}次">
                                        <div class="number-type-badge ${num.type === 'prime' ? 'prime' : 'composite'}">${num.type === 'prime' ? '质' : '合'}</div>
                                        <span class="number-badge">${num.number}</span>
                                        <div class="number-stats">
                                            <span class="number-omission">${num.currentOmission}</span>
                                            <span class="number-frequency">${num.frequency}次</span>
                                        </div>
                                        <div class="number-prediction">
                                            ${this.generateNumberPrediction(num, primeCompositeData.statusTransitionProb)}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <div class="number-category cold-category">
                            <div class="category-header">
                                <span class="category-icon">❄️</span>
                                <span class="category-title">冷号 (${coldNumbers.length}个)</span>
                                <span class="category-desc">遗漏远高于平均值</span>
                            </div>
                            <div class="number-grid">
                                ${coldNumbers.map(num => `
                                    <div class="number-card cold-card enhanced" title="当前遗漏: ${num.currentOmission}, 平均遗漏: ${num.avgOmission.toFixed(1)}, 频率: ${num.frequency}次">
                                        <div class="number-type-badge ${num.type === 'prime' ? 'prime' : 'composite'}">${num.type === 'prime' ? '质' : '合'}</div>
                                        <span class="number-badge">${num.number}</span>
                                        <div class="number-stats">
                                            <span class="number-omission">${num.currentOmission}</span>
                                            <span class="number-frequency">${num.frequency}次</span>
                                        </div>
                                        <div class="number-prediction">
                                            ${this.generateNumberPrediction(num, primeCompositeData.statusTransitionProb)}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="strategy-section strategy-recommendations">
                        <h4>💡 选号策略建议</h4>

                        <div class="recommendation-grid">
                            <div class="recommendation-card prime-rec">
                                <div class="rec-header">
                                    <i class="fas fa-calculator"></i>
                                    <span>质数数量建议</span>
                                </div>
                                <div class="rec-value">
                                    ${Math.round(recentPrimeAvg) - 1} ~ ${Math.round(recentPrimeAvg) + 1}
                                </div>
                                <div class="rec-desc">基于最近5期平均质数数量</div>
                            </div>

                            <div class="recommendation-card composite-rec">
                                <div class="rec-header">
                                    <i class="fas fa-calculator"></i>
                                    <span>合数数量建议</span>
                                </div>
                                <div class="rec-value">
                                    ${Math.round(recentCompositeAvg) - 1} ~ ${Math.round(recentCompositeAvg) + 1}
                                </div>
                                <div class="rec-desc">基于最近5期平均合数数量</div>
                            </div>
                        </div>

                        <div class="number-priorities">
                            <div class="priority-section high-priority">
                                <div class="priority-header">
                                    <span class="priority-icon">⭐</span>
                                    <span class="priority-title">重点关注</span>
                                </div>
                                <div class="priority-numbers">
                                    ${hotNumbers.slice(0, 5).map(num => `
                                        <span class="priority-number high">${num.number}</span>
                                    `).join('')}
                                </div>
                                <div class="priority-note">热号前5位，遗漏值最低</div>
                            </div>

                            <div class="priority-section medium-priority">
                                <div class="priority-header">
                                    <span class="priority-icon">👍</span>
                                    <span class="priority-title">适当考虑</span>
                                </div>
                                <div class="priority-numbers">
                                    ${warmNumbers.slice(0, 5).map(num => `
                                        <span class="priority-number medium">${num.number}</span>
                                    `).join('')}
                                </div>
                                <div class="priority-note">温号前5位，遗漏值适中</div>
                            </div>

                            <div class="priority-section low-priority">
                                <div class="priority-header">
                                    <span class="priority-icon">⚠️</span>
                                    <span class="priority-title">谨慎选择</span>
                                </div>
                                <div class="priority-numbers">
                                    ${coldNumbers.slice(0, 5).map(num => `
                                        <span class="priority-number low">${num.number}</span>
                                    `).join('')}
                                </div>
                                <div class="priority-note">冷号前5位，遗漏值较高</div>
                            </div>
                        </div>
                    </div>

                    <div class="strategy-section strategy-low-frequency">
                        <h4>⚠️ 低频组合提醒</h4>

                        <div class="low-frequency-grid">
                            ${lowFrequencyCombinations.map((rec, index) => `
                                <div class="low-frequency-card">
                                    <div class="low-frequency-icon">📉</div>
                                    <div class="low-frequency-content">
                                        <div class="low-frequency-combo">${rec.combo}</div>
                                        <div class="low-frequency-stats">
                                            <span>出现频次: ${rec.frequency}次</span>
                                            <span>占比: ${rec.percentage}%</span>
                                        </div>
                                        <div class="low-frequency-reason">${rec.reason}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="strategy-section strategy-tips">
                        <h4>⚠️ 关键提醒</h4>

                        <div class="tips-grid">
                            <div class="tip-card">
                                <div class="tip-icon">📋</div>
                                <div class="tip-content">
                                    <h5>质数号码</h5>
                                    <p>共11个: 02, 03, 05, 07, 11, 13, 17, 19, 23, 29, 31</p>
                                    <span class="tip-badge">理论占比: 33.3%</span>
                                </div>
                            </div>

                            <div class="tip-card">
                                <div class="tip-icon">📋</div>
                                <div class="tip-content">
                                    <h5>合数号码</h5>
                                    <p>共22个: 01, 04, 06, 08, 09, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33</p>
                                    <span class="tip-badge">理论占比: 66.7%</span>
                                </div>
                            </div>

                            <div class="tip-card ${parseFloat(primeRatio) > 33.3 ? 'tip-warning' : 'tip-info'}">
                                <div class="tip-icon">${parseFloat(primeRatio) > 33.3 ? '⚠️' : 'ℹ️'}</div>
                                <div class="tip-content">
                                    <h5>当前质数占比</h5>
                                    <p>当前质数占比${parseFloat(primeRatio) > 33.3 ? '高于' : '低于'}理论值 ${Math.abs(primeDiff)}%</p>
                                    <span class="tip-badge">${parseFloat(primeRatio) > 33.3 ? '偏高' : '偏低'}</span>
                                </div>
                            </div>

                            <div class="tip-card tip-advice">
                                <div class="tip-icon">💡</div>
                                <div class="tip-content">
                                    <h5>选号建议</h5>
                                    <p>建议根据历史数据和近期趋势合理搭配质合比例</p>
                                    <span class="tip-badge">综合分析</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                strategyContent.innerHTML = strategyHTML;
            }

            static generateTripleDimensionRecommendations(primeCompositeData, totalPeriods) {
                const recommendations = [];
                const linkedData = primeCompositeData.linkedData || [];
                const combinationFrequency = primeCompositeData.primeCompositeCombinationFrequency || {};
                const acValueCorrelation = primeCompositeData.primeCompositeAcValueCorrelation || {};
                const threeZoneCorrelation = primeCompositeData.primeCompositeThreeZoneCorrelation || {};

                const linkedHeatmapData = [];
                linkedData.forEach(item => {
                    const existing = linkedHeatmapData.find(d => 
                        d.primeCombo === item.primeCompositeCombination && 
                        d.zoneCombo === item.threeZoneCombination
                    );
                    if (existing) {
                        existing.count++;
                        existing.acValues.push(item.acValue);
                    } else {
                        linkedHeatmapData.push({
                            primeCombo: item.primeCompositeCombination,
                            zoneCombo: item.threeZoneCombination,
                            count: 1,
                            acValues: [item.acValue]
                        });
                    }
                });

                linkedHeatmapData.sort((a, b) => b.count - a.count);

                linkedHeatmapData.slice(0, 5).forEach(item => {
                    const [prime, composite] = item.primeCombo.split(':').map(Number);
                    const avgAC = (item.acValues.reduce((sum, ac) => sum + ac, 0) / item.acValues.length).toFixed(1);
                    const percentage = ((item.count / totalPeriods) * 100).toFixed(1);

                    const comboKey = item.primeCombo;
                    const acStat = acValueCorrelation[comboKey] || {};
                    const zoneStat = threeZoneCorrelation[comboKey] || {};

                    const topAC = Object.entries(acStat).sort((a, b) => b[1] - a[1])[0];
                    const topZone = Object.entries(zoneStat).sort((a, b) => b[1] - a[1])[0];

                    const confidence = item.count > totalPeriods * 0.2 ? 'high' : item.count > totalPeriods * 0.1 ? 'medium' : 'low';
                    const confidenceText = confidence === 'high' ? '高' : confidence === 'medium' ? '中' : '低';

                    const reason = `该组合出现${item.count}次（占比${percentage}%），为综合高频组合。${topAC ? `常对应AC值${topAC[0]}。` : ''}${topZone ? `常对应三区${topZone[0]}组合。` : ''}`;

                    recommendations.push({
                        primeComposite: `${prime}质${composite}合`,
                        threeZone: item.zoneCombo,
                        acValue: avgAC,
                        frequency: item.count,
                        percentage: percentage,
                        confidence: confidence,
                        confidenceText: confidenceText,
                        reason: reason
                    });
                });

                return recommendations;
            }

            static generateWarmingCombinations(primeCompositeData) {
                const warmingCombinations = [];
                const combinationFrequency = primeCompositeData.primeCompositeCombinationFrequency || {};
                const trend = primeCompositeData.trend || [];
                const totalPeriods = trend.length;

                const recentPeriods = trend.slice(-10);
                const recentCombinationFrequency = {};

                recentPeriods.forEach(item => {
                    const comboKey = `${item.prime}:${item.composite}`;
                    recentCombinationFrequency[comboKey] = (recentCombinationFrequency[comboKey] || 0) + 1;
                });

                const last20Periods = trend.slice(-20);
                const last20CombinationFrequency = {};

                last20Periods.forEach(item => {
                    const comboKey = `${item.prime}:${item.composite}`;
                    last20CombinationFrequency[comboKey] = (last20CombinationFrequency[comboKey] || 0) + 1;
                });

                Object.entries(combinationFrequency).forEach(([comboKey, totalFreq]) => {
                    const avgFrequency = totalFreq / totalPeriods;
                    const recentFreq = recentCombinationFrequency[comboKey] || 0;
                    const last20Freq = last20CombinationFrequency[comboKey] || 0;

                    const recentGrowthRate = last20Freq > 0 ? ((recentFreq - last20Freq) / last20Freq * 100) : 0;
                    const avgGrowthRate = avgFrequency > 0 ? ((recentFreq - avgFrequency) / avgFrequency * 100) : 0;

                    const consecutiveAppearances = this.calculateConsecutiveAppearances(trend, comboKey);
                    const lastAppearanceIndex = trend.map(item => `${item.prime}:${item.composite}`).lastIndexOf(comboKey);
                    const periodsSinceLastAppearance = lastAppearanceIndex >= 0 ? trend.length - 1 - lastAppearanceIndex : trend.length;

                    let strength = 'weak';
                    let strengthScore = 0;

                    if (recentFreq > avgFrequency * 2 && consecutiveAppearances >= 2) {
                        strength = 'strong';
                        strengthScore = 85 + Math.min(15, recentGrowthRate / 2);
                    } else if (recentFreq > avgFrequency * 1.5 && consecutiveAppearances >= 1) {
                        strength = 'medium';
                        strengthScore = 70 + Math.min(10, recentGrowthRate / 3);
                    } else if (recentFreq > avgFrequency * 1.2) {
                        strength = 'weak';
                        strengthScore = 55 + Math.min(5, recentGrowthRate / 5);
                    }

                    if (recentFreq > avgFrequency * 1.2 && totalFreq < totalPeriods * 0.15) {
                        const [prime, composite] = comboKey.split(':').map(Number);
                        const percentage = ((totalFreq / totalPeriods) * 100).toFixed(1);

                        let reason = `该组合近期出现${recentFreq}次，高于历史平均值${avgFrequency.toFixed(1)}次/期`;
                        if (recentGrowthRate > 30) {
                            reason += `，近期增长率${recentGrowthRate.toFixed(0)}%`;
                        }
                        if (consecutiveAppearances >= 2) {
                            reason += `，连续出现${consecutiveAppearances}次`;
                        }
                        if (periodsSinceLastAppearance <= 3) {
                            reason += `，最近${periodsSinceLastAppearance}期刚出现过`;
                        }
                        reason += '，呈回暖趋势。';

                        warmingCombinations.push({
                            combo: `${prime}质${composite}合`,
                            recentCount: recentFreq,
                            last20Count: last20Freq,
                            avgFrequency: avgFrequency,
                            frequency: totalFreq,
                            percentage: percentage,
                            recentGrowthRate: recentGrowthRate.toFixed(1),
                            avgGrowthRate: avgGrowthRate.toFixed(1),
                            consecutiveAppearances: consecutiveAppearances,
                            periodsSinceLastAppearance: periodsSinceLastAppearance,
                            strength: strength,
                            strengthScore: Math.min(100, Math.round(strengthScore)),
                            reason: reason
                        });
                    }
                });

                warmingCombinations.sort((a, b) => {
                    if (b.strengthScore !== a.strengthScore) {
                        return b.strengthScore - a.strengthScore;
                    }
                    return b.recentCount - a.recentCount;
                });

                return warmingCombinations.slice(0, 5);
            }

            static calculateConsecutiveAppearances(trend, comboKey) {
                let maxConsecutive = 0;
                let currentConsecutive = 0;

                for (let i = trend.length - 1; i >= 0; i--) {
                    const currentCombo = `${trend[i].prime}:${trend[i].composite}`;
                    if (currentCombo === comboKey) {
                        currentConsecutive++;
                        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                    } else {
                        if (currentConsecutive > 0) {
                            break;
                        }
                    }
                }

                return maxConsecutive;
            }

            static generateNumberPrediction(num, statusTransitionProb) {
                const numStr = num.number;
                const transitions = statusTransitionProb[numStr];

                if (!transitions) {
                    return '<span class="prediction-unknown">数据不足</span>';
                }

                const hotProb = parseFloat(transitions.hot?.hot || 0) + parseFloat(transitions.hot?.just_appeared || 0);
                const warmProb = parseFloat(transitions.warm?.hot || 0) + parseFloat(transitions.warm?.just_appeared || 0);
                const coldProb = parseFloat(transitions.cold?.hot || 0) + parseFloat(transitions.cold?.just_appeared || 0);
                const justAppearedProb = parseFloat(transitions.just_appeared?.hot || 0);

                const totalProb = hotProb + warmProb + coldProb + justAppearedProb;

                if (totalProb === 0) {
                    return '<span class="prediction-unknown">数据不足</span>';
                }

                const hotProbPercent = ((hotProb / totalProb) * 100).toFixed(0);
                const warmProbPercent = ((warmProb / totalProb) * 100).toFixed(0);
                const coldProbPercent = ((coldProb / totalProb) * 100).toFixed(0);

                let prediction = '';
                let predictionClass = '';

                if (parseFloat(hotProbPercent) > 40) {
                    prediction = '🔥 高概率';
                    predictionClass = 'prediction-high';
                } else if (parseFloat(warmProbPercent) > 30) {
                    prediction = '⚡ 中概率';
                    predictionClass = 'prediction-medium';
                } else if (parseFloat(coldProbPercent) > 20) {
                    prediction = '❄️ 低概率';
                    predictionClass = 'prediction-low';
                } else {
                    prediction = '➡️ 稳定';
                    predictionClass = 'prediction-stable';
                }

                return `<span class="prediction-badge ${predictionClass}" title="热:${hotProbPercent}% 温:${warmProbPercent}% 冷:${coldProbPercent}%">${prediction}</span>`;
            }

            static generateLowFrequencyCombinations(primeCompositeData) {
                const lowFrequencyCombinations = [];
                const combinationFrequency = primeCompositeData.primeCompositeCombinationFrequency || {};
                const acValueCorrelation = primeCompositeData.primeCompositeAcValueCorrelation || {};
                const threeZoneCorrelation = primeCompositeData.primeCompositeThreeZoneCorrelation || {};
                const linkedData = primeCompositeData.linkedData || [];
                const totalPeriods = linkedData.length;

                Object.entries(combinationFrequency).forEach(([comboKey, freq]) => {
                    const percentage = ((freq / totalPeriods) * 100).toFixed(1);

                    if (freq < totalPeriods * 0.05) {
                        const acStat = acValueCorrelation[comboKey] || {};
                        const zoneStat = threeZoneCorrelation[comboKey] || {};

                        const topAC = Object.entries(acStat).sort((a, b) => b[1] - a[1])[0];
                        const topZone = Object.entries(zoneStat).sort((a, b) => b[1] - a[1])[0];

                        const hasLinkage = topAC && topZone && topAC[1] > 0 && topZone[1] > 0;

                        const [prime, composite] = comboKey.split(':').map(Number);

                        lowFrequencyCombinations.push({
                            combo: `${prime}质${composite}合`,
                            frequency: freq,
                            percentage: percentage,
                            reason: hasLinkage 
                                ? `该组合出现频次较低，但与AC值${topAC[0]}和三区${topZone[0]}有一定关联，可适当关注。`
                                : `该组合出现频次较低，且无明显的联动优势，建议谨慎选择。`
                        });
                    }
                });

                lowFrequencyCombinations.sort((a, b) => a.frequency - b.frequency);

                return lowFrequencyCombinations.slice(0, 3);
            }

            static calculateConfidenceLevel(primeCompositeData, recentTrend) {
                const variance = recentTrend.reduce((sum, item) => {
                    const avg = recentTrend.reduce((s, i) => s + i.prime, 0) / recentTrend.length;
                    return sum + Math.pow(item.prime - avg, 2);
                }, 0) / recentTrend.length;

                if (variance < 0.5) {
                    return { level: 'high', levelText: '高' };
                } else if (variance < 1.0) {
                    return { level: 'medium', levelText: '中' };
                } else {
                    return { level: 'low', levelText: '低' };
                }
            }

            static handleAcValueAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    this.performAcValueAnalysis(draws);

                    MessageSystem.showMessage(`已完成${draws.length}期数据的AC值分析`, 'success');
                });
            }

            static performAcValueAnalysis(draws) {
                const periodSelect = document.getElementById('acValuePeriodSelect');
                const periodValue = periodSelect ? periodSelect.value : '50';
                const analysisPeriod = periodValue === 'all' ? draws.length : parseInt(periodValue);

                const reversedDraws = [...draws].reverse().slice(0, analysisPeriod);

                // 更新分析范围显示
                const acValueDataRangeInfo = document.getElementById('acValueDataRangeInfo');
                if (acValueDataRangeInfo && reversedDraws.length > 0) {
                    const startPeriod = reversedDraws[reversedDraws.length - 1].period;
                    const endPeriod = reversedDraws[0].period;
                    acValueDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${reversedDraws.length}期）`;
                }

                const phase1Data = this.performAcValuePhase1Analysis(reversedDraws);

                const acValueData = {
                    values: [],
                    trend: [],
                    statistics: {},
                    periods: []
                };

                reversedDraws.forEach(draw => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    const acValue = this.calculateACValue(redBalls);

                    acValueData.values.push(acValue);
                    acValueData.trend.push({
                        period: draw.period,
                        acValue: acValue
                    });
                    acValueData.periods.push(draw.period);
                });

                acValueData.statistics = this.calculateAcValueStatistics(acValueData, phase1Data);

                acValueChartData = acValueData;
                acValueAnalysisResults = acValueData.statistics;

                this.updateAcValueChart(acValueData, phase1Data);
                this.generateAcValueConclusion(acValueData, phase1Data);

                MessageSystem.showMessage(`已完成${reversedDraws.length}期数据的AC值分析`, 'success');
            }

            static performAcValuePhase1Analysis(draws) {
                console.log('=== 开始执行AC值分析阶段1（逐期关联分析） ===');
                console.log('数据期数:', draws.length);

                const phase1Data = {
                    consecutivePatterns: [],
                    acValueTransitions: {},
                    acValueChangePatterns: [],
                    sameAcValueStreaks: [],
                    acValueOscillation: [],
                    acValueIntervalTransitions: {}
                };

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    const currentRedBalls = currentDraw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    const nextRedBalls = nextDraw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    const currentAcValue = this.calculateACValue(currentRedBalls);
                    const nextAcValue = this.calculateACValue(nextRedBalls);

                    const transitionKey = `${currentAcValue}->${nextAcValue}`;
                    if (!phase1Data.acValueTransitions[transitionKey]) {
                        phase1Data.acValueTransitions[transitionKey] = 0;
                    }
                    phase1Data.acValueTransitions[transitionKey]++;

                    phase1Data.consecutivePatterns.push({
                        period: currentDraw.period,
                        currentAcValue: currentAcValue,
                        nextAcValue: nextAcValue,
                        acValueChange: nextAcValue - currentAcValue
                    });

                    if (currentAcValue === nextAcValue) {
                        let streak = 1;
                        for (let j = i - 1; j >= 0; j--) {
                            const prevDraw = draws[j];
                            const prevRedBalls = prevDraw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                            const prevAcValue = this.calculateACValue(prevRedBalls);
                            if (prevAcValue === currentAcValue) {
                                streak++;
                            } else {
                                break;
                            }
                        }
                        phase1Data.sameAcValueStreaks.push({
                            period: currentDraw.period,
                            acValue: currentAcValue,
                            streak: streak
                        });
                    }

                    phase1Data.acValueOscillation.push({
                        period: currentDraw.period,
                        currentAcValue: currentAcValue,
                        nextAcValue: nextAcValue,
                        oscillation: Math.abs(nextAcValue - currentAcValue)
                    });

                    const currentInterval = this.getAcValueInterval(currentAcValue);
                    const nextInterval = this.getAcValueInterval(nextAcValue);

                    const intervalTransitionKey = `${currentInterval}->${nextInterval}`;
                    if (!phase1Data.acValueIntervalTransitions[intervalTransitionKey]) {
                        phase1Data.acValueIntervalTransitions[intervalTransitionKey] = 0;
                    }
                    phase1Data.acValueIntervalTransitions[intervalTransitionKey]++;
                }

                phase1Data.acValueChangePatterns = phase1Data.consecutivePatterns.map(pattern => ({
                    period: pattern.period,
                    changeType: pattern.acValueChange > 0 ? 'increase' : pattern.acValueChange < 0 ? 'decrease' : 'stable',
                    acValueChange: pattern.acValueChange
                }));

                console.log('AC值分析阶段1完成');
                console.log('连续模式数:', phase1Data.consecutivePatterns.length);
                console.log('AC值转换类型数:', Object.keys(phase1Data.acValueTransitions).length);

                return phase1Data;
            }

            static getAcValueInterval(acValue) {
                if (acValue >= 0 && acValue <= 3) {
                    return '0-3';
                } else if (acValue >= 4 && acValue <= 7) {
                    return '4-7';
                } else if (acValue >= 8 && acValue <= 10) {
                    return '8-10';
                }
                return 'other';
            }

            static calculateACValue(numbers) {
                let differences = new Set();
                for (let i = 0; i < numbers.length; i++) {
                    for (let j = i + 1; j < numbers.length; j++) {
                        differences.add(Math.abs(numbers[i] - numbers[j]));
                    }
                }
                return differences.size - (numbers.length - 1);
            }

            static calculateAcValueStatistics(acValueData) {
                const values = acValueData.values;
                const valueCounts = {};

                values.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });

                const sortedValues = Object.keys(valueCounts).sort((a, b) => parseInt(a) - parseInt(b));
                const counts = sortedValues.map(value => valueCounts[value]);
                const total = values.length;

                const hotACValues = sortedValues
                    .map(value => ({ value: parseInt(value), count: valueCounts[value] }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);

                const coldACValues = sortedValues
                    .map(value => ({ value: parseInt(value), count: valueCounts[value] }))
                    .sort((a, b) => a.count - b.count)
                    .slice(0, 3);

                const sum = values.reduce((acc, val) => acc + val, 0);
                const mean = (sum / total).toFixed(2);

                const sortedValuesForMedian = [...values].sort((a, b) => a - b);
                const median = total % 2 === 0 
                    ? ((sortedValuesForMedian[total / 2 - 1] + sortedValuesForMedian[total / 2]) / 2).toFixed(2)
                    : sortedValuesForMedian[Math.floor(total / 2)].toFixed(2);

                const intervalDistribution = {
                    '0-3': values.filter(v => v >= 0 && v <= 3).length,
                    '4-7': values.filter(v => v >= 4 && v <= 7).length,
                    '8-10': values.filter(v => v >= 8 && v <= 10).length
                };

                const trendAnalysis = this.analyzeAcValueTrend(acValueData.trend);

                return {
                    hotACValues,
                    coldACValues,
                    mean,
                    median,
                    intervalDistribution,
                    valueCounts,
                    total,
                    trendAnalysis,
                    mostFrequent: hotACValues[0]
                };
            }

            static analyzeAcValueTrend(trendData) {
                const recentTrend = trendData.slice(-10);
                const recentValues = recentTrend.map(item => item.acValue);
                const avgRecent = recentValues.reduce((a, b) => a + b, 0) / recentValues.length;

                const warmingACValues = [];
                const coolingACValues = [];

                for (let ac = 0; ac <= 10; ac++) {
                    const recentCount = recentValues.filter(v => v === ac).length;
                    const earlierTrend = trendData.slice(-20, -10);
                    const earlierCount = earlierTrend.filter(item => item.acValue === ac).length;

                    if (recentCount > earlierCount && recentCount >= 2) {
                        warmingACValues.push({ value: ac, recentCount, earlierCount });
                    } else if (recentCount < earlierCount && earlierCount >= 2) {
                        coolingACValues.push({ value: ac, recentCount, earlierCount });
                    }
                }

                return {
                    avgRecent: avgRecent.toFixed(2),
                    warmingACValues,
                    coolingACValues
                };
            }

            static updateAcValueChart(acValueData) {
                const chartDom = document.getElementById('acValueChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                switch (currentAcValueChartType) {
                    case 'bar':
                        this.renderAcValueBarChart(chart, acValueData);
                        break;
                    case 'line':
                        this.renderAcValueLineChart(chart, acValueData);
                        break;
                    case 'pie':
                        this.renderAcValuePieChart(chart, acValueData);
                        break;
                    case 'scatter':
                        this.renderAcValueScatterChart(chart, acValueData);
                        break;
                }
            }

            static renderAcValueBarChart(chart, acValueData) {
                const valueCounts = acValueData.statistics.valueCounts;
                const sortedValues = Object.keys(valueCounts).sort((a, b) => parseInt(a) - parseInt(b));
                const counts = sortedValues.map(value => valueCounts[value]);
                const total = acValueData.statistics.total;

                const option = {
                    title: {
                        text: 'AC值频次分布',
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const value = param.name;
                            const count = param.value;
                            const percentage = ((count / total) * 100).toFixed(1);
                            return `AC值: ${value}<br/>出现次数: ${count}<br/>占比: ${percentage}%`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: sortedValues,
                        name: 'AC值',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            fontSize: 12
                        }
                    },
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: counts,
                            itemStyle: {
                                color: function(params) {
                                    const colors = ['#FF7700', '#FF9900', '#FFBB00', '#FFDD00', '#FFFF00', '#DDFF00', '#BBFF00', '#99FF00', '#77FF00', '#55FF00', '#33FF00'];
                                    return colors[params.dataIndex % colors.length];
                                }
                            },
                            label: {
                                show: true,
                                position: 'top',
                                formatter: function(params) {
                                    return params.value;
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static renderAcValueLineChart(chart, acValueData) {
                const trendData = acValueData.trend.slice().reverse();
                const periods = trendData.map(item => item.period);
                const acValues = trendData.map(item => item.acValue);

                const option = {
                    title: {
                        text: `AC值趋势变化（最近${trendData.length}期）`,
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const data = params[0];
                            return `期号: ${data.name}<br/>AC值: ${data.value}`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期号',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            fontSize: 10,
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: 'AC值',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        min: 0,
                        max: 10,
                        axisLabel: {
                            fontSize: 12
                        }
                    },
                    series: [
                        {
                            name: 'AC值',
                            type: 'line',
                            data: acValues,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            itemStyle: {
                                color: '#FF7700'
                            },
                            lineStyle: {
                                width: 2
                            },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0,
                                    y: 0,
                                    x2: 0,
                                    y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(255, 119, 0, 0.3)' },
                                        { offset: 1, color: 'rgba(255, 119, 0, 0.05)' }
                                    ]
                                }
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#FF0000',
                                    type: 'dashed'
                                },
                                label: {
                                    formatter: '平均值: {c}'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static renderAcValuePieChart(chart, acValueData) {
                const valueCounts = acValueData.statistics.valueCounts;
                const total = acValueData.statistics.total;

                const data = Object.keys(valueCounts).sort((a, b) => parseInt(a) - parseInt(b)).map(value => ({
                    value: valueCounts[value],
                    name: `AC值 ${value}`
                }));

                const option = {
                    title: {
                        text: 'AC值占比分布',
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            const percentage = ((params.value / total) * 100).toFixed(1);
                            return `${params.name}<br/>出现次数: ${params.value}<br/>占比: ${percentage}%`;
                        }
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        top: 'middle'
                    },
                    series: [
                        {
                            name: 'AC值',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            label: {
                                show: true,
                                formatter: function(params) {
                                    const percentage = ((params.value / total) * 100).toFixed(1);
                                    return `${params.name}\n${percentage}%`;
                                }
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 16,
                                    fontWeight: 'bold'
                                }
                            },
                            data: data
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static renderAcValueScatterChart(chart, acValueData) {
                const trendData = acValueData.trend;
                const data = trendData.map((item, index) => [index, item.acValue, item.period]);

                const option = {
                    title: {
                        text: `AC值关联分析（最近${trendData.length}期）`,
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            return `期号: ${params.data[2]}<br/>AC值: ${params.data[1]}`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '7%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'value',
                        name: '期数（从最近到最远）',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            formatter: function(value) {
                                return `最近${value + 1}期`;
                            }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: 'AC值',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        min: 0,
                        max: 10
                    },
                    series: [
                        {
                            name: 'AC值',
                            type: 'scatter',
                            data: data,
                            symbolSize: function(data) {
                                return 10;
                            },
                            itemStyle: {
                                color: function(params) {
                                    const colors = ['#FF7700', '#FF9900', '#FFBB00', '#FFDD00', '#FFFF00', '#DDFF00', '#BBFF00', '#99FF00', '#77FF00', '#55FF00', '#33FF00'];
                                    return colors[params.data[1] % colors.length];
                                },
                                opacity: 0.7
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#FF0000',
                                    type: 'dashed'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateAcValueConclusion(acValueData) {
                const stats = acValueData.statistics;
                const phase1Data = acValueData.phase1Data;
                const conclusionContent = document.getElementById('acValueConclusionContent');

                if (!conclusionContent) return;

                let html = '<div style="line-height: 1.8;">';

                html += '<p><strong>📊 基本统计：</strong></p>';
                html += `<ul style="margin-left: 20px;">`;
                html += `<li>分析期数：<strong>${stats.total}</strong> 期</li>`;
                html += `<li>平均AC值：<strong>${stats.mean}</strong></li>`;
                html += `<li>中位数AC值：<strong>${stats.median}</strong></li>`;
                html += `</ul>`;

                html += '<p><strong>🔥 热门AC值（Top3）：</strong></p>';
                html += `<ul style="margin-left: 20px;">`;
                stats.hotACValues.forEach((item, index) => {
                    const percentage = ((item.count / stats.total) * 100).toFixed(1);
                    html += `<li>第${index + 1}名：AC值 <strong>${item.value}</strong>，出现 <strong>${item.count}</strong> 次（占比 ${percentage}%）</li>`;
                });
                html += `</ul>`;

                html += '<p><strong>❄️ 冷门AC值（出现最少）：</strong></p>';
                html += `<ul style="margin-left: 20px;">`;
                stats.coldACValues.forEach((item, index) => {
                    const percentage = ((item.count / stats.total) * 100).toFixed(1);
                    html += `<li>第${index + 1}名：AC值 <strong>${item.value}</strong>，仅出现 <strong>${item.count}</strong> 次（占比 ${percentage}%）</li>`;
                });
                html += `</ul>`;

                html += '<p><strong>📈 区间分布：</strong></p>';
                html += `<ul style="margin-left: 20px;">`;
                html += `<li>AC值 0-3 区间：<strong>${stats.intervalDistribution['0-3']}</strong> 次（占比 ${((stats.intervalDistribution['0-3'] / stats.total) * 100).toFixed(1)}%）</li>`;
                html += `<li>AC值 4-7 区间：<strong>${stats.intervalDistribution['4-7']}</strong> 次（占比 ${((stats.intervalDistribution['4-7'] / stats.total) * 100).toFixed(1)}%）</li>`;
                html += `<li>AC值 8-10 区间：<strong>${stats.intervalDistribution['8-10']}</strong> 次（占比 ${((stats.intervalDistribution['8-10'] / stats.total) * 100).toFixed(1)}%）</li>`;
                html += `</ul>`;

                if (phase1Data && phase1Data.consecutiveAcPatterns.length > 0) {
                    html += '<p><strong>🔄 逐期关联分析（阶段1）：</strong></p>';
                    html += `<ul style="margin-left: 20px;">`;

                    const avgAcChange = phase1Data.consecutiveAcPatterns.reduce((sum, p) => sum + p.acChange, 0) / phase1Data.consecutiveAcPatterns.length;
                    const stableCount = phase1Data.consecutiveAcPatterns.filter(p => p.acChange === 0).length;
                    const stableRatio = (stableCount / phase1Data.consecutiveAcPatterns.length * 100).toFixed(1);

                    html += `<li>相邻期AC值平均变化：<strong>${avgAcChange.toFixed(2)}</strong></li>`;
                    html += `<li>AC值保持不变：<strong>${stableCount}</strong> 次（占比 ${stableRatio}%）</li>`;

                    const intervalTransitions = {};
                    Object.entries(phase1Data.intervalTransitions).forEach(([key, count]) => {
                        const [from, to] = key.split('_');
                        if (!intervalTransitions[from]) {
                            intervalTransitions[from] = {};
                        }
                        intervalTransitions[from][to] = count;
                    });

                    const intervalNames = {
                        '0-3': '低值区间(0-3)',
                        '4-7': '中值区间(4-7)',
                        '8-10': '高值区间(8-10)'
                    };

                    const topTransitions = [];
                    Object.entries(intervalTransitions).forEach(([from, tos]) => {
                        Object.entries(tos).forEach(([to, count]) => {
                            topTransitions.push({ from, to, count });
                        });
                    });
                    topTransitions.sort((a, b) => b.count - a.count);

                    if (topTransitions.length > 0) {
                        html += `<li>高频区间转换：`;
                        topTransitions.slice(0, 3).forEach(t => {
                            html += `<strong>${intervalNames[t.from] || t.from}</strong> → <strong>${intervalNames[t.to] || t.to}</strong> (${t.count}次) `;
                        });
                        html += `</li>`;
                    }

                    html += `</ul>`;
                }

                if (stats.trendAnalysis.warmingACValues.length > 0) {
                    html += '<p><strong>🌡️ 回暖AC值：</strong></p>';
                    html += `<ul style="margin-left: 20px;">`;
                    stats.trendAnalysis.warmingACValues.forEach(item => {
                        html += `<li>AC值 <strong>${item.value}</strong>：近期 ${item.recentCount} 次，前期 ${item.earlierCount} 次</li>`;
                    });
                    html += `</ul>`;
                }

                if (stats.trendAnalysis.coolingACValues.length > 0) {
                    html += '<p><strong>🧊 降温AC值：</strong></p>';
                    html += `<ul style="margin-left: 20px;">`;
                    stats.trendAnalysis.coolingACValues.forEach(item => {
                        html += `<li>AC值 <strong>${item.value}</strong>：近期 ${item.recentCount} 次，前期 ${item.earlierCount} 次</li>`;
                    });
                    html += `</ul>`;
                }

                html += '<p><strong>💡 综合结论：</strong></p>';
                html += `<p style="color: #666; font-style: italic;">`;
                html += `近${stats.total}期${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}AC值主要集中在${stats.intervalDistribution['4-7'] > stats.intervalDistribution['0-3'] && stats.intervalDistribution['4-7'] > stats.intervalDistribution['8-10'] ? '4-7' : stats.intervalDistribution['0-3'] > stats.intervalDistribution['8-10'] ? '0-3' : '8-10'}区间，平均AC值为${stats.mean}，`;
                html += `AC值 = ${stats.mostFrequent.value}的出现频次最高（${stats.mostFrequent.count}次）。`;
                if (phase1Data && phase1Data.consecutiveAcPatterns.length > 0) {
                    const avgAcChange = phase1Data.consecutiveAcPatterns.reduce((sum, p) => sum + p.acChange, 0) / phase1Data.consecutiveAcPatterns.length;
                    html += `相邻期AC值平均变化${avgAcChange.toFixed(2)}，${Math.abs(avgAcChange) < 1 ? '表明相邻期AC值相对稳定' : '表明相邻期AC值变化较大'}。`;
                }
                html += `</p>`;

                html += '</div>';

                conclusionContent.innerHTML = html;
            }

            static generateAcValueRecommendation() {
                const minRange = parseInt(document.getElementById('acValueMinRange').value);
                const maxRange = parseInt(document.getElementById('acValueMaxRange').value);
                const recommendationContent = document.getElementById('acValueRecommendationContent');

                if (!recommendationContent || !acValueAnalysisResults) return;

                const stats = acValueAnalysisResults;
                const targetACValues = [];

                for (let ac = minRange; ac <= maxRange; ac++) {
                    if (stats.valueCounts[ac]) {
                        targetACValues.push({
                            value: ac,
                            count: stats.valueCounts[ac],
                            percentage: ((stats.valueCounts[ac] / stats.total) * 100).toFixed(1)
                        });
                    }
                }

                if (targetACValues.length === 0) {
                    recommendationContent.innerHTML = '<p style="color: #999;">指定AC值范围内无数据，请调整范围后重试。</p>';
                    return;
                }

                targetACValues.sort((a, b) => b.count - a.count);

                const recommendations = [];
                const maxRecommendations = 3;

                targetACValues.slice(0, maxRecommendations).forEach(acItem => {
                    const sampleNumbers = this.generateSmartNumbersForAC(acItem.value, 3);

                    sampleNumbers.forEach(numbers => {
                        recommendations.push({
                            acValue: acItem.value,
                            numbers: numbers,
                            count: acItem.count,
                            percentage: acItem.percentage,
                            isHot: stats.hotACValues.some(h => h.value === acItem.value),
                            isWarming: stats.trendAnalysis.warmingACValues.some(w => w.value === acItem.value)
                        });
                    });
                });

                let html = '<div class="ac-recommendation-container">';

                recommendations.forEach((rec, index) => {
                    const acLevel = rec.acValue >= 9 ? '极高' : (rec.acValue >= 7 ? '高' : (rec.acValue >= 5 ? '中' : (rec.acValue >= 3 ? '低' : '极低')));
                    const acColor = rec.acValue >= 9 ? '#FF4757' : (rec.acValue >= 7 ? '#FF6B81' : (rec.acValue >= 5 ? '#FFA502' : (rec.acValue >= 3 ? '#2ED573' : '#1E90FF')));

                    let reason = `该AC值出现${rec.count}次，占比${rec.percentage}%`;
                    if (rec.isHot) reason += '，属于热门AC值';
                    if (rec.isWarming) reason += '，近期有回暖趋势';

                    html += '<div class="recommendation-card enhanced">';
                    html += `<div class="card-header enhanced">`;
                    html += `<span class="card-title">推荐 ${index + 1}</span>`;
                    html += `<span class="card-ac" style="background: ${acColor};">AC值: ${rec.acValue} <span style="font-size: 11px;">(${acLevel})</span></span>`;
                    html += `</div>`;

                    html += '<div class="card-body enhanced">';

                    html += '<div class="number-display enhanced">';
                    rec.numbers.forEach(num => {
                        html += `<span class="number-ball red enhanced">${num.toString().padStart(2, '0')}</span>`;
                    });
                    html += '</div>';

                    html += '<div class="recommendation-stats">';
                    html += `<div class="stat-item"><i class="fas fa-chart-line"></i> 出现次数: <strong>${rec.count}</strong></div>`;
                    html += `<div class="stat-item"><i class="fas fa-percentage"></i> 占比: <strong>${rec.percentage}%</strong></div>`;
                    if (rec.isHot) html += `<div class="stat-item hot"><i class="fas fa-fire"></i> 热门AC值</div>`;
                    if (rec.isWarming) html += `<div class="stat-item warming"><i class="fas fa-arrow-up"></i> 回暖趋势</div>`;
                    html += '</div>';

                    html += `<div class="recommendation-reason">💡 ${reason}</div>`;

                    html += '</div>';
                    html += '</div>';
                });

                html += '</div>';

                recommendationContent.innerHTML = html;

                MessageSystem.showMessage('已生成AC值推荐号码', 'success');
            }

            static generateSmartNumbersForAC(targetAC, count = 1) {
                const results = [];
                const maxAttempts = 5000;
                let attempts = 0;

                while (results.length < count && attempts < maxAttempts) {
                    attempts++;

                    const numbers = [];
                    const usedNumbers = new Set();

                    while (numbers.length < 6) {
                        const num = Math.floor(Math.random() * 33) + 1;
                        if (!usedNumbers.has(num)) {
                            numbers.push(num);
                            usedNumbers.add(num);
                        }
                    }

                    numbers.sort((a, b) => a - b);

                    const currentAC = this.calculateACValue(numbers);

                    if (currentAC === targetAC) {
                        const isDuplicate = results.some(result => 
                            result.join(',') === numbers.join(',')
                        );

                        if (!isDuplicate) {
                            results.push(numbers);
                        }
                    }
                }

                return results;
            }

            static exportAcValueData() {
                if (!acValueChartData) {
                    MessageSystem.showMessage('请先进行AC值分析', 'warning');
                    return;
                }

                let csv = '期号,AC值\n';
                acValueChartData.trend.forEach(item => {
                    csv += `${item.period},${item.acValue}\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `AC值分析数据_${new Date().toLocaleDateString()}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                MessageSystem.showMessage('AC值数据已导出', 'success');
            }

            static handleThreeZoneAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    const draws = currentDatabaseData.draws || [];

                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('threeZonePeriodSelect');
                    currentThreeZonePeriod = periodSelect ? parseInt(periodSelect.value) : 50;

                    this.performThreeZoneAnalysis(draws);

                    MessageSystem.showMessage(`已完成${draws.length}期数据的大中小分析`, 'success');
                });
            }

            static performThreeZoneAnalysis(draws) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const zoneRanges = rules.threeZoneRanges;

                const reversedDraws = [...draws].reverse();
                const totalDraws = currentThreeZonePeriod === 'all' ? reversedDraws.length : Math.min(currentThreeZonePeriod, reversedDraws.length);
                const analyzedDraws = reversedDraws.slice(0, totalDraws);

                // 更新分析范围显示
                const threeZoneDataRangeInfo = document.getElementById('threeZoneDataRangeInfo');
                if (threeZoneDataRangeInfo && analyzedDraws.length > 0) {
                    const startPeriod = analyzedDraws[analyzedDraws.length - 1].period;
                    const endPeriod = analyzedDraws[0].period;
                    threeZoneDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analyzedDraws.length}期）`;
                }

                const phase1Data = this.performThreeZonePhase1Analysis(analyzedDraws, zoneRanges);
                const advancedAnalysis = this.performAdvancedThreeZoneAnalysis(analyzedDraws, zoneRanges);

                const threeZoneData = {
                    zone1Count: 0,
                    zone2Count: 0,
                    zone3Count: 0,
                    trend: [],
                    combinations: {},
                    acValueCorrelation: [],
                    advancedAnalysis: advancedAnalysis
                };

                analyzedDraws.forEach(draw => {
                    let zone1Count = 0;
                    let zone2Count = 0;
                    let zone3Count = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            zone1Count++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            zone2Count++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            zone3Count++;
                        }
                    });

                    threeZoneData.zone1Count += zone1Count;
                    threeZoneData.zone2Count += zone2Count;
                    threeZoneData.zone3Count += zone3Count;

                    const combination = `${zone1Count}-${zone2Count}-${zone3Count}`;
                    threeZoneData.combinations[combination] = (threeZoneData.combinations[combination] || 0) + 1;

                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);
                    const acValue = this.calculateACValue(redBalls);
                    threeZoneData.acValueCorrelation.push({
                        period: draw.period,
                        zone1: zone1Count,
                        zone2: zone2Count,
                        zone3: zone3Count,
                        combination: combination,
                        acValue: acValue
                    });

                    threeZoneData.trend.push({
                        period: draw.period,
                        zone1: zone1Count,
                        zone2: zone2Count,
                        zone3: zone3Count,
                        combination: combination
                    });
                });

                threeZoneChartData = threeZoneData;
                threeZoneAnalysisResults = this.generateThreeZoneAnalysisResults(threeZoneData, totalDraws, phase1Data, advancedAnalysis);

                this.updateThreeZoneChart(threeZoneData, phase1Data);
                this.updateThreeZoneConclusion(threeZoneAnalysisResults);
            }

            static performThreeZonePhase1Analysis(draws, zoneRanges) {
                console.log('=== 开始执行大中小分析阶段1（逐期关联分析） ===');
                console.log('数据期数:', draws.length);

                const phase1Data = {
                    consecutivePatterns: [],
                    zoneTransitions: {},
                    zoneChangePatterns: [],
                    sameCombinationStreaks: [],
                    positionZoneTransitions: [[], [], [], [], [], []],
                    zoneOscillation: [],
                    zoneNumberTransitions: {}
                };

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    let currentZone1Count = 0;
                    let currentZone2Count = 0;
                    let currentZone3Count = 0;
                    currentDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            currentZone1Count++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            currentZone2Count++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            currentZone3Count++;
                        }
                    });

                    let nextZone1Count = 0;
                    let nextZone2Count = 0;
                    let nextZone3Count = 0;
                    nextDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            nextZone1Count++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            nextZone2Count++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            nextZone3Count++;
                        }
                    });

                    const currentCombination = `${currentZone1Count}-${currentZone2Count}-${currentZone3Count}`;
                    const nextCombination = `${nextZone1Count}-${nextZone2Count}-${nextZone3Count}`;

                    const transitionKey = `${currentCombination}->${nextCombination}`;
                    if (!phase1Data.zoneTransitions[transitionKey]) {
                        phase1Data.zoneTransitions[transitionKey] = 0;
                    }
                    phase1Data.zoneTransitions[transitionKey]++;

                    phase1Data.consecutivePatterns.push({
                        period: currentDraw.period,
                        currentCombination: currentCombination,
                        nextCombination: nextCombination,
                        zone1Change: nextZone1Count - currentZone1Count,
                        zone2Change: nextZone2Count - currentZone2Count,
                        zone3Change: nextZone3Count - currentZone3Count
                    });

                    if (currentCombination === nextCombination) {
                        let streak = 1;
                        for (let j = i - 1; j >= 0; j--) {
                            const prevDraw = draws[j];
                            let prevZone1Count = 0;
                            let prevZone2Count = 0;
                            let prevZone3Count = 0;
                            prevDraw.redBalls.forEach(ball => {
                                const num = parseInt(ball);
                                if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                                    prevZone1Count++;
                                } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                                    prevZone2Count++;
                                } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                                    prevZone3Count++;
                                }
                            });
                            const prevCombination = `${prevZone1Count}-${prevZone2Count}-${prevZone3Count}`;
                            if (prevCombination === currentCombination) {
                                streak++;
                            } else {
                                break;
                            }
                        }
                        phase1Data.sameCombinationStreaks.push({
                            period: currentDraw.period,
                            combination: currentCombination,
                            streak: streak
                        });
                    }

                    for (let pos = 0; pos < 6; pos++) {
                        const currentNum = parseInt(currentDraw.redBalls[pos]);
                        const nextNum = parseInt(nextDraw.redBalls[pos]);

                        let currentZone = 0;
                        let nextZone = 0;

                        if (currentNum >= zoneRanges.zone1[0] && currentNum <= zoneRanges.zone1[1]) {
                            currentZone = 1;
                        } else if (currentNum >= zoneRanges.zone2[0] && currentNum <= zoneRanges.zone2[1]) {
                            currentZone = 2;
                        } else if (currentNum >= zoneRanges.zone3[0] && currentNum <= zoneRanges.zone3[1]) {
                            currentZone = 3;
                        }

                        if (nextNum >= zoneRanges.zone1[0] && nextNum <= zoneRanges.zone1[1]) {
                            nextZone = 1;
                        } else if (nextNum >= zoneRanges.zone2[0] && nextNum <= zoneRanges.zone2[1]) {
                            nextZone = 2;
                        } else if (nextNum >= zoneRanges.zone3[0] && nextNum <= zoneRanges.zone3[1]) {
                            nextZone = 3;
                        }

                        const transitionType = currentZone === nextZone ? 'same' : `zone${currentZone}ToZone${nextZone}`;

                        phase1Data.positionZoneTransitions[pos].push({
                            period: currentDraw.period,
                            position: pos + 1,
                            currentNum: currentNum,
                            nextNum: nextNum,
                            currentZone: currentZone,
                            nextZone: nextZone,
                            transitionType: transitionType
                        });
                    }

                    phase1Data.zoneOscillation.push({
                        period: currentDraw.period,
                        currentZone1: currentZone1Count,
                        nextZone1: nextZone1Count,
                        currentZone2: currentZone2Count,
                        nextZone2: nextZone2Count,
                        currentZone3: currentZone3Count,
                        nextZone3: nextZone3Count,
                        oscillation: Math.abs(nextZone1Count - currentZone1Count) + Math.abs(nextZone2Count - currentZone2Count) + Math.abs(nextZone3Count - currentZone3Count)
                    });

                    currentDraw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        const numStr = num.toString().padStart(2, '0');
                        let currentZone = 0;

                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            currentZone = 1;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            currentZone = 2;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            currentZone = 3;
                        }

                        const appearsInNext = nextDraw.redBalls.includes(numStr);
                        const key = `${numStr}_zone${currentZone}_${appearsInNext ? 'stay' : 'leave'}`;

                        if (!phase1Data.zoneNumberTransitions[key]) {
                            phase1Data.zoneNumberTransitions[key] = 0;
                        }
                        phase1Data.zoneNumberTransitions[key]++;
                    });
                }

                phase1Data.zoneChangePatterns = phase1Data.consecutivePatterns.map(pattern => ({
                    period: pattern.period,
                    changeType: pattern.zone1Change !== 0 || pattern.zone2Change !== 0 || pattern.zone3Change !== 0 ? 'zoneChange' : 'stable',
                    zone1Change: pattern.zone1Change,
                    zone2Change: pattern.zone2Change,
                    zone3Change: pattern.zone3Change
                }));

                console.log('大中小分析阶段1完成');
                console.log('连续模式数:', phase1Data.consecutivePatterns.length);
                console.log('区间转换类型数:', Object.keys(phase1Data.zoneTransitions).length);

                return phase1Data;
            }

            static performAdvancedThreeZoneAnalysis(draws, zoneRanges) {
                console.log('=== 开始执行大中小分析高级分析 ===');
                console.log('数据期数:', draws.length);

                const advancedData = {
                    zoneOmissionAnalysis: {},
                    zoneHotColdAnalysis: {},
                    zoneCycleAnalysis: {},
                    zoneBalanceAnalysis: {},
                    zonePatternAnalysis: {},
                    zonePredictionAnalysis: {}
                };

                const totalDraws = draws.length;

                const zone1Numbers = [];
                const zone2Numbers = [];
                const zone3Numbers = [];

                for (let num = zoneRanges.zone1[0]; num <= zoneRanges.zone1[1]; num++) zone1Numbers.push(num);
                for (let num = zoneRanges.zone2[0]; num <= zoneRanges.zone2[1]; num++) zone2Numbers.push(num);
                for (let num = zoneRanges.zone3[0]; num <= zoneRanges.zone3[1]; num++) zone3Numbers.push(num);

                advancedData.zoneOmissionAnalysis = this.analyzeZoneOmissions(draws, zoneRanges, zone1Numbers, zone2Numbers, zone3Numbers);
                advancedData.zoneHotColdAnalysis = this.analyzeZoneHotCold(draws, zoneRanges, zone1Numbers, zone2Numbers, zone3Numbers, totalDraws);
                advancedData.zoneCycleAnalysis = this.analyzeZoneCycles(draws, zoneRanges);
                advancedData.zoneBalanceAnalysis = this.analyzeZoneBalance(draws, zoneRanges);
                advancedData.zonePatternAnalysis = this.analyzeZonePatterns(draws, zoneRanges);
                advancedData.zonePredictionAnalysis = this.analyzeZonePredictions(draws, zoneRanges, advancedData);

                console.log('大中小分析高级分析完成');

                return advancedData;
            }

            static analyzeZoneOmissions(draws, zoneRanges, zone1Numbers, zone2Numbers, zone3Numbers) {
                const omissionData = {
                    zone1: {},
                    zone2: {},
                    zone3: {}
                };

                const initializeZoneOmission = (zone, numbers) => {
                    numbers.forEach(num => {
                        const numStr = num.toString().padStart(2, '0');
                        omissionData[zone][numStr] = {
                            number: numStr,
                            currentOmission: 0,
                            maxOmission: 0,
                            avgOmission: 0,
                            omissionHistory: [],
                            omissionTrend: 'stable'
                        };
                    });
                };

                initializeZoneOmission('zone1', zone1Numbers);
                initializeZoneOmission('zone2', zone2Numbers);
                initializeZoneOmission('zone3', zone3Numbers);

                const reversedDraws = [...draws].reverse();

                reversedDraws.forEach((draw, drawIndex) => {
                    const zoneKey = (num) => {
                        const n = parseInt(num);
                        if (n >= zoneRanges.zone1[0] && n <= zoneRanges.zone1[1]) return 'zone1';
                        if (n >= zoneRanges.zone2[0] && n <= zoneRanges.zone2[1]) return 'zone2';
                        return 'zone3';
                    };

                    Object.keys(omissionData).forEach(zone => {
                        Object.values(omissionData[zone]).forEach(data => {
                            if (draw.redBalls.includes(data.number)) {
                                data.omissionHistory.push(data.currentOmission);
                                if (data.currentOmission > data.maxOmission) {
                                    data.maxOmission = data.currentOmission;
                                }
                                data.currentOmission = 0;
                            } else {
                                data.currentOmission++;
                            }
                        });
                    });
                });

                Object.keys(omissionData).forEach(zone => {
                    Object.values(omissionData[zone]).forEach(data => {
                        if (data.omissionHistory.length > 0) {
                            data.avgOmission = data.omissionHistory.reduce((sum, val) => sum + val, 0) / data.omissionHistory.length;

                            if (data.omissionHistory.length >= 3) {
                                const recent = data.omissionHistory.slice(-3);
                                const earlier = data.omissionHistory.slice(0, -3);
                                const recentAvg = recent.reduce((sum, val) => sum + val, 0) / recent.length;
                                const earlierAvg = earlier.length > 0 ? earlier.reduce((sum, val) => sum + val, 0) / earlier.length : recentAvg;

                                if (recentAvg > earlierAvg * 1.2) {
                                    data.omissionTrend = 'increasing';
                                } else if (recentAvg < earlierAvg * 0.8) {
                                    data.omissionTrend = 'decreasing';
                                } else {
                                    data.omissionTrend = 'stable';
                                }
                            }
                        }
                    });
                });

                return omissionData;
            }

            static analyzeZoneHotCold(draws, zoneRanges, zone1Numbers, zone2Numbers, zone3Numbers, totalDraws) {
                const hotColdData = {
                    zone1: { hot: [], warm: [], cold: [], veryCold: [] },
                    zone2: { hot: [], warm: [], cold: [], veryCold: [] },
                    zone3: { hot: [], warm: [], cold: [], veryCold: [] }
                };

                const frequencyMap = {};

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        frequencyMap[ball] = (frequencyMap[ball] || 0) + 1;
                    });
                });

                const avgFrequency = Object.values(frequencyMap).reduce((sum, val) => sum + val, 0) / Object.keys(frequencyMap).length;
                const stdDev = Math.sqrt(Object.values(frequencyMap).reduce((sum, val) => sum + Math.pow(val - avgFrequency, 2), 0) / Object.keys(frequencyMap).length);

                const classifyNumber = (numStr, zone) => {
                    const frequency = frequencyMap[numStr] || 0;
                    const zScore = (frequency - avgFrequency) / stdDev;

                    if (zScore > 1.5) {
                        hotColdData[zone].hot.push(numStr);
                    } else if (zScore > 0.5) {
                        hotColdData[zone].warm.push(numStr);
                    } else if (zScore > -0.5) {
                        hotColdData[zone].cold.push(numStr);
                    } else {
                        hotColdData[zone].veryCold.push(numStr);
                    }
                };

                zone1Numbers.forEach(num => classifyNumber(num.toString().padStart(2, '0'), 'zone1'));
                zone2Numbers.forEach(num => classifyNumber(num.toString().padStart(2, '0'), 'zone2'));
                zone3Numbers.forEach(num => classifyNumber(num.toString().padStart(2, '0'), 'zone3'));

                return hotColdData;
            }

            static analyzeZoneCycles(draws, zoneRanges) {
                const cycleData = {
                    zone1: { cycles: [], avgCycle: 0, cyclePattern: 'random' },
                    zone2: { cycles: [], avgCycle: 0, cyclePattern: 'random' },
                    zone3: { cycles: [], avgCycle: 0, cyclePattern: 'random' }
                };

                const zoneCounts = [];

                draws.forEach(draw => {
                    let zone1Count = 0;
                    let zone2Count = 0;
                    let zone3Count = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            zone1Count++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            zone2Count++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            zone3Count++;
                        }
                    });

                    zoneCounts.push({ zone1: zone1Count, zone2: zone2Count, zone3: zone3Count });
                });

                const analyzeZoneCycle = (zoneKey, countKey) => {
                    const counts = zoneCounts.map(zc => zc[countKey]);
                    const cycles = [];

                    for (let i = 1; i < counts.length; i++) {
                        if (counts[i] !== counts[i-1]) {
                            cycles.push(i);
                        }
                    }

                    if (cycles.length > 0) {
                        const avgCycle = cycles.reduce((sum, val) => sum + val, 0) / cycles.length;
                        const stdDev = Math.sqrt(cycles.reduce((sum, val) => sum + Math.pow(val - avgCycle, 2), 0) / cycles.length);

                        let pattern = 'random';
                        if (stdDev < avgCycle * 0.3) {
                            pattern = 'regular';
                        } else if (stdDev < avgCycle * 0.6) {
                            pattern = 'semi-regular';
                        }

                        cycleData[zoneKey] = {
                            cycles: cycles,
                            avgCycle: avgCycle,
                            stdDev: stdDev,
                            cyclePattern: pattern
                        };
                    }
                };

                analyzeZoneCycle('zone1', 'zone1');
                analyzeZoneCycle('zone2', 'zone2');
                analyzeZoneCycle('zone3', 'zone3');

                return cycleData;
            }

            static analyzeZoneBalance(draws, zoneRanges) {
                const balanceData = {
                    zone1Balance: 0,
                    zone2Balance: 0,
                    zone3Balance: 0,
                    overallBalance: 0,
                    balanceTrend: 'stable',
                    balanceScore: 0
                };

                const zone1Counts = [];
                const zone2Counts = [];
                const zone3Counts = [];

                draws.forEach(draw => {
                    let zone1Count = 0;
                    let zone2Count = 0;
                    let zone3Count = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            zone1Count++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            zone2Count++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            zone3Count++;
                        }
                    });

                    zone1Counts.push(zone1Count);
                    zone2Counts.push(zone2Count);
                    zone3Counts.push(zone3Count);
                });

                const avgZone1 = zone1Counts.reduce((sum, val) => sum + val, 0) / zone1Counts.length;
                const avgZone2 = zone2Counts.reduce((sum, val) => sum + val, 0) / zone2Counts.length;
                const avgZone3 = zone3Counts.reduce((sum, val) => sum + val, 0) / zone3Counts.length;

                const idealAvg = 2;

                balanceData.zone1Balance = 1 - Math.abs(avgZone1 - idealAvg) / idealAvg;
                balanceData.zone2Balance = 1 - Math.abs(avgZone2 - idealAvg) / idealAvg;
                balanceData.zone3Balance = 1 - Math.abs(avgZone3 - idealAvg) / idealAvg;

                balanceData.overallBalance = (balanceData.zone1Balance + balanceData.zone2Balance + balanceData.zone3Balance) / 3;

                const recentDraws = Math.min(20, draws.length);
                const recentZone1Avg = zone1Counts.slice(-recentDraws).reduce((sum, val) => sum + val, 0) / recentDraws;
                const recentZone2Avg = zone2Counts.slice(-recentDraws).reduce((sum, val) => sum + val, 0) / recentDraws;
                const recentZone3Avg = zone3Counts.slice(-recentDraws).reduce((sum, val) => sum + val, 0) / recentDraws;

                const earlierDraws = Math.min(20, draws.length - recentDraws);
                if (earlierDraws > 0) {
                    const earlierZone1Avg = zone1Counts.slice(-recentDraws - earlierDraws, -recentDraws).reduce((sum, val) => sum + val, 0) / earlierDraws;
                    const earlierZone2Avg = zone2Counts.slice(-recentDraws - earlierDraws, -recentDraws).reduce((sum, val) => sum + val, 0) / earlierDraws;
                    const earlierZone3Avg = zone3Counts.slice(-recentDraws - earlierDraws, -recentDraws).reduce((sum, val) => sum + val, 0) / earlierDraws;

                    const recentBalance = 1 - (Math.abs(recentZone1Avg - idealAvg) + Math.abs(recentZone2Avg - idealAvg) + Math.abs(recentZone3Avg - idealAvg)) / (3 * idealAvg);
                    const earlierBalance = 1 - (Math.abs(earlierZone1Avg - idealAvg) + Math.abs(earlierZone2Avg - idealAvg) + Math.abs(earlierZone3Avg - idealAvg)) / (3 * idealAvg);

                    if (recentBalance > earlierBalance * 1.1) {
                        balanceData.balanceTrend = 'improving';
                    } else if (recentBalance < earlierBalance * 0.9) {
                        balanceData.balanceTrend = 'declining';
                    } else {
                        balanceData.balanceTrend = 'stable';
                    }
                }

                balanceData.balanceScore = Math.round(balanceData.overallBalance * 100);

                return balanceData;
            }

            static analyzeZonePatterns(draws, zoneRanges) {
                const patternData = {
                    commonPatterns: [],
                    rarePatterns: [],
                    patternFrequency: {},
                    patternStreaks: [],
                    patternTransitions: {}
                };

                const combinations = [];

                draws.forEach(draw => {
                    let zone1Count = 0;
                    let zone2Count = 0;
                    let zone3Count = 0;

                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            zone1Count++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            zone2Count++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            zone3Count++;
                        }
                    });

                    const combination = `${zone1Count}-${zone2Count}-${zone3Count}`;
                    combinations.push(combination);
                });

                combinations.forEach((comb, index) => {
                    patternData.patternFrequency[comb] = (patternData.patternFrequency[comb] || 0) + 1;

                    if (index > 0) {
                        const transition = `${combinations[index-1]}→${comb}`;
                        patternData.patternTransitions[transition] = (patternData.patternTransitions[transition] || 0) + 1;
                    }
                });

                const sortedPatterns = Object.entries(patternData.patternFrequency)
                    .sort((a, b) => b[1] - a[1]);

                patternData.commonPatterns = sortedPatterns.slice(0, 5).map(([pattern, count]) => ({
                    pattern,
                    count,
                    frequency: (count / draws.length * 100).toFixed(1)
                }));

                patternData.rarePatterns = sortedPatterns.slice(-5).reverse().map(([pattern, count]) => ({
                    pattern,
                    count,
                    frequency: (count / draws.length * 100).toFixed(1)
                }));

                let currentStreak = 1;
                let maxStreak = 1;
                let streakPattern = combinations[0];

                for (let i = 1; i < combinations.length; i++) {
                    if (combinations[i] === combinations[i-1]) {
                        currentStreak++;
                        if (currentStreak > maxStreak) {
                            maxStreak = currentStreak;
                            streakPattern = combinations[i];
                        }
                    } else {
                        currentStreak = 1;
                    }
                }

                patternData.patternStreaks.push({
                    pattern: streakPattern,
                    maxStreak: maxStreak
                });

                return patternData;
            }

            static analyzeZonePredictions(draws, zoneRanges, advancedData) {
                const predictionData = {
                    nextCombination: null,
                    confidence: 0,
                    zone1Prediction: 0,
                    zone2Prediction: 0,
                    zone3Prediction: 0,
                    predictionReasoning: []
                };

                const recentDraws = draws.slice(-10);

                const recentZone1Avg = recentDraws.reduce((sum, draw) => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) count++;
                    });
                    return sum + count;
                }, 0) / recentDraws.length;

                const recentZone2Avg = recentDraws.reduce((sum, draw) => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) count++;
                    });
                    return sum + count;
                }, 0) / recentDraws.length;

                const recentZone3Avg = recentDraws.reduce((sum, draw) => {
                    let count = 0;
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) count++;
                    });
                    return sum + count;
                }, 0) / recentDraws.length;

                const balanceData = advancedData.zoneBalanceAnalysis;
                const patternData = advancedData.zonePatternAnalysis;

                const predictedZone1 = Math.round(recentZone1Avg * 0.6 + 2 * 0.4);
                const predictedZone2 = Math.round(recentZone2Avg * 0.6 + 2 * 0.4);
                const predictedZone3 = Math.round(recentZone3Avg * 0.6 + 2 * 0.4);

                const total = predictedZone1 + predictedZone2 + predictedZone3;
                if (total !== 6) {
                    const adjustment = (6 - total) / 3;
                    predictionData.zone1Prediction = Math.max(0, Math.min(6, predictedZone1 + Math.round(adjustment)));
                    predictionData.zone2Prediction = Math.max(0, Math.min(6, predictedZone2 + Math.round(adjustment)));
                    predictionData.zone3Prediction = Math.max(0, Math.min(6, predictedZone3 + Math.round(adjustment)));
                } else {
                    predictionData.zone1Prediction = predictedZone1;
                    predictionData.zone2Prediction = predictedZone2;
                    predictionData.zone3Prediction = predictedZone3;
                }

                predictionData.nextCombination = `${predictionData.zone1Prediction}-${predictionData.zone2Prediction}-${predictionData.zone3Prediction}`;

                let confidence = 0;

                if (balanceData.balanceScore > 70) {
                    confidence += 25;
                    predictionData.predictionReasoning.push('三区平衡性良好（' + balanceData.balanceScore + '分）');
                }

                if (patternData.commonPatterns.length > 0) {
                    const topPattern = patternData.commonPatterns[0];
                    if (parseFloat(topPattern.frequency) > 15) {
                        confidence += 20;
                        predictionData.predictionReasoning.push('高频组合' + topPattern.pattern + '出现频率' + topPattern.frequency + '%');
                    }
                }

                const lastCombination = `${recentDraws[recentDraws.length-1].redBalls.filter(b => {
                    const num = parseInt(b);
                    return num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1];
                }).length}-${recentDraws[recentDraws.length-1].redBalls.filter(b => {
                    const num = parseInt(b);
                    return num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1];
                }).length}-${recentDraws[recentDraws.length-1].redBalls.filter(b => {
                    const num = parseInt(b);
                    return num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1];
                }).length}`;

                if (lastCombination === predictionData.nextCombination) {
                    confidence -= 15;
                    predictionData.predictionReasoning.push('与上期相同，降低置信度');
                }

                const cycleData = advancedData.zoneCycleAnalysis;
                if (cycleData.zone1.cyclePattern === 'regular' || cycleData.zone2.cyclePattern === 'regular' || cycleData.zone3.cyclePattern === 'regular') {
                    confidence += 15;
                    predictionData.predictionReasoning.push('部分区间呈现规律性周期');
                }

                predictionData.confidence = Math.max(0, Math.min(100, confidence));

                return predictionData;
            }

            static updateThreeZoneChart(threeZoneData) {
                const chartDom = document.getElementById('threeZoneChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const rules = LOTTERY_RULES[currentLotteryType];
                const zoneRanges = rules.threeZoneRanges;
                const zone1Label = `一区(${zoneRanges.zone1[0]}-${zoneRanges.zone1[1]})`;
                const zone2Label = `二区(${zoneRanges.zone2[0]}-${zoneRanges.zone2[1]})`;
                const zone3Label = `三区(${zoneRanges.zone3[0]}-${zoneRanges.zone3[1]})`;

                switch (currentThreeZoneChartType) {
                    case 'stackedBar':
                        this.renderThreeZoneStackedBarChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label);
                        break;
                    case 'line':
                        this.renderThreeZoneLineChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label);
                        break;
                    case 'pie':
                        this.renderThreeZonePieChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label);
                        break;
                    case 'scatter':
                        this.renderThreeZoneScatterChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label);
                        break;
                    default:
                        this.renderThreeZoneStackedBarChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label);
                }
            }

            static renderThreeZoneStackedBarChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label) {
                const trendData = threeZoneData.trend.slice().reverse();
                const periods = trendData.map(item => item.period);
                const zone1Data = trendData.map(item => item.zone1);
                const zone2Data = trendData.map(item => item.zone2);
                const zone3Data = trendData.map(item => item.zone3);

                const option = {
                    title: {
                        text: `每期三区出号数量分布（最近${threeZoneData.trend.length}期）`,
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(param => {
                                result += `${param.marker}${param.seriesName}: ${param.value}个<br/>`;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: [zone1Label, zone2Label, zone3Label],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        name: '期号',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出号数量',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        max: 6
                    },
                    series: [
                        {
                            name: zone1Label,
                            type: 'bar',
                            stack: 'total',
                            emphasis: {
                                focus: 'series'
                            },
                            data: zone1Data,
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: zone2Label,
                            type: 'bar',
                            stack: 'total',
                            emphasis: {
                                focus: 'series'
                            },
                            data: zone2Data,
                            itemStyle: {
                                color: '#F4A261'
                            }
                        },
                        {
                            name: zone3Label,
                            type: 'bar',
                            stack: 'total',
                            emphasis: {
                                focus: 'series'
                            },
                            data: zone3Data,
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static renderThreeZoneLineChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label) {
                const trendData = threeZoneData.trend.slice().reverse();
                const periods = trendData.map(item => item.period);
                const zone1Data = trendData.map(item => item.zone1);
                const zone2Data = trendData.map(item => item.zone2);
                const zone3Data = trendData.map(item => item.zone3);

                const option = {
                    title: {
                        text: `各区间出号数变化趋势（最近${threeZoneData.trend.length}期）`,
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const paramArray = Array.isArray(params) ? params : [params];
                            let result = paramArray[0].name + '<br/>';
                            paramArray.forEach(param => {
                                result += `${param.marker}${param.seriesName}: ${param.value}个<br/>`;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: [zone1Label, zone2Label, zone3Label],
                        top: '10%'
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期号',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        axisLabel: {
                            rotate: 45
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出号数量',
                        nameTextStyle: {
                            fontWeight: 'bold'
                        },
                        max: 6
                    },
                    series: [
                        {
                            name: zone1Label,
                            type: 'line',
                            data: zone1Data,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 2
                            },
                            itemStyle: {
                                color: '#E63946'
                            }
                        },
                        {
                            name: zone2Label,
                            type: 'line',
                            data: zone2Data,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 2
                            },
                            itemStyle: {
                                color: '#F4A261'
                            }
                        },
                        {
                            name: zone3Label,
                            type: 'line',
                            data: zone3Data,
                            smooth: true,
                            symbol: 'circle',
                            symbolSize: 6,
                            lineStyle: {
                                width: 2
                            },
                            itemStyle: {
                                color: '#457B9D'
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static renderThreeZonePieChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label) {
                const total = threeZoneData.zone1Count + threeZoneData.zone2Count + threeZoneData.zone3Count;

                const option = {
                    title: {
                        text: `三区出号总数占比（共${total}个号码）`,
                        left: 'center',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{a} <br/>{b}: {c}个 ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: [zone1Label, zone2Label, zone3Label]
                    },
                    series: [
                        {
                            name: '大中小分布',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['60%', '50%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            label: {
                                show: true,
                                formatter: '{b}: {c}个 ({d}%)'
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 16,
                                    fontWeight: 'bold'
                                },
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            },
                            data: [
                                { value: threeZoneData.zone1Count, name: zone1Label, itemStyle: { color: '#E63946' } },
                                { value: threeZoneData.zone2Count, name: zone2Label, itemStyle: { color: '#F4A261' } },
                                { value: threeZoneData.zone3Count, name: zone3Label, itemStyle: { color: '#457B9D' } }
                            ]
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static renderThreeZoneScatterChart(chart, threeZoneData, zone1Label, zone2Label, zone3Label) {
                if (!threeZoneData || !threeZoneData.acValueCorrelation || threeZoneData.acValueCorrelation.length === 0) {
                    console.warn('AC值关联数据为空，无法渲染散点图');
                    return;
                }

                const scatterData = threeZoneData.acValueCorrelation.slice().reverse().map((item, index) => {
                    const acValue = item.acValue;
                    let color;
                    let symbol;

                    if (acValue >= 9) {
                        color = '#FF4757';
                        symbol = 'diamond';
                    } else if (acValue >= 7) {
                        color = '#FF6B81';
                        symbol = 'circle';
                    } else if (acValue >= 5) {
                        color = '#FFA502';
                        symbol = 'triangle';
                    } else if (acValue >= 3) {
                        color = '#2ED573';
                        symbol = 'rect';
                    } else {
                        color = '#1E90FF';
                        symbol = 'pin';
                    }

                    return {
                        name: item.period,
                        value: [item.zone1, item.zone2, item.zone3, acValue, item.combination],
                        itemStyle: {
                            color: color,
                            borderColor: '#fff',
                            borderWidth: 2
                        },
                        symbol: symbol,
                        symbolSize: function() {
                            return 12 + acValue * 2.5;
                        },
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 20,
                                shadowColor: color
                            }
                        }
                    };
                });

                const acValueStats = this.calculateACValueStats(threeZoneData.acValueCorrelation);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `三区出号组合与AC值关联分析（最近${threeZoneData.trend.length}期）`,
                        subtext: `平均AC值: ${acValueStats.avgACValue.toFixed(2)} | 最高AC值: ${acValueStats.maxACValue} | 最低AC值: ${acValueStats.minACValue}`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#7f8c8d'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 13
                        },
                        formatter: function(params) {
                            const data = params.data;
                            const acValue = data.value[3];
                            const acLevel = acValue >= 9 ? '极高' : (acValue >= 7 ? '高' : (acValue >= 5 ? '中' : (acValue >= 3 ? '低' : '极低')));
                            const acColor = acValue >= 9 ? '#FF4757' : (acValue >= 7 ? '#FF6B81' : (acValue >= 5 ? '#FFA502' : (acValue >= 3 ? '#2ED573' : '#1E90FF')));

                            return `<div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">期号: ${data.name}</div>
                                    <div style="margin: 4px 0;">一区: <strong>${data.value[0]}</strong> 个</div>
                                    <div style="margin: 4px 0;">二区: <strong>${data.value[1]}</strong> 个</div>
                                    <div style="margin: 4px 0;">三区: <strong>${data.value[2]}</strong> 个</div>
                                    <div style="margin: 4px 0;">组合: <strong>${data.value[4]}</strong></div>
                                    <div style="margin: 8px 0; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2);">
                                        AC值: <strong style="color: ${acColor}; font-size: 16px;">${acValue}</strong>
                                        <span style="margin-left: 8px; padding: 2px 8px; background: ${acColor}; border-radius: 10px; font-size: 11px;">${acLevel}</span>
                                    </div>
                                    <div style="margin-top: 4px; font-size: 11px; color: #bdc3c7;">
                                        点击查看详细分析
                                    </div>
                                </div>`;
                        }
                    },
                    legend: {
                        data: ['AC值 ≥ 9 (极高)', 'AC值 7-8 (高)', 'AC值 5-6 (中)', 'AC值 3-4 (低)', 'AC值 < 3 (极低)'],
                        top: '18%',
                        textStyle: {
                            fontSize: 12
                        },
                        itemGap: 8
                    },
                    grid: {
                        left: '8%',
                        right: '8%',
                        bottom: '12%',
                        top: '30%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        name: '期号',
                        nameTextStyle: {
                            fontWeight: 'bold',
                            fontSize: 13
                        },
                        data: threeZoneData.trend.map(item => item.period),
                        axisLabel: {
                            rotate: 45,
                            fontSize: 11,
                            interval: 0
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: 'AC值',
                        nameTextStyle: {
                            fontWeight: 'bold',
                            fontSize: 13
                        },
                        min: 0,
                        max: 10,
                        interval: 1,
                        axisLabel: {
                            fontSize: 11
                        },
                        splitLine: {
                            lineStyle: {
                                color: '#ecf0f1',
                                type: 'dashed'
                            }
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        },
                        markLine: {
                            data: [
                                {
                                    yAxis: acValueStats.avgACValue,
                                    name: '平均AC值',
                                    lineStyle: {
                                        color: '#e74c3c',
                                        type: 'solid',
                                        width: 2
                                    },
                                    label: {
                                        formatter: '平均: {c}',
                                        position: 'end',
                                        color: '#e74c3c',
                                        fontWeight: 'bold'
                                    }
                                },
                                {
                                    yAxis: 5,
                                    name: '中等AC值',
                                    lineStyle: {
                                        color: '#3498db',
                                        type: 'dashed',
                                        width: 1
                                    },
                                    label: {
                                        formatter: '中等: {c}',
                                        position: 'end',
                                        color: '#3498db'
                                    }
                                }
                            ]
                        }
                    },
                    dataZoom: [
                        {
                            type: 'slider',
                            show: true,
                            xAxisIndex: [0],
                            start: 0,
                            end: 100,
                            bottom: '5%',
                            height: 20,
                            borderColor: '#bdc3c7',
                            fillerColor: 'rgba(52, 152, 219, 0.2)',
                            handleStyle: {
                                color: '#3498db'
                            }
                        },
                        {
                            type: 'inside',
                            xAxisIndex: [0],
                            start: 0,
                            end: 100
                        }
                    ],
                    series: [
                        {
                            name: 'AC值关联',
                            type: 'scatter',
                            data: scatterData,
                            symbolSize: function(data) {
                                return 12 + data[3] * 2.5;
                            },
                            label: {
                                show: false,
                                formatter: function(params) {
                                    return params.data.value[4];
                                },
                                position: 'top',
                                fontSize: 9,
                                color: '#2c3e50',
                                fontWeight: 'bold'
                            },
                            emphasis: {
                                label: {
                                    show: true
                                },
                                scale: true
                            },
                            animationDelay: function(idx) {
                                return idx * 50;
                            }
                        }
                    ],
                    animationEasing: 'elasticOut',
                    animationDelayUpdate: function(idx) {
                        return idx * 5;
                    }
                };

                chart.off('click');
                chart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const data = params.data;
                        const period = data.name;
                        const zone1 = data.value[0];
                        const zone2 = data.value[1];
                        const zone3 = data.value[2];
                        const acValue = data.value[3];
                        const combination = data.value[4];

                        alert(`期号: ${period}\n一区: ${zone1}个\n二区: ${zone2}个\n三区: ${zone3}个\n组合: ${combination}\nAC值: ${acValue}`);
                    }
                });

                chart.setOption(option, true);
            }

            static calculateACValueStats(acValueCorrelation) {
                if (!acValueCorrelation || acValueCorrelation.length === 0) {
                    return { avgACValue: 0, maxACValue: 0, minACValue: 0 };
                }

                const acValues = acValueCorrelation.map(item => item.acValue);
                const sum = acValues.reduce((a, b) => a + b, 0);
                const avgACValue = sum / acValues.length;
                const maxACValue = Math.max(...acValues);
                const minACValue = Math.min(...acValues);

                return { avgACValue, maxACValue, minACValue };
            }

            static updateThreeZonePieChart(threeZoneData) {
                const chartDom = document.getElementById('threeZonePieChart');
                if (!chartDom) return;

                const chart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);

                const option = {
                    title: {
                        text: '三区总体分布',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{a} <br/>{b}: {c} ({d}%)'
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        data: ['一区(1-11)', '二区(12-22)', '三区(23-33)']
                    },
                    series: [
                        {
                            name: '大中小分布',
                            type: 'pie',
                            radius: '50%',
                            data: [
                                { value: threeZoneData.zone1Count, name: '一区(1-11)', itemStyle: { color: '#E63946' } },
                                { value: threeZoneData.zone2Count, name: '二区(12-22)', itemStyle: { color: '#F4A261' } },
                                { value: threeZoneData.zone3Count, name: '三区(23-33)', itemStyle: { color: '#457B9D' } }
                            ],
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                chart.setOption(option, true);
            }

            static generateThreeZoneAnalysisResults(threeZoneData, totalDraws, phase1Data, advancedAnalysis) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const zoneRanges = rules.threeZoneRanges;
                const totalNumbers = threeZoneData.zone1Count + threeZoneData.zone2Count + threeZoneData.zone3Count;

                const zone1Label = `一区(${zoneRanges.zone1[0]}-${zoneRanges.zone1[1]})`;
                const zone2Label = `二区(${zoneRanges.zone2[0]}-${zoneRanges.zone2[1]})`;
                const zone3Label = `三区(${zoneRanges.zone3[0]}-${zoneRanges.zone3[1]})`;

                const zone1Percent = ((threeZoneData.zone1Count / totalNumbers) * 100).toFixed(1);
                const zone2Percent = ((threeZoneData.zone2Count / totalNumbers) * 100).toFixed(1);
                const zone3Percent = ((threeZoneData.zone3Count / totalNumbers) * 100).toFixed(1);

                const sortedZones = [
                    { name: zone1Label, count: threeZoneData.zone1Count, percent: zone1Percent },
                    { name: zone2Label, count: threeZoneData.zone2Count, percent: zone2Percent },
                    { name: zone3Label, count: threeZoneData.zone3Count, percent: zone3Percent }
                ].sort((a, b) => b.count - a.count);

                const hotZone = sortedZones[0];
                const coldZone = sortedZones[2];

                const sortedCombinations = Object.entries(threeZoneData.combinations)
                    .map(([combination, count]) => ({ combination, count }))
                    .sort((a, b) => b.count - a.count);

                const topCombinations = sortedCombinations.slice(0, 5);

                const acValueByCombination = {};
                threeZoneData.acValueCorrelation.forEach(item => {
                    if (!acValueByCombination[item.combination]) {
                        acValueByCombination[item.combination] = [];
                    }
                    acValueByCombination[item.combination].push(item.acValue);
                });

                const combinationACStats = {};
                Object.entries(acValueByCombination).forEach(([combination, acValues]) => {
                    const avgAC = (acValues.reduce((sum, val) => sum + val, 0) / acValues.length).toFixed(2);
                    const minAC = Math.min(...acValues);
                    const maxAC = Math.max(...acValues);
                    combinationACStats[combination] = {
                        count: acValues.length,
                        avgAC,
                        minAC,
                        maxAC,
                        acValues
                    };
                });

                const trendAnalysis = this.analyzeThreeZoneTrend(threeZoneData);

                return {
                    totalDraws,
                    totalNumbers,
                    hotZone,
                    coldZone,
                    topCombinations,
                    combinationACStats,
                    trendAnalysis,
                    zoneDistribution: {
                        [zone1Label]: { count: threeZoneData.zone1Count, percent: zone1Percent },
                        [zone2Label]: { count: threeZoneData.zone2Count, percent: zone2Percent },
                        [zone3Label]: { count: threeZoneData.zone3Count, percent: zone3Percent }
                    },
                    phase1Data,
                    advancedAnalysis
                };
            }

            static analyzeThreeZoneTrend(threeZoneData) {
                const trend = threeZoneData.trend;
                const recentDraws = trend.slice(-10);
                const earlierDraws = trend.slice(-20, -10);

                const calculateAverage = (draws, zone) => {
                    return draws.reduce((sum, item) => sum + item[zone], 0) / draws.length;
                };

                const recentZone1Avg = calculateAverage(recentDraws, 'zone1');
                const recentZone2Avg = calculateAverage(recentDraws, 'zone2');
                const recentZone3Avg = calculateAverage(recentDraws, 'zone3');

                const earlierZone1Avg = earlierDraws.length > 0 ? calculateAverage(earlierDraws, 'zone1') : recentZone1Avg;
                const earlierZone2Avg = earlierDraws.length > 0 ? calculateAverage(earlierDraws, 'zone2') : recentZone2Avg;
                const earlierZone3Avg = earlierDraws.length > 0 ? calculateAverage(earlierDraws, 'zone3') : recentZone3Avg;

                const zone1Trend = recentZone1Avg - earlierZone1Avg;
                const zone2Trend = recentZone2Avg - earlierZone2Avg;
                const zone3Trend = recentZone3Avg - earlierZone3Avg;

                return {
                    zone1: { recent: recentZone1Avg.toFixed(2), trend: zone1Trend.toFixed(2), status: zone1Trend > 0.2 ? '升温' : (zone1Trend < -0.2 ? '降温' : '平稳') },
                    zone2: { recent: recentZone2Avg.toFixed(2), trend: zone2Trend.toFixed(2), status: zone2Trend > 0.2 ? '升温' : (zone2Trend < -0.2 ? '降温' : '平稳') },
                    zone3: { recent: recentZone3Avg.toFixed(2), trend: zone3Trend.toFixed(2), status: zone3Trend > 0.2 ? '升温' : (zone3Trend < -0.2 ? '降温' : '平稳') }
                };
            }

            static updateThreeZoneConclusion(results) {
                const conclusionContent = document.getElementById('threeZoneConclusionContent');
                if (!conclusionContent) return;

                const phase1Data = results.phase1Data;
                const advancedAnalysis = results.advancedAnalysis;

                let html = '<div class="conclusion-grid">';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-fire" style="color: #E63946;"></i> 热门区间</h4>';
                html += `<p><strong>${results.hotZone.name}</strong> 出号最多，共 ${results.hotZone.count} 个，占比 ${results.hotZone.percent}%</p>`;
                html += '</div>';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-snowflake" style="color: #457B9D;"></i> 冷门区间</h4>';
                html += `<p><strong>${results.coldZone.name}</strong> 出号最少，共 ${results.coldZone.count} 个，占比 ${results.coldZone.percent}%</p>`;
                html += '</div>';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-chart-line" style="color: #F4A261;"></i> 趋势分析</h4>';
                html += `<p>一区：${results.trendAnalysis.zone1.status}（${results.trendAnalysis.zone1.trend > 0 ? '+' : ''}${results.trendAnalysis.zone1.trend}）</p>`;
                html += `<p>二区：${results.trendAnalysis.zone2.status}（${results.trendAnalysis.zone2.trend > 0 ? '+' : ''}${results.trendAnalysis.zone2.trend}）</p>`;
                html += `<p>三区：${results.trendAnalysis.zone3.status}（${results.trendAnalysis.zone3.trend > 0 ? '+' : ''}${results.trendAnalysis.zone3.trend}）</p>`;
                html += '</div>';

                if (advancedAnalysis && advancedAnalysis.zoneBalanceAnalysis) {
                    const balanceData = advancedAnalysis.zoneBalanceAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-balance-scale" style="color: #9B59B6;"></i> 平衡性分析</h4>';
                    html += `<p>平衡评分：<strong>${balanceData.balanceScore}分</strong>（${balanceData.balanceTrend === 'improving' ? '改善中' : balanceData.balanceTrend === 'declining' ? '下降中' : '稳定'}）</p>`;
                    html += `<p>一区平衡：${(balanceData.zone1Balance * 100).toFixed(0)}%</p>`;
                    html += `<p>二区平衡：${(balanceData.zone2Balance * 100).toFixed(0)}%</p>`;
                    html += `<p>三区平衡：${(balanceData.zone3Balance * 100).toFixed(0)}%</p>`;
                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.zonePredictionAnalysis) {
                    const predictionData = advancedAnalysis.zonePredictionAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-magic" style="color: #2ECC71;"></i> 预测分析</h4>';
                    html += `<p>预测组合：<strong>${predictionData.nextCombination}</strong></p>`;
                    html += `<p>置信度：<strong>${predictionData.confidence.toFixed(0)}%</strong></p>`;
                    if (predictionData.predictionReasoning.length > 0) {
                        html += '<p>预测依据：';
                        predictionData.predictionReasoning.forEach(reason => {
                            html += `${reason}；`;
                        });
                        html += '</p>';
                    }
                    html += '</div>';
                }

                if (phase1Data && phase1Data.consecutivePatterns.length > 0) {
                    html += '<div class="conclusion-item full-width">';
                    html += '<h4><i class="fas fa-exchange-alt" style="color: #9B59B6;"></i> 逐期关联分析（阶段1）</h4>';

                    const avgZoneChange = phase1Data.consecutivePatterns.reduce((sum, p) => sum + (p.zone1Change !== 0 || p.zone2Change !== 0 || p.zone3Change !== 0 ? 1 : 0), 0) / phase1Data.consecutivePatterns.length;
                    const stableCount = phase1Data.consecutivePatterns.filter(p => p.zone1Change === 0 && p.zone2Change === 0 && p.zone3Change === 0).length;
                    const stableRatio = (stableCount / phase1Data.consecutivePatterns.length * 100).toFixed(1);

                    html += `<p>相邻期三区组合平均变化：<strong>${avgZoneChange.toFixed(2)}</strong></p>`;
                    html += `<p>三区组合保持不变：<strong>${stableCount}</strong> 次（占比 ${stableRatio}%）</p>`;

                    const topTransitions = Object.entries(phase1Data.zoneTransitions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);

                    if (topTransitions.length > 0) {
                        html += `<p>高频组合转换：`;
                        topTransitions.forEach(([key, count]) => {
                            const [from, to] = key.split('->');
                            html += `<strong>${from}</strong> → <strong>${to}</strong> (${count}次) `;
                        });
                        html += `</p>`;
                    }

                    const sameCombinationStreaks = phase1Data.sameCombinationStreaks;
                    const longestStreak = sameCombinationStreaks.length > 0 ? Math.max(...sameCombinationStreaks.map(s => s.streak)) : 0;
                    if (longestStreak > 1) {
                        html += `<p>最长连续期数：<strong>${longestStreak}</strong> 期（${sameCombinationStreaks.find(s => s.streak === longestStreak)?.combination || '无'}）</p>`;
                    }

                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.zoneOmissionAnalysis) {
                    const omissionData = advancedAnalysis.zoneOmissionAnalysis;
                    html += '<div class="conclusion-item full-width">';
                    html += '<h4><i class="fas fa-clock" style="color: #E74C3C;"></i> 遗漏分析</h4>';

                    const getHighOmissionNumbers = (zone) => {
                        const numbers = Object.values(omissionData[zone]).filter(n => n.currentOmission > n.avgOmission * 1.5);
                        return numbers.sort((a, b) => b.currentOmission - a.currentOmission).slice(0, 3);
                    };

                    const zone1HighOmission = getHighOmissionNumbers('zone1');
                    const zone2HighOmission = getHighOmissionNumbers('zone2');
                    const zone3HighOmission = getHighOmissionNumbers('zone3');

                    if (zone1HighOmission.length > 0) {
                        html += `<p>一区高遗漏号码：${zone1HighOmission.map(n => n.number).join(' ')}</p>`;
                    }
                    if (zone2HighOmission.length > 0) {
                        html += `<p>二区高遗漏号码：${zone2HighOmission.map(n => n.number).join(' ')}</p>`;
                    }
                    if (zone3HighOmission.length > 0) {
                        html += `<p>三区高遗漏号码：${zone3HighOmission.map(n => n.number).join(' ')}</p>`;
                    }

                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.zoneHotColdAnalysis) {
                    const hotColdData = advancedAnalysis.zoneHotColdAnalysis;
                    html += '<div class="conclusion-item full-width">';
                    html += '<h4><i class="fas fa-thermometer-half" style="color: #F39C12;"></i> 冷热分析</h4>';

                    html += `<p>一区热号：${hotColdData.zone1.hot.join(' ')}（${hotColdData.zone1.warm.length}个温号）</p>`;
                    html += `<p>二区热号：${hotColdData.zone2.hot.join(' ')}（${hotColdData.zone2.warm.length}个温号）</p>`;
                    html += `<p>三区热号：${hotColdData.zone3.hot.join(' ')}（${hotColdData.zone3.warm.length}个温号）</p>`;

                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.zoneCycleAnalysis) {
                    const cycleData = advancedAnalysis.zoneCycleAnalysis;
                    html += '<div class="conclusion-item full-width">';
                    html += '<h4><i class="fas fa-sync-alt" style="color: #3498DB;"></i> 周期分析</h4>';

                    const getPatternText = (pattern) => {
                        switch(pattern) {
                            case 'regular': return '规律性强';
                            case 'semi-regular': return '规律性中等';
                            default: return '规律性弱';
                        }
                    };

                    html += `<p>一区周期：${getPatternText(cycleData.zone1.cyclePattern)}（平均周期${cycleData.zone1.avgCycle.toFixed(1)}期）</p>`;
                    html += `<p>二区周期：${getPatternText(cycleData.zone2.cyclePattern)}（平均周期${cycleData.zone2.avgCycle.toFixed(1)}期）</p>`;
                    html += `<p>三区周期：${getPatternText(cycleData.zone3.cyclePattern)}（平均周期${cycleData.zone3.avgCycle.toFixed(1)}期）</p>`;

                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.zonePatternAnalysis) {
                    const patternData = advancedAnalysis.zonePatternAnalysis;
                    html += '<div class="conclusion-item full-width">';
                    html += '<h4><i class="fas fa-puzzle-piece" style="color: #1ABC9C;"></i> 模式分析</h4>';

                    html += '<p>高频组合：';
                    patternData.commonPatterns.forEach(p => {
                        html += `<strong>${p.pattern}</strong>(${p.frequency}%) `;
                    });
                    html += '</p>';

                    if (patternData.patternStreaks.length > 0) {
                        const streak = patternData.patternStreaks[0];
                        html += `<p>最长连续：<strong>${streak.pattern}</strong>（${streak.maxStreak}期）</p>`;
                    }

                    html += '</div>';
                }

                html += '<div class="conclusion-item full-width">';
                html += '<h4><i class="fas fa-trophy" style="color: #FFD700;"></i> 高频三区组合（Top 5）</h4>';
                html += '<table class="combination-table">';
                html += '<thead><tr><th>组合</th><th>出现次数</th><th>占比</th><th>平均AC值</th></tr></thead>';
                html += '<tbody>';

                results.topCombinations.forEach((item, index) => {
                    const acStats = results.combinationACStats[item.combination];
                    const percent = ((item.count / results.totalDraws) * 100).toFixed(1);
                    html += `<tr>
                        <td><span class="rank-badge rank-${index + 1}">${index + 1}</span> ${item.combination}</td>
                        <td>${item.count}次</td>
                        <td>${percent}%</td>
                        <td>${acStats.avgAC}</td>
                    </tr>`;
                });

                html += '</tbody></table>';
                html += '</div>';

                html += '<div class="conclusion-item full-width">';
                html += '<h4><i class="fas fa-lightbulb" style="color: #2A9D8F;"></i> 综合结论</h4>';
                html += `<p>在最近 ${results.totalDraws} 期数据中，${results.hotZone.name} 为热门区间（占比 ${results.hotZone.percent}%），`;
                html += `${results.coldZone.name} 为冷门区间（占比 ${results.coldZone.percent}%）。`;
                html += `高频三区组合为 ${results.topCombinations[0].combination}（出现 ${results.topCombinations[0].count} 次），`;
                html += `该组合对应的平均AC值为 ${results.combinationACStats[results.topCombinations[0].combination].avgAC}。`;
                if (advancedAnalysis && advancedAnalysis.zoneBalanceAnalysis) {
                    html += `三区平衡性评分为${advancedAnalysis.zoneBalanceAnalysis.balanceScore}分，`;
                    html += `${advancedAnalysis.zoneBalanceAnalysis.balanceTrend === 'improving' ? '近期平衡性有所改善' : advancedAnalysis.zoneBalanceAnalysis.balanceTrend === 'declining' ? '近期平衡性有所下降' : '近期平衡性保持稳定'}。`;
                }
                if (advancedAnalysis && advancedAnalysis.zonePredictionAnalysis) {
                    html += `预测下期三区组合为${advancedAnalysis.zonePredictionAnalysis.nextCombination}，`;
                    html += `置信度为${advancedAnalysis.zonePredictionAnalysis.confidence.toFixed(0)}%。`;
                }
                html += '</div>';

                html += '</div>';

                conclusionContent.innerHTML = html;
            }

            static handleGenerateThreeZoneRecommendation() {
                if (!threeZoneChartData || !threeZoneAnalysisResults) {
                    MessageSystem.showMessage('请先进行大中小分析', 'error');
                    return;
                }

                const recommendation = this.generateThreeZoneRecommendation();
                this.displayThreeZoneRecommendation(recommendation);
            }

            static generateThreeZoneRecommendation() {
                const rules = LOTTERY_RULES[currentLotteryType];
                const zoneRanges = rules.threeZoneRanges;

                if (!threeZoneAnalysisResults || !threeZoneAnalysisResults.advancedAnalysis) {
                    MessageSystem.showMessage('请先进行大中小分析', 'error');
                    return null;
                }

                const advancedAnalysis = threeZoneAnalysisResults.advancedAnalysis;
                const predictionData = advancedAnalysis.zonePredictionAnalysis;
                const hotColdData = advancedAnalysis.zoneHotColdAnalysis;
                const omissionData = advancedAnalysis.zoneOmissionAnalysis;
                const balanceData = advancedAnalysis.zoneBalanceAnalysis;

                const targetCombination = predictionData.nextCombination;
                const [zone1Count, zone2Count, zone3Count] = targetCombination.split('-').map(Number);

                const hotZone = threeZoneAnalysisResults.hotZone;
                const coldZone = threeZoneAnalysisResults.coldZone;

                const zone1Pool = [];
                const zone2Pool = [];
                const zone3Pool = [];

                for (let num = zoneRanges.zone1[0]; num <= zoneRanges.zone1[1]; num++) zone1Pool.push(num);
                for (let num = zoneRanges.zone2[0]; num <= zoneRanges.zone2[1]; num++) zone2Pool.push(num);
                for (let num = zoneRanges.zone3[0]; num <= zoneRanges.zone3[1]; num++) zone3Pool.push(num);

                const recommendations = [];
                const maxRecommendations = 5;

                const calculateNumberWeight = (numStr, zone) => {
                    let weight = 1.0;

                    const hotColdInfo = hotColdData[zone];
                    if (hotColdInfo.hot.includes(numStr)) {
                        weight *= 1.3;
                    } else if (hotColdInfo.warm.includes(numStr)) {
                        weight *= 1.1;
                    } else if (hotColdInfo.cold.includes(numStr)) {
                        weight *= 0.9;
                    } else {
                        weight *= 0.7;
                    }

                    const omissionInfo = omissionData[zone][numStr];
                    if (omissionInfo) {
                        const omissionRatio = omissionInfo.currentOmission / (omissionInfo.avgOmission || 1);
                        if (omissionRatio > 1.5) {
                            weight *= 1.4;
                        } else if (omissionRatio > 1.2) {
                            weight *= 1.2;
                        } else if (omissionRatio < 0.5) {
                            weight *= 0.8;
                        }
                    }

                    return weight;
                };

                const getWeightedPool = (pool, zone) => {
                    const weightedPool = [];
                    pool.forEach(num => {
                        const numStr = num.toString().padStart(2, '0');
                        const weight = calculateNumberWeight(numStr, zone);
                        for (let i = 0; i < Math.ceil(weight * 10); i++) {
                            weightedPool.push(num);
                        }
                    });
                    return weightedPool;
                };

                for (let i = 0; i < maxRecommendations * 50 && recommendations.length < maxRecommendations; i++) {
                    const zone1Numbers = [];
                    const zone2Numbers = [];
                    const zone3Numbers = [];

                    const weightedZone1Pool = getWeightedPool(zone1Pool, 'zone1');
                    const weightedZone2Pool = getWeightedPool(zone2Pool, 'zone2');
                    const weightedZone3Pool = getWeightedPool(zone3Pool, 'zone3');

                    const tempZone1Pool = [...weightedZone1Pool];
                    const tempZone2Pool = [...weightedZone2Pool];
                    const tempZone3Pool = [...weightedZone3Pool];

                    for (let j = 0; j < zone1Count && tempZone1Pool.length > 0; j++) {
                        const idx = Math.floor(Math.random() * tempZone1Pool.length);
                        const num = tempZone1Pool.splice(idx, 1)[0];
                        if (!zone1Numbers.includes(num)) {
                            zone1Numbers.push(num);
                        }
                    }

                    for (let j = 0; j < zone2Count && tempZone2Pool.length > 0; j++) {
                        const idx = Math.floor(Math.random() * tempZone2Pool.length);
                        const num = tempZone2Pool.splice(idx, 1)[0];
                        if (!zone2Numbers.includes(num)) {
                            zone2Numbers.push(num);
                        }
                    }

                    for (let j = 0; j < zone3Count && tempZone3Pool.length > 0; j++) {
                        const idx = Math.floor(Math.random() * tempZone3Pool.length);
                        const num = tempZone3Pool.splice(idx, 1)[0];
                        if (!zone3Numbers.includes(num)) {
                            zone3Numbers.push(num);
                        }
                    }

                    const combinedNumbers = [...zone1Numbers, ...zone2Numbers, ...zone3Numbers].sort((a, b) => a - b);

                    if (combinedNumbers.length === rules.redBallCount) {
                        const acValue = this.calculateACValue(combinedNumbers);

                        const isDuplicate = recommendations.some(rec => 
                            rec.numbers.join(',') === combinedNumbers.join(',')
                        );

                        if (!isDuplicate) {
                            recommendations.push({
                                numbers: combinedNumbers,
                                acValue: acValue,
                                combination: targetCombination,
                                zone1Numbers,
                                zone2Numbers,
                                zone3Numbers,
                                score: this.calculateAdvancedRecommendationScore(combinedNumbers, acValue, targetCombination, hotZone, coldZone, advancedAnalysis)
                            });
                        }
                    }
                }

                recommendations.sort((a, b) => b.score - a.score);

                return {
                    targetCombination: targetCombination,
                    hotZone,
                    coldZone,
                    predictionConfidence: predictionData.confidence,
                    balanceScore: balanceData.balanceScore,
                    recommendations: recommendations.slice(0, maxRecommendations)
                };
            }

            static calculateAdvancedRecommendationScore(numbers, acValue, combination, hotZone, coldZone, advancedAnalysis) {
                let score = 0;

                const acLevel = acValue >= 9 ? 5 : (acValue >= 7 ? 4 : (acValue >= 5 ? 3 : (acValue >= 3 ? 2 : 1)));
                score += acLevel * 15;

                const [zone1Count, zone2Count, zone3Count] = combination.split('-').map(Number);
                const total = zone1Count + zone2Count + zone3Count;
                const zone1Percent = zone1Count / total;
                const zone2Percent = zone2Count / total;
                const zone3Percent = zone3Count / total;

                const balanceData = advancedAnalysis.zoneBalanceAnalysis;
                score += balanceData.balanceScore * 0.3;

                const hotColdData = advancedAnalysis.zoneHotColdAnalysis;
                const omissionData = advancedAnalysis.zoneOmissionAnalysis;

                let hotColdBonus = 0;
                let omissionBonus = 0;

                numbers.forEach(num => {
                    const numStr = num.toString().padStart(2, '0');

                    let zone = '';
                    if (num >= 1 && num <= 11) zone = 'zone1';
                    else if (num >= 12 && num <= 22) zone = 'zone2';
                    else zone = 'zone3';

                    if (hotColdData[zone].hot.includes(numStr)) {
                        hotColdBonus += 3;
                    } else if (hotColdData[zone].warm.includes(numStr)) {
                        hotColdBonus += 2;
                    } else if (hotColdData[zone].cold.includes(numStr)) {
                        hotColdBonus += 1;
                    }

                    const omissionInfo = omissionData[zone][numStr];
                    if (omissionInfo) {
                        const omissionRatio = omissionInfo.currentOmission / (omissionInfo.avgOmission || 1);
                        if (omissionRatio > 1.5) {
                            omissionBonus += 4;
                        } else if (omissionRatio > 1.2) {
                            omissionBonus += 3;
                        } else if (omissionRatio > 1.0) {
                            omissionBonus += 2;
                        }
                    }
                });

                score += hotColdBonus;
                score += omissionBonus;

                const balanceScore = 1 - Math.abs(zone1Percent - 0.33) - Math.abs(zone2Percent - 0.33) - Math.abs(zone3Percent - 0.33);
                score += balanceScore * 20;

                const patternData = advancedAnalysis.zonePatternAnalysis;
                const isCommonPattern = patternData.commonPatterns.some(p => p.pattern === combination);
                if (isCommonPattern) {
                    score += 10;
                }

                const cycleData = advancedAnalysis.zoneCycleAnalysis;
                if (cycleData.zone1.cyclePattern === 'regular' || 
                    cycleData.zone2.cyclePattern === 'regular' || 
                    cycleData.zone3.cyclePattern === 'regular') {
                    score += 5;
                }

                return score;
            }

            static displayThreeZoneRecommendation(recommendation) {
                const recommendationContent = document.getElementById('threeZoneRecommendationContent');
                if (!recommendationContent) return;

                if (!recommendation) {
                    recommendationContent.innerHTML = '<div class="no-recommendation"><i class="fas fa-exclamation-circle"></i><p>推荐生成失败，请先进行大中小分析</p></div>';
                    return;
                }

                let html = '<div class="recommendation-summary">';

                html += `<div class="summary-item">`;
                html += `<span class="label">目标三区组合：</span>`;
                html += `<span class="value highlight">${recommendation.targetCombination}</span>`;
                html += `</div>`;

                html += `<div class="summary-item">`;
                html += `<span class="label">热区：</span>`;
                html += `<span class="value hot-zone">${recommendation.hotZone.name}</span>`;
                html += `</div>`;

                html += `<div class="summary-item">`;
                html += `<span class="label">冷区：</span>`;
                html += `<span class="value cold-zone">${recommendation.coldZone.name}</span>`;
                html += `</div>`;

                if (recommendation.predictionConfidence !== undefined) {
                    html += `<div class="summary-item">`;
                    html += `<span class="label">预测置信度：</span>`;
                    html += `<span class="value">${recommendation.predictionConfidence.toFixed(0)}%</span>`;
                    html += `</div>`;
                }

                if (recommendation.balanceScore !== undefined) {
                    html += `<div class="summary-item">`;
                    html += `<span class="label">平衡评分：</span>`;
                    html += `<span class="value">${recommendation.balanceScore.toFixed(0)}分</span>`;
                    html += `</div>`;
                }

                html += `</div>`;

                if (recommendation.recommendations.length > 0) {
                    html += '<div class="recommendation-list">';

                    recommendation.recommendations.forEach((rec, index) => {
                        const scorePercent = Math.min(100, (rec.score / 100) * 100);
                        const acLevel = rec.acValue >= 9 ? '极高' : (rec.acValue >= 7 ? '高' : (rec.acValue >= 5 ? '中' : (rec.acValue >= 3 ? '低' : '极低')));
                        const acColor = rec.acValue >= 9 ? '#FF4757' : (rec.acValue >= 7 ? '#FF6B81' : (rec.acValue >= 5 ? '#FFA502' : (rec.acValue >= 3 ? '#2ED573' : '#1E90FF')));

                        html += '<div class="recommendation-card">';
                        html += `<div class="card-header">`;
                        html += `<span class="card-title">推荐 ${index + 1}</span>`;
                        html += `<span class="card-ac" style="background-color: ${acColor};">AC值: ${rec.acValue} <span class="ac-level">${acLevel}</span></span>`;
                        html += `</div>`;

                        html += '<div class="card-body">';

                        html += '<div class="number-display">';
                        rec.numbers.forEach(num => {
                            html += `<span class="number-ball red">${num.toString().padStart(2, '0')}</span>`;
                        });
                        html += '</div>';

                        html += '<div class="recommendation-score">';
                        html += `<div class="score-label">推荐评分</div>`;
                        html += `<div class="score-bar">`;
                        html += `<div class="score-fill" style="width: ${scorePercent}%; background: linear-gradient(90deg, #3498db, #2ecc71);"></div>`;
                        html += `<span class="score-value">${rec.score.toFixed(1)}</span>`;
                        html += `</div>`;
                        html += `</div>`;

                        html += '<div class="zone-breakdown">';
                        html += `<div class="zone-item zone1">`;
                        html += `<span class="zone-label">一区：</span>`;
                        html += `<span class="zone-numbers">${rec.zone1Numbers.map(n => n.toString().padStart(2, '0')).join(' ')}</span>`;
                        html += `<span class="zone-count">${rec.zone1Numbers.length}个</span>`;
                        html += `</div>`;

                        html += `<div class="zone-item zone2">`;
                        html += `<span class="zone-label">二区：</span>`;
                        html += `<span class="zone-numbers">${rec.zone2Numbers.map(n => n.toString().padStart(2, '0')).join(' ')}</span>`;
                        html += `<span class="zone-count">${rec.zone2Numbers.length}个</span>`;
                        html += `</div>`;

                        html += `<div class="zone-item zone3">`;
                        html += `<span class="zone-label">三区：</span>`;
                        html += `<span class="zone-numbers">${rec.zone3Numbers.map(n => n.toString().padStart(2, '0')).join(' ')}</span>`;
                        html += `<span class="zone-count">${rec.zone3Numbers.length}个</span>`;
                        html += `</div>`;
                        html += '</div>';

                        html += '<div class="recommendation-details">';
                        html += `<div class="detail-item">`;
                        html += `<i class="fas fa-chart-line"></i>`;
                        html += `<span>组合类型：${rec.combination}</span>`;
                        html += `</div>`;
                        html += `<div class="detail-item">`;
                        html += `<i class="fas fa-star"></i>`;
                        html += `<span>综合评分：${rec.score.toFixed(1)}/100</span>`;
                        html += `</div>`;
                        html += `</div>`;

                        html += '</div>';
                        html += '</div>';
                    });

                    html += '</div>';
                } else {
                    html += '<div class="no-recommendation">';
                    html += '<i class="fas fa-exclamation-circle"></i>';
                    html += '<p>未找到符合条件的高质量推荐号码，请尝试调整目标组合或AC值区间</p>';
                    html += '</div>';
                }

                recommendationContent.innerHTML = html;
            }

            static setupChartLinkage() {
                if (!acValueChartData || !threeZoneChartData) {
                    MessageSystem.showMessage('请先完成AC值分析和大中小分析', 'error');
                    return;
                }

                this.setupACValueChartClickEvents();
                this.setupThreeZoneChartClickEvents();
                this.setupCombinationFiltering();

                MessageSystem.showMessage('图表联动功能已启用', 'success');
            }

            static setupACValueChartClickEvents() {
                const acValueChartDom = document.getElementById('acValueChart');
                if (!acValueChartDom) return;

                const acValueChart = echarts.getInstanceByDom(acValueChartDom);
                if (!acValueChart) return;

                acValueChart.off('click');
                acValueChart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const acValue = params.name;
                        EventDelegate.filterThreeZoneDataByACValue(acValue);
                    }
                });
            }

            static setupThreeZoneChartClickEvents() {
                const threeZoneChartDom = document.getElementById('threeZoneChart');
                if (!threeZoneChartDom) return;

                const threeZoneChart = echarts.getInstanceByDom(threeZoneChartDom);
                if (!threeZoneChart) return;

                threeZoneChart.off('click');
                threeZoneChart.on('click', function(params) {
                    if (params.componentType === 'series') {
                        const combination = params.name;
                        EventDelegate.filterACValueDataByCombination(combination);
                    }
                });
            }

            static filterThreeZoneDataByACValue(acValue) {
                if (!threeZoneChartData || !threeZoneChartData.acValueCorrelation) {
                    MessageSystem.showMessage('大中小分析数据不存在', 'error');
                    return;
                }

                const filteredData = threeZoneChartData.acValueCorrelation.filter(
                    item => item.acValue === parseInt(acValue)
                );

                if (filteredData.length === 0) {
                    MessageSystem.showMessage(`AC值 ${acValue} 没有对应的三区数据`, 'warning');
                    return;
                }

                const filteredThreeZoneData = {
                    zone1Count: 0,
                    zone2Count: 0,
                    zone3Count: 0,
                    trend: [],
                    combinations: {},
                    acValueCorrelation: filteredData
                };

                filteredData.forEach(item => {
                    filteredThreeZoneData.zone1Count += item.zone1;
                    filteredThreeZoneData.zone2Count += item.zone2;
                    filteredThreeZoneData.zone3Count += item.zone3;

                    const combination = item.combination;
                    filteredThreeZoneData.combinations[combination] = (filteredThreeZoneData.combinations[combination] || 0) + 1;

                    filteredThreeZoneData.trend.push({
                        period: item.period,
                        zone1: item.zone1,
                        zone2: item.zone2,
                        zone3: item.zone3,
                        combination: combination
                    });
                });

                const filteredResults = this.generateThreeZoneAnalysisResults(filteredThreeZoneData, filteredData.length);

                this.updateThreeZoneChart(filteredThreeZoneData);
                this.updateThreeZoneConclusion(filteredResults);

                MessageSystem.showMessage(`已筛选AC值 ${acValue} 的三区数据，共 ${filteredData.length} 期`, 'success');
            }

            static filterACValueDataByCombination(combination) {
                if (!threeZoneChartData || !threeZoneChartData.acValueCorrelation) {
                    MessageSystem.showMessage('大中小分析数据不存在', 'error');
                    return;
                }

                const filteredData = threeZoneChartData.acValueCorrelation.filter(
                    item => item.combination === combination
                );

                if (filteredData.length === 0) {
                    MessageSystem.showMessage(`三区组合 ${combination} 没有对应的AC值数据`, 'warning');
                    return;
                }

                const filteredACValueData = {
                    statistics: {
                        total: filteredData.length,
                        valueCounts: {},
                        average: 0,
                        median: 0,
                        mode: 0,
                        min: 0,
                        max: 0,
                        stdDev: 0
                    },
                    trend: [],
                    distribution: {}
                };

                const acValues = filteredData.map(item => item.acValue);

                acValues.forEach(acValue => {
                    filteredACValueData.statistics.valueCounts[acValue] = 
                        (filteredACValueData.statistics.valueCounts[acValue] || 0) + 1;
                });

                const sortedACValues = acValues.sort((a, b) => a - b);
                const sum = sortedACValues.reduce((acc, val) => acc + val, 0);

                filteredACValueData.statistics.average = (sum / sortedACValues.length).toFixed(2);
                filteredACValueData.statistics.min = sortedACValues[0];
                filteredACValueData.statistics.max = sortedACValues[sortedACValues.length - 1];
                filteredACValueData.statistics.median = sortedACValues[Math.floor(sortedACValues.length / 2)];

                const modeMap = {};
                let maxCount = 0;
                sortedACValues.forEach(acValue => {
                    modeMap[acValue] = (modeMap[acValue] || 0) + 1;
                    if (modeMap[acValue] > maxCount) {
                        maxCount = modeMap[acValue];
                        filteredACValueData.statistics.mode = acValue;
                    }
                });

                const variance = sortedACValues.reduce((acc, val) => 
                    acc + Math.pow(val - filteredACValueData.statistics.average, 2), 0) / sortedACValues.length;
                filteredACValueData.statistics.stdDev = Math.sqrt(variance).toFixed(2);

                filteredData.forEach(item => {
                    filteredACValueData.trend.push({
                        period: item.period,
                        value: item.acValue
                    });
                });

                this.updateAcValueChart(filteredACValueData);

                MessageSystem.showMessage(`已筛选三区组合 ${combination} 的AC值数据，共 ${filteredData.length} 期`, 'success');
            }

            static setupCombinationFiltering() {
                const combinationSelect = document.getElementById('threeZoneTargetCombination');
                if (!combinationSelect) return;

                if (!threeZoneAnalysisResults || !threeZoneAnalysisResults.topCombinations) {
                    return;
                }

                combinationSelect.innerHTML = '<option value="">自动选择高频组合</option>';

                threeZoneAnalysisResults.topCombinations.forEach(combo => {
                    const option = document.createElement('option');
                    option.value = combo.combination;
                    option.textContent = `${combo.combination} (出现 ${combo.count} 次)`;
                    combinationSelect.appendChild(option);
                });

                combinationSelect.addEventListener('change', function() {
                    const selectedCombination = this.value;
                    if (selectedCombination) {
                        EventDelegate.filterACValueDataByCombination(selectedCombination);
                    }
                });
            }

            static generateLinkageReport() {
                if (!acValueChartData || !threeZoneChartData || !threeZoneAnalysisResults) {
                    MessageSystem.showMessage('请先完成AC值分析和大中小分析', 'error');
                    return;
                }

                const report = {
                    generatedAt: new Date().toLocaleString(),
                    lotteryType: currentLotteryType,
                    analysisPeriod: currentThreeZonePeriod,
                    acValueSummary: {
                        average: acValueChartData.statistics.mean,
                        median: acValueChartData.statistics.median,
                        mode: acValueChartData.statistics.mostFrequent.value,
                        min: Math.min(...acValueChartData.values),
                        max: Math.max(...acValueChartData.values)
                    },
                    threeZoneSummary: {
                        hotZone: threeZoneAnalysisResults.hotZone,
                        coldZone: threeZoneAnalysisResults.coldZone,
                        topCombinations: threeZoneAnalysisResults.topCombinations.slice(0, 3)
                    },
                    correlation: this.generateCorrelationAnalysis()
                };

                this.displayLinkageReport(report);
            }

            static generateCorrelationAnalysis() {
                const correlation = {
                    highACCombinations: [],
                    lowACCombinations: [],
                    insights: []
                };

                const avgAC = parseFloat(acValueChartData.statistics.mean);

                if (!threeZoneAnalysisResults.combinationACStats) {
                    correlation.insights.push('暂无三区组合AC值统计数据');
                    return correlation;
                }

                Object.entries(threeZoneAnalysisResults.combinationACStats).forEach(([combination, stats]) => {
                    const avgCombinationAC = parseFloat(stats.avgAC);
                    if (avgCombinationAC >= avgAC) {
                        correlation.highACCombinations.push({
                            combination,
                            avgAC: avgCombinationAC,
                            count: stats.count
                        });
                    } else {
                        correlation.lowACCombinations.push({
                            combination,
                            avgAC: avgCombinationAC,
                            count: stats.count
                        });
                    }
                });

                correlation.highACCombinations.sort((a, b) => b.count - a.count);
                correlation.lowACCombinations.sort((a, b) => b.count - a.count);

                if (threeZoneAnalysisResults.hotZone && threeZoneAnalysisResults.topCombinations && threeZoneAnalysisResults.topCombinations[0]) {
                    correlation.insights.push(
                        `平均AC值为 ${avgAC.toFixed(2)}，${threeZoneAnalysisResults.hotZone.name} 为热门区间`,
                        `高频三区组合 ${threeZoneAnalysisResults.topCombinations[0].combination} 对应的平均AC值为 ${threeZoneAnalysisResults.combinationACStats[threeZoneAnalysisResults.topCombinations[0].combination].avgAC}`,
                        `建议选择热门区间 ${threeZoneAnalysisResults.hotZone.name} 中的号码，并关注AC值在 ${Math.floor(avgAC - 1)}-${Math.ceil(avgAC + 1)} 区间的组合`
                    );
                } else {
                    correlation.insights.push(`平均AC值为 ${avgAC.toFixed(2)}`);
                }

                return correlation;
            }

            static performFollowUpAnalysis() {
                const draws = currentDatabaseData.draws || [];
                if (draws.length === 0) {
                    MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                    return;
                }

                const period = currentFollowUpPeriod !== 'all' ? currentFollowUpPeriod : draws.length;
                const analysisDraws = period !== 'all' ? draws.slice(-period) : draws;

                followUpAnalysisResults = {
                    scatter: EventDelegate.calculateScatterAnalysis(analysisDraws),
                    bias: EventDelegate.calculateBiasAnalysis(analysisDraws),
                    amplitude: EventDelegate.calculateAmplitudeAnalysis(analysisDraws),
                    follow: EventDelegate.calculateFollowAnalysis(analysisDraws),
                    repeatAdjacent: EventDelegate.calculateRepeatAdjacentAnalysis(analysisDraws),
                    dragonPhoenix: EventDelegate.calculateDragonPhoenixAnalysis(analysisDraws)
                };

                followUpChartData = followUpAnalysisResults;

                const firstDraw = analysisDraws[0];
                const lastDraw = analysisDraws[analysisDraws.length - 1];
                document.getElementById('followUpDataRangeInfo').textContent = `分析范围：${firstDraw.period} - ${lastDraw.period}（共${analysisDraws.length}期）`;

                const followAnalysisResult = followUpAnalysisResults.follow;
                const statistics = EventDelegate.calculateFollowStatistics(followAnalysisResult);
                const currentDraw = draws[draws.length - 1];
                const followMatrix = followAnalysisResult.redFollowMatrix || followAnalysisResult;
                const recommendations = EventDelegate.generateFollowRecommendations(followMatrix, currentDraw);

                currentFollowUpData = {
                    followAnalysisResult: followAnalysisResult,
                    statistics: statistics,
                    recommendations: recommendations
                };

                EventDelegate.displayFollowResults(followAnalysisResult, statistics, recommendations);
                EventDelegate.updateFollowHeatmap(followAnalysisResult);

                EventDelegate.updateFollowUpChart(followUpChartData);
                EventDelegate.generateFollowUpConclusion(followUpChartData);

                const followUpResultsElement = document.getElementById('followUpAnalysisResults');
                if (followUpResultsElement) {
                    followUpResultsElement.style.display = 'block';
                }

                MessageSystem.showMessage(`已完成${analysisDraws.length}期数据的跟随分析`, 'success');
            }

            static performOptimizedFollowUpAnalysis() {
                const draws = currentDatabaseData.draws || [];
                if (draws.length === 0) {
                    MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                    return;
                }

                const windowPeriod = document.getElementById('followWindowPeriod').value;
                const minCount = parseInt(document.getElementById('followMinCount').value);
                const minProbability = parseInt(document.getElementById('followMinProbability').value) / 100;
                const enableOmissionCheck = document.getElementById('followOmissionCheck').value === 'enabled';
                const enableColdHotCheck = document.getElementById('followColdHotCheck').value === 'enabled';
                const enableAdjacentCheck = document.getElementById('followAdjacentCheck').value === 'enabled';
                const seedNumberCount = parseInt(document.getElementById('seedNumberCount').value);
                const finalFocusCount = parseInt(document.getElementById('finalFocusCount').value);
                const enableThreePeriodCheck = document.getElementById('followThreePeriodCheck').value === 'enabled';

                const windowDraws = windowPeriod !== 'all' ? draws.slice(-parseInt(windowPeriod)) : draws;

                const optimizedFollowMatrix = EventDelegate.calculateOptimizedFollowAnalysis(
                    windowDraws, minCount, minProbability, 
                    enableOmissionCheck, enableColdHotCheck, enableAdjacentCheck,
                    enableThreePeriodCheck, draws
                );

                const seedNumbers = EventDelegate.getSeedNumbers();
                const comprehensiveScores = EventDelegate.calculateComprehensiveScores(
                    optimizedFollowMatrix, seedNumbers, windowDraws, 
                    enableOmissionCheck, enableColdHotCheck, enableAdjacentCheck,
                    finalFocusCount
                );

                EventDelegate.displayComprehensiveScores(comprehensiveScores);

                MessageSystem.showMessage(`已完成优化跟随分析，共${comprehensiveScores.length}个候选号码`, 'success');
            }

            static calculateOptimizedFollowAnalysis(draws, minCount, minProbability, 
                enableOmissionCheck, enableColdHotCheck, enableAdjacentCheck,
                enableThreePeriodCheck, allDraws) {
                
                const followMatrix = {};
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    const currentBalls = currentDraw.redBalls.map(b => parseInt(b));
                    const nextBalls = nextDraw.redBalls.map(b => parseInt(b));

                    currentBalls.forEach(currentNum => {
                        const currentNumStr = currentNum.toString().padStart(2, '0');

                        if (!followMatrix[currentNumStr]) {
                            followMatrix[currentNumStr] = {
                                totalAppearances: 0,
                                follows: {},
                                threePeriodChain: {}
                            };
                        }
                        followMatrix[currentNumStr].totalAppearances++;

                        nextBalls.forEach(nextNum => {
                            if (nextNum === currentNum) {
                                return;
                            }
                            const nextNumStr = nextNum.toString().padStart(2, '0');

                            if (!followMatrix[currentNumStr].follows[nextNumStr]) {
                                followMatrix[currentNumStr].follows[nextNumStr] = {
                                    count: 0,
                                    probability: 0,
                                    confidence: 0,
                                    strength: 0
                                };
                            }
                            followMatrix[currentNumStr].follows[nextNumStr].count++;
                        });
                    });
                }

                for (const sourceNum in followMatrix) {
                    const sourceData = followMatrix[sourceNum];
                    const totalFollows = sourceData.totalAppearances;

                    for (const targetNum in sourceData.follows) {
                        const followData = sourceData.follows[targetNum];
                        const count = followData.count;

                        if (count < minCount) {
                            followData.valid = false;
                            continue;
                        }

                        followData.probability = count / totalFollows;

                        if (followData.probability < minProbability) {
                            followData.valid = false;
                            continue;
                        }

                        followData.valid = true;

                        const sampleSize = totalFollows;
                        const expectedCount = sampleSize * (1 / (redBallRange[1] - redBallRange[0] + 1));
                        const standardDeviation = Math.sqrt(sampleSize * (1 / (redBallRange[1] - redBallRange[0] + 1)) * (1 - (1 / (redBallRange[1] - redBallRange[0] + 1))));
                        
                        if (standardDeviation > 0) {
                            const zScore = (count - expectedCount) / standardDeviation;
                            followData.confidence = Math.min(1, Math.max(0, (zScore + 3) / 6));
                        } else {
                            followData.confidence = 0.5;
                        }

                        followData.strength = followData.probability * followData.confidence;
                    }
                }

                if (enableThreePeriodCheck) {
                    for (let i = 0; i < draws.length - 2; i++) {
                        const drawA = draws[i];
                        const drawB = draws[i + 1];
                        const drawC = draws[i + 2];

                        const ballsA = drawA.redBalls.map(b => parseInt(b));
                        const ballsB = drawB.redBalls.map(b => parseInt(b));
                        const ballsC = drawC.redBalls.map(b => parseInt(b));

                        ballsA.forEach(numA => {
                            const numAStr = numA.toString().padStart(2, '0');
                            
                            if (!followMatrix[numAStr].threePeriodChain) {
                                followMatrix[numAStr].threePeriodChain = {};
                            }

                            ballsB.forEach(numB => {
                                const numBStr = numB.toString().padStart(2, '0');
                                
                                if (!followMatrix[numAStr].threePeriodChain[numBStr]) {
                                    followMatrix[numAStr].threePeriodChain[numBStr] = {};
                                }

                                ballsC.forEach(numC => {
                                    const numCStr = numC.toString().padStart(2, '0');
                                    
                                    if (!followMatrix[numAStr].threePeriodChain[numBStr][numCStr]) {
                                        followMatrix[numAStr].threePeriodChain[numBStr][numCStr] = {
                                            count: 0,
                                            strength: 0
                                        };
                                    }
                                    followMatrix[numAStr].threePeriodChain[numBStr][numCStr].count++;
                                });
                            });
                        });
                    }

                    for (const sourceNum in followMatrix) {
                        for (const midNum in followMatrix[sourceNum].threePeriodChain) {
                            for (const targetNum in followMatrix[sourceNum].threePeriodChain[midNum]) {
                                const chainData = followMatrix[sourceNum].threePeriodChain[midNum][targetNum];
                                const chainStrength = chainData.count / (draws.length - 2);
                                
                                if (chainStrength > 0.05) {
                                    if (followMatrix[sourceNum].follows[targetNum]) {
                                        followMatrix[sourceNum].follows[targetNum].threePeriodStrength = chainStrength;
                                        followMatrix[sourceNum].follows[targetNum].strength = Math.max(
                                            followMatrix[sourceNum].follows[targetNum].strength,
                                            chainStrength * 0.8
                                        );
                                    }
                                }
                            }
                        }
                    }
                }

                return followMatrix;
            }

            static getSeedNumbers() {
                const seedNumbers = [];
                const container = document.getElementById('seedNumbersContainer');
                const selectedBalls = container.querySelectorAll('.seed-ball.selected');
                
                selectedBalls.forEach(ball => {
                    seedNumbers.push(parseInt(ball.textContent));
                });

                return seedNumbers;
            }

            static calculateComprehensiveScores(followMatrix, seedNumbers, draws, 
                enableOmissionCheck, enableColdHotCheck, enableAdjacentCheck,
                finalFocusCount) {
                
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                const currentDraw = draws[draws.length - 1];
                const currentBalls = currentDraw.redBalls.map(b => parseInt(b));

                const omissionData = EventDelegate.calculateOmissionData(draws, redBallRange);
                const hotColdData = EventDelegate.calculateHotColdData(draws, redBallRange);

                const candidateScores = {};

                const sourceNums = seedNumbers.length > 0 ? seedNumbers : currentBalls;

                sourceNums.forEach(sourceNum => {
                    const sourceNumStr = sourceNum.toString().padStart(2, '0');
                    
                    if (followMatrix[sourceNumStr]) {
                        const follows = followMatrix[sourceNumStr].follows;
                        
                        for (const targetNumStr in follows) {
                            const followData = follows[targetNumStr];
                            
                            if (!followData.valid) {
                                continue;
                            }

                            const targetNum = parseInt(targetNumStr);
                            
                            if (!candidateScores[targetNumStr]) {
                                candidateScores[targetNumStr] = {
                                    num: targetNumStr,
                                    totalScore: 0,
                                    followScore: 0,
                                    omissionScore: 0,
                                    adjacentScore: 0,
                                    hotScore: 0,
                                    threePeriodScore: 0,
                                    reasons: []
                                };
                            }

                            const score = candidateScores[targetNumStr];

                            score.followScore = followData.strength * 3;
                            score.totalScore += score.followScore;
                            score.reasons.push(`直接跟随概率高（强度${followData.strength.toFixed(3)}）`);

                            if (enableOmissionCheck && omissionData[targetNum]) {
                                const avgOmission = omissionData[targetNum].avg;
                                const currentOmission = omissionData[targetNum].current;
                                
                                if (currentOmission > avgOmission) {
                                    score.omissionScore = 2;
                                    score.totalScore += score.omissionScore;
                                    score.reasons.push(`遗漏值高（${currentOmission} > 平均${avgOmission.toFixed(1)}）`);
                                }
                            }

                            if (enableAdjacentCheck) {
                                const isAdjacent = currentBalls.some(ball => Math.abs(ball - targetNum) === 1);
                                const isGap = currentBalls.some(ball => Math.abs(ball - targetNum) === 2);
                                
                                if (isAdjacent) {
                                    score.adjacentScore = 2;
                                    score.totalScore += score.adjacentScore;
                                    score.reasons.push('是上期号码的邻号');
                                } else if (isGap) {
                                    score.adjacentScore = 1;
                                    score.totalScore += score.adjacentScore;
                                    score.reasons.push('是上期号码的隔号');
                                }
                            }

                            if (enableColdHotCheck) {
                                const sourceHot = hotColdData[sourceNum].status === 'hot';
                                const targetHot = hotColdData[targetNum].status === 'hot';
                                const targetCold = hotColdData[targetNum].status === 'cold';
                                
                                if (sourceHot && targetHot) {
                                    score.hotScore = 1;
                                    score.totalScore += score.hotScore;
                                    score.reasons.push('热跟随（源和目标都是热号）');
                                } else if (sourceHot && targetCold) {
                                    score.hotScore = 2;
                                    score.totalScore += score.hotScore;
                                    score.reasons.push('冷号激活（热号带动冷号）');
                                }
                            }

                            if (followData.threePeriodStrength) {
                                score.threePeriodScore = 1;
                                score.totalScore += score.threePeriodScore;
                                score.reasons.push('三周期验证通过（A→C→B）');
                            }
                        }
                    }
                });

                const sortedCandidates = Object.values(candidateScores)
                    .sort((a, b) => b.totalScore - a.totalScore)
                    .slice(0, finalFocusCount);

                return sortedCandidates;
            }

            static calculateOmissionData(draws, redBallRange) {
                const omissionData = {};
                
                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    omissionData[numStr] = {
                        omissions: [],
                        current: 0,
                        avg: 0
                    };
                }

                for (let i = draws.length - 1; i >= 0; i--) {
                    const draw = draws[i];
                    const balls = draw.redBalls.map(b => parseInt(b));
                    
                    for (let j = redBallRange[0]; j <= redBallRange[1]; j++) {
                        const numStr = j.toString().padStart(2, '0');
                        
                        if (!balls.includes(j)) {
                            omissionData[numStr].current++;
                        } else {
                            omissionData[numStr].omissions.push(omissionData[numStr].current);
                            omissionData[numStr].current = 0;
                        }
                    }
                }

                for (const numStr in omissionData) {
                    const omissions = omissionData[numStr].omissions;
                    if (omissions.length > 0) {
                        const sum = omissions.reduce((a, b) => a + b, 0);
                        omissionData[numStr].avg = sum / omissions.length;
                    }
                }

                return omissionData;
            }

            static calculateHotColdData(draws, redBallRange) {
                const hotColdData = {};
                const recentDraws = draws.slice(-50);
                const numberCounts = {};

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    numberCounts[numStr] = 0;
                }

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        numberCounts[ball]++;
                    });
                });

                const totalDraws = recentDraws.length;
                const avgAppearance = (totalDraws * 6) / (redBallRange[1] - redBallRange[0] + 1);

                for (const numStr in numberCounts) {
                    const count = numberCounts[numStr];
                    const ratio = count / totalDraws;
                    
                    if (ratio > avgAppearance * 1.3) {
                        hotColdData[numStr] = { status: 'hot', count, ratio };
                    } else if (ratio < avgAppearance * 0.7) {
                        hotColdData[numStr] = { status: 'cold', count, ratio };
                    } else {
                        hotColdData[numStr] = { status: 'normal', count, ratio };
                    }
                }

                return hotColdData;
            }

            static displayComprehensiveScores(scores) {
                const section = document.getElementById('comprehensiveScoreSection');
                const tableBody = document.getElementById('comprehensiveScoreTableBody');
                
                section.style.display = 'block';
                
                tableBody.innerHTML = scores.map((score, index) => {
                    return `
                        <tr>
                            <td>${index + 1}</td>
                            <td><span style="display: inline-block; width: 35px; height: 35px; line-height: 35px; text-align: center; border-radius: 50%; background-color: #E63946; color: white; font-weight: bold; font-size: 14px;">${score.num}</span></td>
                            <td><span style="color: #E63946; font-weight: bold; font-size: 16px;">${score.totalScore.toFixed(1)}</span></td>
                            <td>${score.followScore.toFixed(1)}</td>
                            <td>${score.omissionScore > 0 ? '+' + score.omissionScore : '-'}</td>
                            <td>${score.adjacentScore > 0 ? '+' + score.adjacentScore : '-'}</td>
                            <td>${score.hotScore > 0 ? '+' + score.hotScore : '-'}</td>
                            <td>${score.threePeriodScore > 0 ? '+' + score.threePeriodScore : '-'}</td>
                            <td><small style="color: #666;">${score.reasons.join('；')}</small></td>
                        </tr>
                    `;
                }).join('');
            }

            static generateSeedNumbersUI() {
                const container = document.getElementById('seedNumbersContainer');
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                let html = '';
                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    html += `
                        <div class="seed-ball" data-num="${numStr}" style="
                            width: 40px;
                            height: 40px;
                            line-height: 40px;
                            text-align: center;
                            border-radius: 50%;
                            background-color: #e9ecef;
                            color: #333;
                            font-weight: bold;
                            cursor: pointer;
                            transition: all 0.3s;
                            border: 2px solid #dee2e6;
                        ">
                            ${numStr}
                        </div>
                    `;
                }
                container.innerHTML = html;

                const seedBalls = container.querySelectorAll('.seed-ball');
                seedBalls.forEach(ball => {
                    ball.addEventListener('click', function() {
                        this.classList.toggle('selected');
                        if (this.classList.contains('selected')) {
                            this.style.backgroundColor = '#E63946';
                            this.style.color = 'white';
                            this.style.borderColor = '#E63946';
                        } else {
                            this.style.backgroundColor = '#e9ecef';
                            this.style.color = '#333';
                            this.style.borderColor = '#dee2e6';
                        }
                    });
                });
            }

            static autoSelectSeedNumbers() {
                const draws = currentDatabaseData.draws || [];
                if (draws.length === 0) {
                    MessageSystem.showMessage('没有可分析的数据', 'error');
                    return;
                }

                const seedNumberCount = parseInt(document.getElementById('seedNumberCount').value);
                const recentDraws = draws.slice(-50);
                const numberCounts = {};
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    numberCounts[numStr] = 0;
                }

                recentDraws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        numberCounts[ball]++;
                    });
                });

                const sortedNumbers = Object.entries(numberCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, seedNumberCount)
                    .map(entry => entry[0]);

                const seedBalls = document.querySelectorAll('.seed-ball');
                seedBalls.forEach(ball => {
                    ball.classList.remove('selected');
                    ball.style.backgroundColor = '#e9ecef';
                    ball.style.color = '#333';
                    ball.style.borderColor = '#dee2e6';

                    if (sortedNumbers.includes(ball.dataset.num)) {
                        ball.classList.add('selected');
                        ball.style.backgroundColor = '#E63946';
                        ball.style.color = 'white';
                        ball.style.borderColor = '#E63946';
                    }
                });

                MessageSystem.showMessage(`已智能推荐${seedNumberCount}个种子号码`, 'success');
            }

            static clearSeedNumbers() {
                const seedBalls = document.querySelectorAll('.seed-ball');
                seedBalls.forEach(ball => {
                    ball.classList.remove('selected');
                    ball.style.backgroundColor = '#e9ecef';
                    ball.style.color = '#333';
                    ball.style.borderColor = '#dee2e6';
                });

                MessageSystem.showMessage('已清空种子号码', 'success');
            }

            static calculateScatterAnalysis(draws) {
                const scatterData = [];
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const isRed = true;

                draws.forEach(draw => {
                    const balls = isRed ? draw.redBalls : draw.blueBalls;
                    const numbers = balls.map(b => parseInt(b));

                    let totalDiff = 0;
                    let diffCount = 0;

                    for (let i = 0; i < numbers.length; i++) {
                        for (let j = i + 1; j < numbers.length; j++) {
                            totalDiff += Math.abs(numbers[i] - numbers[j]);
                            diffCount++;
                        }
                    }

                    const avgDiff = diffCount > 0 ? totalDiff / diffCount : 0;

                    scatterData.push({
                        period: draw.period,
                        numbers: numbers,
                        scatter: avgDiff.toFixed(2),
                        maxDiff: Math.max(...numbers) - Math.min(...numbers)
                    });
                });

                const avgScatter = scatterData.reduce((sum, d) => sum + parseFloat(d.scatter), 0) / scatterData.length;

                return {
                    data: scatterData,
                    average: avgScatter.toFixed(2),
                    max: Math.max(...scatterData.map(d => parseFloat(d.scatter))),
                    min: Math.min(...scatterData.map(d => parseFloat(d.scatter)))
                };
            }

            static calculateBiasAnalysis(draws) {
                const biasData = {
                    sumBias: [],
                    zoneBias: []
                };

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];

                draws.forEach(draw => {
                    const balls = draw.redBalls.map(b => parseInt(b));
                    const sum = balls.reduce((a, b) => a + b, 0);

                    biasData.sumBias.push({
                        period: draw.period,
                        sum: sum,
                        deviation: sum - 102
                    });
                });

                const avgSum = biasData.sumBias.reduce((sum, d) => sum + d.sum, 0) / biasData.sumBias.length;

                biasData.sumBias.forEach(d => {
                    d.avg = avgSum;
                    d.status = d.sum > avgSum ? '高于均值' : (d.sum < avgSum ? '低于均值' : '持平');
                });

                const zoneRanges = {
                    zone1: [1, 11],
                    zone2: [12, 22],
                    zone3: [23, 33]
                };

                const zoneCounts = { zone1: 0, zone2: 0, zone3: 0 };

                draws.forEach(draw => {
                    draw.redBalls.forEach(ball => {
                        const num = parseInt(ball);
                        if (num >= zoneRanges.zone1[0] && num <= zoneRanges.zone1[1]) {
                            zoneCounts.zone1++;
                        } else if (num >= zoneRanges.zone2[0] && num <= zoneRanges.zone2[1]) {
                            zoneCounts.zone2++;
                        } else if (num >= zoneRanges.zone3[0] && num <= zoneRanges.zone3[1]) {
                            zoneCounts.zone3++;
                        }
                    });
                });

                const totalBalls = draws.length * 6;
                const expectedPerZone = totalBalls / 3;

                Object.keys(zoneCounts).forEach(zone => {
                    biasData.zoneBias.push({
                        zone: zone,
                        count: zoneCounts[zone],
                        expected: expectedPerZone.toFixed(0),
                        deviation: zoneCounts[zone] - expectedPerZone,
                        status: zoneCounts[zone] > expectedPerZone ? '亢奋' : (zoneCounts[zone] < expectedPerZone ? '亏损' : '正常')
                    });
                });

                return biasData;
            }

            static calculateAmplitudeAnalysis(draws) {
                const amplitudeData = {};
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];

                const ballNumbers = [];
                for (let i = rules.redBallRange[0]; i <= rules.redBallRange[1]; i++) {
                    ballNumbers.push(i);
                }

                ballNumbers.forEach(num => {
                    const numStr = num.toString().padStart(2, '0');
                    const appearances = [];
                    let lastOmission = 0;

                    for (let i = 0; i < draws.length; i++) {
                        const draw = draws[i];
                        const balls = draw.redBalls.map(b => parseInt(b));

                        if (balls.includes(num)) {
                            appearances.push({
                                period: draw.period,
                                omission: lastOmission
                            });
                            lastOmission = 0;
                        } else {
                            lastOmission++;
                        }
                    }

                    const amplitudes = [];
                    for (let i = 1; i < appearances.length; i++) {
                        const amp = Math.abs(appearances[i].omission - appearances[i - 1].omission);
                        amplitudes.push(amp);
                    }

                    const avgAmplitude = amplitudes.length > 0 ? amplitudes.reduce((sum, a) => sum + a, 0) / amplitudes.length : 0;
                    const maxAmplitude = amplitudes.length > 0 ? Math.max(...amplitudes) : 0;
                    const minAmplitude = amplitudes.length > 0 ? Math.min(...amplitudes) : 0;
                    const stability = amplitudes.length > 0 ? (1 - (Math.max(...amplitudes) - Math.min(...amplitudes)) / Math.max(...amplitudes) * 10) : 0;

                    amplitudeData[numStr] = {
                        number: numStr,
                        appearances: appearances.length,
                        avgAmplitude: avgAmplitude.toFixed(2),
                        maxAmplitude: maxAmplitude,
                        minAmplitude: minAmplitude,
                        stability: stability.toFixed(2),
                        trend: amplitudes.length > 3 ? (amplitudes.slice(-3).reduce((sum, a) => sum + a, 0) / 3 > avgAmplitude ? '上升' : '下降') : '稳定'
                    };
                });

                return amplitudeData;
            }

            static calculateFollowAnalysis(draws) {
                const followMatrix = {};
                const blueFollowMatrix = {};
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    const currentBalls = currentDraw.redBalls.map(b => parseInt(b));
                    const nextBalls = nextDraw.redBalls.map(b => parseInt(b));

                    currentBalls.forEach(currentNum => {
                        const currentNumStr = currentNum.toString().padStart(2, '0');

                        if (!followMatrix[currentNumStr]) {
                            followMatrix[currentNumStr] = {
                                totalAppearances: 0,
                                follows: {}
                            };
                        }
                        followMatrix[currentNumStr].totalAppearances++;

                        nextBalls.forEach(nextNum => {
                            if (nextNum === currentNum) {
                                return;
                            }
                            const nextNumStr = nextNum.toString().padStart(2, '0');

                            if (!followMatrix[currentNumStr].follows[nextNumStr]) {
                                followMatrix[currentNumStr].follows[nextNumStr] = {
                                    count: 0,
                                    probability: 0,
                                    confidence: 0,
                                    strength: 0
                                };
                            }
                            followMatrix[currentNumStr].follows[nextNumStr].count++;
                        });
                    });

                    if (lotteryType === 'dlt') {
                        const currentBlue = currentDraw.blueBalls && currentDraw.blueBalls.length > 0 ? parseInt(currentDraw.blueBalls[0]) : null;
                        const nextBlue = nextDraw.blueBalls && nextDraw.blueBalls.length > 0 ? parseInt(nextDraw.blueBalls[0]) : null;
                        
                        if (currentBlue !== null && nextBlue !== null && currentBlue !== nextBlue) {
                            const currentBlueStr = currentBlue.toString().padStart(2, '0');
                            const nextBlueStr = nextBlue.toString().padStart(2, '0');

                            if (!blueFollowMatrix[currentBlueStr]) {
                                blueFollowMatrix[currentBlueStr] = {
                                    totalAppearances: 0,
                                    follows: {}
                                };
                            }
                            blueFollowMatrix[currentBlueStr].totalAppearances++;

                            if (!blueFollowMatrix[currentBlueStr].follows[nextBlueStr]) {
                                blueFollowMatrix[currentBlueStr].follows[nextBlueStr] = {
                                    count: 0,
                                    probability: 0,
                                    confidence: 0,
                                    strength: 0
                                };
                            }
                            blueFollowMatrix[currentBlueStr].follows[nextBlueStr].count++;
                        }
                    }
                }

                for (const sourceNum in followMatrix) {
                    const sourceData = followMatrix[sourceNum];
                    const totalFollows = sourceData.totalAppearances;

                    for (const targetNum in sourceData.follows) {
                        const followData = sourceData.follows[targetNum];
                        const count = followData.count;

                        followData.probability = count / totalFollows;

                        const sampleSize = totalFollows;
                        const expectedCount = sampleSize * (1 / (redBallRange[1] - redBallRange[0] + 1));
                        const standardDeviation = Math.sqrt(sampleSize * (1 / (redBallRange[1] - redBallRange[0] + 1)) * (1 - (1 / (redBallRange[1] - redBallRange[0] + 1))));
                        
                        if (standardDeviation > 0) {
                            const zScore = (count - expectedCount) / standardDeviation;
                            followData.confidence = Math.min(1, Math.max(0, (zScore + 3) / 6));
                        } else {
                            followData.confidence = 0.5;
                        }

                        followData.strength = followData.probability * followData.confidence;
                    }
                }

                if (lotteryType === 'dlt') {
                    const blueBallRange = rules.blueBallRange;

                    for (const sourceNum in blueFollowMatrix) {
                        const sourceData = blueFollowMatrix[sourceNum];
                        const totalFollows = sourceData.totalAppearances;

                        for (const targetNum in sourceData.follows) {
                            const followData = sourceData.follows[targetNum];
                            const count = followData.count;

                            followData.probability = count / totalFollows;

                            const sampleSize = totalFollows;
                            const expectedCount = sampleSize * (1 / (blueBallRange[1] - blueBallRange[0] + 1));
                            const standardDeviation = Math.sqrt(sampleSize * (1 / (blueBallRange[1] - blueBallRange[0] + 1)) * (1 - (1 / (blueBallRange[1] - blueBallRange[0] + 1))));
                            
                            if (standardDeviation > 0) {
                                const zScore = (count - expectedCount) / standardDeviation;
                                followData.confidence = Math.min(1, Math.max(0, (zScore + 3) / 6));
                            } else {
                                followData.confidence = 0.5;
                            }

                            followData.strength = followData.probability * followData.confidence;
                        }
                    }
                }

                return {
                    redFollowMatrix: followMatrix,
                    blueFollowMatrix: blueFollowMatrix
                };
            }

            static calculateFollowStatistics(followAnalysisResult) {
                const redFollowMatrix = followAnalysisResult.redFollowMatrix || followAnalysisResult;
                const blueFollowMatrix = followAnalysisResult.blueFollowMatrix;

                let totalFollowRelations = 0;
                let totalProbability = 0;
                let totalConfidence = 0;
                let totalStrength = 0;
                let maxStrength = 0;
                let strongestFollowPair = null;
                let highStrengthCount = 0;

                const allFollowRelations = [];

                for (const sourceNum in redFollowMatrix) {
                    const sourceData = redFollowMatrix[sourceNum];
                    
                    for (const targetNum in sourceData.follows) {
                        const followData = sourceData.follows[targetNum];
                        
                        totalFollowRelations++;
                        totalProbability += followData.probability;
                        totalConfidence += followData.confidence;
                        totalStrength += followData.strength;

                        allFollowRelations.push({
                            source: sourceNum,
                            target: targetNum,
                            count: followData.count,
                            probability: followData.probability,
                            confidence: followData.confidence,
                            strength: followData.strength,
                            type: 'red'
                        });

                        if (followData.strength > maxStrength) {
                            maxStrength = followData.strength;
                            strongestFollowPair = {
                                source: sourceNum,
                                target: targetNum,
                                count: followData.count,
                                probability: followData.probability,
                                confidence: followData.confidence,
                                strength: followData.strength,
                                type: 'red'
                            };
                        }

                        if (followData.strength > 0.3) {
                            highStrengthCount++;
                        }
                    }
                }

                if (blueFollowMatrix) {
                    for (const sourceNum in blueFollowMatrix) {
                        const sourceData = blueFollowMatrix[sourceNum];
                        
                        for (const targetNum in sourceData.follows) {
                            const followData = sourceData.follows[targetNum];
                            
                            totalFollowRelations++;
                            totalProbability += followData.probability;
                            totalConfidence += followData.confidence;
                            totalStrength += followData.strength;

                            allFollowRelations.push({
                                source: sourceNum,
                                target: targetNum,
                                count: followData.count,
                                probability: followData.probability,
                                confidence: followData.confidence,
                                strength: followData.strength,
                                type: 'blue'
                            });

                            if (followData.strength > maxStrength) {
                                maxStrength = followData.strength;
                                strongestFollowPair = {
                                    source: sourceNum,
                                    target: targetNum,
                                    count: followData.count,
                                    probability: followData.probability,
                                    confidence: followData.confidence,
                                    strength: followData.strength,
                                    type: 'blue'
                                };
                            }

                            if (followData.strength > 0.3) {
                                highStrengthCount++;
                            }
                        }
                    }
                }

                const avgProbability = totalFollowRelations > 0 ? totalProbability / totalFollowRelations : 0;
                const avgConfidence = totalFollowRelations > 0 ? totalConfidence / totalFollowRelations : 0;
                const avgStrength = totalFollowRelations > 0 ? totalStrength / totalFollowRelations : 0;

                const countPercentiles = this.calculatePercentiles(allFollowRelations.map(r => r.count));
                const probabilityPercentiles = this.calculatePercentiles(allFollowRelations.map(r => r.probability));

                allFollowRelations.forEach(relation => {
                    const countPercentile = countPercentiles[relation.count] || 0;
                    const probabilityPercentile = probabilityPercentiles[relation.probability] || 0;
                    relation.compositeScore = countPercentile * 0.6 + probabilityPercentile * 0.4;
                    relation.countPercentile = countPercentile;
                    relation.probabilityPercentile = probabilityPercentile;
                });

                const compositePercentiles = this.calculatePercentiles(allFollowRelations.map(r => r.compositeScore));
                allFollowRelations.forEach(relation => {
                    relation.compositePercentile = compositePercentiles[relation.compositeScore] || 0;
                });

                for (const relation of allFollowRelations) {
                    const targetMatrix = relation.type === 'red' ? redFollowMatrix : blueFollowMatrix;
                    if (targetMatrix && targetMatrix[relation.source] && 
                        targetMatrix[relation.source].follows[relation.target]) {
                        targetMatrix[relation.source].follows[relation.target].countPercentile = relation.countPercentile;
                        targetMatrix[relation.source].follows[relation.target].probabilityPercentile = relation.probabilityPercentile;
                        targetMatrix[relation.source].follows[relation.target].compositeScore = relation.compositeScore;
                        targetMatrix[relation.source].follows[relation.target].compositePercentile = relation.compositePercentile;
                    }
                }

                return {
                    totalFollowRelations,
                    avgProbability,
                    avgConfidence,
                    avgStrength,
                    maxStrength,
                    strongestFollowPair,
                    highStrengthCount,
                    highStrengthRatio: totalFollowRelations > 0 ? highStrengthCount / totalFollowRelations : 0,
                    allFollowRelations,
                    redFollowMatrix,
                    blueFollowMatrix
                };
            }

            static calculatePercentiles(values) {
                if (values.length === 0) return {};
                
                const sorted = [...values].sort((a, b) => a - b);
                const percentiles = {};
                
                sorted.forEach((value, index) => {
                    const percentile = index / (sorted.length - 1);
                    if (!(value in percentiles) || percentile > percentiles[value]) {
                        percentiles[value] = percentile;
                    }
                });
                
                return percentiles;
            }

            static displayFollowResults(followAnalysisResult, statistics, recommendations) {
                const resultsContainer = document.getElementById('followUpAnalysisResults');
                const tableBody = document.getElementById('followUpTableBody');
                const recommendationsContainer = document.getElementById('followUpRecommendations');

                resultsContainer.style.display = 'block';

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                const redFollowMatrix = followAnalysisResult.redFollowMatrix || followAnalysisResult;
                const blueFollowMatrix = followAnalysisResult.blueFollowMatrix;

                let html = '';

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const sourceNum = i.toString().padStart(2, '0');
                    const sourceData = redFollowMatrix[sourceNum];

                    if (!sourceData) {
                        continue;
                    }

                    const validTargets = [];
                    for (const targetNum in sourceData.follows) {
                        if (targetNum === sourceNum) {
                            continue;
                        }
                        const followData = sourceData.follows[targetNum];
                        if (followData.count >= 3) {
                            const compositePercentile = followData.compositePercentile !== undefined ? followData.compositePercentile : 0;
                            validTargets.push({
                                num: targetNum,
                                count: followData.count,
                                probability: followData.probability,
                                strength: followData.strength,
                                compositePercentile: compositePercentile
                            });
                        }
                    }

                    if (validTargets.length === 0) {
                        continue;
                    }

                    validTargets.sort((a, b) => b.compositePercentile - a.compositePercentile);

                    const highTargets = validTargets.filter(t => t.compositePercentile >= 0.8);
                    const mediumTargets = validTargets.filter(t => t.compositePercentile >= 0.3 && t.compositePercentile < 0.8);
                    const lowTargets = validTargets.filter(t => t.compositePercentile < 0.3);

                    const createTargetBall = (target, color) => `
                        <div style="display: inline-flex; flex-direction: column; align-items: center; margin: 5px; min-width: 50px;">
                            <span style="display: inline-block; width: 36px; height: 36px; line-height: 36px; text-align: center; border-radius: 50%; background-color: ${color}; color: white; font-weight: bold; font-size: 14px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);">${target.num}</span>
                            <span style="margin-top: 2px; color: #666; font-size: 11px; font-weight: bold;">${target.count}次/${(target.probability * 100).toFixed(2)}%</span>
                        </div>
                    `;

                    const targetsHtml = [
                        ...highTargets.map(t => createTargetBall(t, '#7030A0')),
                        ...mediumTargets.map(t => createTargetBall(t, '#70AD47')),
                        ...lowTargets.map(t => createTargetBall(t, '#4472C4'))
                    ].join('');

                    html += `
                        <tr>
                            <td style="vertical-align: top; padding: 15px;">
                                <span style="display: inline-block; width: 45px; height: 45px; line-height: 45px; text-align: center; border-radius: 50%; background: linear-gradient(135deg, #E63946 0%, #D62839 100%); color: white; font-weight: bold; font-size: 18px; box-shadow: 0 4px 12px rgba(230, 57, 70, 0.3);">${sourceNum}</span>
                            </td>
                            <td style="vertical-align: top; padding: 15px;">
                                <div style="display: flex; flex-wrap: wrap; gap: 5px; align-items: flex-start;">
                                    ${targetsHtml}
                                </div>
                            </td>
                        </tr>
                    `;
                }

                tableBody.innerHTML = html;

                const blueFollowSection = document.getElementById('blueFollowSection');
                const blueFollowTableBody = document.getElementById('blueFollowTableBody');

                if (lotteryType === 'dlt' && blueFollowMatrix) {
                    blueFollowSection.style.display = 'block';
                    const blueBallRange = rules.blueBallRange;
                    let blueHtml = '';

                    for (let i = blueBallRange[0]; i <= blueBallRange[1]; i++) {
                        const sourceNum = i.toString().padStart(2, '0');
                        const sourceData = blueFollowMatrix[sourceNum];

                        if (!sourceData) {
                            continue;
                        }

                        const validTargets = [];
                        for (const targetNum in sourceData.follows) {
                            if (targetNum === sourceNum) {
                                continue;
                            }
                            const followData = sourceData.follows[targetNum];
                            if (followData.count >= 1) {
                                const compositePercentile = followData.compositePercentile !== undefined ? followData.compositePercentile : 0;
                                validTargets.push({
                                    num: targetNum,
                                    count: followData.count,
                                    probability: followData.probability,
                                    strength: followData.strength,
                                    compositePercentile: compositePercentile
                                });
                            }
                        }

                        if (validTargets.length === 0) {
                            continue;
                        }

                        validTargets.sort((a, b) => b.compositePercentile - a.compositePercentile);

                        const highTargets = validTargets.filter(t => t.compositePercentile >= 0.8);
                        const mediumTargets = validTargets.filter(t => t.compositePercentile >= 0.3 && t.compositePercentile < 0.8);
                        const lowTargets = validTargets.filter(t => t.compositePercentile < 0.3);

                        const createTargetBall = (target, color) => `
                            <div style="display: inline-flex; flex-direction: column; align-items: center; margin: 5px; min-width: 50px;">
                                <span style="display: inline-block; width: 36px; height: 36px; line-height: 36px; text-align: center; border-radius: 50%; background-color: ${color}; color: white; font-weight: bold; font-size: 14px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);">${target.num}</span>
                                <span style="margin-top: 2px; color: #666; font-size: 11px; font-weight: bold;">${target.count}次/${(target.probability * 100).toFixed(2)}%</span>
                            </div>
                        `;

                        const targetsHtml = [
                            ...highTargets.map(t => createTargetBall(t, '#7030A0')),
                            ...mediumTargets.map(t => createTargetBall(t, '#70AD47')),
                            ...lowTargets.map(t => createTargetBall(t, '#4472C4'))
                        ].join('');

                        blueHtml += `
                            <tr>
                                <td style="vertical-align: top; padding: 15px;">
                                    <span style="display: inline-block; width: 45px; height: 45px; line-height: 45px; text-align: center; border-radius: 50%; background: linear-gradient(135deg, #1E88E5 0%, #1565C0 100%); color: white; font-weight: bold; font-size: 18px; box-shadow: 0 4px 12px rgba(30, 136, 229, 0.3);">${sourceNum}</span>
                                </td>
                                <td style="vertical-align: top; padding: 15px;">
                                    <div style="display: flex; flex-wrap: wrap; gap: 5px; align-items: flex-start;">
                                        ${targetsHtml}
                                    </div>
                                </td>
                            </tr>
                        `;
                    }

                    blueFollowTableBody.innerHTML = blueHtml;
                } else {
                    blueFollowSection.style.display = 'none';
                }

                const statisticsHtml = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 14px; opacity: 0.9;">总跟随关系数</div>
                            <div style="font-size: 24px; font-weight: bold; margin-top: 5px;">${statistics.totalFollowRelations}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 14px; opacity: 0.9;">平均跟随概率</div>
                            <div style="font-size: 24px; font-weight: bold; margin-top: 5px;">${(statistics.avgProbability * 100).toFixed(1)}%</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 14px; opacity: 0.9;">平均置信度</div>
                            <div style="font-size: 24px; font-weight: bold; margin-top: 5px;">${(statistics.avgConfidence * 100).toFixed(1)}%</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 14px; opacity: 0.9;">平均强度</div>
                            <div style="font-size: 24px; font-weight: bold; margin-top: 5px;">${statistics.avgStrength.toFixed(3)}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 14px; opacity: 0.9;">高强度关系数</div>
                            <div style="font-size: 24px; font-weight: bold; margin-top: 5px;">${statistics.highStrengthCount}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 14px; opacity: 0.9;">最强跟随对</div>
                            <div style="font-size: 18px; font-weight: bold; margin-top: 5px;">${statistics.strongestFollowPair ? statistics.strongestFollowPair.source + '→' + statistics.strongestFollowPair.target : '无'}</div>
                            <div style="font-size: 12px; opacity: 0.9; margin-top: 3px;">强度: ${statistics.strongestFollowPair ? statistics.strongestFollowPair.strength.toFixed(3) : '0'}</div>
                        </div>
                    </div>
                `;

                const recommendationsHtml = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                        ${recommendations.map(rec => `
                            <div style="background: white; border-left: 4px solid ${rec.strengthColor}; padding: 15px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <div style="display: flex; align-items: center;">
                                        <span style="display: inline-block; width: 40px; height: 40px; line-height: 40px; text-align: center; border-radius: 50%; background-color: #E63946; color: white; font-weight: bold; font-size: 18px; margin-right: 10px;">${rec.num}</span>
                                        <div>
                                            <div style="font-weight: bold; color: #333;">推荐号码</div>
                                            <div style="font-size: 12px; color: #666;">排名 #${rec.rank}</div>
                                        </div>
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 12px; color: #666;">综合强度</div>
                                        <div style="font-size: 20px; font-weight: bold; color: ${rec.strengthColor};">${rec.totalStrength}</div>
                                    </div>
                                </div>
                                <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                                    <div style="font-size: 14px; color: #333; margin-bottom: 5px;">
                                        <strong>推荐理由：</strong>${rec.reason}
                                    </div>
                                    <div style="font-size: 12px; color: #666;">
                                        源号码：${rec.sources}
                                    </div>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 12px;">
                                    <div style="text-align: center; padding: 5px; background: #f9f9f9; border-radius: 4px;">
                                        <div style="color: #666; margin-bottom: 3px;">跟随概率</div>
                                        <div style="color: #E63946; font-weight: bold;">${rec.avgProbability}</div>
                                    </div>
                                    <div style="text-align: center; padding: 5px; background: #f9f9f9; border-radius: 4px;">
                                        <div style="color: #666; margin-bottom: 3px;">置信度</div>
                                        <div style="color: #457B9D; font-weight: bold;">${rec.avgConfidence}</div>
                                    </div>
                                    <div style="text-align: center; padding: 5px; background: #f9f9f9; border-radius: 4px;">
                                        <div style="color: #666; margin-bottom: 3px;">跟随次数</div>
                                        <div style="color: #2A9D8F; font-weight: bold;">${rec.totalFollows}</div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;

                recommendationsContainer.innerHTML = recommendationsHtml;

                const conclusionContent = document.getElementById('followUpConclusionContent');
                conclusionContent.innerHTML = `
                    ${statisticsHtml}
                    <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="margin-top: 0; color: #333;">分析结论</h4>
                        <ul style="margin: 10px 0; padding-left: 20px; color: #666;">
                            <li>共分析了 <strong>${statistics.totalFollowRelations}</strong> 个跟随关系</li>
                            <li>平均跟随概率为 <strong>${(statistics.avgProbability * 100).toFixed(1)}%</strong></li>
                            <li>平均置信度为 <strong>${(statistics.avgConfidence * 100).toFixed(1)}%</strong></li>
                            <li>发现 <strong>${statistics.highStrengthCount}</strong> 个高强度跟随关系（综合百分位≥0.8）</li>
                            <li>最强跟随对为 <strong>${statistics.strongestFollowPair ? statistics.strongestFollowPair.source + '→' + statistics.strongestFollowPair.target : '无'}</strong>，强度为 <strong>${statistics.strongestFollowPair ? statistics.strongestFollowPair.strength.toFixed(3) : '0'}</strong></li>
                            <li>基于最新一期开奖，推荐了 <strong>${recommendations.length}</strong> 个号码</li>
                        </ul>
                    </div>
                `;
            }

            static generateFollowRecommendations(followMatrix, currentDraw) {
                const recommendations = [];
                const currentRedBalls = currentDraw.redBalls.map(b => parseInt(b));
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallCount = rules.redBallCount;

                const followScores = {};

                currentRedBalls.forEach(currentNum => {
                    const currentNumStr = currentNum.toString().padStart(2, '0');
                    
                    if (followMatrix[currentNumStr]) {
                        const follows = followMatrix[currentNumStr].follows;
                        
                        for (const targetNumStr in follows) {
                            const followData = follows[targetNumStr];
                            
                            if (!followScores[targetNumStr]) {
                                followScores[targetNumStr] = {
                                    num: targetNumStr,
                                    totalStrength: 0,
                                    sources: [],
                                    avgProbability: 0,
                                    avgConfidence: 0,
                                    totalFollows: 0
                                };
                            }
                            
                            followScores[targetNumStr].totalStrength += followData.strength;
                            followScores[targetNumStr].sources.push(currentNumStr);
                            followScores[targetNumStr].avgProbability += followData.probability;
                            followScores[targetNumStr].avgConfidence += followData.confidence;
                            followScores[targetNumStr].totalFollows += followData.count;
                        }
                    }
                });

                const sortedRecommendations = Object.values(followScores)
                    .map(rec => {
                        const sourceCount = rec.sources.length;
                        rec.avgProbability = rec.avgProbability / sourceCount;
                        rec.avgConfidence = rec.avgConfidence / sourceCount;
                        rec.sourceCount = sourceCount;
                        return rec;
                    })
                    .sort((a, b) => b.totalStrength - a.totalStrength)
                    .slice(0, redBallCount);

                sortedRecommendations.forEach((rec, index) => {
                    const strengthLevel = rec.totalStrength > 0.5 ? '高' : rec.totalStrength > 0.3 ? '中' : '低';
                    const strengthColor = rec.totalStrength > 0.5 ? '#E63946' : rec.totalStrength > 0.3 ? '#F4A261' : '#2A9D8F';
                    
                    recommendations.push({
                        rank: index + 1,
                        num: rec.num,
                        totalStrength: rec.totalStrength.toFixed(3),
                        strengthLevel: strengthLevel,
                        strengthColor: strengthColor,
                        sourceCount: rec.sourceCount,
                        sources: rec.sources.join(', '),
                        avgProbability: (rec.avgProbability * 100).toFixed(1) + '%',
                        avgConfidence: (rec.avgConfidence * 100).toFixed(1) + '%',
                        totalFollows: rec.totalFollows,
                        reason: `基于${rec.sourceCount}个源号码的强跟随关系，综合强度${strengthLevel}`
                    });
                });

                return recommendations;
            }

            static calculateRepeatAdjacentAnalysis(draws) {
                const repeatAdjacentData = {
                    repeat: [],
                    adjacent: [],
                    gap: []
                };

                for (let i = 1; i < draws.length; i++) {
                    const prevDraw = draws[i - 1];
                    const currentDraw = draws[i];

                    const prevBalls = prevDraw.redBalls.map(b => parseInt(b));
                    const currentBalls = currentDraw.redBalls.map(b => parseInt(b));

                    const repeats = currentBalls.filter(ball => prevBalls.includes(ball));
                    const adjacents = currentBalls.filter(ball => {
                        return prevBalls.some(prev => Math.abs(prev - ball) === 1);
                    });
                    const gaps = currentBalls.filter(ball => {
                        return prevBalls.some(prev => Math.abs(prev - ball) === 2);
                    });

                    repeatAdjacentData.repeat.push({
                        period: currentDraw.period,
                        count: repeats.length,
                        numbers: repeats.map(n => n.toString().padStart(2, '0'))
                    });

                    repeatAdjacentData.adjacent.push({
                        period: currentDraw.period,
                        count: adjacents.length,
                        numbers: adjacents.map(n => n.toString().padStart(2, '0'))
                    });

                    repeatAdjacentData.gap.push({
                        period: currentDraw.period,
                        count: gaps.length,
                        numbers: gaps.map(n => n.toString().padStart(2, '0'))
                    });
                }

                const avgRepeat = repeatAdjacentData.repeat.reduce((sum, d) => sum + d.count, 0) / repeatAdjacentData.repeat.length;
                const avgAdjacent = repeatAdjacentData.adjacent.reduce((sum, d) => sum + d.count, 0) / repeatAdjacentData.adjacent.length;
                const avgGap = repeatAdjacentData.gap.reduce((sum, d) => sum + d.count, 0) / repeatAdjacentData.gap.length;

                return {
                    repeat: repeatAdjacentData.repeat,
                    adjacent: repeatAdjacentData.adjacent,
                    gap: repeatAdjacentData.gap,
                    avgRepeat: avgRepeat.toFixed(2),
                    avgAdjacent: avgAdjacent.toFixed(2),
                    avgGap: avgGap.toFixed(2)
                };
            }

            static calculateDragonPhoenixAnalysis(draws) {
                const dragonPhoenixData = {
                    dragon: [],
                    phoenix: [],
                    span: []
                };

                draws.forEach(draw => {
                    const balls = draw.redBalls.map(b => parseInt(b)).sort((a, b) => a - b);
                    const dragon = balls[0];
                    const phoenix = balls[balls.length - 1];
                    const span = phoenix - dragon;

                    const dragonOddEven = dragon % 2 === 0 ? '偶' : '奇';
                    const phoenixOddEven = phoenix % 2 === 0 ? '偶' : '奇';

                    const dragonPrime = this.isPrime(dragon) ? '质' : '合';
                    const phoenixPrime = this.isPrime(phoenix) ? '质' : '合';

                    const dragon012 = dragon % 3;
                    const phoenix012 = phoenix % 3;

                    dragonPhoenixData.dragon.push({
                        period: draw.period,
                        number: dragon,
                        oddEven: dragonOddEven,
                        prime: dragonPrime,
                        zeroOneTwo: dragon012
                    });

                    dragonPhoenixData.phoenix.push({
                        period: draw.period,
                        number: phoenix,
                        oddEven: phoenixOddEven,
                        prime: phoenixPrime,
                        zeroOneTwo: phoenix012
                    });

                    dragonPhoenixData.span.push({
                        period: draw.period,
                        span: span,
                        trend: span > 20 ? '大跨度' : (span > 10 ? '中跨度' : '小跨度')
                    });
                });

                const avgDragon = dragonPhoenixData.dragon.reduce((sum, d) => sum + d.number, 0) / dragonPhoenixData.dragon.length;
                const avgPhoenix = dragonPhoenixData.phoenix.reduce((sum, d) => sum + d.number, 0) / dragonPhoenixData.phoenix.length;
                const avgSpan = dragonPhoenixData.span.reduce((sum, d) => sum + d.span, 0) / dragonPhoenixData.span.length;

                return {
                    dragon: dragonPhoenixData.dragon,
                    phoenix: dragonPhoenixData.phoenix,
                    span: dragonPhoenixData.span,
                    avgDragon: avgDragon.toFixed(2),
                    avgPhoenix: avgPhoenix.toFixed(2),
                    avgSpan: avgSpan.toFixed(2)
                };
            }

            static isPrime(num) {
                if (num < 2) return false;
                for (let i = 2; i <= Math.sqrt(num); i++) {
                    if (num % i === 0) return false;
                }
                return true;
            }

            static updateFollowUpChart(data) {
                const chartDom = document.getElementById('followUpChart');
                if (!chartDom) return;

                if (followUpScatterChart) {
                    followUpScatterChart.dispose();
                    followUpScatterChart = null;
                }
                if (followUpBarChart) {
                    followUpBarChart.dispose();
                    followUpBarChart = null;
                }
                if (followUpLineChart) {
                    followUpLineChart.dispose();
                    followUpLineChart = null;
                }
                if (followUpPieChart) {
                    followUpPieChart.dispose();
                    followUpPieChart = null;
                }
                if (followUpTrendChart) {
                    followUpTrendChart.dispose();
                    followUpTrendChart = null;
                }

                let option;

                switch (currentFollowUpChartType) {
                    case 'scatter':
                        followUpScatterChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                        option = this.createScatterChartOption(data.scatter);
                        followUpScatterChart.setOption(option);
                        break;
                    case 'bar':
                        followUpBarChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                        option = this.createBiasChartOption(data.bias);
                        followUpBarChart.setOption(option);
                        break;
                    case 'line':
                        followUpLineChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                        option = this.createAmplitudeChartOption(data.amplitude);
                        followUpLineChart.setOption(option);
                        break;
                    case 'network':
                        option = this.createFollowChartOption(data.follow);
                        if (option) {
                            const networkChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                            networkChart.setOption(option);
                        }
                        break;
                    case 'pie':
                        followUpPieChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                        option = this.createRepeatAdjacentChartOption(data.repeatAdjacent);
                        followUpPieChart.setOption(option);
                        break;
                    case 'trend':
                        followUpTrendChart = echarts.getInstanceByDom(chartDom) || echarts.init(chartDom);
                        option = this.createDragonPhoenixChartOption(data.dragonPhoenix);
                        followUpTrendChart.setOption(option);
                        break;
                }
            }

            static createScatterChartOption(data) {
                const periods = data.data.map(d => d.period);
                const scatterValues = data.data.map(d => parseFloat(d.scatter));
                const maxDiffValues = data.data.map(d => d.maxDiff);

                return {
                    title: {
                        text: '散度分析 - 号码离散程度',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const dataIndex = params[0].dataIndex;
                            const item = data.data[dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">期号：${item.period}</div>
                                    <div style="margin-bottom: 3px;">散度值：<span style="color: #E63946; font-weight: bold;">${item.scatter}</span></div>
                                    <div style="margin-bottom: 3px;">最大差值：<span style="color: #F4A261;">${item.maxDiff}</span></div>
                                    <div>号码：${item.numbers.join(', ')}</div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['散度值', '最大差值'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '散度值',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '散度值',
                            type: 'line',
                            data: scatterValues,
                            smooth: true,
                            itemStyle: {
                                color: '#E63946'
                            },
                            lineStyle: {
                                width: 2
                            }
                        },
                        {
                            name: '最大差值',
                            type: 'bar',
                            data: maxDiffValues,
                            itemStyle: {
                                color: '#F4A261'
                            }
                        }
                    ]
                };
            }

            static createBiasChartOption(data) {
                const periods = data.sumBias.map(d => d.period);
                const sumValues = data.sumBias.map(d => d.sum);
                const avgSum = data.sumBias.reduce((sum, d) => sum + d.sum, 0) / data.sumBias.length;

                return {
                    title: {
                        text: '偏态分析 - 和值与区间分布',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const dataIndex = params[0].dataIndex;
                            const item = data.sumBias[dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">期号：${item.period}</div>
                                    <div style="margin-bottom: 3px;">和值：<span style="color: #E63946; font-weight: bold;">${item.sum}</span></div>
                                    <div style="margin-bottom: 3px;">偏差：<span style="color: ${item.deviation > 0 ? '#E63946' : '#F4A261'};">${item.deviation > 0 ? '+' : ''}${item.deviation}</span></div>
                                    <div>状态：<span style="color: #2A9D8F;">${item.status}</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['和值', '均值线'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '和值',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '和值',
                            type: 'bar',
                            data: sumValues,
                            itemStyle: {
                                color: function(params) {
                                    const value = params.value;
                                    if (value > avgSum + 10) return '#E63946';
                                    if (value < avgSum - 10) return '#457B9D';
                                    return '#2A9D8F';
                                }
                            }
                        },
                        {
                            name: '均值线',
                            type: 'line',
                            data: Array(periods.length).fill(avgSum),
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                type: 'dashed',
                                width: 2
                            }
                        }
                    ]
                };
            }

            static createAmplitudeChartOption(data) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;
                
                const numbers = [];
                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    if (data[numStr]) {
                        numbers.push(numStr);
                    }
                }
                
                const avgAmplitudes = numbers.map(num => parseFloat(data[num].avgAmplitude));

                return {
                    title: {
                        text: '振幅分析 - 号码出现间隔变化',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const dataIndex = params[0].dataIndex;
                            const num = numbers[dataIndex];
                            const item = data[num];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${item.number}</div>
                                    <div style="margin-bottom: 3px;">出现次数：<span style="color: #E63946;">${item.appearances}</span></div>
                                    <div style="margin-bottom: 3px;">平均振幅：<span style="color: #F4A261; font-weight: bold;">${item.avgAmplitude}</span></div>
                                    <div style="margin-bottom: 3px;">最大振幅：<span style="color: #457B9D;">${item.maxAmplitude}</span></div>
                                    <div style="margin-bottom: 3px;">最小振幅：<span style="color: #2A9D8F;">${item.minAmplitude}</span></div>
                                    <div style="margin-bottom: 3px;">稳定性：<span style="color: #E63946;">${item.stability}</span></div>
                                    <div>趋势：<span style="color: #F4A261;">${item.trend}</span></div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['平均振幅'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '振幅',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '平均振幅',
                            type: 'bar',
                            data: avgAmplitudes,
                            itemStyle: {
                                color: function(params) {
                                    const value = params.value;
                                    if (value > 5) return '#E63946';
                                    if (value > 3) return '#F4A261';
                                    return '#2A9D8F';
                                }
                            }
                        }
                    ]
                };
            }

            static createFollowChartOption(followMatrix) {
                const actualMatrix = followMatrix.redFollowMatrix || followMatrix;
                const chartData = [];
                
                for (const sourceNum in actualMatrix) {
                    const sourceData = actualMatrix[sourceNum];
                    const topFollows = [];
                    
                    for (const targetNum in sourceData.follows) {
                        const followData = sourceData.follows[targetNum];
                        topFollows.push({
                            num: targetNum,
                            count: followData.count,
                            probability: followData.probability,
                            confidence: followData.confidence,
                            strength: followData.strength
                        });
                    }
                    
                    topFollows.sort((a, b) => b.count - a.count);
                    const top3 = topFollows.slice(0, 3);
                    
                    const totalFollows = Object.values(sourceData.follows).reduce((sum, f) => sum + f.count, 0);
                    
                    chartData.push({
                        currentNum: sourceNum,
                        totalFollows: totalFollows,
                        topFollows: top3
                    });
                }
                
                chartData.sort((a, b) => a.currentNum.localeCompare(b.currentNum));
                
                const currentNums = chartData.map(d => d.currentNum);
                const topFollowCounts = chartData.map(d => d.topFollows[0] ? d.topFollows[0].count : 0);

                return {
                    title: {
                        text: '跟随分析 - 号码关联关系',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const dataIndex = params[0].dataIndex;
                            const item = chartData[dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">号码：${item.currentNum}</div>
                                    <div style="margin-bottom: 3px;">总跟随次数：<span style="color: #E63946; font-weight: bold;">${item.totalFollows}</span></div>
                                    <div style="margin-bottom: 5px;">最常跟随号码：</div>
                                    ${item.topFollows.map(function(f) {
                                        return `
                                        <div style="margin-bottom: 3px;">
                                            <span style="color: #F4A261;">${f.num}</span> 
                                            <span style="color: #2A9D8F;">(${f.count}次, ${(f.probability * 100).toFixed(1)}%)</span>
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['跟随次数'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: currentNums,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '跟随次数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '跟随次数',
                            type: 'bar',
                            data: topFollowCounts,
                            itemStyle: {
                                color: '#E63946'
                            }
                        }
                    ]
                };
            }

            static createRepeatAdjacentChartOption(data) {
                const periods = data.repeat.map(d => d.period);
                const repeatCounts = data.repeat.map(d => d.count);
                const adjacentCounts = data.adjacent.map(d => d.count);
                const gapCounts = data.gap.map(d => d.count);

                return {
                    title: {
                        text: '重号邻号隔号分析',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const dataIndex = params[0].dataIndex;
                            const item = data.repeat[dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">期号：${item.period}</div>
                                    <div style="margin-bottom: 3px;">重号：<span style="color: #E63946; font-weight: bold;">${item.count}个</span> ${item.numbers.join(', ')}</div>
                                    <div style="margin-bottom: 3px;">邻号：<span style="color: #F4A261; font-weight: bold;">${data.adjacent[dataIndex].count}个</span> ${data.adjacent[dataIndex].numbers.join(', ')}</div>
                                    <div>隔号：<span style="color: #2A9D8F; font-weight: bold;">${data.gap[dataIndex].count}个</span> ${data.gap[dataIndex].numbers.join(', ')}</div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['重号', '邻号', '隔号'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '个数',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '重号',
                            type: 'line',
                            data: repeatCounts,
                            itemStyle: {
                                color: '#E63946'
                            },
                            lineStyle: {
                                width: 2
                            }
                        },
                        {
                            name: '邻号',
                            type: 'line',
                            data: adjacentCounts,
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                width: 2
                            }
                        },
                        {
                            name: '隔号',
                            type: 'line',
                            data: gapCounts,
                            itemStyle: {
                                color: '#2A9D8F'
                            },
                            lineStyle: {
                                width: 2
                            }
                        }
                    ]
                };
            }

            static createDragonPhoenixChartOption(data) {
                const periods = data.dragon.map(d => d.period);
                const dragonValues = data.dragon.map(d => d.number);
                const phoenixValues = data.phoenix.map(d => d.number);
                const spanValues = data.span.map(d => d.span);

                return {
                    title: {
                        text: '龙头凤尾分析 - 首尾走势',
                        left: 'center',
                        top: 10,
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            const dataIndex = params[0].dataIndex;
                            const dragonItem = data.dragon[dataIndex];
                            const phoenixItem = data.phoenix[dataIndex];
                            const spanItem = data.span[dataIndex];
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">期号：${dragonItem.period}</div>
                                    <div style="margin-bottom: 3px;">龙头：<span style="color: #E63946; font-weight: bold;">${dragonItem.number}</span> (${dragonItem.oddEven}, ${dragonItem.prime}, 012路${dragonItem.zeroOneTwo})</div>
                                    <div style="margin-bottom: 3px;">凤尾：<span style="color: #F4A261; font-weight: bold;">${phoenixItem.number}</span> (${phoenixItem.oddEven}, ${phoenixItem.prime}, 012路${phoenixItem.zeroOneTwo})</div>
                                    <div style="margin-bottom: 3px;">跨度：<span style="color: #2A9D8F; font-weight: bold;">${spanItem.span}</span> (${spanItem.trend})</div>
                                </div>
                            `;
                        }
                    },
                    legend: {
                        data: ['龙头', '凤尾', '跨度'],
                        top: 45,
                        textStyle: {
                            color: '#333'
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: periods,
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '号码/跨度',
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '龙头',
                            type: 'line',
                            data: dragonValues,
                            itemStyle: {
                                color: '#E63946'
                            },
                            lineStyle: {
                                width: 2
                            }
                        },
                        {
                            name: '凤尾',
                            type: 'line',
                            data: phoenixValues,
                            itemStyle: {
                                color: '#F4A261'
                            },
                            lineStyle: {
                                width: 2
                            }
                        },
                        {
                            name: '跨度',
                            type: 'bar',
                            data: spanValues,
                            itemStyle: {
                                color: function(params) {
                                    const value = params.value;
                                    if (value > 20) return '#E63946';
                                    if (value > 10) return '#F4A261';
                                    return '#2A9D8F';
                                }
                            }
                        }
                    ]
                };
            }

            static generateFollowUpConclusion(data) {
                const conclusionDiv = document.getElementById('followUpConclusionContent');
                if (!conclusionDiv) return;

                const scatterAvg = parseFloat(data.scatter.average);
                const biasAvgSum = data.bias.sumBias.reduce((sum, d) => sum + d.sum, 0) / data.bias.sumBias.length;
                const repeatAvg = parseFloat(data.repeatAdjacent.avgRepeat);
                const adjacentAvg = parseFloat(data.repeatAdjacent.avgAdjacent);
                const gapAvg = parseFloat(data.repeatAdjacent.avgGap);
                const dragonAvg = parseFloat(data.dragonPhoenix.avgDragon);
                const phoenixAvg = parseFloat(data.dragonPhoenix.avgPhoenix);
                const spanAvg = parseFloat(data.dragonPhoenix.avgSpan);

                let insights = [];

                insights.push(`<strong>📊 散度分析：</strong>平均散度值为 ${data.scatter.average}，号码${scatterAvg > 15 ? '较为分散' : '相对集中'}`);
                insights.push(`<strong>📈 偏态分析：</strong>平均和值为 ${biasAvgSum.toFixed(2)}，${data.bias.zoneBias.some(z => z.status === '亢奋') ? '存在亢奋区间' : '各区间分布相对均衡'}`);
                insights.push(`<strong>📉 振幅分析：</strong>号码出现周期${repeatAvg > 5 ? '波动较大' : '相对稳定'}`);
                
                const followMatrix = data.follow;
                let followInsight = '弱关联关系';
                if (followMatrix && Object.keys(followMatrix).length > 0) {
                    const actualMatrix = followMatrix.redFollowMatrix || followMatrix;
                    let highStrengthCount = 0;
                    let mediumStrengthCount = 0;
                    let lowStrengthCount = 0;
                    
                    for (const sourceNum in actualMatrix) {
                        for (const targetNum in actualMatrix[sourceNum].follows) {
                            const compositePercentile = actualMatrix[sourceNum].follows[targetNum].compositePercentile;
                            if (compositePercentile >= 0.8) {
                                highStrengthCount++;
                            } else if (compositePercentile >= 0.3) {
                                mediumStrengthCount++;
                            } else {
                                lowStrengthCount++;
                            }
                        }
                    }
                    
                    const totalRelations = highStrengthCount + mediumStrengthCount + lowStrengthCount;
                    const highRatio = totalRelations > 0 ? (highStrengthCount / totalRelations * 100).toFixed(1) : 0;
                    const mediumRatio = totalRelations > 0 ? (mediumStrengthCount / totalRelations * 100).toFixed(1) : 0;
                    
                    if (highRatio > 30) {
                        followInsight = `强关联关系（高强度${highRatio}%，中强度${mediumRatio}%）`;
                    } else if (highRatio > 15) {
                        followInsight = `中等关联关系（高强度${highRatio}%，中强度${mediumRatio}%）`;
                    } else {
                        followInsight = `弱关联关系（高强度${highRatio}%，中强度${mediumRatio}%）`;
                    }
                }
                insights.push(`<strong>🔗 跟随分析：</strong>号码间存在${followInsight}`);
                
                insights.push(`<strong>🔄 重号邻号隔号：</strong>平均重号 ${data.repeatAdjacent.avgRepeat}个，邻号 ${data.repeatAdjacent.avgAdjacent}个，隔号 ${data.repeatAdjacent.avgGap}个`);
                insights.push(`<strong>🐉 龙头凤尾：</strong>平均龙头 ${data.dragonPhoenix.avgDragon}，凤尾 ${data.dragonPhoenix.avgPhoenix}，跨度 ${data.dragonPhoenix.avgSpan}`);

                conclusionDiv.innerHTML = insights.map(insight => `<p style="margin-bottom: 10px; line-height: 1.6;">${insight}</p>`).join('');
            }

            static updateFollowHeatmap(followMatrix) {
                const actualMatrix = followMatrix.redFollowMatrix || followMatrix;
                const heatmapData = [];
                const xData = [];
                const yData = [];
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const redBallRange = rules.redBallRange;

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    const numStr = i.toString().padStart(2, '0');
                    xData.push(numStr);
                    yData.push(numStr);
                }

                for (let y = 0; y < yData.length; y++) {
                    for (let x = 0; x < xData.length; x++) {
                        const sourceNum = xData[x];
                        const targetNum = yData[y];
                        
                        let value = 0;
                        if (actualMatrix[sourceNum] && actualMatrix[sourceNum].follows[targetNum]) {
                            value = actualMatrix[sourceNum].follows[targetNum].strength;
                        }
                        
                        heatmapData.push([x, y, value]);
                    }
                }

                const option = {
                    title: {
                        text: '跟随矩阵热力图 - 号码跟随关系强度',
                        left: 'center',
                        textStyle: {
                            color: '#333',
                            fontSize: 18,
                            fontWeight: 'bold'
                        }
                    },
                    tooltip: {
                        position: 'top',
                        formatter: (params) => {
                            const sourceNum = xData[params.value[0]];
                            const targetNum = yData[params.value[1]];
                            const strength = params.value[2];
                            
                            let details = '';
                            if (followMatrix[sourceNum] && followMatrix[sourceNum].follows[targetNum]) {
                                const followData = followMatrix[sourceNum].follows[targetNum];
                                details = `
                                    <div style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #ddd;">
                                        <div style="margin-bottom: 3px;">跟随次数：<span style="color: #E63946; font-weight: bold;">${followData.count}</span></div>
                                        <div style="margin-bottom: 3px;">跟随概率：<span style="color: #F4A261;">${(followData.probability * 100).toFixed(1)}%</span></div>
                                        <div style="margin-bottom: 3px;">置信度：<span style="color: #457B9D;">${(followData.confidence * 100).toFixed(1)}%</span></div>
                                        <div>强度：<span style="color: #2A9D8F; font-weight: bold;">${strength.toFixed(3)}</span></div>
                                    </div>
                                `;
                            }
                            
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">${sourceNum} → ${targetNum}</div>
                                    ${details}
                                </div>
                            `;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: xData,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            rotate: 45,
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: yData,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            color: '#333'
                        }
                    },
                    visualMap: {
                        min: 0,
                        max: 1,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '0%',
                        inRange: {
                            color: ['#E0F7FA', '#B2EBF2', '#80DEEA', '#4DD0E1', '#26C6DA', '#00BCD4', '#00ACC1', '#0097A7', '#00838F', '#006064']
                        },
                        textStyle: {
                            color: '#333'
                        }
                    },
                    series: [
                        {
                            name: '跟随强度',
                            type: 'heatmap',
                            data: heatmapData,
                            label: {
                                show: false
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                if (followUpHeatmapChart) {
                    followUpHeatmapChart.setOption(option);
                } else {
                    followUpHeatmapChart = echarts.init(document.getElementById('followUpHeatmap'));
                    followUpHeatmapChart.setOption(option);
                }

                followUpHeatmapChart.resize();
            }

            static displayLinkageReport(report) {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h3><i class="fas fa-chart-line"></i> AC值与大中小分析联动报告</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="report-section">
                                <h4><i class="fas fa-info-circle"></i> 报告信息</h4>
                                <div class="report-info">
                                    <p><strong>生成时间：</strong>${report.generatedAt}</p>
                                    <p><strong>彩种：</strong>${report.lotteryType === 'ssq' ? '双色球' : '大乐透'}</p>
                                    <p><strong>分析期数：</strong>${report.analysisPeriod}</p>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-calculator"></i> AC值统计摘要</h4>
                                <div class="report-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">平均值</span>
                                        <span class="stat-value">${report.acValueSummary.average}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">中位数</span>
                                        <span class="stat-value">${report.acValueSummary.median}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">众数</span>
                                        <span class="stat-value">${report.acValueSummary.mode}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">最小值</span>
                                        <span class="stat-value">${report.acValueSummary.min}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">最大值</span>
                                        <span class="stat-value">${report.acValueSummary.max}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-th-large"></i> 大中小分析摘要</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">热门区间</span>
                                        <span class="stat-value">${report.threeZoneSummary.hotZone.name}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">冷门区间</span>
                                        <span class="stat-value">${report.threeZoneSummary.coldZone.name}</span>
                                    </div>
                                </div>
                                <div class="top-combinations">
                                    <h5>高频三区组合 TOP3</h5>
                                    <ul>
                                        ${report.threeZoneSummary.topCombinations.map((combo, index) => 
                                            `<li><strong>${index + 1}. ${combo.combination}</strong> - 出现 ${combo.count} 次</li>`
                                        ).join('')}
                                    </ul>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-lightbulb"></i> 联动分析洞察</h4>
                                <div class="report-insights">
                                    ${report.correlation.insights.map(insight => 
                                        `<p><i class="fas fa-check-circle"></i> ${insight}</p>`
                                    ).join('')}
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                            <button class="btn btn-primary" onclick="EventDelegate.printLinkageReport()">打印报告</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            static printLinkageReport() {
                window.print();
            }

            static showComparisonView() {
                if (!acValueChartData || !threeZoneChartData || !threeZoneAnalysisResults) {
                    MessageSystem.showMessage('请先完成AC值分析和大中小分析', 'error');
                    return;
                }

                if (!acValueChartData.statistics || !acValueChartData.values) {
                    MessageSystem.showMessage('AC值分析数据不完整', 'error');
                    return;
                }

                if (!threeZoneAnalysisResults.hotZone || !threeZoneAnalysisResults.coldZone) {
                    MessageSystem.showMessage('大中小分析数据不完整', 'error');
                    return;
                }

                if (!threeZoneAnalysisResults.topCombinations || threeZoneAnalysisResults.topCombinations.length === 0) {
                    MessageSystem.showMessage('三区组合数据不完整', 'error');
                    return;
                }

                if (!threeZoneAnalysisResults.combinationACStats) {
                    MessageSystem.showMessage('AC值关联数据不完整', 'error');
                    return;
                }

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 1400px;">
                        <div class="modal-header">
                            <h3><i class="fas fa-columns"></i> AC值分析与大中小分析对比展示</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="comparison-container">
                                <div class="comparison-section">
                                    <h4><i class="fas fa-calculator"></i> AC值分析结果</h4>
                                    <div class="comparison-stats">
                                        <div class="stat-item">
                                            <span class="stat-label">平均值</span>
                                            <span class="stat-value">${acValueChartData.statistics.mean || 'N/A'}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">中位数</span>
                                            <span class="stat-value">${acValueChartData.statistics.median || 'N/A'}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">众数</span>
                                            <span class="stat-value">${acValueChartData.statistics.mostFrequent?.value || 'N/A'}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">最小值</span>
                                            <span class="stat-value">${acValueChartData.values.length > 0 ? Math.min(...acValueChartData.values) : 'N/A'}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">最大值</span>
                                            <span class="stat-value">${acValueChartData.values.length > 0 ? Math.max(...acValueChartData.values) : 'N/A'}</span>
                                        </div>
                                    </div>
                                    <div class="comparison-chart" id="acValueComparisonChart" style="height: 300px;"></div>
                                </div>

                                <div class="comparison-section">
                                    <h4><i class="fas fa-th-large"></i> 大中小分析结果</h4>
                                    <div class="comparison-stats">
                                        <div class="stat-item highlight">
                                            <span class="stat-label">热门区间</span>
                                            <span class="stat-value">${threeZoneAnalysisResults.hotZone?.name || 'N/A'}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">冷门区间</span>
                                            <span class="stat-value">${threeZoneAnalysisResults.coldZone?.name || 'N/A'}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">一区总数</span>
                                            <span class="stat-value">${threeZoneChartData.zone1Count || 0}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">二区总数</span>
                                            <span class="stat-value">${threeZoneChartData.zone2Count || 0}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">三区总数</span>
                                            <span class="stat-value">${threeZoneChartData.zone3Count || 0}</span>
                                        </div>
                                    </div>
                                    <div class="comparison-chart" id="threeZoneComparisonChart" style="height: 300px;"></div>
                                </div>
                            </div>

                            <div class="comparison-summary">
                                <h4><i class="fas fa-lightbulb"></i> 联动分析总结</h4>
                                <div class="summary-content">
                                    ${threeZoneAnalysisResults.topCombinations.length > 0 ? `
                                        <p><strong>高频三区组合：</strong> ${threeZoneAnalysisResults.topCombinations[0].combination}（出现 ${threeZoneAnalysisResults.topCombinations[0].count} 次）</p>
                                        <p><strong>对应AC值：</strong> ${threeZoneAnalysisResults.combinationACStats[threeZoneAnalysisResults.topCombinations[0].combination]?.avgAC || 'N/A'}</p>
                                        <p><strong>推荐策略：</strong> 优先选择 ${threeZoneAnalysisResults.hotZone?.name || 'N/A'} 中的号码，关注AC值在 ${Math.floor(parseFloat(acValueChartData.statistics.mean || 0) - 1)}-${Math.ceil(parseFloat(acValueChartData.statistics.mean || 0) + 1)} 区间的组合</p>
                                    ` : '<p>暂无高频三区组合数据</p>'}
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                            <button class="btn btn-primary" onclick="EventDelegate.printComparisonView()">打印对比</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                setTimeout(() => {
                    this.renderComparisonCharts();
                }, 100);
            }

            static renderComparisonCharts() {
                const acValueChartDom = document.getElementById('acValueComparisonChart');
                const threeZoneChartDom = document.getElementById('threeZoneComparisonChart');

                if (acValueChartDom && acValueChartData && acValueChartData.statistics && acValueChartData.statistics.valueCounts) {
                    try {
                        const acValueChart = echarts.getInstanceByDom(acValueChartDom) || echarts.init(acValueChartDom);
                        const acValueOption = {
                            title: {
                                text: 'AC值分布',
                                left: 'center',
                                textStyle: { fontSize: 14 }
                            },
                            tooltip: {
                                trigger: 'axis',
                                axisPointer: { type: 'shadow' }
                            },
                            xAxis: {
                                type: 'category',
                                data: Object.keys(acValueChartData.statistics.valueCounts).sort((a, b) => a - b),
                                name: 'AC值'
                            },
                            yAxis: {
                                type: 'value',
                                name: '出现次数'
                            },
                            series: [{
                                type: 'bar',
                                data: Object.keys(acValueChartData.statistics.valueCounts)
                                    .sort((a, b) => a - b)
                                    .map(key => acValueChartData.statistics.valueCounts[key]),
                                itemStyle: { color: '#3B82F6' }
                            }]
                        };
                        acValueChart.setOption(acValueOption);
                    } catch (error) {
                        console.error('AC值对比图表渲染失败:', error);
                    }
                }

                if (threeZoneChartDom && threeZoneChartData) {
                    try {
                        const threeZoneChart = echarts.getInstanceByDom(threeZoneChartDom) || echarts.init(threeZoneChartDom);
                        const rules = LOTTERY_RULES[currentLotteryType];
                        const zoneRanges = rules.threeZoneRanges;

                        const threeZoneOption = {
                            title: {
                                text: '三区出号占比',
                                left: 'center',
                                textStyle: { fontSize: 14 }
                            },
                            tooltip: {
                                trigger: 'item',
                                formatter: '{a} <br/>{b}: {c} ({d}%)'
                            },
                            legend: {
                                orient: 'vertical',
                                left: 'left',
                                data: [
                                    `一区(${zoneRanges.zone1[0]}-${zoneRanges.zone1[1]})`,
                                    `二区(${zoneRanges.zone2[0]}-${zoneRanges.zone2[1]})`,
                                    `三区(${zoneRanges.zone3[0]}-${zoneRanges.zone3[1]})`
                                ]
                            },
                            series: [{
                                name: '大中小分布',
                                type: 'pie',
                                radius: '60%',
                                data: [
                                    { 
                                        value: threeZoneChartData.zone1Count, 
                                        name: `一区(${zoneRanges.zone1[0]}-${zoneRanges.zone1[1]})`,
                                        itemStyle: { color: '#E63946' }
                                    },
                                    { 
                                        value: threeZoneChartData.zone2Count, 
                                        name: `二区(${zoneRanges.zone2[0]}-${zoneRanges.zone2[1]})`,
                                        itemStyle: { color: '#F4A261' }
                                    },
                                    { 
                                        value: threeZoneChartData.zone3Count, 
                                        name: `三区(${zoneRanges.zone3[0]}-${zoneRanges.zone3[1]})`,
                                        itemStyle: { color: '#457B9D' }
                                    }
                                ],
                                emphasis: {
                                    itemStyle: {
                                        shadowBlur: 10,
                                        shadowOffsetX: 0,
                                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                                    }
                                }
                            }]
                        };
                        threeZoneChart.setOption(threeZoneOption);
                    } catch (error) {
                        console.error('三区对比图表渲染失败:', error);
                    }
                }
            }

            static printComparisonView() {
                window.print();
            }

            static performCorrelationAnalysis(draws) {
                if (!draws) {
                    draws = currentDatabaseData.draws || [];
                }

                if (draws.length === 0) {
                    MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                    return;
                }

                const periodSelect = document.getElementById('correlationPeriodSelect');
                const periodValue = periodSelect ? periodSelect.value : '100';
                const analysisPeriod = periodValue === 'all' ? draws.length : parseInt(periodValue);

                const reversedDraws = [...draws].reverse().slice(0, analysisPeriod);

                // 更新分析范围显示
                const correlationDataRangeInfo = document.getElementById('correlationDataRangeInfo');
                if (correlationDataRangeInfo && reversedDraws.length > 0) {
                    const startPeriod = reversedDraws[reversedDraws.length - 1].period;
                    const endPeriod = reversedDraws[0].period;
                    correlationDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${reversedDraws.length}期）`;
                }

                const phase1Data = this.performCorrelationPhase1Analysis(reversedDraws);

                const correlationData = {
                    numberCorrelation: this.calculateNumberCorrelation(reversedDraws),
                    dimensionCorrelation: this.calculateDimensionCorrelation(reversedDraws),
                    networkData: this.calculateNetworkData(reversedDraws),
                    statistics: {},
                    period: analysisPeriod,
                    phase1Data: phase1Data
                };

                correlationData.statistics = this.calculateCorrelationStatistics(correlationData);

                correlationAnalysisData = correlationData;
                correlationAnalysisResults = correlationData.statistics;

                this.updateCorrelationChart(correlationData);
                this.generateCorrelationConclusion(correlationData);

                MessageSystem.showMessage(`已完成${reversedDraws.length}期数据的相关性分析`, 'success');
            }

            static performCorrelationPhase1Analysis(draws) {
                console.log('=== 开始执行相关性分析阶段1（逐期关联分析） ===');
                console.log('数据期数:', draws.length);

                const phase1Data = {
                    consecutiveNumberPatterns: [],
                    consecutiveDimensionPatterns: [],
                    numberPairTransitions: {},
                    dimensionTransitions: {},
                    correlationOscillation: [],
                    strongCorrelationStreaks: []
                };

                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                for (let i = 0; i < draws.length - 1; i++) {
                    const currentDraw = draws[i];
                    const nextDraw = draws[i + 1];

                    const currentRedBalls = currentDraw.redBalls.map(ball => parseInt(ball));
                    const nextRedBalls = nextDraw.redBalls.map(ball => parseInt(ball));

                    const currentPairs = [];
                    for (let j = 0; j < currentRedBalls.length; j++) {
                        for (let k = j + 1; k < currentRedBalls.length; k++) {
                            currentPairs.push([currentRedBalls[j], currentRedBalls[k]].sort().join('-'));
                        }
                    }

                    const nextPairs = [];
                    for (let j = 0; j < nextRedBalls.length; j++) {
                        for (let k = j + 1; k < nextRedBalls.length; k++) {
                            nextPairs.push([nextRedBalls[j], nextRedBalls[k]].sort().join('-'));
                        }
                    }

                    const commonPairs = currentPairs.filter(pair => nextPairs.includes(pair));
                    const uniqueToCurrent = currentPairs.filter(pair => !nextPairs.includes(pair));
                    const uniqueToNext = nextPairs.filter(pair => !currentPairs.includes(pair));

                    phase1Data.consecutiveNumberPatterns.push({
                        period: currentDraw.period,
                        commonPairs: commonPairs,
                        uniqueToCurrent: uniqueToCurrent,
                        uniqueToNext: uniqueToNext,
                        pairRetentionRate: commonPairs.length / currentPairs.length
                    });

                    currentPairs.forEach(pair => {
                        const transitionKey = `${pair}_${nextPairs.includes(pair) ? 'stay' : 'leave'}`;
                        if (!phase1Data.numberPairTransitions[transitionKey]) {
                            phase1Data.numberPairTransitions[transitionKey] = 0;
                        }
                        phase1Data.numberPairTransitions[transitionKey]++;
                    });

                    const currentDimensions = this.calculateDrawDimensions(currentDraw);
                    const nextDimensions = this.calculateDrawDimensions(nextDraw);

                    const dimensionChanges = {};
                    Object.keys(currentDimensions).forEach(dim => {
                        const currentVal = currentDimensions[dim];
                        const nextVal = nextDimensions[dim];
                        const change = nextVal - currentVal;
                        dimensionChanges[dim] = {
                            current: currentVal,
                            next: nextVal,
                            change: change,
                            direction: change > 0 ? 'increase' : change < 0 ? 'decrease' : 'stable'
                        };
                    });

                    phase1Data.consecutiveDimensionPatterns.push({
                        period: currentDraw.period,
                        dimensionChanges: dimensionChanges
                    });

                    Object.keys(dimensionChanges).forEach(dim => {
                        const direction = dimensionChanges[dim].direction;
                        const transitionKey = `${dim}_${direction}`;
                        if (!phase1Data.dimensionTransitions[transitionKey]) {
                            phase1Data.dimensionTransitions[transitionKey] = 0;
                        }
                        phase1Data.dimensionTransitions[transitionKey]++;
                    });

                    const currentCorrelation = this.calculateSinglePeriodCorrelation(currentDraw);
                    const nextCorrelation = this.calculateSinglePeriodCorrelation(nextDraw);

                    phase1Data.correlationOscillation.push({
                        period: currentDraw.period,
                        currentCorrelation: currentCorrelation,
                        nextCorrelation: nextCorrelation,
                        oscillation: Math.abs(nextCorrelation - currentCorrelation)
                    });

                    if (currentCorrelation > 0.5 && nextCorrelation > 0.5) {
                        let streak = 1;
                        for (let j = i - 1; j >= 0; j--) {
                            const prevDraw = draws[j];
                            const prevCorrelation = this.calculateSinglePeriodCorrelation(prevDraw);
                            if (prevCorrelation > 0.5) {
                                streak++;
                            } else {
                                break;
                            }
                        }
                        phase1Data.strongCorrelationStreaks.push({
                            period: currentDraw.period,
                            streak: streak
                        });
                    }
                }

                console.log('相关性分析阶段1完成');
                console.log('连续号码模式数:', phase1Data.consecutiveNumberPatterns.length);
                console.log('连续维度模式数:', phase1Data.consecutiveDimensionPatterns.length);

                return phase1Data;
            }

            static calculateDrawDimensions(draw) {
                const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                const sum = redBalls.reduce((acc, val) => acc + val, 0);
                const span = redBalls[redBalls.length - 1] - redBalls[0];
                const acValue = this.calculateACValue(redBalls);
                const oddCount = redBalls.filter(n => n % 2 === 1).length;
                const bigCount = redBalls.filter(n => n > 17).length;
                const primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
                const primeCount = redBalls.filter(n => primeNumbers.includes(n)).length;

                return {
                    sum: sum,
                    span: span,
                    acValue: acValue,
                    oddCount: oddCount,
                    bigCount: bigCount,
                    primeCount: primeCount
                };
            }

            static calculateSinglePeriodCorrelation(draw) {
                const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                const sum = redBalls.reduce((acc, val) => acc + val, 0);
                const span = redBalls[redBalls.length - 1] - redBalls[0];
                const acValue = this.calculateACValue(redBalls);

                const normalizedSum = (sum - 102) / 51;
                const normalizedSpan = (span - 16) / 16;
                const normalizedAC = (acValue - 5) / 5;

                return (normalizedSum + normalizedSpan + normalizedAC) / 3;
            }

            static calculateNumberCorrelation(draws) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;
                const totalNumbers = redBallRange[1] - redBallRange[0] + 1;

                const coOccurrenceMatrix = {};
                const pairFrequency = {};

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    coOccurrenceMatrix[i] = {};
                    for (let j = redBallRange[0]; j <= redBallRange[1]; j++) {
                        coOccurrenceMatrix[i][j] = 0;
                    }
                }

                draws.forEach(draw => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball));
                    for (let i = 0; i < redBalls.length; i++) {
                        for (let j = i + 1; j < redBalls.length; j++) {
                            coOccurrenceMatrix[redBalls[i]][redBalls[j]]++;
                            coOccurrenceMatrix[redBalls[j]][redBalls[i]]++;

                            const key = [redBalls[i], redBalls[j]].sort().join('-');
                            pairFrequency[key] = (pairFrequency[key] || 0) + 1;
                        }
                    }
                });

                const correlationMatrix = {};
                const numberFrequency = {};

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    numberFrequency[i] = 0;
                    draws.forEach(draw => {
                        if (draw.redBalls.includes(i.toString())) {
                            numberFrequency[i]++;
                        }
                    });
                }

                const maxCoOccurrence = Math.max(...Object.values(pairFrequency));
                const minCoOccurrence = Math.min(...Object.values(pairFrequency));

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    correlationMatrix[i] = {};
                    for (let j = redBallRange[0]; j <= redBallRange[1]; j++) {
                        if (i === j) {
                            correlationMatrix[i][j] = 1;
                        } else {
                            const expected = (numberFrequency[i] * numberFrequency[j]) / draws.length;
                            const actual = coOccurrenceMatrix[i][j];

                            const pearsonCorrelation = expected > 0 ? (actual - expected) / Math.sqrt(numberFrequency[i] * numberFrequency[j] * (1 - numberFrequency[i] / draws.length) * (1 - numberFrequency[j] / draws.length)) : 0;

                            const normalizedCoOccurrence = maxCoOccurrence > minCoOccurrence ? (actual - minCoOccurrence) / (maxCoOccurrence - minCoOccurrence) : 0;

                            const combinedCorrelation = 0.6 * (isNaN(pearsonCorrelation) ? 0 : pearsonCorrelation) + 0.4 * normalizedCoOccurrence;

                            correlationMatrix[i][j] = isNaN(combinedCorrelation) ? 0 : combinedCorrelation;
                        }
                    }
                }

                return correlationMatrix;
            }

            static calculateDimensionCorrelation(draws) {
                const dimensions = {
                    '和值': [],
                    '跨度': [],
                    'AC值': [],
                    '奇偶比': [],
                    '大小比': [],
                    '质合比': [],
                    '大中小分布': []
                };

                const rules = LOTTERY_RULES[currentLotteryType];

                draws.forEach(draw => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    const sum = redBalls.reduce((acc, val) => acc + val, 0);
                    dimensions['和值'].push(sum);

                    const span = redBalls[redBalls.length - 1] - redBalls[0];
                    dimensions['跨度'].push(span);

                    const acValue = this.calculateACValue(redBalls);
                    dimensions['AC值'].push(acValue);

                    const oddCount = redBalls.filter(n => n % 2 === 1).length;
                    dimensions['奇偶比'].push(oddCount / redBalls.length);

                    const bigCount = redBalls.filter(n => n > 17).length;
                    dimensions['大小比'].push(bigCount / redBalls.length);

                    const primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
                    const primeCount = redBalls.filter(n => primeNumbers.includes(n)).length;
                    dimensions['质合比'].push(primeCount / redBalls.length);

                    const zone1Count = redBalls.filter(n => n >= 1 && n <= 11).length;
                    const zone2Count = redBalls.filter(n => n >= 12 && n <= 22).length;
                    const zone3Count = redBalls.filter(n => n >= 23 && n <= 33).length;
                    dimensions['大中小分布'].push([zone1Count, zone2Count, zone3Count]);
                });

                const correlationMatrix = {};
                const dimensionNames = Object.keys(dimensions);

                for (let i = 0; i < dimensionNames.length; i++) {
                    correlationMatrix[dimensionNames[i]] = {};
                    for (let j = 0; j < dimensionNames.length; j++) {
                        if (i === j) {
                            correlationMatrix[dimensionNames[i]][dimensionNames[j]] = 1;
                        } else {
                            const correlation = this.calculatePearsonCorrelation(dimensions[dimensionNames[i]], dimensions[dimensionNames[j]]);
                            correlationMatrix[dimensionNames[i]][dimensionNames[j]] = correlation;
                        }
                    }
                }

                return correlationMatrix;
            }

            static calculatePearsonCorrelation(x, y) {
                const n = x.length;
                if (n !== y.length || n === 0) return 0;

                const meanX = x.reduce((a, b) => a + b, 0) / n;
                const meanY = y.reduce((a, b) => a + b, 0) / n;

                let numerator = 0;
                let denominatorX = 0;
                let denominatorY = 0;

                for (let i = 0; i < n; i++) {
                    const diffX = x[i] - meanX;
                    const diffY = y[i] - meanY;
                    numerator += diffX * diffY;
                    denominatorX += diffX * diffX;
                    denominatorY += diffY * diffY;
                }

                const denominator = Math.sqrt(denominatorX * denominatorY);
                return denominator === 0 ? 0 : numerator / denominator;
            }

            static calculateNetworkData(draws) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                const nodes = [];
                const links = [];

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    nodes.push({
                        id: i.toString(),
                        name: i.toString(),
                        symbolSize: 10,
                        value: 0
                    });
                }

                const coOccurrence = {};

                draws.forEach(draw => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball));
                    for (let i = 0; i < redBalls.length; i++) {
                        nodes[redBalls[i] - 1].value++;
                        for (let j = i + 1; j < redBalls.length; j++) {
                            const key = [redBalls[i], redBalls[j]].sort().join('-');
                            coOccurrence[key] = (coOccurrence[key] || 0) + 1;
                        }
                    }
                });

                Object.entries(coOccurrence).forEach(([key, count]) => {
                    const [source, target] = key.split('-');
                    links.push({
                        source: source,
                        target: target,
                        value: count
                    });
                });

                nodes.forEach(node => {
                    node.symbolSize = 10 + node.value * 2;
                });

                return { nodes, links };
            }

            static calculateCorrelationStatistics(correlationData) {
                const numberCorrelation = correlationData.numberCorrelation;
                const dimensionCorrelation = correlationData.dimensionCorrelation;

                let strongestPair = { pair: '-', value: 0 };
                let highCorrelationCount = 0;
                let lowCorrelationCount = 0;

                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    for (let j = i + 1; j <= redBallRange[1]; j++) {
                        const value = numberCorrelation[i][j];
                        if (Math.abs(value) > Math.abs(strongestPair.value)) {
                            strongestPair = { pair: `${i}-${j}`, value };
                        }
                        if (value > 0.3) highCorrelationCount++;
                        if (value < -0.3) lowCorrelationCount++;
                    }
                }

                let strongestDimension = { dimension: '-', value: 0 };
                const dimensionNames = Object.keys(dimensionCorrelation);

                for (let i = 0; i < dimensionNames.length; i++) {
                    for (let j = i + 1; j < dimensionNames.length; j++) {
                        const value = dimensionCorrelation[dimensionNames[i]][dimensionNames[j]];
                        if (Math.abs(value) > Math.abs(strongestDimension.value)) {
                            strongestDimension = { dimension: `${dimensionNames[i]}-${dimensionNames[j]}`, value };
                        }
                    }
                }

                return {
                    strongestPair,
                    strongestDimension,
                    highCorrelationCount,
                    lowCorrelationCount,
                    averageCorrelation: this.calculateAverageCorrelation(numberCorrelation, redBallRange)
                };
            }

            static calculateAverageCorrelation(correlationMatrix, range) {
                let sum = 0;
                let count = 0;

                for (let i = range[0]; i <= range[1]; i++) {
                    for (let j = i + 1; j <= range[1]; j++) {
                        sum += Math.abs(correlationMatrix[i][j]);
                        count++;
                    }
                }

                return count > 0 ? (sum / count).toFixed(3) : 0;
            }

            static updateCorrelationChart(correlationData) {
                const heatmapContent = document.getElementById('correlation-heatmap');
                const scatterContent = document.getElementById('correlation-scatter');
                const networkContent = document.getElementById('correlation-network');

                heatmapContent.style.display = 'none';
                scatterContent.style.display = 'none';
                networkContent.style.display = 'none';

                if (currentCorrelationChartType === 'heatmap') {
                    heatmapContent.style.display = 'block';
                    this.updateCorrelationHeatmap(correlationData);
                } else if (currentCorrelationChartType === 'scatter') {
                    scatterContent.style.display = 'block';
                    this.updateCorrelationScatter(correlationData);
                } else if (currentCorrelationChartType === 'network') {
                    networkContent.style.display = 'block';
                    this.updateCorrelationNetwork(correlationData);
                }
            }

            static updateCorrelationHeatmap(correlationData) {
                const chartDom = document.getElementById('correlationHeatmapChart');
                if (!chartDom) return;

                if (correlationHeatmapChart) {
                    correlationHeatmapChart.dispose();
                }

                correlationHeatmapChart = echarts.init(chartDom);

                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                const xData = [];
                const yData = [];
                const data = [];

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    xData.push(i.toString());
                    yData.push(i.toString());
                }

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    for (let j = redBallRange[0]; j <= redBallRange[1]; j++) {
                        data.push([j - 1, i - 1, correlationData.numberCorrelation[i][j]]);
                    }
                }

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `号码相关性热力图（最近${correlationData.period}期）`,
                        subtext: `平均相关系数: ${correlationData.statistics.averageCorrelation}`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#7f8c8d'
                        }
                    },
                    tooltip: {
                        position: 'top',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 13
                        },
                        formatter: function(params) {
                            const value = params.value[2];
                            const level = Math.abs(value) >= 0.5 ? '强' : (Math.abs(value) >= 0.3 ? '中' : '弱');
                            const color = value >= 0.5 ? '#e74c3c' : (value >= 0.3 ? '#e67e22' : (value >= 0 ? '#f39c12' : (value >= -0.3 ? '#3498db' : (value >= -0.5 ? '#2980b9' : '#8e44ad'))));
                            return `<div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 8px;">号码对: ${params.value[1] + 1} - ${params.value[0] + 1}</div>
                                    <div style="margin: 4px 0;">相关系数: <strong style="color: ${color}; font-size: 16px;">${value.toFixed(3)}</strong></div>
                                    <div style="margin-top: 4px; font-size: 11px; color: #bdc3c7;">
                                        相关性: <span style="padding: 2px 8px; background: ${color}; border-radius: 10px; font-size: 11px;">${level}</span>
                                    </div>
                                </div>`;
                        }
                    },
                    grid: {
                        height: '70%',
                        top: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        data: xData,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            fontSize: 11
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: yData,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            fontSize: 11
                        }
                    },
                    visualMap: {
                        min: -1,
                        max: 1,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '5%',
                        inRange: {
                            color: ['#3498db', '#ecf0f1', '#e74c3c']
                        },
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    series: [{
                        name: '相关系数',
                        type: 'heatmap',
                        data: data,
                        label: {
                            show: false
                        },
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    }]
                };

                correlationHeatmapChart.setOption(option);
            }

            static updateCorrelationScatter(correlationData) {
                const chartDom = document.getElementById('correlationScatterChart');
                if (!chartDom) return;

                if (correlationScatterChart) {
                    correlationScatterChart.dispose();
                }

                correlationScatterChart = echarts.init(chartDom);

                const dimensionCorrelation = correlationData.dimensionCorrelation;
                const dimensionNames = Object.keys(dimensionCorrelation);

                const xData = [];
                const yData = [];
                const data = [];

                for (let i = 0; i < dimensionNames.length; i++) {
                    for (let j = 0; j < dimensionNames.length; j++) {
                        xData.push(dimensionNames[j]);
                        yData.push(dimensionNames[i]);
                        data.push([j, i, dimensionCorrelation[dimensionNames[i]][dimensionNames[j]]]);
                    }
                }

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `维度相关性散点图（最近${correlationData.period}期）`,
                        subtext: `最强相关: ${correlationData.statistics.strongestDimension.dimension} (${correlationData.statistics.strongestDimension.value.toFixed(3)})`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#7f8c8d'
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 13
                        },
                        formatter: function(params) {
                            const value = params.value[2];
                            const level = Math.abs(value) >= 0.5 ? '强' : (Math.abs(value) >= 0.3 ? '中' : '弱');
                            const color = value >= 0.5 ? '#e74c3c' : (value >= 0.3 ? '#e67e22' : (value >= 0 ? '#f39c12' : (value >= -0.3 ? '#3498db' : (value >= -0.5 ? '#2980b9' : '#8e44ad'))));
                            return `<div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 8px;">维度对: ${params.value[1]} - ${params.value[0]}</div>
                                    <div style="margin: 4px 0;">相关系数: <strong style="color: ${color}; font-size: 16px;">${value.toFixed(3)}</strong></div>
                                    <div style="margin-top: 4px; font-size: 11px; color: #bdc3c7;">
                                        相关性: <span style="padding: 2px 8px; background: ${color}; border-radius: 10px; font-size: 11px;">${level}</span>
                                    </div>
                                </div>`;
                        }
                    },
                    grid: {
                        left: '10%',
                        right: '5%',
                        bottom: '10%',
                        top: '20%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: dimensionNames,
                        boundaryGap: true,
                        axisLabel: {
                            interval: 0,
                            rotate: 45,
                            fontSize: 11
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: dimensionNames,
                        axisLabel: {
                            interval: 0,
                            fontSize: 11
                        },
                        axisLine: {
                            lineStyle: {
                                color: '#bdc3c7'
                            }
                        }
                    },
                    visualMap: {
                        min: -1,
                        max: 1,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '2%',
                        inRange: {
                            color: ['#3498db', '#ecf0f1', '#e74c3c']
                        },
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    series: [{
                        name: '相关系数',
                        type: 'scatter',
                        symbolSize: function(data) {
                            return 20 + Math.abs(data[2]) * 30;
                        },
                        data: data,
                        itemStyle: {
                            shadowBlur: 10,
                            shadowColor: 'rgba(0, 0, 0, 0.3)'
                        }
                    }]
                };

                correlationScatterChart.setOption(option);
            }

            static updateCorrelationNetwork(correlationData) {
                const chartDom = document.getElementById('correlationNetworkChart');
                if (!chartDom) return;

                if (correlationNetworkChart) {
                    correlationNetworkChart.dispose();
                }

                correlationNetworkChart = echarts.init(chartDom);

                const networkData = correlationData.networkData;
                const numberCorrelation = correlationData.numberCorrelation;

                const minLinkValue = Math.max(2, Math.floor(networkData.links.length / 50));
                const filteredLinks = networkData.links.filter(link => link.value >= minLinkValue);

                const linkValueRange = filteredLinks.length > 0 ? {
                    min: Math.min(...filteredLinks.map(l => l.value)),
                    max: Math.max(...filteredLinks.map(l => l.value))
                } : { min: 0, max: 1 };

                const nodeValueRange = networkData.nodes.length > 0 ? {
                    min: Math.min(...networkData.nodes.map(n => n.value)),
                    max: Math.max(...networkData.nodes.map(n => n.value))
                } : { min: 0, max: 1 };

                const getNodeColor = (value) => {
                    const ratio = (value - nodeValueRange.min) / (nodeValueRange.max - nodeValueRange.min || 1);
                    if (ratio > 0.7) return '#e74c3c';
                    if (ratio > 0.4) return '#f39c12';
                    if (ratio > 0.2) return '#3498db';
                    return '#95a5a6';
                };

                const getLinkColor = (value) => {
                    const ratio = (value - linkValueRange.min) / (linkValueRange.max - linkValueRange.min || 1);
                    if (ratio > 0.7) return '#e74c3c';
                    if (ratio > 0.4) return '#f39c12';
                    return '#95a5a6';
                };

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `号码关联网络图（最近${correlationData.period}期）`,
                        subtext: `节点: ${networkData.nodes.length} | 连线: ${filteredLinks.length} | 阈值: ≥${minLinkValue}次`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        },
                        subtextStyle: {
                            fontSize: 12,
                            color: '#7f8c8d'
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 13
                        },
                        formatter: function(params) {
                            if (params.dataType === 'node') {
                                const ratio = ((params.value - nodeValueRange.min) / (nodeValueRange.max - nodeValueRange.min || 1) * 100).toFixed(1);
                                return `<div style="padding: 8px;">
                                        <div style="font-weight: bold; margin-bottom: 8px;">号码: ${params.name}</div>
                                        <div style="margin: 4px 0;">出现次数: <strong>${params.value}</strong></div>
                                        <div style="margin: 4px 0;">热度排名: <strong>${ratio}%</strong></div>
                                    </div>`;
                            } else {
                                const source = params.data.source;
                                const target = params.data.target;
                                const value = params.data.value;
                                const correlation = numberCorrelation[source][target];
                                return `<div style="padding: 8px;">
                                        <div style="font-weight: bold; margin-bottom: 8px;">连线: ${source} - ${target}</div>
                                        <div style="margin: 4px 0;">共现次数: <strong>${value}</strong></div>
                                        <div style="margin: 4px 0;">相关系数: <strong>${correlation.toFixed(3)}</strong></div>
                                    </div>`;
                            }
                        }
                    },
                    legend: {
                        data: ['高热度', '中热度', '低热度'],
                        top: '15%',
                        right: '5%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    series: [{
                        type: 'graph',
                        layout: 'force',
                        data: networkData.nodes.map(node => ({
                            name: node.name,
                            value: node.value,
                            symbolSize: Math.max(15, Math.min(40, 15 + (node.value - nodeValueRange.min) / (nodeValueRange.max - nodeValueRange.min || 1) * 25)),
                            itemStyle: {
                                color: getNodeColor(node.value),
                                borderColor: '#2c3e50',
                                borderWidth: 2,
                                shadowBlur: 10,
                                shadowColor: 'rgba(0, 0, 0, 0.3)'
                            },
                            categories: node.value > (nodeValueRange.max + nodeValueRange.min) / 2 ? [0] : [1]
                        })),
                        links: filteredLinks.map(link => ({
                            source: link.source,
                            target: link.target,
                            value: link.value,
                            lineStyle: {
                                color: getLinkColor(link.value),
                                width: Math.max(1, Math.min(8, (link.value - linkValueRange.min) / (linkValueRange.max - linkValueRange.min || 1) * 7 + 1)),
                                opacity: 0.7,
                                curveness: 0.1
                            }
                        })),
                        categories: [{ name: '高热度' }, { name: '中热度' }, { name: '低热度' }],
                        roam: true,
                        label: {
                            show: true,
                            position: 'right',
                            formatter: '{b}',
                            fontSize: 11,
                            color: '#2c3e50'
                        },
                        force: {
                            repulsion: Math.max(200, Math.min(500, networkData.nodes.length * 10)),
                            edgeLength: [30, 200],
                            gravity: 0.05,
                            friction: 0.6
                        },
                        emphasis: {
                            focus: 'adjacency',
                            lineStyle: {
                                width: 4
                            },
                            itemStyle: {
                                shadowBlur: 20,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        }
                    }]
                };

                correlationNetworkChart.setOption(option);
            }

            static generateCorrelationConclusion(correlationData) {
                const statistics = correlationData.statistics;
                const phase1Data = correlationData.phase1Data;
                const rules = LOTTERY_RULES[currentLotteryType];

                document.getElementById('correlationAnalysisPeriods').textContent = correlationData.period;
                document.getElementById('correlationStrongestPair').textContent = statistics.strongestPair.pair;
                document.getElementById('correlationStrongestValue').textContent = statistics.strongestPair.value.toFixed(3);
                document.getElementById('correlationHighCount').textContent = statistics.highCorrelationCount;

                document.getElementById('correlationScatterPeriods').textContent = correlationData.period;
                document.getElementById('correlationStrongestDimension').textContent = statistics.strongestDimension.dimension;
                document.getElementById('correlationStrongestDimValue').textContent = statistics.strongestDimension.value.toFixed(3);

                document.getElementById('correlationNetworkPeriods').textContent = correlationData.period;
                document.getElementById('correlationNodeCount').textContent = correlationData.networkData.nodes.length;
                document.getElementById('correlationEdgeCount').textContent = correlationData.networkData.links.filter(link => link.value >= 3).length;

                const conclusionContent = document.getElementById('correlationConclusionContent');
                const insights = [];

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-chart-line"></i>
                        <strong>号码相关性分析</strong>
                    </div>
                    <div class="insight-body">
                        <p>在最近${correlationData.period}期数据中，号码<strong>${statistics.strongestPair.pair}</strong>表现出最强的相关性，相关系数为<strong>${statistics.strongestPair.value.toFixed(3)}</strong>。</p>
                        <p>共有<strong>${statistics.highCorrelationCount}</strong>对号码表现出较强的正相关性（相关系数 > 0.3），<strong>${statistics.lowCorrelationCount}</strong>对号码表现出较强的负相关性（相关系数 < -0.3）。</p>
                        <p>平均相关系数为<strong>${statistics.averageCorrelation}</strong>，${parseFloat(statistics.averageCorrelation) > 0.2 ? '整体号码间存在较强的关联性' : '整体号码间关联性较弱'}。</p>
                    </div>
                </div>`);

                if (phase1Data && phase1Data.consecutiveNumberPatterns.length > 0) {
                    const avgRetentionRate = phase1Data.consecutiveNumberPatterns.reduce((sum, p) => sum + p.pairRetentionRate, 0) / phase1Data.consecutiveNumberPatterns.length;
                    const strongRetentionPairs = Object.entries(phase1Data.numberPairTransitions)
                        .filter(([key, count]) => key.endsWith('_stay') && count >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);

                    insights.push(`<div class="insight-item">
                        <div class="insight-header">
                            <i class="fas fa-exchange-alt"></i>
                            <strong>逐期关联分析（阶段1）</strong>
                        </div>
                        <div class="insight-body">
                            <p>相邻期号码对平均保留率为<strong>${(avgRetentionRate * 100).toFixed(1)}%</strong>，${avgRetentionRate > 0.3 ? '表明相邻期之间存在较强的号码对延续性' : '表明相邻期之间号码对变化较大'}。</p>
                            ${strongRetentionPairs.length > 0 ? `<p>高频保留号码对：${strongRetentionPairs.map(([key, count]) => `<strong>${key.replace('_stay', '')}</strong>(${count}次)`).join('、')}。</p>` : ''}
                            <p>最强相关性连续期数：${phase1Data.strongCorrelationStreaks.length > 0 ? `<strong>${Math.max(...phase1Data.strongCorrelationStreaks.map(s => s.streak))}</strong>期` : '无'}。</p>
                        </div>
                    </div>`);
                }

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-braille"></i>
                        <strong>维度相关性分析</strong>
                    </div>
                    <div class="insight-body">
                        <p>维度<strong>${statistics.strongestDimension.dimension}</strong>表现出最强的相关性，相关系数为<strong>${statistics.strongestDimension.value.toFixed(3)}</strong>。</p>
                        ${Math.abs(statistics.strongestDimension.value) > 0.5 ? '<p>该维度对之间存在强相关性，建议在选号时综合考虑这两个维度的变化趋势。</p>' : '<p>各维度间的相关性整体较弱，选号时可以相对独立地考虑各个维度。</p>'}
                    </div>
                </div>`);

                if (phase1Data && phase1Data.consecutiveDimensionPatterns.length > 0) {
                    const dimensionDirectionCounts = {};
                    Object.entries(phase1Data.dimensionTransitions).forEach(([key, count]) => {
                        const [dim, direction] = key.split('_');
                        if (!dimensionDirectionCounts[dim]) {
                            dimensionDirectionCounts[dim] = { increase: 0, decrease: 0, stable: 0 };
                        }
                        dimensionDirectionCounts[dim][direction] += count;
                    });

                    const dominantTrends = Object.entries(dimensionDirectionCounts)
                        .map(([dim, counts]) => {
                            const maxCount = Math.max(counts.increase, counts.decrease, counts.stable);
                            const direction = counts.increase === maxCount ? 'increase' : counts.decrease === maxCount ? 'decrease' : 'stable';
                            return { dim, direction, count: maxCount };
                        })
                        .slice(0, 3);

                    insights.push(`<div class="insight-item">
                        <div class="insight-header">
                            <i class="fas fa-chart-bar"></i>
                            <strong>维度逐期变化趋势（阶段1）</strong>
                        </div>
                        <div class="insight-body">
                            ${dominantTrends.map(trend => {
                                const directionText = trend.direction === 'increase' ? '上升' : trend.direction === 'decrease' ? '下降' : '稳定';
                                return `<p><strong>${trend.dim}</strong>主要呈${directionText}趋势（${trend.count}次）。</p>`;
                            }).join('')}
                        </div>
                    </div>`);
                }

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-project-diagram"></i>
                        <strong>关联网络分析</strong>
                    </div>
                    <div class="insight-body">
                        <p>网络图中共有<strong>${correlationData.networkData.nodes.length}</strong>个节点（号码），<strong>${correlationData.networkData.links.filter(link => link.value >= 3).length}</strong>条有效连线（共现次数 ≥ 3）。</p>
                        <p>连线越粗表示两个号码共现次数越多，节点越大表示该号码出现频率越高。</p>
                        <p>建议关注网络图中连线较粗的号码对，这些号码对在历史数据中经常同时出现。</p>
                    </div>
                </div>`);

                conclusionContent.innerHTML = insights.join('');
            }

            static generateCorrelationRecommendation() {
                if (!correlationAnalysisData) {
                    MessageSystem.showMessage('请先完成相关性分析', 'error');
                    return;
                }

                const mode = document.getElementById('correlationRecommendationMode').value;
                const threshold = parseFloat(document.getElementById('correlationThreshold').value);
                const rules = LOTTERY_RULES[currentLotteryType];

                const numberCorrelation = correlationAnalysisData.numberCorrelation;
                const networkData = correlationAnalysisData.networkData;
                const redBallRange = rules.redBallRange;

                let recommendedNumbers = [];
                let recommendationReason = '';
                let usedPairs = [];

                if (mode === 'highCorrelation') {
                    let highCorrelationPairs = [];
                    for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                        for (let j = i + 1; j <= redBallRange[1]; j++) {
                            if (numberCorrelation[i][j] >= threshold) {
                                highCorrelationPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            }
                        }
                    }

                    highCorrelationPairs.sort((a, b) => b.value - a.value);

                    if (highCorrelationPairs.length === 0) {
                        const adjustedThreshold = Math.max(0, threshold - 0.2);
                        for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                            for (let j = i + 1; j <= redBallRange[1]; j++) {
                                if (numberCorrelation[i][j] >= adjustedThreshold) {
                                    highCorrelationPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                                }
                            }
                        }
                        highCorrelationPairs.sort((a, b) => b.value - a.value);
                    }

                    if (highCorrelationPairs.length === 0) {
                        const allPairs = [];
                        for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                            for (let j = i + 1; j <= redBallRange[1]; j++) {
                                allPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            }
                        }
                        allPairs.sort((a, b) => b.value - a.value);
                        highCorrelationPairs = allPairs.slice(0, 10);
                    }

                    if (highCorrelationPairs.length > 0) {
                        const topPairs = highCorrelationPairs.slice(0, 4);
                        const selectedNumbers = new Set();
                        topPairs.forEach(pair => {
                            selectedNumbers.add(pair.pair[0]);
                            selectedNumbers.add(pair.pair[1]);
                            usedPairs.push(pair);
                        });
                        recommendedNumbers = Array.from(selectedNumbers).sort((a, b) => a - b);
                        recommendationReason = `基于${usedPairs.length}个高相关号码对（相关系数范围：${usedPairs[usedPairs.length-1].value.toFixed(3)} ~ ${usedPairs[0].value.toFixed(3)}）`;
                    }
                } else if (mode === 'lowCorrelation') {
                    let lowCorrelationPairs = [];
                    for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                        for (let j = i + 1; j <= redBallRange[1]; j++) {
                            if (numberCorrelation[i][j] <= -threshold) {
                                lowCorrelationPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            }
                        }
                    }

                    lowCorrelationPairs.sort((a, b) => a.value - b.value);

                    if (lowCorrelationPairs.length === 0) {
                        const adjustedThreshold = Math.max(0, threshold - 0.2);
                        for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                            for (let j = i + 1; j <= redBallRange[1]; j++) {
                                if (numberCorrelation[i][j] <= -adjustedThreshold) {
                                    lowCorrelationPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                                }
                            }
                        }
                        lowCorrelationPairs.sort((a, b) => a.value - b.value);
                    }

                    if (lowCorrelationPairs.length === 0) {
                        const allPairs = [];
                        for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                            for (let j = i + 1; j <= redBallRange[1]; j++) {
                                allPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            }
                        }
                        allPairs.sort((a, b) => a.value - b.value);
                        lowCorrelationPairs = allPairs.slice(0, 10);
                    }

                    if (lowCorrelationPairs.length > 0) {
                        const topPairs = lowCorrelationPairs.slice(0, 4);
                        const selectedNumbers = new Set();
                        topPairs.forEach(pair => {
                            selectedNumbers.add(pair.pair[0]);
                            selectedNumbers.add(pair.pair[1]);
                            usedPairs.push(pair);
                        });
                        recommendedNumbers = Array.from(selectedNumbers).sort((a, b) => a - b);
                        recommendationReason = `基于${usedPairs.length}个低相关号码对（相关系数范围：${usedPairs[usedPairs.length-1].value.toFixed(3)} ~ ${usedPairs[0].value.toFixed(3)}）`;
                    }
                } else if (mode === 'balanced') {
                    let highCorrelationPairs = [];
                    let lowCorrelationPairs = [];

                    for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                        for (let j = i + 1; j <= redBallRange[1]; j++) {
                            if (numberCorrelation[i][j] >= threshold) {
                                highCorrelationPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            } else if (numberCorrelation[i][j] <= -threshold) {
                                lowCorrelationPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            }
                        }
                    }

                    highCorrelationPairs.sort((a, b) => b.value - a.value);
                    lowCorrelationPairs.sort((a, b) => a.value - b.value);

                    const selectedNumbers = new Set();

                    if (highCorrelationPairs.length === 0 && lowCorrelationPairs.length === 0) {
                        const allPairs = [];
                        for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                            for (let j = i + 1; j <= redBallRange[1]; j++) {
                                allPairs.push({ pair: [i, j], value: numberCorrelation[i][j] });
                            }
                        }
                        allPairs.sort((a, b) => Math.abs(b.value) - Math.abs(a.value));

                        const topPairs = allPairs.slice(0, 6);
                        topPairs.forEach(pair => {
                            selectedNumbers.add(pair.pair[0]);
                            selectedNumbers.add(pair.pair[1]);
                            usedPairs.push(pair);
                        });
                        recommendationReason = `基于${usedPairs.length}个中等相关号码对（综合考虑正负相关）`;
                    } else {
                        if (highCorrelationPairs.length > 0) {
                            const topHighPairs = highCorrelationPairs.slice(0, 3);
                            topHighPairs.forEach(pair => {
                                selectedNumbers.add(pair.pair[0]);
                                selectedNumbers.add(pair.pair[1]);
                                usedPairs.push(pair);
                            });
                        }

                        if (lowCorrelationPairs.length > 0) {
                            const topLowPairs = lowCorrelationPairs.slice(0, 3);
                            topLowPairs.forEach(pair => {
                                selectedNumbers.add(pair.pair[0]);
                                selectedNumbers.add(pair.pair[1]);
                                usedPairs.push(pair);
                            });
                        }

                        recommendationReason = `基于${highCorrelationPairs.length > 0 ? highCorrelationPairs.slice(0, 3).length : 0}个高相关和${lowCorrelationPairs.length > 0 ? lowCorrelationPairs.slice(0, 3).length : 0}个低相关号码对`;
                    }

                    recommendedNumbers = Array.from(selectedNumbers).sort((a, b) => a - b);
                }

                if (recommendedNumbers.length === 0) {
                    const sortedNodes = [...networkData.nodes].sort((a, b) => b.value - a.value);
                    const topNodes = sortedNodes.slice(0, 6);
                    recommendedNumbers = topNodes.map(node => parseInt(node.name)).sort((a, b) => a - b);
                    recommendationReason = `基于网络图中出现频率最高的${topNodes.length}个号码（热度推荐）`;
                    usedPairs = topNodes.map(node => ({ pair: [parseInt(node.name)], value: node.value }));
                }

                const recommendationContent = document.getElementById('correlationRecommendationContent');
                recommendationContent.innerHTML = `
                    <div class="recommendation-result">
                        <div class="result-header">
                            <i class="fas fa-star"></i>
                            <strong>推荐号码</strong>
                        </div>
                        <div class="result-numbers">
                            ${recommendedNumbers.map(num => `<span class="result-number">${num.toString().padStart(2, '0')}</span>`).join('')}
                        </div>
                        <div class="result-info">
                            <p><strong>推荐模式：</strong>${mode === 'highCorrelation' ? '基于高相关对' : (mode === 'lowCorrelation' ? '基于低相关对' : '平衡推荐')}</p>
                            <p><strong>推荐理由：</strong>${recommendationReason}</p>
                            <p><strong>相关系数阈值：</strong>${threshold}</p>
                            ${usedPairs.length > 0 ? `
                            <div class="result-pairs">
                                <p><strong>使用的号码对/号码：</strong></p>
                                <div class="pairs-list">
                                    ${usedPairs.map(item => 
                                        `<span class="pair-tag">${item.pair.join('-')} (${item.value.toFixed(3)})</span>`
                                    ).join('')}
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            static exportCorrelationReport() {
                if (!correlationAnalysisData) {
                    MessageSystem.showMessage('请先完成相关性分析', 'error');
                    return;
                }

                const statistics = correlationAnalysisData.statistics;
                const rules = LOTTERY_RULES[currentLotteryType];

                const report = {
                    generatedAt: new Date().toLocaleString(),
                    lotteryType: currentLotteryType === 'ssq' ? '双色球' : '大乐透',
                    analysisPeriod: correlationAnalysisData.period,
                    statistics: {
                        strongestPair: statistics.strongestPair,
                        strongestDimension: statistics.strongestDimension,
                        highCorrelationCount: statistics.highCorrelationCount,
                        lowCorrelationCount: statistics.lowCorrelationCount,
                        averageCorrelation: statistics.averageCorrelation
                    },
                    network: {
                        nodeCount: correlationAnalysisData.networkData.nodes.length,
                        edgeCount: correlationAnalysisData.networkData.links.filter(link => link.value >= 3).length
                    }
                };

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h3><i class="fas fa-link"></i> 相关性分析报告</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="report-section">
                                <h4><i class="fas fa-info-circle"></i> 报告信息</h4>
                                <div class="report-info">
                                    <p><strong>生成时间：</strong>${report.generatedAt}</p>
                                    <p><strong>彩种：</strong>${report.lotteryType}</p>
                                    <p><strong>分析期数：</strong>${report.analysisPeriod}</p>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-chart-line"></i> 统计摘要</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">最强相关对</span>
                                        <span class="stat-value">${report.statistics.strongestPair.pair}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">相关系数</span>
                                        <span class="stat-value">${report.statistics.strongestPair.value.toFixed(3)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">高相关对数</span>
                                        <span class="stat-value">${report.statistics.highCorrelationCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">低相关对数</span>
                                        <span class="stat-value">${report.statistics.lowCorrelationCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">平均相关系数</span>
                                        <span class="stat-value">${report.statistics.averageCorrelation}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-project-diagram"></i> 网络统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">节点数量</span>
                                        <span class="stat-value">${report.network.nodeCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">连线数量</span>
                                        <span class="stat-value">${report.network.edgeCount}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                            <button class="btn btn-primary" onclick="EventDelegate.printCorrelationReport()">打印报告</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            static printCorrelationReport() {
                window.print();
            }

            // ==================== 统计分析相关函数 ====================
            static performStatisticsAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    if (!currentDatabaseData || !currentDatabaseData.draws || currentDatabaseData.draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('statisticsPeriodSelect');
                    const periodValue = periodSelect ? periodSelect.value : '100';
                    const analysisPeriod = periodValue === 'all' ? currentDatabaseData.draws.length : parseInt(periodValue);

                    const reversedDraws = [...currentDatabaseData.draws].reverse().slice(0, analysisPeriod);

                    // 更新分析范围显示
                    const statisticsDataRangeInfo = document.getElementById('statisticsDataRangeInfo');
                    if (statisticsDataRangeInfo && reversedDraws.length > 0) {
                        const startPeriod = reversedDraws[reversedDraws.length - 1].period;
                        const endPeriod = reversedDraws[0].period;
                        statisticsDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${reversedDraws.length}期）`;
                    }

                    const statisticsData = this.calculateStatisticsData(reversedDraws);
                    statisticsData.period = analysisPeriod;

                    statisticalAnalysisData = statisticsData;
                    statisticalAnalysisResults = statisticsData;

                    this.updateStatisticsChart(statisticsData);
                    this.generateStatisticsConclusion(statisticsData);
                    this.discoverStatisticsPatterns(statisticsData);

                    MessageSystem.showMessage(`已完成${reversedDraws.length}期数据的统计分析`, 'success');
                });
            }

            static calculateStatisticsData(draws) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                const sums = [];
                const spans = [];
                const acValues = [];
                const oddEvenRatios = [];
                const bigSmallRatios = [];
                const primeCompositeRatios = [];
                const zoneDistributions = [];
                const numberFrequencies = {};

                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    numberFrequencies[i] = 0;
                }

                draws.forEach(draw => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    const sum = redBalls.reduce((acc, val) => acc + val, 0);
                    sums.push(sum);

                    const span = redBalls[redBalls.length - 1] - redBalls[0];
                    spans.push(span);

                    const acValue = this.calculateACValue(redBalls);
                    acValues.push(acValue);

                    const oddCount = redBalls.filter(n => n % 2 === 1).length;
                    oddEvenRatios.push(oddCount / redBalls.length);

                    const bigCount = redBalls.filter(n => n > 17).length;
                    bigSmallRatios.push(bigCount / redBalls.length);

                    const primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
                    const primeCount = redBalls.filter(n => primeNumbers.includes(n)).length;
                    primeCompositeRatios.push(primeCount / redBalls.length);

                    const zone1Count = redBalls.filter(n => n >= 1 && n <= 11).length;
                    const zone2Count = redBalls.filter(n => n >= 12 && n <= 22).length;
                    const zone3Count = redBalls.filter(n => n >= 23 && n <= 33).length;
                    zoneDistributions.push([zone1Count, zone2Count, zone3Count]);

                    redBalls.forEach(ball => {
                        numberFrequencies[ball]++;
                    });
                });

                const avgSum = sums.reduce((a, b) => a + b, 0) / sums.length;
                const avgSpan = spans.reduce((a, b) => a + b, 0) / spans.length;
                const avgAC = acValues.reduce((a, b) => a + b, 0) / acValues.length;
                const avgOddEven = oddEvenRatios.reduce((a, b) => a + b, 0) / oddEvenRatios.length;
                const avgBigSmall = bigSmallRatios.reduce((a, b) => a + b, 0) / bigSmallRatios.length;
                const avgPrimeComposite = primeCompositeRatios.reduce((a, b) => a + b, 0) / primeCompositeRatios.length;

                const stdDevSum = Math.sqrt(sums.reduce((acc, val) => acc + Math.pow(val - avgSum, 2), 0) / sums.length);
                const stdDevSpan = Math.sqrt(spans.reduce((acc, val) => acc + Math.pow(val - avgSpan, 2), 0) / spans.length);
                const stdDevAC = Math.sqrt(acValues.reduce((acc, val) => acc + Math.pow(val - avgAC, 2), 0) / acValues.length);

                const medianSum = this.calculateMedian(sums);
                const medianSpan = this.calculateMedian(spans);
                const medianAC = this.calculateMedian(acValues);

                const modeSum = this.calculateMode(sums);
                const modeSpan = this.calculateMode(spans);
                const modeAC = this.calculateMode(acValues);

                const trendData = {
                    periods: draws.map((_, index) => index + 1),
                    sums: sums,
                    spans: spans,
                    acValues: acValues,
                    oddEvenRatios: oddEvenRatios.map(r => r.toFixed(2)),
                    bigSmallRatios: bigSmallRatios.map(r => r.toFixed(2)),
                    primeCompositeRatios: primeCompositeRatios.map(r => r.toFixed(2))
                };

                const distributionData = {
                    sumDistribution: this.calculateDistribution(sums, 10),
                    spanDistribution: this.calculateDistribution(spans, 10),
                    acDistribution: this.calculateDistribution(acValues, 10),
                    numberFrequency: numberFrequencies
                };

                const comparisonData = this.calculateComparisonData(draws, sums, spans, acValues);

                const heatmapData = this.calculateStatisticsHeatmap(sums, spans, acValues, oddEvenRatios, bigSmallRatios, primeCompositeRatios);

                return {
                    trendData,
                    distributionData,
                    comparisonData,
                    heatmapData,
                    statistics: {
                        avgSum: avgSum.toFixed(2),
                        avgSpan: avgSpan.toFixed(2),
                        avgAC: avgAC.toFixed(2),
                        stdDevSum: stdDevSum.toFixed(2),
                        stdDevSpan: stdDevSpan.toFixed(2),
                        stdDevAC: stdDevAC.toFixed(2),
                        medianSum: medianSum,
                        medianSpan: medianSpan,
                        medianAC: medianAC,
                        modeSum: modeSum,
                        modeSpan: modeSpan,
                        modeAC: modeAC,
                        avgOddEven: avgOddEven.toFixed(2),
                        avgBigSmall: avgBigSmall.toFixed(2),
                        avgPrimeComposite: avgPrimeComposite.toFixed(2)
                    }
                };
            }

            static calculateMedian(arr) {
                const sorted = [...arr].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 !== 0 ? sorted[mid] : ((sorted[mid - 1] + sorted[mid]) / 2).toFixed(2);
            }

            static calculateMode(arr) {
                const frequency = {};
                let maxFreq = 0;
                let modes = [];

                arr.forEach(val => {
                    frequency[val] = (frequency[val] || 0) + 1;
                    if (frequency[val] > maxFreq) {
                        maxFreq = frequency[val];
                    }
                });

                Object.keys(frequency).forEach(key => {
                    if (frequency[key] === maxFreq) {
                        modes.push(key);
                    }
                });

                return modes.slice(0, 3).join(', ');
            }

            static calculateDistribution(arr, binCount) {
                const min = Math.min(...arr);
                const max = Math.max(...arr);
                const binSize = (max - min) / binCount;

                const bins = [];
                for (let i = 0; i < binCount; i++) {
                    const binMin = min + i * binSize;
                    const binMax = min + (i + 1) * binSize;
                    const count = arr.filter(val => val >= binMin && val < binMax).length;
                    bins.push({
                        range: `${binMin.toFixed(0)}-${binMax.toFixed(0)}`,
                        count: count,
                        percentage: ((count / arr.length) * 100).toFixed(2)
                    });
                }

                return bins;
            }

            static calculateComparisonData(draws, sums, spans, acValues) {
                const midPoint = Math.floor(draws.length / 2);

                const firstHalf = draws.slice(0, midPoint);
                const secondHalf = draws.slice(midPoint);

                const firstSums = sums.slice(0, midPoint);
                const secondSums = sums.slice(midPoint);
                const firstSpans = spans.slice(0, midPoint);
                const secondSpans = spans.slice(midPoint);
                const firstAC = acValues.slice(0, midPoint);
                const secondAC = acValues.slice(midPoint);

                const firstAvgSum = firstSums.reduce((a, b) => a + b, 0) / firstSums.length;
                const secondAvgSum = secondSums.reduce((a, b) => a + b, 0) / secondSums.length;
                const firstAvgSpan = firstSpans.reduce((a, b) => a + b, 0) / firstSpans.length;
                const secondAvgSpan = secondSpans.reduce((a, b) => a + b, 0) / secondSpans.length;
                const firstAvgAC = firstAC.reduce((a, b) => a + b, 0) / firstAC.length;
                const secondAvgAC = secondAC.reduce((a, b) => a + b, 0) / secondAC.length;

                const sumChangeRate = ((secondAvgSum - firstAvgSum) / firstAvgSum * 100).toFixed(2);
                const spanChangeRate = ((secondAvgSpan - firstAvgSpan) / firstAvgSpan * 100).toFixed(2);
                const acChangeRate = ((secondAvgAC - firstAvgAC) / firstAvgAC * 100).toFixed(2);

                return {
                    firstHalf: {
                        period: firstHalf.length,
                        avgSum: firstAvgSum.toFixed(2),
                        avgSpan: firstAvgSpan.toFixed(2),
                        avgAC: firstAvgAC.toFixed(2)
                    },
                    secondHalf: {
                        period: secondHalf.length,
                        avgSum: secondAvgSum.toFixed(2),
                        avgSpan: secondAvgSpan.toFixed(2),
                        avgAC: secondAvgAC.toFixed(2)
                    },
                    changeRates: {
                        sum: sumChangeRate,
                        span: spanChangeRate,
                        ac: acChangeRate
                    }
                };
            }

            static calculateStatisticsHeatmap(sums, spans, acValues, oddEvenRatios, bigSmallRatios, primeCompositeRatios) {
                const metrics = ['和值', '跨度', 'AC值', '奇偶比', '大小比', '质合比'];
                const data = [sums, spans, acValues, oddEvenRatios, bigSmallRatios, primeCompositeRatios];

                const correlationMatrix = {};

                for (let i = 0; i < metrics.length; i++) {
                    correlationMatrix[metrics[i]] = {};
                    for (let j = 0; j < metrics.length; j++) {
                        if (i === j) {
                            correlationMatrix[metrics[i]][metrics[j]] = 1;
                        } else {
                            const correlation = this.calculatePearsonCorrelation(data[i], data[j]);
                            correlationMatrix[metrics[i]][metrics[j]] = correlation;
                        }
                    }
                }

                return correlationMatrix;
            }

            static updateStatisticsChart(statisticsData) {
                const trendContent = document.getElementById('statistics-trend');
                const distributionContent = document.getElementById('statistics-distribution');
                const comparisonContent = document.getElementById('statistics-comparison');
                const heatmapContent = document.getElementById('statistics-heatmap');

                trendContent.style.display = 'none';
                distributionContent.style.display = 'none';
                comparisonContent.style.display = 'none';
                heatmapContent.style.display = 'none';

                if (currentStatisticalChartType === 'trend') {
                    trendContent.style.display = 'block';
                    this.updateStatisticsTrendChart(statisticsData);
                } else if (currentStatisticalChartType === 'distribution') {
                    distributionContent.style.display = 'block';
                    this.updateStatisticsDistributionChart(statisticsData);
                } else if (currentStatisticalChartType === 'comparison') {
                    comparisonContent.style.display = 'block';
                    this.updateStatisticsComparisonChart(statisticsData);
                } else if (currentStatisticalChartType === 'heatmap') {
                    heatmapContent.style.display = 'block';
                    this.updateStatisticsHeatmapChart(statisticsData);
                }
            }

            static updateStatisticsTrendChart(statisticsData) {
                document.getElementById('statisticsTrendPeriods').textContent = statisticsData.period;
                document.getElementById('statisticsAvgSum').textContent = statisticsData.statistics.avgSum;
                document.getElementById('statisticsAvgSpan').textContent = statisticsData.statistics.avgSpan;
                document.getElementById('statisticsAvgAC').textContent = statisticsData.statistics.avgAC;

                const chartDom = document.getElementById('statisticsTrendChart');
                if (!chartDom) return;

                if (statisticalTrendChart) {
                    statisticalTrendChart.dispose();
                }

                statisticalTrendChart = echarts.init(chartDom);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `统计指标趋势图（最近${statisticsData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['和值', '跨度', 'AC值'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: statisticsData.trendData.periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '数值',
                            nameTextStyle: {
                                fontSize: 12
                            },
                            splitLine: {
                                lineStyle: {
                                    type: 'dashed'
                                }
                            }
                        }
                    ],
                    series: [
                        {
                            name: '和值',
                            type: 'line',
                            smooth: true,
                            data: statisticsData.trendData.sums,
                            itemStyle: {
                                color: '#e74c3c'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(231, 76, 60, 0.3)' },
                                    { offset: 1, color: 'rgba(231, 76, 60, 0.05)' }
                                ])
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#e74c3c',
                                    type: 'dashed'
                                }
                            }
                        },
                        {
                            name: '跨度',
                            type: 'line',
                            smooth: true,
                            data: statisticsData.trendData.spans,
                            itemStyle: {
                                color: '#3498db'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(52, 152, 219, 0.3)' },
                                    { offset: 1, color: 'rgba(52, 152, 219, 0.05)' }
                                ])
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#3498db',
                                    type: 'dashed'
                                }
                            }
                        },
                        {
                            name: 'AC值',
                            type: 'line',
                            smooth: true,
                            data: statisticsData.trendData.acValues,
                            itemStyle: {
                                color: '#27ae60'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(39, 174, 96, 0.3)' },
                                    { offset: 1, color: 'rgba(39, 174, 96, 0.05)' }
                                ])
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#27ae60',
                                    type: 'dashed'
                                }
                            }
                        }
                    ]
                };

                statisticalTrendChart.setOption(option);
            }

            static updateStatisticsDistributionChart(statisticsData) {
                document.getElementById('statisticsDistributionPeriods').textContent = statisticsData.period;
                document.getElementById('statisticsStdDev').textContent = statisticsData.statistics.stdDevSum;
                document.getElementById('statisticsMedian').textContent = statisticsData.statistics.medianSum;
                document.getElementById('statisticsMode').textContent = statisticsData.statistics.modeSum;

                const chartDom = document.getElementById('statisticsDistributionChart');
                if (!chartDom) return;

                if (statisticalDistributionChart) {
                    statisticalDistributionChart.dispose();
                }

                statisticalDistributionChart = echarts.init(chartDom);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `统计数据分布图（最近${statisticsData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'shadow'
                        },
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['和值分布', '跨度分布', 'AC值分布'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        data: statisticsData.distributionData.sumDistribution.map(d => d.range),
                        name: '区间',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '频数',
                            nameTextStyle: {
                                fontSize: 12
                            },
                            splitLine: {
                                lineStyle: {
                                    type: 'dashed'
                                }
                            }
                        }
                    ],
                    series: [
                        {
                            name: '和值分布',
                            type: 'bar',
                            data: statisticsData.distributionData.sumDistribution.map(d => d.count),
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#e74c3c' },
                                    { offset: 1, color: '#c0392b' }
                                ])
                            },
                            barMaxWidth: 30
                        },
                        {
                            name: '跨度分布',
                            type: 'bar',
                            data: statisticsData.distributionData.spanDistribution.map(d => d.count),
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#3498db' },
                                    { offset: 1, color: '#2980b9' }
                                ])
                            },
                            barMaxWidth: 30
                        },
                        {
                            name: 'AC值分布',
                            type: 'bar',
                            data: statisticsData.distributionData.acDistribution.map(d => d.count),
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#27ae60' },
                                    { offset: 1, color: '#219150' }
                                ])
                            },
                            barMaxWidth: 30
                        }
                    ]
                };

                statisticalDistributionChart.setOption(option);
            }

            static updateStatisticsComparisonChart(statisticsData) {
                document.getElementById('statisticsComparisonPeriod1').textContent = statisticsData.comparisonData.firstHalf.period;
                document.getElementById('statisticsComparisonPeriod2').textContent = statisticsData.comparisonData.secondHalf.period;
                document.getElementById('statisticsChangeRate').textContent = `${statisticsData.comparisonData.changeRates.sum}%`;

                const chartDom = document.getElementById('statisticsComparisonChart');
                if (!chartDom) return;

                if (statisticalComparisonChart) {
                    statisticalComparisonChart.dispose();
                }

                statisticalComparisonChart = echarts.init(chartDom);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `时期对比分析图（最近${statisticsData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['前期', '后期'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        data: ['和值', '跨度', 'AC值'],
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '平均值',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '前期',
                            type: 'bar',
                            data: [
                                statisticsData.comparisonData.firstHalf.avgSum,
                                statisticsData.comparisonData.firstHalf.avgSpan,
                                statisticsData.comparisonData.firstHalf.avgAC
                            ],
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#3498db' },
                                    { offset: 1, color: '#2980b9' }
                                ])
                            },
                            barMaxWidth: 40
                        },
                        {
                            name: '后期',
                            type: 'bar',
                            data: [
                                statisticsData.comparisonData.secondHalf.avgSum,
                                statisticsData.comparisonData.secondHalf.avgSpan,
                                statisticsData.comparisonData.secondHalf.avgAC
                            ],
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#e74c3c' },
                                    { offset: 1, color: '#c0392b' }
                                ])
                            },
                            barMaxWidth: 40
                        }
                    ]
                };

                statisticalComparisonChart.setOption(option);
            }

            static updateStatisticsHeatmapChart(statisticsData) {
                document.getElementById('statisticsHeatmapPeriods').textContent = statisticsData.period;

                const heatmapData = statisticsData.heatmapData;
                let strongestLinkage = '-';
                let maxCorrelation = 0;

                const metrics = Object.keys(heatmapData);
                for (let i = 0; i < metrics.length; i++) {
                    for (let j = i + 1; j < metrics.length; j++) {
                        const correlation = Math.abs(heatmapData[metrics[i]][metrics[j]]);
                        if (correlation > maxCorrelation) {
                            maxCorrelation = correlation;
                            strongestLinkage = `${metrics[i]}-${metrics[j]}`;
                        }
                    }
                }

                document.getElementById('statisticsStrongestLinkage').textContent = strongestLinkage;
                document.getElementById('statisticsLinkageCoeff').textContent = maxCorrelation.toFixed(3);

                const chartDom = document.getElementById('statisticsHeatmapChart');
                if (!chartDom) return;

                if (statisticalHeatmapChart) {
                    statisticalHeatmapChart.dispose();
                }

                statisticalHeatmapChart = echarts.init(chartDom);

                const xData = metrics;
                const yData = metrics;
                const data = [];

                for (let i = 0; i < metrics.length; i++) {
                    for (let j = 0; j < metrics.length; j++) {
                        data.push([j, i, heatmapData[metrics[i]][metrics[j]]]);
                    }
                }

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `统计指标关联热力图（最近${statisticsData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        position: 'top',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 13
                        },
                        formatter: function(params) {
                            const value = params.value[2];
                            const level = Math.abs(value) >= 0.7 ? '强' : (Math.abs(value) >= 0.4 ? '中' : '弱');
                            const color = value >= 0.7 ? '#e74c3c' : (value >= 0.4 ? '#e67e22' : (value >= 0 ? '#f39c12' : (value >= -0.4 ? '#3498db' : (value >= -0.7 ? '#2980b9' : '#8e44ad'))));
                            return `<div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 8px;">指标对: ${yData[params.value[1]]} - ${xData[params.value[0]]}</div>
                                    <div style="margin: 4px 0;">相关系数: <strong style="color: ${color}; font-size: 16px;">${value.toFixed(3)}</strong></div>
                                    <div style="margin-top: 4px; font-size: 11px; color: #bdc3c7;">
                                        相关性: <span style="padding: 2px 8px; background: ${color}; border-radius: 10px; font-size: 11px;">${level}</span>
                                    </div>
                                </div>`;
                        }
                    },
                    grid: {
                        height: '70%',
                        top: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        data: xData,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            fontSize: 11
                        }
                    },
                    yAxis: {
                        type: 'category',
                        data: yData,
                        splitArea: {
                            show: true
                        },
                        axisLabel: {
                            fontSize: 11
                        }
                    },
                    visualMap: {
                        min: -1,
                        max: 1,
                        calculable: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: '5%',
                        inRange: {
                            color: ['#3498db', '#ecf0f1', '#e74c3c']
                        },
                        textStyle: {
                            fontSize: 11
                        }
                    },
                    series: [
                        {
                            name: '相关系数',
                            type: 'heatmap',
                            data: data,
                            label: {
                                show: true,
                                fontSize: 10
                            },
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }
                    ]
                };

                statisticalHeatmapChart.setOption(option);
            }

            static generateStatisticsConclusion(statisticsData) {
                const conclusionContent = document.getElementById('statisticsConclusionContent');
                const stats = statisticsData.statistics;

                const insights = [];

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-chart-line"></i>
                        <strong>和值分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>在最近${statisticsData.period}期数据中，平均和值为<strong>${stats.avgSum}</strong>，中位数为<strong>${stats.medianSum}</strong>。</p>
                        <p>标准差为<strong>${stats.stdDevSum}</strong>，${parseFloat(stats.stdDevSum) > 20 ? '和值波动较大，分布较为分散' : '和值波动较小，分布相对集中'}。</p>
                        <p>众数为<strong>${stats.modeSum}</strong>，${stats.modeSum.includes(',') ? '存在多个高频和值，表明和值分布较为均匀' : '存在明显的高频和值，建议关注该区间'}。</p>
                        <p>前后期和值变化率为<strong>${statisticsData.comparisonData.changeRates.sum}%</strong>，${parseFloat(statisticsData.comparisonData.changeRates.sum) > 0 ? '近期和值呈上升趋势' : (parseFloat(statisticsData.comparisonData.changeRates.sum) < 0 ? '近期和值呈下降趋势' : '近期和值保持稳定')}。</p>
                    </div>
                </div>`);

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-arrows-alt-h"></i>
                        <strong>跨度分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>平均跨度为<strong>${stats.avgSpan}</strong>，中位数为<strong>${stats.medianSpan}</strong>。</p>
                        <p>标准差为<strong>${stats.stdDevSpan}</strong>，${parseFloat(stats.stdDevSpan) > 5 ? '跨度波动较大，号码分布范围变化明显' : '跨度波动较小，号码分布范围相对稳定'}。</p>
                        <p>前后期跨度变化率为<strong>${statisticsData.comparisonData.changeRates.span}%</strong>，${parseFloat(statisticsData.comparisonData.changeRates.span) > 0 ? '近期跨度呈扩大趋势，号码分布范围增加' : (parseFloat(statisticsData.comparisonData.changeRates.span) < 0 ? '近期跨度呈缩小趋势，号码分布范围减少' : '近期跨度保持稳定')}。</p>
                    </div>
                </div>`);

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-calculator"></i>
                        <strong>AC值分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>平均AC值为<strong>${stats.avgAC}</strong>，中位数为<strong>${stats.medianAC}</strong>。</p>
                        <p>标准差为<strong>${stats.stdDevAC}</strong>，${parseFloat(stats.stdDevAC) > 2 ? 'AC值波动较大，号码组合复杂度变化明显' : 'AC值波动较小，号码组合复杂度相对稳定'}。</p>
                        <p>前后期AC值变化率为<strong>${statisticsData.comparisonData.changeRates.ac}%</strong>，${parseFloat(statisticsData.comparisonData.changeRates.ac) > 0 ? '近期号码组合复杂度呈上升趋势' : (parseFloat(statisticsData.comparisonData.changeRates.ac) < 0 ? '近期号码组合复杂度呈下降趋势' : '近期号码组合复杂度保持稳定')}。</p>
                    </div>
                </div>`);

                conclusionContent.innerHTML = insights.join('');
            }

            static discoverStatisticsPatterns(statisticsData) {
                const patternContent = document.getElementById('statisticsPatternContent');
                const patterns = [];

                const stats = statisticsData.statistics;
                const comparison = statisticsData.comparisonData;
                const heatmap = statisticsData.heatmapData;

                patterns.push(`<div class="pattern-item">
                    <div class="pattern-header">
                        <i class="fas fa-trending-up"></i>
                        <strong>趋势规律</strong>
                    </div>
                    <div class="pattern-body">
                        <p>和值趋势：${parseFloat(comparison.changeRates.sum) > 5 ? '明显上升，建议关注高和值区间' : (parseFloat(comparison.changeRates.sum) < -5 ? '明显下降，建议关注低和值区间' : '相对稳定，可参考历史均值')}</p>
                        <p>跨度趋势：${parseFloat(comparison.changeRates.span) > 5 ? '明显扩大，建议选择分散的号码组合' : (parseFloat(comparison.changeRates.span) < -5 ? '明显缩小，建议选择集中的号码组合' : '相对稳定，可参考历史均值')}</p>
                        <p>AC值趋势：${parseFloat(comparison.changeRates.ac) > 5 ? '明显上升，建议选择复杂度较高的号码组合' : (parseFloat(comparison.changeRates.ac) < -5 ? '明显下降，建议选择复杂度较低的号码组合' : '相对稳定，可参考历史均值')}</p>
                    </div>
                </div>`);

                patterns.push(`<div class="pattern-item">
                    <div class="pattern-header">
                        <i class="fas fa-balance-scale"></i>
                        <strong>平衡规律</strong>
                    </div>
                    <div class="pattern-body">
                        <p>奇偶比平均值为<strong>${stats.avgOddEven}</strong>，${parseFloat(stats.avgOddEven) > 0.55 ? '奇数偏多，建议适当增加偶数选择' : (parseFloat(stats.avgOddEven) < 0.45 ? '偶数偏多，建议适当增加奇数选择' : '奇偶相对平衡，可保持当前比例')}</p>
                        <p>大小比平均值为<strong>${stats.avgBigSmall}</strong>，${parseFloat(stats.avgBigSmall) > 0.55 ? '大号偏多，建议适当增加小号选择' : (parseFloat(stats.avgBigSmall) < 0.45 ? '小号偏多，建议适当增加大号选择' : '大小相对平衡，可保持当前比例')}</p>
                        <p>质合比平均值为<strong>${stats.avgPrimeComposite}</strong>，${parseFloat(stats.avgPrimeComposite) > 0.55 ? '质数偏多，建议适当增加合数选择' : (parseFloat(stats.avgPrimeComposite) < 0.45 ? '合数偏多，建议适当增加质数选择' : '质合相对平衡，可保持当前比例')}</p>
                    </div>
                </div>`);

                let strongCorrelations = [];
                const metrics = Object.keys(heatmap);
                for (let i = 0; i < metrics.length; i++) {
                    for (let j = i + 1; j < metrics.length; j++) {
                        const correlation = Math.abs(heatmap[metrics[i]][metrics[j]]);
                        if (correlation > 0.5) {
                            strongCorrelations.push({
                                pair: `${metrics[i]}-${metrics[j]}`,
                                value: heatmap[metrics[i]][metrics[j]]
                            });
                        }
                    }
                }

                patterns.push(`<div class="pattern-item">
                    <div class="pattern-header">
                        <i class="fas fa-link"></i>
                        <strong>关联规律</strong>
                    </div>
                    <div class="pattern-body">
                        ${strongCorrelations.length > 0 ? `
                        <p>发现<strong>${strongCorrelations.length}</strong>对强相关指标：</p>
                        <ul>
                            ${strongCorrelations.map(c => `<li>${c.pair}（相关系数：${c.value.toFixed(3)}）</li>`).join('')}
                        </ul>
                        <p>这些指标之间存在较强的关联性，建议综合考虑这些指标的变化趋势。</p>
                        ` : '<p>各指标间的关联性整体较弱，选号时可以相对独立地考虑各个指标。</p>'}
                    </div>
                </div>`);

                patterns.push(`<div class="pattern-item">
                    <div class="pattern-header">
                        <i class="fas fa-lightbulb"></i>
                        <strong>选号建议</strong>
                    </div>
                    <div class="pattern-body">
                        <p>基于统计分析结果，建议：</p>
                        <ul>
                            <li>和值参考范围：${(parseFloat(stats.avgSum) - parseFloat(stats.stdDevSum)).toFixed(0)} - ${(parseFloat(stats.avgSum) + parseFloat(stats.stdDevSum)).toFixed(0)}</li>
                            <li>跨度参考范围：${(parseFloat(stats.avgSpan) - parseFloat(stats.stdDevSpan)).toFixed(0)} - ${(parseFloat(stats.avgSpan) + parseFloat(stats.stdDevSpan)).toFixed(0)}</li>
                            <li>AC值参考范围：${(parseFloat(stats.avgAC) - parseFloat(stats.stdDevAC)).toFixed(0)} - ${(parseFloat(stats.avgAC) + parseFloat(stats.stdDevAC)).toFixed(0)}</li>
                            <li>奇偶比例：${stats.avgOddEven}</li>
                            <li>大小比例：${stats.avgBigSmall}</li>
                            <li>质合比例：${stats.avgPrimeComposite}</li>
                        </ul>
                    </div>
                </div>`);

                patternContent.innerHTML = patterns.join('');
            }

            static generateStatisticsResults() {
                if (!statisticalAnalysisData) {
                    MessageSystem.showMessage('请先完成统计分析', 'error');
                    return;
                }

                const mode = document.getElementById('statisticsResultsMode').value;
                const resultsContent = document.getElementById('statisticsResultsContent');
                const stats = statisticalAnalysisData.statistics;
                const comparison = statisticalAnalysisData.comparisonData;

                if (mode === 'summary') {
                    resultsContent.innerHTML = `
                        <div class="result-summary">
                            <h4><i class="fas fa-clipboard-list"></i> 统计分析摘要</h4>
                            <div class="summary-grid">
                                <div class="summary-item">
                                    <div class="summary-label">分析期数</div>
                                    <div class="summary-value">${statisticalAnalysisData.period}期</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">平均和值</div>
                                    <div class="summary-value">${stats.avgSum}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">平均跨度</div>
                                    <div class="summary-value">${stats.avgSpan}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">平均AC值</div>
                                    <div class="summary-value">${stats.avgAC}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">和值标准差</div>
                                    <div class="summary-value">${stats.stdDevSum}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">跨度标准差</div>
                                    <div class="summary-value">${stats.stdDevSpan}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">AC值标准差</div>
                                    <div class="summary-value">${stats.stdDevAC}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">和值中位数</div>
                                    <div class="summary-value">${stats.medianSum}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">跨度中位数</div>
                                    <div class="summary-value">${stats.medianSpan}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">AC值中位数</div>
                                    <div class="summary-value">${stats.medianAC}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">奇偶比</div>
                                    <div class="summary-value">${stats.avgOddEven}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">大小比</div>
                                    <div class="summary-value">${stats.avgBigSmall}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">质合比</div>
                                    <div class="summary-value">${stats.avgPrimeComposite}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (mode === 'detailed') {
                    resultsContent.innerHTML = `
                        <div class="result-detailed">
                            <h4><i class="fas fa-list-alt"></i> 详细分析结果</h4>
                            <div class="detailed-section">
                                <h5>和值分析</h5>
                                <p>平均值：${stats.avgSum}，中位数：${stats.medianSum}，众数：${stats.modeSum}</p>
                                <p>标准差：${stats.stdDevSum}，${parseFloat(stats.stdDevSum) > 20 ? '波动较大' : '波动较小'}</p>
                                <p>前后期变化率：${comparison.changeRates.sum}%，${parseFloat(comparison.changeRates.sum) > 0 ? '上升趋势' : (parseFloat(comparison.changeRates.sum) < 0 ? '下降趋势' : '稳定')}</p>
                            </div>
                            <div class="detailed-section">
                                <h5>跨度分析</h5>
                                <p>平均值：${stats.avgSpan}，中位数：${stats.medianSpan}，众数：${stats.modeSpan}</p>
                                <p>标准差：${stats.stdDevSpan}，${parseFloat(stats.stdDevSpan) > 5 ? '波动较大' : '波动较小'}</p>
                                <p>前后期变化率：${comparison.changeRates.span}%，${parseFloat(comparison.changeRates.span) > 0 ? '扩大趋势' : (parseFloat(comparison.changeRates.span) < 0 ? '缩小趋势' : '稳定')}</p>
                            </div>
                            <div class="detailed-section">
                                <h5>AC值分析</h5>
                                <p>平均值：${stats.avgAC}，中位数：${stats.medianAC}，众数：${stats.modeAC}</p>
                                <p>标准差：${stats.stdDevAC}，${parseFloat(stats.stdDevAC) > 2 ? '波动较大' : '波动较小'}</p>
                                <p>前后期变化率：${comparison.changeRates.ac}%，${parseFloat(comparison.changeRates.ac) > 0 ? '上升趋势' : (parseFloat(comparison.changeRates.ac) < 0 ? '下降趋势' : '稳定')}</p>
                            </div>
                            <div class="detailed-section">
                                <h5>比例分析</h5>
                                <p>奇偶比：${stats.avgOddEven}，${parseFloat(stats.avgOddEven) > 0.55 ? '奇数偏多' : (parseFloat(stats.avgOddEven) < 0.45 ? '偶数偏多' : '相对平衡')}</p>
                                <p>大小比：${stats.avgBigSmall}，${parseFloat(stats.avgBigSmall) > 0.55 ? '大号偏多' : (parseFloat(stats.avgBigSmall) < 0.45 ? '小号偏多' : '相对平衡')}</p>
                                <p>质合比：${stats.avgPrimeComposite}，${parseFloat(stats.avgPrimeComposite) > 0.55 ? '质数偏多' : (parseFloat(stats.avgPrimeComposite) < 0.45 ? '合数偏多' : '相对平衡')}</p>
                            </div>
                        </div>
                    `;
                } else if (mode === 'recommendation') {
                    const sumRange = `${(parseFloat(stats.avgSum) - parseFloat(stats.stdDevSum)).toFixed(0)}-${(parseFloat(stats.avgSum) + parseFloat(stats.stdDevSum)).toFixed(0)}`;
                    const spanRange = `${(parseFloat(stats.avgSpan) - parseFloat(stats.stdDevSpan)).toFixed(0)}-${(parseFloat(stats.avgSpan) + parseFloat(stats.stdDevSpan)).toFixed(0)}`;
                    const acRange = `${(parseFloat(stats.avgAC) - parseFloat(stats.stdDevAC)).toFixed(0)}-${(parseFloat(stats.avgAC) + parseFloat(stats.stdDevAC)).toFixed(0)}`;

                    resultsContent.innerHTML = `
                        <div class="result-recommendation">
                            <h4><i class="fas fa-star"></i> 选号建议</h4>
                            <div class="recommendation-list">
                                <div class="recommendation-item">
                                    <div class="recommendation-icon">
                                        <i class="fas fa-plus-circle"></i>
                                    </div>
                                    <div class="recommendation-content">
                                        <h5>和值建议</h5>
                                        <p>推荐和值范围：<strong>${sumRange}</strong></p>
                                        <p>参考平均值：${stats.avgSum}，标准差：${stats.stdDevSum}</p>
                                        <p>趋势：${parseFloat(comparison.changeRates.sum) > 0 ? '上升' : (parseFloat(comparison.changeRates.sum) < 0 ? '下降' : '稳定')}</p>
                                    </div>
                                </div>
                                <div class="recommendation-item">
                                    <div class="recommendation-icon">
                                        <i class="fas fa-arrows-alt-h"></i>
                                    </div>
                                    <div class="recommendation-content">
                                        <h5>跨度建议</h5>
                                        <p>推荐跨度范围：<strong>${spanRange}</strong></p>
                                        <p>参考平均值：${stats.avgSpan}，标准差：${stats.stdDevSpan}</p>
                                        <p>趋势：${parseFloat(comparison.changeRates.span) > 0 ? '扩大' : (parseFloat(comparison.changeRates.span) < 0 ? '缩小' : '稳定')}</p>
                                    </div>
                                </div>
                                <div class="recommendation-item">
                                    <div class="recommendation-icon">
                                        <i class="fas fa-calculator"></i>
                                    </div>
                                    <div class="recommendation-content">
                                        <h5>AC值建议</h5>
                                        <p>推荐AC值范围：<strong>${acRange}</strong></p>
                                        <p>参考平均值：${stats.avgAC}，标准差：${stats.stdDevAC}</p>
                                        <p>趋势：${parseFloat(comparison.changeRates.ac) > 0 ? '上升' : (parseFloat(comparison.changeRates.ac) < 0 ? '下降' : '稳定')}</p>
                                    </div>
                                </div>
                                <div class="recommendation-item">
                                    <div class="recommendation-icon">
                                        <i class="fas fa-balance-scale"></i>
                                    </div>
                                    <div class="recommendation-content">
                                        <h5>比例建议</h5>
                                        <p>奇偶比：${stats.avgOddEven}（${parseFloat(stats.avgOddEven) > 0.55 ? '建议增加偶数' : (parseFloat(stats.avgOddEven) < 0.45 ? '建议增加奇数' : '保持平衡')}）</p>
                                        <p>大小比：${stats.avgBigSmall}（${parseFloat(stats.avgBigSmall) > 0.55 ? '建议增加小号' : (parseFloat(stats.avgBigSmall) < 0.45 ? '建议增加大号' : '保持平衡')}）</p>
                                        <p>质合比：${stats.avgPrimeComposite}（${parseFloat(stats.avgPrimeComposite) > 0.55 ? '建议增加合数' : (parseFloat(stats.avgPrimeComposite) < 0.45 ? '建议增加质数' : '保持平衡')}）</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            static exportStatisticsReport() {
                if (!statisticalAnalysisData) {
                    MessageSystem.showMessage('请先完成统计分析', 'error');
                    return;
                }

                const stats = statisticalAnalysisData.statistics;
                const comparison = statisticalAnalysisData.comparisonData;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px;">
                        <div class="modal-header">
                            <h3><i class="fas fa-clipboard-list"></i> 统计分析报告</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="report-section">
                                <h4><i class="fas fa-info-circle"></i> 报告信息</h4>
                                <div class="report-info">
                                    <p><strong>生成时间：</strong>${new Date().toLocaleString()}</p>
                                    <p><strong>彩种：</strong>${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}</p>
                                    <p><strong>分析期数：</strong>${statisticalAnalysisData.period}期</p>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-chart-line"></i> 统计摘要</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">平均和值</span>
                                        <span class="stat-value">${stats.avgSum}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">平均跨度</span>
                                        <span class="stat-value">${stats.avgSpan}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">平均AC值</span>
                                        <span class="stat-value">${stats.avgAC}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">和值标准差</span>
                                        <span class="stat-value">${stats.stdDevSum}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">跨度标准差</span>
                                        <span class="stat-value">${stats.stdDevSpan}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">AC值标准差</span>
                                        <span class="stat-value">${stats.stdDevAC}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">奇偶比</span>
                                        <span class="stat-value">${stats.avgOddEven}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">大小比</span>
                                        <span class="stat-value">${stats.avgBigSmall}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">质合比</span>
                                        <span class="stat-value">${stats.avgPrimeComposite}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-exchange-alt"></i> 时期对比</h4>
                                <div class="report-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">前期平均和值</span>
                                        <span class="stat-value">${comparison.firstHalf.avgSum}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">后期平均和值</span>
                                        <span class="stat-value">${comparison.secondHalf.avgSum}</span>
                                    </div>
                                    <div class="stat-item highlight">
                                        <span class="stat-label">和值变化率</span>
                                        <span class="stat-value">${comparison.changeRates.sum}%</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">前期平均跨度</span>
                                        <span class="stat-value">${comparison.firstHalf.avgSpan}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">后期平均跨度</span>
                                        <span class="stat-value">${comparison.secondHalf.avgSpan}</span>
                                    </div>
                                    <div class="stat-item highlight">
                                        <span class="stat-label">跨度变化率</span>
                                        <span class="stat-value">${comparison.changeRates.span}%</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">前期平均AC值</span>
                                        <span class="stat-value">${comparison.firstHalf.avgAC}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">后期平均AC值</span>
                                        <span class="stat-value">${comparison.secondHalf.avgAC}</span>
                                    </div>
                                    <div class="stat-item highlight">
                                        <span class="stat-label">AC值变化率</span>
                                        <span class="stat-value">${comparison.changeRates.ac}%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                            <button class="btn btn-primary" onclick="EventDelegate.printStatisticsReport()">打印报告</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            static printStatisticsReport() {
                window.print();
            }

            static performPatternRecognition() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    if (!currentDatabaseData || !currentDatabaseData.draws || currentDatabaseData.draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('patternRecognitionPeriodSelect');
                    const periodValue = periodSelect ? periodSelect.value : '100';
                    const analysisPeriod = periodValue === 'all' ? currentDatabaseData.draws.length : parseInt(periodValue);

                    const reversedDraws = [...currentDatabaseData.draws].reverse().slice(0, analysisPeriod);

                    // 更新分析范围显示
                    const patternRecognitionDataRangeInfo = document.getElementById('patternRecognitionDataRangeInfo');
                    if (patternRecognitionDataRangeInfo && reversedDraws.length > 0) {
                        const startPeriod = reversedDraws[reversedDraws.length - 1].period;
                        const endPeriod = reversedDraws[0].period;
                        patternRecognitionDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${reversedDraws.length}期）`;
                    }

                    const patternData = this.calculatePatternRecognitionData(reversedDraws);
                    patternData.period = analysisPeriod;

                    patternRecognitionData = patternData;
                    patternRecognitionResults = patternData;

                    this.updatePatternRecognitionChart(patternData);
                    this.generatePatternRecognitionConclusion(patternData);
                    this.discoverPatternRecognitionPatterns(patternData);

                    MessageSystem.showMessage(`已完成${reversedDraws.length}期数据的模式识别`, 'success');
                });
            }

            static calculatePatternRecognitionData(draws) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                const sequencePatterns = {
                    consecutive: [],
                    arithmetic: [],
                    geometric: []
                };

                const periodicPatterns = {
                    periods: {},
                    strongestPeriod: null,
                    periodConfidence: 0
                };

                const morphologyPatterns = {
                    symmetry: [],
                    cluster: [],
                    disperse: []
                };

                const repetitionPatterns = {
                    fullRepetitions: [],
                    partialRepetitions: [],
                    maxRepetition: 0
                };

                const jumpPatterns = {
                    jumps: [],
                    avgJump: 0,
                    maxJump: 0
                };

                const numberPeriodicity = {};
                for (let i = redBallRange[0]; i <= redBallRange[1]; i++) {
                    numberPeriodicity[i] = [];
                }

                draws.forEach((draw, drawIndex) => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    const consecutive = this.detectConsecutivePattern(redBalls);
                    if (consecutive.length > 0) {
                        sequencePatterns.consecutive.push({
                            drawIndex: drawIndex + 1,
                            pattern: consecutive,
                            count: consecutive.length
                        });
                    }

                    const arithmetic = this.detectArithmeticPattern(redBalls);
                    if (arithmetic.length > 0) {
                        sequencePatterns.arithmetic.push({
                            drawIndex: drawIndex + 1,
                            pattern: arithmetic,
                            difference: arithmetic[1] - arithmetic[0]
                        });
                    }

                    const geometric = this.detectGeometricPattern(redBalls);
                    if (geometric.length > 0) {
                        sequencePatterns.geometric.push({
                            drawIndex: drawIndex + 1,
                            pattern: geometric,
                            ratio: geometric[1] / geometric[0]
                        });
                    }

                    redBalls.forEach(ball => {
                        numberPeriodicity[ball].push(drawIndex);
                    });

                    const symmetry = this.detectSymmetryPattern(redBalls);
                    if (symmetry) {
                        morphologyPatterns.symmetry.push({
                            drawIndex: drawIndex + 1,
                            center: symmetry.center,
                            pairs: symmetry.pairs
                        });
                    }

                    const cluster = this.detectClusterPattern(redBalls);
                    if (cluster) {
                        morphologyPatterns.cluster.push({
                            drawIndex: drawIndex + 1,
                            clusters: cluster.clusters,
                            maxClusterSize: cluster.maxClusterSize
                        });
                    }

                    const disperse = this.detectDispersePattern(redBalls);
                    if (disperse) {
                        morphologyPatterns.disperse.push({
                            drawIndex: drawIndex + 1,
                            gaps: disperse.gaps,
                            avgGap: disperse.avgGap
                        });
                    }

                    const jumps = this.calculateJumps(redBalls);
                    jumpPatterns.jumps.push({
                        drawIndex: drawIndex + 1,
                        jumps: jumps,
                        avgJump: jumps.reduce((a, b) => a + b, 0) / jumps.length,
                        maxJump: Math.max(...jumps)
                    });
                });

                Object.keys(numberPeriodicity).forEach(num => {
                    const occurrences = numberPeriodicity[num];
                    if (occurrences.length > 1) {
                        for (let i = 1; i < occurrences.length; i++) {
                            const period = occurrences[i] - occurrences[i - 1];
                            if (!periodicPatterns.periods[period]) {
                                periodicPatterns.periods[period] = 0;
                            }
                            periodicPatterns.periods[period]++;
                        }
                    }
                });

                let maxPeriodCount = 0;
                Object.keys(periodicPatterns.periods).forEach(period => {
                    if (periodicPatterns.periods[period] > maxPeriodCount) {
                        maxPeriodCount = periodicPatterns.periods[period];
                        periodicPatterns.strongestPeriod = parseInt(period);
                    }
                });

                periodicPatterns.periodConfidence = maxPeriodCount > 0 ? (maxPeriodCount / draws.length * 100).toFixed(2) : 0;

                const drawCombinations = draws.map(draw => 
                    draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b).join(',')
                );

                const combinationCounts = {};
                drawCombinations.forEach((combo, index) => {
                    if (!combinationCounts[combo]) {
                        combinationCounts[combo] = { count: 0, indices: [] };
                    }
                    combinationCounts[combo].count++;
                    combinationCounts[combo].indices.push(index + 1);
                });

                Object.keys(combinationCounts).forEach(combo => {
                    if (combinationCounts[combo].count > 1) {
                        if (combinationCounts[combo].count === 6) {
                            repetitionPatterns.fullRepetitions.push({
                                combination: combo,
                                count: combinationCounts[combo].count,
                                indices: combinationCounts[combo].indices
                            });
                        } else {
                            repetitionPatterns.partialRepetitions.push({
                                combination: combo,
                                count: combinationCounts[combo].count,
                                indices: combinationCounts[combo].indices
                            });
                        }

                        if (combinationCounts[combo].count > repetitionPatterns.maxRepetition) {
                            repetitionPatterns.maxRepetition = combinationCounts[combo].count;
                        }
                    }
                });

                const allJumps = jumpPatterns.jumps.map(j => j.jumps).flat();
                jumpPatterns.avgJump = allJumps.length > 0 ? (allJumps.reduce((a, b) => a + b, 0) / allJumps.length).toFixed(2) : 0;
                jumpPatterns.maxJump = allJumps.length > 0 ? Math.max(...allJumps) : 0;

                return {
                    sequencePatterns,
                    periodicPatterns,
                    morphologyPatterns,
                    repetitionPatterns,
                    jumpPatterns,
                    statistics: {
                        consecutiveCount: sequencePatterns.consecutive.length,
                        arithmeticCount: sequencePatterns.arithmetic.length,
                        geometricCount: sequencePatterns.geometric.length,
                        strongestPeriod: periodicPatterns.strongestPeriod || '-',
                        periodConfidence: periodicPatterns.periodConfidence + '%',
                        periodCount: Object.keys(periodicPatterns.periods).length,
                        symmetryCount: morphologyPatterns.symmetry.length,
                        clusterCount: morphologyPatterns.cluster.length,
                        disperseCount: morphologyPatterns.disperse.length,
                        fullRepetitionCount: repetitionPatterns.fullRepetitions.length,
                        partialRepetitionCount: repetitionPatterns.partialRepetitions.length,
                        maxRepetition: repetitionPatterns.maxRepetition || '-',
                        avgJump: jumpPatterns.avgJump,
                        maxJump: jumpPatterns.maxJump,
                        jumpCount: jumpPatterns.jumps.length
                    }
                };
            }

            static detectConsecutivePattern(numbers) {
                const consecutive = [];
                for (let i = 0; i < numbers.length - 1; i++) {
                    if (numbers[i + 1] - numbers[i] === 1) {
                        if (consecutive.length === 0 || consecutive[consecutive.length - 1] !== numbers[i]) {
                            consecutive.push(numbers[i]);
                        }
                        consecutive.push(numbers[i + 1]);
                    }
                }
                return consecutive;
            }

            static detectArithmeticPattern(numbers) {
                const arithmetic = [];
                for (let i = 0; i < numbers.length - 2; i++) {
                    const diff = numbers[i + 1] - numbers[i];
                    let isArithmetic = true;
                    for (let j = i + 1; j < numbers.length - 1; j++) {
                        if (numbers[j + 1] - numbers[j] !== diff) {
                            isArithmetic = false;
                            break;
                        }
                    }
                    if (isArithmetic && diff > 0) {
                        arithmetic.push(numbers.slice(i, i + 3));
                        break;
                    }
                }
                return arithmetic;
            }

            static detectGeometricPattern(numbers) {
                const geometric = [];
                for (let i = 0; i < numbers.length - 2; i++) {
                    const ratio = numbers[i + 1] / numbers[i];
                    let isGeometric = true;
                    for (let j = i + 1; j < numbers.length - 1; j++) {
                        if (numbers[j + 1] / numbers[j] !== ratio || ratio === 1) {
                            isGeometric = false;
                            break;
                        }
                    }
                    if (isGeometric && ratio > 1 && Number.isInteger(ratio)) {
                        geometric.push(numbers.slice(i, i + 3));
                        break;
                    }
                }
                return geometric;
            }

            static detectSymmetryPattern(numbers) {
                const center = (numbers[0] + numbers[numbers.length - 1]) / 2;
                const pairs = [];
                for (let i = 0; i < numbers.length; i++) {
                    const symmetricValue = 2 * center - numbers[i];
                    if (numbers.includes(symmetricValue) && symmetricValue !== numbers[i]) {
                        pairs.push([numbers[i], symmetricValue]);
                    }
                }
                if (pairs.length >= 2) {
                    return { center, pairs };
                }
                return null;
            }

            static detectClusterPattern(numbers) {
                const clusters = [];
                let currentCluster = [numbers[0]];

                for (let i = 1; i < numbers.length; i++) {
                    if (numbers[i] - numbers[i - 1] <= 3) {
                        currentCluster.push(numbers[i]);
                    } else {
                        if (currentCluster.length >= 2) {
                            clusters.push([...currentCluster]);
                        }
                        currentCluster = [numbers[i]];
                    }
                }
                if (currentCluster.length >= 2) {
                    clusters.push(currentCluster);
                }

                if (clusters.length > 0) {
                    const maxClusterSize = Math.max(...clusters.map(c => c.length));
                    return { clusters, maxClusterSize };
                }
                return null;
            }

            static detectDispersePattern(numbers) {
                const gaps = [];
                for (let i = 1; i < numbers.length; i++) {
                    gaps.push(numbers[i] - numbers[i - 1]);
                }
                const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                if (avgGap > 4) {
                    return { gaps, avgGap: avgGap.toFixed(2) };
                }
                return null;
            }

            static calculateJumps(numbers) {
                const jumps = [];
                for (let i = 1; i < numbers.length; i++) {
                    jumps.push(numbers[i] - numbers[i - 1]);
                }
                return jumps;
            }

            static updatePatternRecognitionChart(patternData) {
                const chartType = currentPatternRecognitionChartType;

                document.querySelectorAll('.pattern-recognition-chart-content').forEach(content => {
                    content.style.display = 'none';
                });

                const selectedContent = document.getElementById(`pattern-${chartType}`);
                if (selectedContent) {
                    selectedContent.style.display = 'block';
                }

                switch (chartType) {
                    case 'sequence':
                        this.updatePatternSequenceChart(patternData);
                        break;
                    case 'periodic':
                        this.updatePatternPeriodicChart(patternData);
                        break;
                    case 'morphology':
                        this.updatePatternMorphologyChart(patternData);
                        break;
                    case 'repetition':
                        this.updatePatternRepetitionChart(patternData);
                        break;
                    case 'jump':
                        this.updatePatternJumpChart(patternData);
                        break;
                }
            }

            static updatePatternSequenceChart(patternData) {
                document.getElementById('patternSequencePeriods').textContent = patternData.period;
                document.getElementById('patternConsecutiveCount').textContent = patternData.statistics.consecutiveCount;
                document.getElementById('patternArithmeticCount').textContent = patternData.statistics.arithmeticCount;
                document.getElementById('patternGeometricCount').textContent = patternData.statistics.geometricCount;

                const chartDom = document.getElementById('patternSequenceChart');
                if (!chartDom) return;

                if (patternSequenceChart) {
                    patternSequenceChart.dispose();
                }

                patternSequenceChart = echarts.init(chartDom);

                const periods = patternData.sequencePatterns.consecutive.map(p => p.drawIndex);
                const consecutiveData = patternData.sequencePatterns.consecutive.map(p => p.count);
                const arithmeticData = patternData.sequencePatterns.arithmetic.map(p => p.pattern.length);
                const geometricData = patternData.sequencePatterns.geometric.map(p => p.pattern.length);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `序列模式识别（最近${patternData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['连续号码', '等差数列', '等比数列'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '模式长度',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '连续号码',
                            type: 'line',
                            smooth: true,
                            data: consecutiveData,
                            itemStyle: {
                                color: '#e74c3c'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(231, 76, 60, 0.3)' },
                                    { offset: 1, color: 'rgba(231, 76, 60, 0.05)' }
                                ])
                            }
                        },
                        {
                            name: '等差数列',
                            type: 'line',
                            smooth: true,
                            data: arithmeticData,
                            itemStyle: {
                                color: '#3498db'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(52, 152, 219, 0.3)' },
                                    { offset: 1, color: 'rgba(52, 152, 219, 0.05)' }
                                ])
                            }
                        },
                        {
                            name: '等比数列',
                            type: 'line',
                            smooth: true,
                            data: geometricData,
                            itemStyle: {
                                color: '#27ae60'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(39, 174, 96, 0.3)' },
                                    { offset: 1, color: 'rgba(39, 174, 96, 0.05)' }
                                ])
                            }
                        }
                    ]
                };

                patternSequenceChart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    patternSequenceChart.resize();
                });
            }

            static updatePatternPeriodicChart(patternData) {
                document.getElementById('patternPeriodicPeriods').textContent = patternData.period;
                document.getElementById('patternStrongestPeriod').textContent = patternData.statistics.strongestPeriod;
                document.getElementById('patternPeriodConfidence').textContent = patternData.statistics.periodConfidence;
                document.getElementById('patternPeriodCount').textContent = patternData.statistics.periodCount;

                const chartDom = document.getElementById('patternPeriodicChart');
                if (!chartDom) return;

                if (patternPeriodicChart) {
                    patternPeriodicChart.dispose();
                }

                patternPeriodicChart = echarts.init(chartDom);

                const periods = Object.keys(patternData.periodicPatterns.periods).map(Number).sort((a, b) => a - b);
                const counts = periods.map(p => patternData.periodicPatterns.periods[p]);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `周期性模式识别（最近${patternData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '周期（期）',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '周期出现次数',
                            type: 'bar',
                            data: counts,
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#3498db' },
                                    { offset: 1, color: '#2980b9' }
                                ]),
                                borderRadius: [4, 4, 0, 0]
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#e74c3c',
                                    type: 'dashed'
                                }
                            }
                        }
                    ]
                };

                patternPeriodicChart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    patternPeriodicChart.resize();
                });
            }

            static updatePatternMorphologyChart(patternData) {
                document.getElementById('patternMorphologyPeriods').textContent = patternData.period;
                document.getElementById('patternSymmetryCount').textContent = patternData.statistics.symmetryCount;
                document.getElementById('patternClusterCount').textContent = patternData.statistics.clusterCount;
                document.getElementById('patternDisperseCount').textContent = patternData.statistics.disperseCount;

                const chartDom = document.getElementById('patternMorphologyChart');
                if (!chartDom) return;

                if (patternMorphologyChart) {
                    patternMorphologyChart.dispose();
                }

                patternMorphologyChart = echarts.init(chartDom);

                const periods = patternData.morphologyPatterns.symmetry.map(p => p.drawIndex);
                const symmetryData = periods.map(p => 1);
                const clusterData = patternData.morphologyPatterns.cluster.map(p => p.maxClusterSize);
                const disperseData = patternData.morphologyPatterns.disperse.map(p => parseFloat(p.avgGap));

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `形态模式识别（最近${patternData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['对称形态', '聚集形态', '分散形态'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '形态强度',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '对称形态',
                            type: 'line',
                            smooth: true,
                            data: symmetryData,
                            itemStyle: {
                                color: '#9b59b6'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(155, 89, 182, 0.3)' },
                                    { offset: 1, color: 'rgba(155, 89, 182, 0.05)' }
                                ])
                            }
                        },
                        {
                            name: '聚集形态',
                            type: 'line',
                            smooth: true,
                            data: clusterData,
                            itemStyle: {
                                color: '#f39c12'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(243, 156, 18, 0.3)' },
                                    { offset: 1, color: 'rgba(243, 156, 18, 0.05)' }
                                ])
                            }
                        },
                        {
                            name: '分散形态',
                            type: 'line',
                            smooth: true,
                            data: disperseData,
                            itemStyle: {
                                color: '#1abc9c'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(26, 188, 156, 0.3)' },
                                    { offset: 1, color: 'rgba(26, 188, 156, 0.05)' }
                                ])
                            }
                        }
                    ]
                };

                patternMorphologyChart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    patternMorphologyChart.resize();
                });
            }

            static updatePatternRepetitionChart(patternData) {
                document.getElementById('patternRepetitionPeriods').textContent = patternData.period;
                document.getElementById('patternFullRepetitionCount').textContent = patternData.statistics.fullRepetitionCount;
                document.getElementById('patternPartialRepetitionCount').textContent = patternData.statistics.partialRepetitionCount;
                document.getElementById('patternMaxRepetition').textContent = patternData.statistics.maxRepetition;

                const chartDom = document.getElementById('patternRepetitionChart');
                if (!chartDom) return;

                if (patternRepetitionChart) {
                    patternRepetitionChart.dispose();
                }

                patternRepetitionChart = echarts.init(chartDom);

                const fullRepetitions = patternData.repetitionPatterns.fullRepetitions.map(r => ({
                    name: r.combination,
                    value: r.count,
                    indices: r.indices
                }));

                const partialRepetitions = patternData.repetitionPatterns.partialRepetitions.slice(0, 10).map(r => ({
                    name: r.combination,
                    value: r.count,
                    indices: r.indices
                }));

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `重复模式识别（最近${patternData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        },
                        formatter: function(params) {
                            if (params.data.indices) {
                                return `${params.name}<br/>重复次数: ${params.value}<br/>出现期数: ${params.data.indices.join(', ')}`;
                            }
                            return `${params.name}<br/>重复次数: ${params.value}`;
                        }
                    },
                    legend: {
                        data: ['完全重复', '部分重复'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    series: [
                        {
                            name: '完全重复',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['25%', '60%'],
                            data: fullRepetitions.length > 0 ? fullRepetitions : [{ name: '无完全重复', value: 0 }],
                            itemStyle: {
                                color: function(params) {
                                    const colors = ['#e74c3c', '#3498db', '#27ae60', '#f39c12', '#9b59b6'];
                                    return colors[params.dataIndex % colors.length];
                                }
                            },
                            label: {
                                formatter: '{b}: {c}次'
                            }
                        },
                        {
                            name: '部分重复',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['75%', '60%'],
                            data: partialRepetitions.length > 0 ? partialRepetitions : [{ name: '无部分重复', value: 0 }],
                            itemStyle: {
                                color: function(params) {
                                    const colors = ['#1abc9c', '#e67e22', '#34495e', '#16a085', '#c0392b'];
                                    return colors[params.dataIndex % colors.length];
                                }
                            },
                            label: {
                                formatter: '{b}: {c}次'
                            }
                        }
                    ]
                };

                patternRepetitionChart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    patternRepetitionChart.resize();
                });
            }

            static updatePatternJumpChart(patternData) {
                document.getElementById('patternJumpPeriods').textContent = patternData.period;
                document.getElementById('patternAvgJump').textContent = patternData.statistics.avgJump;
                document.getElementById('patternMaxJump').textContent = patternData.statistics.maxJump;
                document.getElementById('patternJumpCount').textContent = patternData.statistics.jumpCount;

                const chartDom = document.getElementById('patternJumpChart');
                if (!chartDom) return;

                if (patternJumpChart) {
                    patternJumpChart.dispose();
                }

                patternJumpChart = echarts.init(chartDom);

                const periods = patternData.jumpPatterns.jumps.map(j => j.drawIndex);
                const avgJumps = patternData.jumpPatterns.jumps.map(j => j.avgJump);
                const maxJumps = patternData.jumpPatterns.jumps.map(j => j.maxJump);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `跳跃模式识别（最近${patternData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['平均跳跃', '最大跳跃'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '跳跃值',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '平均跳跃',
                            type: 'line',
                            smooth: true,
                            data: avgJumps,
                            itemStyle: {
                                color: '#e74c3c'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(231, 76, 60, 0.3)' },
                                    { offset: 1, color: 'rgba(231, 76, 60, 0.05)' }
                                ])
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#e74c3c',
                                    type: 'dashed'
                                }
                            }
                        },
                        {
                            name: '最大跳跃',
                            type: 'line',
                            smooth: true,
                            data: maxJumps,
                            itemStyle: {
                                color: '#3498db'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(52, 152, 219, 0.3)' },
                                    { offset: 1, color: 'rgba(52, 152, 219, 0.05)' }
                                ])
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#3498db',
                                    type: 'dashed'
                                }
                            }
                        }
                    ]
                };

                patternJumpChart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    patternJumpChart.resize();
                });
            }

            static generatePatternRecognitionConclusion(patternData) {
                const conclusionContent = document.getElementById('patternRecognitionConclusionContent');
                const stats = patternData.statistics;

                const insights = [];

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-sort-numeric-up"></i>
                        <strong>序列模式分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>在最近${patternData.period}期数据中，检测到<strong>${stats.consecutiveCount}</strong>次连续号码模式，<strong>${stats.arithmeticCount}</strong>次等差数列模式，<strong>${stats.geometricCount}</strong>次等比数列模式。</p>
                        <p>${stats.consecutiveCount > 0 ? '连续号码模式较为常见，建议关注连续出现的号码组合' : '连续号码模式较少出现，号码分布较为分散'}。</p>
                        <p>${stats.arithmeticCount > 0 ? '等差数列模式表明号码之间存在一定的数学规律，可以用于预测' : '等差数列模式不明显，号码变化较为随机'}。</p>
                        <p>${stats.geometricCount > 0 ? '等比数列模式较为罕见，一旦出现具有较强参考价值' : '等比数列模式极少出现，号码增长不符合几何规律'}。</p>
                    </div>
                </div>`);

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-sync-alt"></i>
                        <strong>周期性模式分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>检测到<strong>${stats.periodCount}</strong>种不同的周期模式，其中最强周期为<strong>${stats.strongestPeriod}</strong>期，置信度为<strong>${stats.periodConfidence}</strong>。</p>
                        <p>${parseFloat(stats.periodConfidence) > 30 ? '周期性模式较为明显，号码出现具有较强规律性' : '周期性模式不明显，号码出现较为随机'}。</p>
                        <p>${stats.strongestPeriod !== '-' ? `建议关注${stats.strongestPeriod}期周期，该周期内号码重复出现概率较高` : '未检测到明显的周期性规律'}。</p>
                    </div>
                </div>`);

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-shapes"></i>
                        <strong>形态模式分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>检测到<strong>${stats.symmetryCount}</strong>次对称形态，<strong>${stats.clusterCount}</strong>次聚集形态，<strong>${stats.disperseCount}</strong>次分散形态。</p>
                        <p>${stats.symmetryCount > 0 ? '对称形态表明号码分布具有中心对称特征，可以用于号码筛选' : '对称形态较少，号码分布缺乏对称性'}。</p>
                        <p>${stats.clusterCount > 0 ? '聚集形态表明号码倾向于集中出现，可以关注号码密集区域' : '聚集形态较少，号码分布较为均匀'}。</p>
                        <p>${stats.disperseCount > 0 ? '分散形态表明号码倾向于分散出现，可以关注号码稀疏区域' : '分散形态较少，号码分布较为集中'}。</p>
                    </div>
                </div>`);

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-redo"></i>
                        <strong>重复模式分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>检测到<strong>${stats.fullRepetitionCount}</strong>次完全重复组合，<strong>${stats.partialRepetitionCount}</strong>次部分重复组合，最高重复次数为<strong>${stats.maxRepetition}</strong>次。</p>
                        <p>${stats.fullRepetitionCount > 0 ? '完全重复组合极为罕见，建议重点关注这些号码组合' : '未检测到完全重复组合，号码组合变化较为多样'}。</p>
                        <p>${stats.partialRepetitionCount > 0 ? '部分重复组合较为常见，表明某些号码组合具有重复出现倾向' : '部分重复组合较少，号码组合变化较为随机'}。</p>
                    </div>
                </div>`);

                insights.push(`<div class="insight-item">
                    <div class="insight-header">
                        <i class="fas fa-random"></i>
                        <strong>跳跃模式分析结论</strong>
                    </div>
                    <div class="insight-body">
                        <p>平均跳跃值为<strong>${stats.avgJump}</strong>，最大跳跃值为<strong>${stats.maxJump}</strong>，共检测到<strong>${stats.jumpCount}</strong>次跳跃模式。</p>
                        <p>${parseFloat(stats.avgJump) > 5 ? '平均跳跃值较大，号码变化幅度明显，建议关注号码跳跃规律' : '平均跳跃值适中，号码变化较为平稳'}。</p>
                        <p>${stats.maxJump > 10 ? '最大跳跃值较大，存在极端号码跳跃情况，需注意号码分布的异常变化' : '最大跳跃值适中，号码分布相对稳定'}。</p>
                    </div>
                </div>`);

                conclusionContent.innerHTML = insights.join('');
            }

            static discoverPatternRecognitionPatterns(patternData) {
                const patternContent = document.getElementById('patternRecognitionPatternContent');
                const stats = patternData.statistics;

                const patterns = [];

                if (stats.consecutiveCount > patternData.period * 0.3) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-exclamation-circle" style="color: #e74c3c;"></i>
                            <strong>连续号码高频模式</strong>
                        </div>
                        <div class="pattern-body">
                            <p>连续号码出现频率较高（${stats.consecutiveCount}次），建议关注连续号码组合，如1-2-3、5-6-7等。</p>
                        </div>
                    </div>`);
                }

                if (parseFloat(stats.periodConfidence) > 30) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-clock" style="color: #3498db;"></i>
                            <strong>周期性规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>检测到明显的周期性规律，最强周期为${stats.strongestPeriod}期，置信度为${stats.periodConfidence}。建议按照该周期进行号码筛选。</p>
                        </div>
                    </div>`);
                }

                if (stats.clusterCount > patternData.period * 0.4) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-compress-arrows-alt" style="color: #27ae60;"></i>
                            <strong>号码聚集规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>号码聚集出现频率较高（${stats.clusterCount}次），建议关注号码密集区域，如1-11区间、12-22区间等。</p>
                        </div>
                    </div>`);
                }

                if (stats.partialRepetitionCount > patternData.period * 0.2) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-copy" style="color: #f39c12;"></i>
                            <strong>部分重复规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>部分重复组合出现频率较高（${stats.partialRepetitionCount}次），表明某些号码组合具有重复出现倾向，建议关注历史高频组合。</p>
                        </div>
                    </div>`);
                }

                if (parseFloat(stats.avgJump) > 6) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-arrow-up" style="color: #9b59b6;"></i>
                            <strong>大跳跃规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>平均跳跃值较大（${stats.avgJump}），号码变化幅度明显，建议关注号码跳跃规律，避免选择过于密集的号码组合。</p>
                        </div>
                    </div>`);
                }

                if (patterns.length === 0) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>无明显规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>在当前分析期数内，未检测到明显的模式规律。建议扩大分析期数或结合其他分析方法进行综合判断。</p>
                        </div>
                    </div>`);
                }

                patternContent.innerHTML = patterns.join('');
            }

            static generatePatternRecognitionResults() {
                const mode = document.getElementById('patternRecognitionResultsMode').value;
                const resultsContent = document.getElementById('patternRecognitionResultsContent');

                if (!patternRecognitionData) {
                    resultsContent.innerHTML = '<p style="color: #7f8c8d; text-align: center;">请先完成模式识别</p>';
                    return;
                }

                const stats = patternRecognitionData.statistics;

                if (mode === 'summary') {
                    resultsContent.innerHTML = `
                        <div class="results-summary">
                            <div class="summary-grid">
                                <div class="summary-item">
                                    <div class="summary-label">序列模式总数</div>
                                    <div class="summary-value">${stats.consecutiveCount + stats.arithmeticCount + stats.geometricCount}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">周期模式数</div>
                                    <div class="summary-value">${stats.periodCount}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">形态模式总数</div>
                                    <div class="summary-value">${stats.symmetryCount + stats.clusterCount + stats.disperseCount}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">重复模式总数</div>
                                    <div class="summary-value">${stats.fullRepetitionCount + stats.partialRepetitionCount}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (mode === 'detailed') {
                    const sequenceDetails = patternRecognitionData.sequencePatterns.consecutive.map(p => 
                        `<li>第${p.drawIndex}期：${p.pattern.join('-')}（${p.count}个连续号码）</li>`
                    ).join('');

                    const periodicDetails = Object.keys(patternRecognitionData.periodicPatterns.periods).slice(0, 10).map(period => 
                        `<li>${period}期周期：出现${patternRecognitionData.periodicPatterns.periods[period]}次</li>`
                    ).join('');

                    const repetitionDetails = patternRecognitionData.repetitionPatterns.partialRepetitions.slice(0, 5).map(r => 
                        `<li>${r.combination}：重复${r.count}次（第${r.indices.join('、')}期）</li>`
                    ).join('');

                    resultsContent.innerHTML = `
                        <div class="results-detailed">
                            <div class="detail-section">
                                <h4>序列模式详情</h4>
                                <ul>${sequenceDetails || '<li>无序列模式</li>'}</ul>
                            </div>
                            <div class="detail-section">
                                <h4>周期模式详情</h4>
                                <ul>${periodicDetails || '<li>无周期模式</li>'}</ul>
                            </div>
                            <div class="detail-section">
                                <h4>重复模式详情</h4>
                                <ul>${repetitionDetails || '<li>无重复模式</li>'}</ul>
                            </div>
                        </div>
                    `;
                } else if (mode === 'recommendation') {
                    const recommendations = [];

                    if (stats.consecutiveCount > 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐连续号码组合</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于连续号码模式，建议关注以下连续号码组合：</p>
                                <ul>
                                    <li>1-2-3-4-5-6</li>
                                    <li>5-6-7-8-9-10</li>
                                    <li>10-11-12-13-14-15</li>
                                    <li>15-16-17-18-19-20</li>
                                    <li>20-21-22-23-24-25</li>
                                </ul>
                            </div>
                        </div>`);
                    }

                    if (stats.strongestPeriod !== '-') {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐周期性号码</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于${stats.strongestPeriod}期周期，建议关注历史周期性出现的号码组合。</p>
                            </div>
                        </div>`);
                    }

                    if (stats.clusterCount > 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐聚集区域号码</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于聚集形态，建议关注以下号码密集区域：</p>
                                <ul>
                                    <li>1-11区间：建议选择2-3个号码</li>
                                    <li>12-22区间：建议选择2-3个号码</li>
                                    <li>23-33区间：建议选择1-2个号码</li>
                                </ul>
                            </div>
                        </div>`);
                    }

                    if (recommendations.length === 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                                <strong>暂无推荐</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>当前分析结果未生成明确推荐，建议扩大分析期数或结合其他分析方法。</p>
                            </div>
                        </div>`);
                    }

                    resultsContent.innerHTML = recommendations.join('');
                }
            }

            static exportPatternReport() {
                if (!patternRecognitionData) {
                    MessageSystem.showMessage('请先完成模式识别', 'error');
                    return;
                }

                const stats = patternRecognitionData.statistics;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px;">
                        <div class="modal-header">
                            <h3><i class="fas fa-fingerprint"></i> 模式识别报告</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="report-section">
                                <h4><i class="fas fa-info-circle"></i> 报告信息</h4>
                                <div class="report-info">
                                    <p><strong>生成时间：</strong>${new Date().toLocaleString()}</p>
                                    <p><strong>彩种：</strong>${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}</p>
                                    <p><strong>分析期数：</strong>${patternRecognitionData.period}期</p>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-sort-numeric-up"></i> 序列模式统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">连续号码模式</span>
                                        <span class="stat-value">${stats.consecutiveCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">等差数列模式</span>
                                        <span class="stat-value">${stats.arithmeticCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">等比数列模式</span>
                                        <span class="stat-value">${stats.geometricCount}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-sync-alt"></i> 周期性模式统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">最强周期</span>
                                        <span class="stat-value">${stats.strongestPeriod}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">周期置信度</span>
                                        <span class="stat-value">${stats.periodConfidence}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">周期模式数</span>
                                        <span class="stat-value">${stats.periodCount}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-shapes"></i> 形态模式统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">对称形态</span>
                                        <span class="stat-value">${stats.symmetryCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">聚集形态</span>
                                        <span class="stat-value">${stats.clusterCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">分散形态</span>
                                        <span class="stat-value">${stats.disperseCount}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-redo"></i> 重复模式统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">完全重复组合</span>
                                        <span class="stat-value">${stats.fullRepetitionCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">部分重复组合</span>
                                        <span class="stat-value">${stats.partialRepetitionCount}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">最高重复次数</span>
                                        <span class="stat-value">${stats.maxRepetition}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-random"></i> 跳跃模式统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">平均跳跃值</span>
                                        <span class="stat-value">${stats.avgJump}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">最大跳跃值</span>
                                        <span class="stat-value">${stats.maxJump}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">跳跃模式数</span>
                                        <span class="stat-value">${stats.jumpCount}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                            <button class="btn btn-primary" onclick="EventDelegate.printPatternReport()">打印报告</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            static printPatternReport() {
                window.print();
            }

            static performDNAAnalysis() {
                dataManager.loadDataForCurrentLottery().then(() => {
                    if (!currentDatabaseData || !currentDatabaseData.draws || currentDatabaseData.draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }

                    const periodSelect = document.getElementById('dnaAnalysisPeriodSelect');
                    const periodValue = periodSelect ? periodSelect.value : '100';
                    const analysisPeriod = periodValue === 'all' ? currentDatabaseData.draws.length : parseInt(periodValue);

                    const reversedDraws = [...currentDatabaseData.draws].reverse().slice(0, analysisPeriod);

                    // 更新分析范围显示
                    const dnaAnalysisDataRangeInfo = document.getElementById('dnaAnalysisDataRangeInfo');
                    if (dnaAnalysisDataRangeInfo && reversedDraws.length > 0) {
                        const startPeriod = reversedDraws[reversedDraws.length - 1].period;
                        const endPeriod = reversedDraws[0].period;
                        dnaAnalysisDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${reversedDraws.length}期）`;
                    }

                    const dnaData = this.calculateDNAAnalysisData(reversedDraws);
                    dnaData.period = analysisPeriod;

                    dnaAnalysisData = dnaData;
                    dnaAnalysisResults = dnaData;

                    this.updateDNAAnalysisChart(dnaData);
                    this.generateDNAAnalysisConclusion(dnaData);
                    this.discoverDNAPatterns(dnaData);

                    MessageSystem.showMessage(`已完成${reversedDraws.length}期数据的DNA分析`, 'success');
                });
            }

            static calculateDNAAnalysisData(draws) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                const sequencePatterns = {
                    sequences: [],
                    gcContent: 0,
                    similarityScore: 0,
                    sequenceLength: 0
                };

                const evolutionPatterns = {
                    generations: [],
                    fitnessScores: [],
                    bestFitness: 0,
                    avgFitness: 0,
                    mutationRate: 0
                };

                const mutationPatterns = {
                    mutations: [],
                    mutationTypes: {},
                    mutationCount: 0,
                    mutationRate: 0
                };

                const diversityPatterns = {
                    shannonIndex: 0,
                    simpsonIndex: 0,
                    populationSize: 0,
                    diversityScore: 0
                };

                const mappingPatterns = {
                    geneMap: {},
                    chromosomeMap: {},
                    linkageMap: {}
                };

                const statistics = {
                    totalSequences: 0,
                    avgGCContent: 0,
                    avgSimilarity: 0,
                    totalMutations: 0,
                    avgFitness: 0,
                    diversityIndex: 0
                };

                draws.forEach((draw, drawIndex) => {
                    const redBalls = draw.redBalls.map(ball => parseInt(ball)).sort((a, b) => a - b);

                    const sequence = this.detectDNASequencePattern(redBalls, drawIndex);
                    sequencePatterns.sequences.push(sequence);

                    const evolution = this.detectGeneticEvolution(redBalls, drawIndex);
                    evolutionPatterns.generations.push(evolution.generation);
                    evolutionPatterns.fitnessScores.push(evolution.fitness);

                    const mutation = this.detectGeneMutation(redBalls, drawIndex);
                    mutationPatterns.mutations.push(mutation);
                    mutationPatterns.mutationCount += mutation.count;

                    const diversity = this.detectPopulationDiversity(redBalls, drawIndex);
                    diversityPatterns.shannonIndex += diversity.shannon;
                    diversityPatterns.simpsonIndex += diversity.simpson;

                    const mapping = this.detectDNAMapping(redBalls, drawIndex);
                    mappingPatterns.geneMap[drawIndex] = mapping.geneMap;
                    mappingPatterns.chromosomeMap[drawIndex] = mapping.chromosomeMap;
                    mappingPatterns.linkageMap[drawIndex] = mapping.linkageMap;
                });

                const totalDraws = draws.length;

                sequencePatterns.gcContent = sequencePatterns.sequences.reduce((sum, s) => sum + s.gcContent, 0) / totalDraws;
                sequencePatterns.similarityScore = sequencePatterns.sequences.reduce((sum, s) => sum + s.similarity, 0) / totalDraws;
                sequencePatterns.sequenceLength = sequencePatterns.sequences[0]?.sequence.length || 0;

                evolutionPatterns.bestFitness = Math.max(...evolutionPatterns.fitnessScores);
                evolutionPatterns.avgFitness = evolutionPatterns.fitnessScores.reduce((a, b) => a + b, 0) / totalDraws;
                evolutionPatterns.mutationRate = mutationPatterns.mutationCount / totalDraws;

                mutationPatterns.mutationRate = mutationPatterns.mutationCount / (totalDraws * rules.redBallCount);

                diversityPatterns.shannonIndex /= totalDraws;
                diversityPatterns.simpsonIndex /= totalDraws;
                diversityPatterns.populationSize = totalDraws;
                diversityPatterns.diversityScore = (diversityPatterns.shannonIndex + diversityPatterns.simpsonIndex) / 2;

                statistics.totalSequences = totalDraws;
                statistics.avgGCContent = sequencePatterns.gcContent.toFixed(4);
                statistics.avgSimilarity = sequencePatterns.similarityScore.toFixed(4);
                statistics.totalMutations = mutationPatterns.mutationCount;
                statistics.avgFitness = evolutionPatterns.avgFitness.toFixed(4);
                statistics.diversityIndex = diversityPatterns.diversityScore.toFixed(4);

                return {
                    sequencePatterns,
                    evolutionPatterns,
                    mutationPatterns,
                    diversityPatterns,
                    mappingPatterns,
                    statistics
                };
            }

            static detectDNASequencePattern(redBalls, drawIndex) {
                const sequence = redBalls.map(ball => {
                    if (ball % 4 === 0) return 'A';
                    if (ball % 4 === 1) return 'T';
                    if (ball % 4 === 2) return 'C';
                    return 'G';
                }).join('');

                const gcCount = sequence.split('').filter(n => n === 'G' || n === 'C').length;
                const gcContent = gcCount / sequence.length;

                let similarity = 0;
                if (drawIndex > 0 && dnaAnalysisData && dnaAnalysisData.sequencePatterns) {
                    const prevSequence = dnaAnalysisData.sequencePatterns.sequences[drawIndex - 1];
                    if (prevSequence) {
                        const matches = sequence.split('').filter((n, i) => n === prevSequence.sequence[i]).length;
                        similarity = matches / sequence.length;
                    }
                }

                return {
                    sequence,
                    gcContent,
                    similarity,
                    drawIndex: drawIndex + 1,
                    redBalls
                };
            }

            static detectGeneticEvolution(redBalls, drawIndex) {
                const sum = redBalls.reduce((a, b) => a + b, 0);
                const avg = sum / redBalls.length;
                const variance = redBalls.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / redBalls.length;
                const stdDev = Math.sqrt(variance);

                const fitness = 1 / (1 + stdDev / avg);
                const generation = drawIndex + 1;

                return {
                    generation,
                    fitness,
                    avg,
                    stdDev,
                    redBalls
                };
            }

            static detectGeneMutation(redBalls, drawIndex) {
                const mutations = [];
                let count = 0;

                if (drawIndex > 0 && dnaAnalysisData && dnaAnalysisData.sequencePatterns) {
                    const prevDraw = dnaAnalysisData.sequencePatterns.sequences[drawIndex - 1];
                    if (prevDraw && prevDraw.redBalls) {
                        redBalls.forEach((ball, i) => {
                            if (ball !== prevDraw.redBalls[i]) {
                                mutations.push({
                                    position: i,
                                    from: prevDraw.redBalls[i],
                                    to: ball,
                                    type: this.getMutationType(prevDraw.redBalls[i], ball)
                                });
                                count++;
                            }
                        });
                    }
                }

                const mutationTypes = {};
                mutations.forEach(m => {
                    if (!mutationTypes[m.type]) {
                        mutationTypes[m.type] = 0;
                    }
                    mutationTypes[m.type]++;
                });

                return {
                    mutations,
                    mutationTypes,
                    count,
                    drawIndex: drawIndex + 1
                };
            }

            static getMutationType(from, to) {
                const diff = Math.abs(to - from);
                if (diff === 0) return 'none';
                if (diff <= 3) return 'point';
                if (diff <= 7) return 'small';
                if (diff <= 15) return 'medium';
                return 'large';
            }

            static detectPopulationDiversity(redBalls, drawIndex) {
                const frequency = {};
                redBalls.forEach(ball => {
                    frequency[ball] = (frequency[ball] || 0) + 1;
                });

                const total = redBalls.length;
                let shannon = 0;
                let simpson = 0;

                Object.values(frequency).forEach(count => {
                    const p = count / total;
                    shannon -= p * Math.log2(p);
                    simpson += p * p;
                });

                simpson = 1 - simpson;

                return {
                    shannon,
                    simpson,
                    frequency,
                    drawIndex: drawIndex + 1
                };
            }

            static detectDNAMapping(redBalls, drawIndex) {
                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;
                const totalChromosomes = Math.ceil(redBallRange[1] / 10);

                const geneMap = redBalls.map((ball, i) => {
                    const chromosome = Math.ceil(ball / 10);
                    const position = ball % 10 === 0 ? 10 : ball % 10;
                    const nucleotide = this.getNucleotide(ball);

                    return {
                        position: i,
                        value: ball,
                        gene: `G${i + 1}`,
                        chromosome,
                        positionOnChromosome: position,
                        nucleotide,
                        geneType: this.getGeneType(ball, redBallRange),
                        expressionLevel: this.calculateExpressionLevel(ball, drawIndex)
                    };
                });

                const chromosomeMap = {};
                geneMap.forEach(gene => {
                    if (!chromosomeMap[gene.chromosome]) {
                        chromosomeMap[gene.chromosome] = {
                            genes: [],
                            nucleotideDistribution: { A: 0, T: 0, C: 0, G: 0 },
                            geneTypes: {},
                            avgExpression: 0
                        };
                    }
                    chromosomeMap[gene.chromosome].genes.push(gene);
                    chromosomeMap[gene.chromosome].nucleotideDistribution[gene.nucleotide]++;

                    if (!chromosomeMap[gene.chromosome].geneTypes[gene.geneType]) {
                        chromosomeMap[gene.chromosome].geneTypes[gene.geneType] = 0;
                    }
                    chromosomeMap[gene.chromosome].geneTypes[gene.geneType]++;
                });

                Object.keys(chromosomeMap).forEach(chrom => {
                    const chromData = chromosomeMap[chrom];
                    const totalGenes = chromData.genes.length;
                    chromData.avgExpression = chromData.genes.reduce((sum, g) => sum + g.expressionLevel, 0) / totalGenes;

                    Object.keys(chromData.nucleotideDistribution).forEach(nuc => {
                        chromData.nucleotideDistribution[nuc] = chromData.nucleotideDistribution[nuc] / totalGenes;
                    });
                });

                const linkageMap = [];
                for (let i = 0; i < geneMap.length - 1; i++) {
                    const distance = Math.abs(geneMap[i + 1].value - geneMap[i].value);
                    const sameChromosome = geneMap[i].chromosome === geneMap[i + 1].chromosome;
                    const linkageStrength = sameChromosome ? (1 - distance / 10) : (1 - distance / redBallRange[1]);

                    linkageMap.push({
                        from: geneMap[i].gene,
                        to: geneMap[i + 1].gene,
                        distance,
                        sameChromosome,
                        linkageStrength,
                        interactionType: this.getInteractionType(geneMap[i], geneMap[i + 1])
                    });
                }

                const geneClusters = this.detectGeneClusters(geneMap, totalChromosomes);

                return {
                    geneMap,
                    chromosomeMap,
                    linkageMap,
                    geneClusters,
                    totalChromosomes
                };
            }

            static getNucleotide(ball) {
                if (ball % 4 === 0) return 'A';
                if (ball % 4 === 1) return 'T';
                if (ball % 4 === 2) return 'C';
                return 'G';
            }

            static getGeneType(ball, redBallRange) {
                const range = redBallRange[1] - redBallRange[0];
                const position = (ball - redBallRange[0]) / range;

                if (position < 0.25) return 'early';
                if (position < 0.5) return 'early-mid';
                if (position < 0.75) return 'mid-late';
                return 'late';
            }

            static calculateExpressionLevel(ball, drawIndex) {
                const baseExpression = 0.5;
                const positionFactor = ball % 10 / 10;
                const timeFactor = Math.sin(drawIndex * 0.1) * 0.2 + 0.5;

                return baseExpression + positionFactor * 0.3 + timeFactor * 0.2;
            }

            static getInteractionType(gene1, gene2) {
                if (gene1.chromosome === gene2.chromosome) {
                    return 'cis-regulation';
                }
                return 'trans-regulation';
            }

            static detectGeneClusters(geneMap, totalChromosomes) {
                const clusters = {};

                geneMap.forEach(gene => {
                    if (!clusters[gene.chromosome]) {
                        clusters[gene.chromosome] = [];
                    }
                    clusters[gene.chromosome].push(gene);
                });

                Object.keys(clusters).forEach(chrom => {
                    const cluster = clusters[chrom];
                    cluster.sort((a, b) => a.positionOnChromosome - b.positionOnChromosome);

                    const subClusters = [];
                    let currentSubCluster = [cluster[0]];

                    for (let i = 1; i < cluster.length; i++) {
                        if (cluster[i].positionOnChromosome - cluster[i-1].positionOnChromosome <= 2) {
                            currentSubCluster.push(cluster[i]);
                        } else {
                            subClusters.push(currentSubCluster);
                            currentSubCluster = [cluster[i]];
                        }
                    }
                    subClusters.push(currentSubCluster);

                    clusters[chrom] = subClusters.map((sub, idx) => ({
                        id: `Cluster_${chrom}_${idx + 1}`,
                        genes: sub,
                        size: sub.length,
                        avgExpression: sub.reduce((sum, g) => sum + g.expressionLevel, 0) / sub.length
                    }));
                });

                return clusters;
            }

            static updateDNAAnalysisChart(dnaData) {
                const chartType = currentDNAAnalysisChartType;

                document.querySelectorAll('.dna-analysis-chart-content').forEach(el => el.style.display = 'none');
                document.getElementById(`dna-${chartType}`).style.display = 'block';

                if (chartType === 'sequence') {
                    this.updateDNASequenceChart(dnaData);
                } else if (chartType === 'evolution') {
                    this.updateDNAEvolutionChart(dnaData);
                } else if (chartType === 'mutation') {
                    this.updateDNAMutationChart(dnaData);
                } else if (chartType === 'diversity') {
                    this.updateDNADiversityChart(dnaData);
                } else if (chartType === 'mapping') {
                    this.updateDNAMappingChart(dnaData);
                }
            }

            static updateDNASequenceChart(dnaData) {
                const container = document.getElementById('dnaSequenceChart');

                if (dnaSequenceChart) {
                    dnaSequenceChart.dispose();
                }

                const sequences = dnaData.sequencePatterns.sequences;
                const periods = sequences.map(s => s.drawIndex);
                const gcContent = sequences.map(s => (s.gcContent * 100).toFixed(2));
                const similarity = sequences.map(s => (s.similarity * 100).toFixed(2));

                dnaSequenceChart = echarts.init(container);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `DNA序列分析（最近${dnaData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#9b59b6',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['GC含量(%)', '序列相似度(%)'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '百分比(%)',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: 'GC含量(%)',
                            type: 'line',
                            smooth: true,
                            data: gcContent,
                            itemStyle: {
                                color: '#9b59b6'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(155, 89, 182, 0.3)' },
                                    { offset: 1, color: 'rgba(155, 89, 182, 0.05)' }
                                ])
                            }
                        },
                        {
                            name: '序列相似度(%)',
                            type: 'line',
                            smooth: true,
                            data: similarity,
                            itemStyle: {
                                color: '#e91e63'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(233, 30, 99, 0.3)' },
                                    { offset: 1, color: 'rgba(233, 30, 99, 0.05)' }
                                ])
                            }
                        }
                    ]
                };

                dnaSequenceChart.setOption(option);

                document.getElementById('dnaSequencePeriods').textContent = dnaData.period;
                document.getElementById('dnaSequenceLength').textContent = dnaData.sequencePatterns.sequenceLength;
                document.getElementById('dnaGCContent').textContent = dnaData.statistics.avgGCContent;
                document.getElementById('dnaSequenceSimilarity').textContent = dnaData.statistics.avgSimilarity;
            }

            static updateDNAEvolutionChart(dnaData) {
                const container = document.getElementById('dnaEvolutionChart');

                if (dnaEvolutionChart) {
                    dnaEvolutionChart.dispose();
                }

                const generations = dnaData.evolutionPatterns.generations;
                const fitnessScores = dnaData.evolutionPatterns.fitnessScores;

                dnaEvolutionChart = echarts.init(container);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `遗传进化分析（最近${dnaData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#2ecc71',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['适应度'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: generations,
                        name: '代数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '适应度',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '适应度',
                            type: 'line',
                            smooth: true,
                            data: fitnessScores,
                            itemStyle: {
                                color: '#2ecc71'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(46, 204, 113, 0.3)' },
                                    { offset: 1, color: 'rgba(46, 204, 113, 0.05)' }
                                ])
                            },
                            markPoint: {
                                data: [
                                    { type: 'max', name: '最大值' },
                                    { type: 'min', name: '最小值' }
                                ]
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ]
                            }
                        }
                    ]
                };

                dnaEvolutionChart.setOption(option);

                document.getElementById('dnaEvolutionPeriods').textContent = dnaData.period;
                document.getElementById('dnaEvolutionGenerations').textContent = dnaData.evolutionPatterns.generations.length;
                document.getElementById('dnaFitnessMean').textContent = dnaData.statistics.avgFitness;
                document.getElementById('dnaFitnessBest').textContent = dnaData.evolutionPatterns.bestFitness.toFixed(4);
            }

            static updateDNAMutationChart(dnaData) {
                const container = document.getElementById('dnaMutationChart');

                if (dnaMutationChart) {
                    dnaMutationChart.dispose();
                }

                const mutations = dnaData.mutationPatterns.mutations;
                const periods = mutations.map(m => m.drawIndex);
                const mutationCounts = mutations.map(m => m.count);

                const mutationTypes = {};
                mutations.forEach(m => {
                    Object.keys(m.mutationTypes).forEach(type => {
                        if (!mutationTypes[type]) {
                            mutationTypes[type] = 0;
                        }
                        mutationTypes[type] += m.mutationTypes[type];
                    });
                });

                const typeData = Object.keys(mutationTypes).map(type => ({
                    name: type,
                    value: mutationTypes[type]
                }));

                dnaMutationChart = echarts.init(container);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `基因突变分析（最近${dnaData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#e74c3c',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['突变次数'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '突变次数',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '突变次数',
                            type: 'line',
                            smooth: true,
                            data: mutationCounts,
                            itemStyle: {
                                color: '#e74c3c'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(231, 76, 60, 0.3)' },
                                    { offset: 1, color: 'rgba(231, 76, 60, 0.05)' }
                                ])
                            }
                        }
                    ]
                };

                dnaMutationChart.setOption(option);

                document.getElementById('dnaMutationPeriods').textContent = dnaData.period;
                document.getElementById('dnaMutationCount').textContent = dnaData.statistics.totalMutations;
                document.getElementById('dnaMutationRate').textContent = (dnaData.mutationPatterns.mutationRate * 100).toFixed(2) + '%';
                document.getElementById('dnaMutationTypes').textContent = Object.keys(mutationTypes).length;
            }

            static updateDNADiversityChart(dnaData) {
                const container = document.getElementById('dnaDiversityChart');

                if (dnaDiversityChart) {
                    dnaDiversityChart.dispose();
                }

                const diversityData = dnaData.diversityPatterns;
                const periods = Array.from({ length: dnaData.period }, (_, i) => i + 1);
                const shannonIndices = [];
                const simpsonIndices = [];

                for (let i = 0; i < dnaData.period; i++) {
                    const shannon = diversityData.shannonIndex / dnaData.period;
                    const simpson = diversityData.simpsonIndex / dnaData.period;
                    shannonIndices.push(shannon.toFixed(4));
                    simpsonIndices.push(simpson.toFixed(4));
                }

                dnaDiversityChart = echarts.init(container);

                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: `种群多样性分析（最近${dnaData.period}期）`,
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['香农多样性指数', '辛普森多样性指数'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        boundaryGap: false,
                        data: periods,
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '多样性指数',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '香农多样性指数',
                            type: 'line',
                            smooth: true,
                            data: shannonIndices,
                            itemStyle: {
                                color: '#3498db'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(52, 152, 219, 0.3)' },
                                    { offset: 1, color: 'rgba(52, 152, 219, 0.05)' }
                                ])
                            }
                        },
                        {
                            name: '辛普森多样性指数',
                            type: 'line',
                            smooth: true,
                            data: simpsonIndices,
                            itemStyle: {
                                color: '#1abc9c'
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(26, 188, 156, 0.3)' },
                                    { offset: 1, color: 'rgba(26, 188, 156, 0.05)' }
                                ])
                            }
                        }
                    ]
                };

                dnaDiversityChart.setOption(option);

                document.getElementById('dnaDiversityPeriods').textContent = dnaData.period;
                document.getElementById('dnaPopulationSize').textContent = dnaData.diversityPatterns.populationSize;
                document.getElementById('dnaShannonIndex').textContent = dnaData.diversityPatterns.shannonIndex.toFixed(4);
                document.getElementById('dnaSimpsonIndex').textContent = dnaData.diversityPatterns.simpsonIndex.toFixed(4);
            }

            static updateDNAMappingChart(dnaData) {
                const container = document.getElementById('dnaMappingChart');

                if (dnaMappingChart) {
                    dnaMappingChart.dispose();
                }

                const mappingData = dnaData.mappingPatterns;
                const sequencePatterns = dnaData.sequencePatterns;

                const rules = LOTTERY_RULES[currentLotteryType];
                const redBallRange = rules.redBallRange;

                const totalChromosomes = Math.ceil(redBallRange[1] / 10);

                const nodes = [];
                const links = [];

                nodes.push({
                    id: 'root',
                    name: 'DNA图谱',
                    symbolSize: 80,
                    itemStyle: { color: '#9b59b6' },
                    category: 0
                });

                for (let i = 1; i <= totalChromosomes; i++) {
                    const chromosomeName = `染色体${i}`;
                    let geneCount = 0;
                    Object.values(mappingData.chromosomeMap).forEach(chromMap => {
                        if (chromMap[i]?.genes) {
                            geneCount += chromMap[i].genes.length;
                        }
                    });

                    nodes.push({
                        id: chromosomeName,
                        name: chromosomeName,
                        symbolSize: 50 + geneCount * 2,
                        itemStyle: { color: this.getChromosomeColor(i) },
                        category: 1
                    });

                    links.push({
                        source: 'root',
                        target: chromosomeName,
                        value: geneCount,
                        lineStyle: { width: geneCount / 2 }
                    });
                }

                const geneFrequency = {};
                sequencePatterns.sequences.forEach(seq => {
                    seq.redBalls.forEach(ball => {
                        const geneName = `基因${ball}`;
                        if (!geneFrequency[geneName]) {
                            geneFrequency[geneName] = 0;
                        }
                        geneFrequency[geneName]++;
                    });
                });

                const topGenes = Object.entries(geneFrequency)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 20);

                topGenes.forEach(([geneName, count]) => {
                    const geneValue = parseInt(geneName.replace('基因', ''));
                    const chromosome = Math.ceil(geneValue / 10);
                    const chromosomeName = `染色体${chromosome}`;

                    nodes.push({
                        id: geneName,
                        name: geneName,
                        symbolSize: 20 + count * 3,
                        itemStyle: { color: this.getChromosomeColor(chromosome) },
                        category: 2
                    });

                    links.push({
                        source: chromosomeName,
                        target: geneName,
                        value: count,
                        lineStyle: { width: count / 3 }
                    });
                });

                const allLinkageMaps = Object.values(mappingData.linkageMap).flat();
                const avgLinkageDistance = allLinkageMaps.reduce((sum, link) => sum + link.distance, 0) / allLinkageMaps.length;
                const linkageStrength = 1 - (avgLinkageDistance / redBallRange[1]);
                const recombinationRate = allLinkageMaps.filter(link => link.distance > avgLinkageDistance).length / allLinkageMaps.length;

                document.getElementById('dnaMappingPeriods').textContent = dnaData.period;
                document.getElementById('dnaGeneLoci').textContent = sequencePatterns.sequences.length * rules.redBallCount;
                document.getElementById('dnaLinkageStrength').textContent = linkageStrength.toFixed(4);
                document.getElementById('dnaRecombinationRate').textContent = (recombinationRate * 100).toFixed(2) + '%';

                dnaMappingChart = echarts.init(container);

                const option = {
                    backgroundColor: 'rgba(248, 250, 252, 0.98)',
                    title: {
                        text: `DNA图谱分析（最近${dnaData.period}期）`,
                        left: 'center',
                        top: '3%',
                        textStyle: {
                            fontSize: 20,
                            fontWeight: 'bold',
                            color: '#2c3e50',
                            fontFamily: 'Microsoft YaHei, Arial, sans-serif'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#9b59b6',
                        borderWidth: 2,
                        textStyle: {
                            color: '#fff',
                            fontSize: 13,
                            fontFamily: 'Microsoft YaHei, Arial, sans-serif'
                        },
                        formatter: function(params) {
                            if (params.dataType === 'edge') {
                                return `<div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 5px;">${params.data.source} → ${params.data.target}</div>
                                    <div>关联强度: <span style="color: #f39c12; font-weight: bold;">${params.data.value}</span></div>
                                </div>`;
                            }
                            const nodeColor = params.data.itemStyle.color;
                            return `<div style="padding: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px; color: ${nodeColor};">${params.name}</div>
                                <div>出现次数: <span style="color: #f39c12; font-weight: bold;">${params.data.value || 0}</span></div>
                            </div>`;
                        }
                    },
                    legend: {
                        orient: 'horizontal',
                        left: 'center',
                        top: '10%',
                        data: ['DNA图谱', '染色体', '基因'],
                        textStyle: {
                            fontSize: 13,
                            color: '#34495e',
                            fontFamily: 'Microsoft YaHei, Arial, sans-serif'
                        },
                        itemGap: 20
                    },
                    series: [
                        {
                            name: 'DNA图谱',
                            type: 'graph',
                            layout: 'force',
                            data: nodes,
                            links: links,
                            categories: [
                                { name: 'DNA图谱', itemStyle: { color: '#9b59b6' } },
                                { name: '染色体', itemStyle: { color: '#3498db' } },
                                { name: '基因', itemStyle: { color: '#2ecc71' } }
                            ],
                            roam: true,
                            label: {
                                show: true,
                                position: 'right',
                                formatter: '{b}',
                                fontSize: 12,
                                color: '#2c3e50',
                                fontFamily: 'Microsoft YaHei, Arial, sans-serif',
                                fontWeight: 500
                            },
                            force: {
                                repulsion: 800,
                                edgeLength: [100, 250],
                                gravity: 0.05,
                                friction: 0.5,
                                layoutAnimation: true
                            },
                            edgeSymbol: ['circle', 'arrow'],
                            edgeSymbolSize: [5, 12],
                            edgeLabel: {
                                fontSize: 11,
                                color: '#7f8c8d',
                                formatter: '{c}'
                            },
                            lineStyle: {
                                opacity: 0.7,
                                width: 2.5,
                                curveness: 0.25,
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 1, y2: 0,
                                    colorStops: [
                                        { offset: 0, color: '#9b59b6' },
                                        { offset: 1, color: '#3498db' }
                                    ]
                                }
                            },
                            itemStyle: {
                                borderColor: '#fff',
                                borderWidth: 2,
                                shadowColor: 'rgba(0, 0, 0, 0.2)',
                                shadowBlur: 10
                            },
                            emphasis: {
                                focus: 'adjacency',
                                lineStyle: {
                                    width: 4,
                                    opacity: 1
                                },
                                itemStyle: {
                                    shadowColor: 'rgba(0, 0, 0, 0.4)',
                                    shadowBlur: 15
                                }
                            }
                        }
                    ]
                };

                dnaMappingChart.setOption(option);

                dnaMappingChart.off('click');
                dnaMappingChart.on('click', (params) => {
                    if (params.dataType === 'node') {
                        this.showGeneDetails(params.data, dnaData);
                    }
                });
            }

            static showGeneDetails(nodeData, dnaData) {
                const detailsPanel = document.getElementById('dnaMappingDetails');
                const detailsContent = document.getElementById('dnaMappingDetailsContent');

                if (nodeData.category === 2) {
                    const geneValue = parseInt(nodeData.name.replace('基因', ''));
                    const chromosome = Math.ceil(geneValue / 10);
                    const position = geneValue % 10 === 0 ? 10 : geneValue % 10;
                    const nucleotide = this.getNucleotide(geneValue);

                    const sequencePatterns = dnaData.sequencePatterns;
                    const geneOccurrences = sequencePatterns.sequences.filter(seq => 
                        seq.redBalls.includes(geneValue)
                    ).length;

                    const frequency = geneOccurrences / sequencePatterns.sequences.length;

                    const mappingData = dnaData.mappingPatterns;
                    let aggregatedChromosomeData = null;
                    Object.values(mappingData.chromosomeMap).forEach(chromMap => {
                        if (chromMap[chromosome]) {
                            if (!aggregatedChromosomeData) {
                                aggregatedChromosomeData = {
                                    genes: [],
                                    nucleotideDistribution: { A: 0, T: 0, C: 0, G: 0 },
                                    geneTypes: {},
                                    avgExpression: 0
                                };
                            }
                            aggregatedChromosomeData.genes.push(...chromMap[chromosome].genes);
                            aggregatedChromosomeData.nucleotideDistribution.A += chromMap[chromosome].nucleotideDistribution.A;
                            aggregatedChromosomeData.nucleotideDistribution.T += chromMap[chromosome].nucleotideDistribution.T;
                            aggregatedChromosomeData.nucleotideDistribution.C += chromMap[chromosome].nucleotideDistribution.C;
                            aggregatedChromosomeData.nucleotideDistribution.G += chromMap[chromosome].nucleotideDistribution.G;
                            aggregatedChromosomeData.avgExpression += chromMap[chromosome].avgExpression;
                            Object.entries(chromMap[chromosome].geneTypes).forEach(([type, count]) => {
                                if (!aggregatedChromosomeData.geneTypes[type]) {
                                    aggregatedChromosomeData.geneTypes[type] = 0;
                                }
                                aggregatedChromosomeData.geneTypes[type] += count;
                            });
                        }
                    });

                    if (aggregatedChromosomeData && aggregatedChromosomeData.genes.length > 0) {
                        const totalGenes = aggregatedChromosomeData.genes.length;
                        aggregatedChromosomeData.nucleotideDistribution.A /= totalGenes;
                        aggregatedChromosomeData.nucleotideDistribution.T /= totalGenes;
                        aggregatedChromosomeData.nucleotideDistribution.C /= totalGenes;
                        aggregatedChromosomeData.nucleotideDistribution.G /= totalGenes;
                        aggregatedChromosomeData.avgExpression /= Object.keys(mappingData.chromosomeMap).length;
                    }

                    let detailsHtml = `
                        <div class="gene-detail-card">
                            <div class="detail-row">
                                <span class="detail-label">基因名称：</span>
                                <span class="detail-value">${nodeData.name}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">基因值：</span>
                                <span class="detail-value">${geneValue}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">所属染色体：</span>
                                <span class="detail-value">染色体${chromosome}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">染色体位置：</span>
                                <span class="detail-value">${position}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">核苷酸类型：</span>
                                <span class="detail-value" style="color: ${this.getNucleotideColor(nucleotide)};">${nucleotide}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">出现次数：</span>
                                <span class="detail-value">${geneOccurrences}次</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">出现频率：</span>
                                <span class="detail-value">${(frequency * 100).toFixed(2)}%</span>
                            </div>
                        </div>
                    `;

                    if (aggregatedChromosomeData) {
                        const typeNames = {
                            'early': '早期',
                            'mid': '中期',
                            'late': '晚期',
                            'early-mid': '早中期',
                            'mid-late': '中晚期',
                            'early-late': '早晚期'
                        };

                        const geneTypesHtml = Object.entries(aggregatedChromosomeData.geneTypes)
                            .map(([type, count]) => `${typeNames[type] || type}: ${count}次`)
                            .join(' | ');

                        const geneTypesInterpretation = this.generateGeneTypesInterpretation(
                            aggregatedChromosomeData.geneTypes,
                            aggregatedChromosomeData.genes.length
                        );

                        detailsHtml += `
                            <div class="chromosome-detail-card">
                                <h5><i class="fas fa-dna"></i> 染色体${chromosome}信息</h5>
                                <div class="detail-row">
                                    <span class="detail-label">核苷酸分布：</span>
                                    <span class="detail-value">
                                        A: ${(aggregatedChromosomeData.nucleotideDistribution.A * 100).toFixed(1)}% | 
                                        T: ${(aggregatedChromosomeData.nucleotideDistribution.T * 100).toFixed(1)}% | 
                                        C: ${(aggregatedChromosomeData.nucleotideDistribution.C * 100).toFixed(1)}% | 
                                        G: ${(aggregatedChromosomeData.nucleotideDistribution.G * 100).toFixed(1)}%
                                    </span>
                                </div>
                                <div class="detail-row">
                                    <span class="detail-label">平均表达水平：</span>
                                    <span class="detail-value">${aggregatedChromosomeData.avgExpression.toFixed(4)}</span>
                                </div>
                                <div class="detail-row">
                                    <span class="detail-label">基因类型分布：</span>
                                    <span class="detail-value">${geneTypesHtml}</span>
                                </div>
                                <div class="detail-row" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(155, 89, 182, 0.2);">
                                    <span class="detail-label" style="font-weight: 600; color: #9b59b6;">DNA图谱分析解读：</span>
                                </div>
                                <div class="detail-row">
                                    <span class="detail-value" style="font-size: 13px; line-height: 1.6;">${geneTypesInterpretation}</span>
                                </div>
                            </div>
                        `;
                    }

                    detailsContent.innerHTML = detailsHtml;
                    detailsPanel.style.display = 'block';
                } else if (nodeData.category === 1) {
                    const chromosome = parseInt(nodeData.name.replace('染色体', ''));
                    const mappingData = dnaData.mappingPatterns;

                    let aggregatedChromosomeData = null;
                    Object.values(mappingData.chromosomeMap).forEach(chromMap => {
                        if (chromMap[chromosome]) {
                            if (!aggregatedChromosomeData) {
                                aggregatedChromosomeData = {
                                    genes: [],
                                    nucleotideDistribution: { A: 0, T: 0, C: 0, G: 0 },
                                    geneTypes: {},
                                    avgExpression: 0
                                };
                            }
                            aggregatedChromosomeData.genes.push(...chromMap[chromosome].genes);
                            aggregatedChromosomeData.nucleotideDistribution.A += chromMap[chromosome].nucleotideDistribution.A;
                            aggregatedChromosomeData.nucleotideDistribution.T += chromMap[chromosome].nucleotideDistribution.T;
                            aggregatedChromosomeData.nucleotideDistribution.C += chromMap[chromosome].nucleotideDistribution.C;
                            aggregatedChromosomeData.nucleotideDistribution.G += chromMap[chromosome].nucleotideDistribution.G;
                            aggregatedChromosomeData.avgExpression += chromMap[chromosome].avgExpression;
                            Object.entries(chromMap[chromosome].geneTypes).forEach(([type, count]) => {
                                if (!aggregatedChromosomeData.geneTypes[type]) {
                                    aggregatedChromosomeData.geneTypes[type] = 0;
                                }
                                aggregatedChromosomeData.geneTypes[type] += count;
                            });
                        }
                    });

                    if (aggregatedChromosomeData && aggregatedChromosomeData.genes.length > 0) {
                        const totalGenes = aggregatedChromosomeData.genes.length;
                        aggregatedChromosomeData.nucleotideDistribution.A /= totalGenes;
                        aggregatedChromosomeData.nucleotideDistribution.T /= totalGenes;
                        aggregatedChromosomeData.nucleotideDistribution.C /= totalGenes;
                        aggregatedChromosomeData.nucleotideDistribution.G /= totalGenes;
                        aggregatedChromosomeData.avgExpression /= Object.keys(mappingData.chromosomeMap).length;
                    }

                    let detailsHtml = `
                        <div class="chromosome-detail-card">
                            <h5><i class="fas fa-dna"></i> ${nodeData.name}信息</h5>
                            <div class="detail-row">
                                <span class="detail-label">基因数量：</span>
                                <span class="detail-value">${aggregatedChromosomeData ? aggregatedChromosomeData.genes.length : 0}</span>
                            </div>
                        `;

                    if (aggregatedChromosomeData) {
                        const typeNames = {
                            'early': '早期',
                            'mid': '中期',
                            'late': '晚期',
                            'early-mid': '早中期',
                            'mid-late': '中晚期',
                            'early-late': '早晚期'
                        };

                        const geneTypesHtml = Object.entries(aggregatedChromosomeData.geneTypes)
                            .map(([type, count]) => `${typeNames[type] || type}: ${count}次`)
                            .join(' | ');

                        const geneTypesInterpretation = this.generateGeneTypesInterpretation(
                            aggregatedChromosomeData.geneTypes,
                            aggregatedChromosomeData.genes.length
                        );

                        detailsHtml += `
                            <div class="detail-row">
                                <span class="detail-label">核苷酸分布：</span>
                                <span class="detail-value">
                                    A: ${(aggregatedChromosomeData.nucleotideDistribution.A * 100).toFixed(1)}% | 
                                    T: ${(aggregatedChromosomeData.nucleotideDistribution.T * 100).toFixed(1)}% | 
                                    C: ${(aggregatedChromosomeData.nucleotideDistribution.C * 100).toFixed(1)}% | 
                                    G: ${(aggregatedChromosomeData.nucleotideDistribution.G * 100).toFixed(1)}%
                                </span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">平均表达水平：</span>
                                <span class="detail-value">${aggregatedChromosomeData.avgExpression.toFixed(4)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">基因类型分布：</span>
                                <span class="detail-value">${geneTypesHtml}</span>
                            </div>
                            <div class="detail-row" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(155, 89, 182, 0.2);">
                                <span class="detail-label" style="font-weight: 600; color: #9b59b6;">DNA图谱分析解读：</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-value" style="font-size: 13px; line-height: 1.6;">${geneTypesInterpretation}</span>
                            </div>
                        `;
                    }

                    detailsHtml += `</div>`;
                    detailsContent.innerHTML = detailsHtml;
                    detailsPanel.style.display = 'block';
                } else {
                    detailsPanel.style.display = 'none';
                }
            }

            static getNucleotideColor(nucleotide) {
                const colors = {
                    'A': '#e74c3c',
                    'T': '#3498db',
                    'C': '#2ecc71',
                    'G': '#f39c12'
                };
                return colors[nucleotide] || '#95a5a6';
            }

            static getChromosomeColor(chromosome) {
                const colors = [
                    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                    '#F8B500', '#00CED1', '#FF69B4', '#20B2AA', '#FF7F50',
                    '#6495ED', '#FFB6C1', '#00FA9A', '#DC143C', '#00BFFF',
                    '#FFD700', '#32CD32', '#FF4500', '#1E90FF', '#FF1493',
                    '#00FF7F', '#FF6347', '#4169E1', '#7CFC00', '#FF00FF',
                    '#00CED1', '#FFA500', '#8A2BE2', '#00FF00', '#FF0000'
                ];
                return colors[(chromosome - 1) % colors.length];
            }

            static generateGeneTypesInterpretation(geneTypes, totalGenes) {
                if (!geneTypes || Object.keys(geneTypes).length === 0) {
                    return '暂无基因类型数据';
                }

                const sortedTypes = Object.entries(geneTypes).sort((a, b) => b[1] - a[1]);
                const dominantType = sortedTypes[0];
                const dominantRatio = (dominantType[1] / totalGenes * 100).toFixed(1);

                const typeNames = {
                    'early': '早期',
                    'mid': '中期',
                    'late': '晚期',
                    'early-mid': '早中期',
                    'mid-late': '中晚期',
                    'early-late': '早晚期'
                };

                let interpretation = '';

                if (sortedTypes.length === 1) {
                    const dominantTypeName = typeNames[dominantType[0]] || dominantType[0];
                    interpretation += `该染色体基因表达高度集中，${dominantTypeName}类型基因占比达到${dominantRatio}%，表明该区域具有极强的单一表达特征。`;
                } else if (sortedTypes.length === 2) {
                    const secondaryType = sortedTypes[1];
                    const secondaryRatio = (secondaryType[1] / totalGenes * 100).toFixed(1);
                    const dominantTypeName = typeNames[dominantType[0]] || dominantType[0];
                    const secondaryTypeName = typeNames[secondaryType[0]] || secondaryType[0];
                    interpretation += `该染色体基因表达呈现双峰分布，${dominantTypeName}类型（${dominantRatio}%）和${secondaryTypeName}类型（${secondaryRatio}%）为主要表达形式，显示出较为平衡的基因表达模式。`;
                } else {
                    interpretation += `该染色体基因表达呈现多样化分布，主要类型包括：`;
                    sortedTypes.slice(0, 3).forEach(([type, count], index) => {
                        const ratio = (count / totalGenes * 100).toFixed(1);
                        const typeName = typeNames[type] || type;
                        interpretation += `${typeName}类型（${ratio}%）`;
                        if (index < Math.min(2, sortedTypes.length - 1)) {
                            interpretation += '、';
                        }
                    });
                    const dominantTypeName = typeNames[dominantType[0]] || dominantType[0];
                    interpretation += `，其中${dominantTypeName}类型为主导表达类型，占比${dominantRatio}%。`;
                }

                const typeDescriptions = {
                    'early': '早期表达基因，通常与基础功能相关',
                    'mid': '中期表达基因，参与主要生理过程',
                    'late': '晚期表达基因，与成熟和分化相关',
                    'early-mid': '早中期过渡表达基因，功能较为活跃',
                    'mid-late': '中晚期过渡表达基因，表达水平较高',
                    'early-late': '早晚期直接关联基因，表达跨度较大'
                };

                const typeDescriptionsHtml = sortedTypes.map(([type, count]) => {
                    const ratio = (count / totalGenes * 100).toFixed(1);
                    const typeName = typeNames[type] || type;
                    const description = typeDescriptions[type] || '特殊表达类型';
                    return `<div style="margin-top: 8px; padding: 6px 10px; background: rgba(155, 89, 182, 0.08); border-radius: 6px; border-left: 3px solid #9b59b6;">
                        <strong>${typeName}</strong> (${ratio}%)：${description}
                    </div>`;
                }).join('');

                return interpretation + typeDescriptionsHtml;
            }

            static generateDNAAnalysisConclusion(dnaData) {
                const conclusionContent = document.getElementById('dnaAnalysisConclusionContent');
                const stats = dnaData.statistics;

                let conclusion = '';

                if (parseFloat(stats.avgGCContent) > 0.5) {
                    conclusion += `<div class="conclusion-item">
                        <div class="conclusion-header">
                            <i class="fas fa-dna" style="color: #9b59b6;"></i>
                            <strong>高GC含量特征</strong>
                        </div>
                        <div class="conclusion-body">
                            <p>检测到高GC含量特征（${stats.avgGCContent}），表明号码分布偏向于特定区间，建议关注GC富集区域的号码组合。</p>
                        </div>
                    </div>`;
                }

                if (parseFloat(stats.avgSimilarity) > 0.6) {
                    conclusion += `<div class="conclusion-item">
                        <div class="conclusion-header">
                            <i class="fas fa-link" style="color: #e91e63;"></i>
                            <strong>高序列相似度</strong>
                        </div>
                        <div class="conclusion-body">
                            <p>序列相似度较高（${stats.avgSimilarity}），表明相邻期号之间存在较强的遗传关联，建议参考历史相似序列进行选号。</p>
                        </div>
                    </div>`;
                }

                if (parseFloat(stats.avgFitness) > 0.7) {
                    conclusion += `<div class="conclusion-item">
                        <div class="conclusion-header">
                            <i class="fas fa-chart-line" style="color: #2ecc71;"></i>
                            <strong>高适应度进化</strong>
                        </div>
                        <div class="conclusion-body">
                            <p>适应度较高（${stats.avgFitness}），表明号码组合具有良好的进化特征，建议关注高适应度号码组合。</p>
                        </div>
                    </div>`;
                }

                if (stats.totalMutations > dnaData.period * 2) {
                    conclusion += `<div class="conclusion-item">
                        <div class="conclusion-header">
                            <i class="fas fa-exchange-alt" style="color: #e74c3c;"></i>
                            <strong>高频突变特征</strong>
                        </div>
                        <div class="conclusion-body">
                            <p>突变频率较高（${stats.totalMutations}次），表明号码组合变化幅度较大，建议关注突变热点区域。</p>
                        </div>
                    </div>`;
                }

                if (parseFloat(stats.diversityIndex) > 0.6) {
                    conclusion += `<div class="conclusion-item">
                        <div class="conclusion-header">
                            <i class="fas fa-globe" style="color: #3498db;"></i>
                            <strong>高种群多样性</strong>
                        </div>
                        <div class="conclusion-body">
                            <p>种群多样性较高（${stats.diversityIndex}），表明号码分布较为均匀，建议采用多样化选号策略。</p>
                        </div>
                    </div>`;
                }

                if (conclusion === '') {
                    conclusion = `<div class="conclusion-item">
                        <div class="conclusion-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>无明显特征</strong>
                        </div>
                        <div class="conclusion-body">
                            <p>在当前分析期数内，未检测到明显的DNA分析特征。建议扩大分析期数或结合其他分析方法进行综合判断。</p>
                        </div>
                    </div>`;
                }

                conclusionContent.innerHTML = conclusion;
            }

            static discoverDNAPatterns(dnaData) {
                const patternContent = document.getElementById('dnaAnalysisPatternContent');
                const stats = dnaData.statistics;

                const patterns = [];

                if (parseFloat(stats.avgGCContent) > 0.5) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-dna" style="color: #9b59b6;"></i>
                            <strong>GC含量规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>检测到GC含量规律（${stats.avgGCContent}），建议关注GC富集区域的号码组合，如号码模4余2或3的号码。</p>
                        </div>
                    </div>`);
                }

                if (parseFloat(stats.avgSimilarity) > 0.6) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-link" style="color: #e91e63;"></i>
                            <strong>序列相似规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>检测到序列相似规律（${stats.avgSimilarity}），相邻期号之间存在较强的遗传关联，建议参考历史相似序列进行选号。</p>
                        </div>
                    </div>`);
                }

                if (parseFloat(stats.avgFitness) > 0.7) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-chart-line" style="color: #2ecc71;"></i>
                            <strong>适应度进化规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>检测到适应度进化规律（${stats.avgFitness}），号码组合具有良好的进化特征，建议关注高适应度号码组合。</p>
                        </div>
                    </div>`);
                }

                if (stats.totalMutations > dnaData.period * 2) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-exchange-alt" style="color: #e74c3c;"></i>
                            <strong>突变热点规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>检测到突变热点规律（${stats.totalMutations}次），号码组合变化幅度较大，建议关注突变热点区域。</p>
                        </div>
                    </div>`);
                }

                if (parseFloat(stats.diversityIndex) > 0.6) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-globe" style="color: #3498db;"></i>
                            <strong>多样性分布规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>检测到多样性分布规律（${stats.diversityIndex}），号码分布较为均匀，建议采用多样化选号策略。</p>
                        </div>
                    </div>`);
                }

                if (patterns.length === 0) {
                    patterns.push(`<div class="pattern-item">
                        <div class="pattern-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>无明显规律</strong>
                        </div>
                        <div class="pattern-body">
                            <p>在当前分析期数内，未检测到明显的DNA分析规律。建议扩大分析期数或结合其他分析方法进行综合判断。</p>
                        </div>
                    </div>`);
                }

                patternContent.innerHTML = patterns.join('');
            }

            static generateDNAAnalysisResults() {
                const mode = document.getElementById('dnaAnalysisResultsMode').value;
                const resultsContent = document.getElementById('dnaAnalysisResultsContent');

                if (!dnaAnalysisData) {
                    resultsContent.innerHTML = '<p style="color: #7f8c8d; text-align: center;">请先完成DNA分析</p>';
                    return;
                }

                const stats = dnaAnalysisData.statistics;

                console.log('DNA分析统计数据:', stats);
                console.log('GC含量:', stats.avgGCContent, '类型:', typeof stats.avgGCContent);
                console.log('相似度:', stats.avgSimilarity, '类型:', typeof stats.avgSimilarity);
                console.log('适应度:', stats.avgFitness, '类型:', typeof stats.avgFitness);
                console.log('多样性:', stats.diversityIndex, '类型:', typeof stats.diversityIndex);
                console.log('突变次数:', stats.totalMutations, '类型:', typeof stats.totalMutations);

                if (mode === 'summary') {
                    resultsContent.innerHTML = `
                        <div class="results-summary">
                            <div class="summary-grid">
                                <div class="summary-item">
                                    <div class="summary-label">序列总数</div>
                                    <div class="summary-value">${stats.totalSequences}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">平均GC含量</div>
                                    <div class="summary-value">${stats.avgGCContent}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">平均相似度</div>
                                    <div class="summary-value">${stats.avgSimilarity}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">总突变次数</div>
                                    <div class="summary-value">${stats.totalMutations}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">平均适应度</div>
                                    <div class="summary-value">${stats.avgFitness}</div>
                                </div>
                                <div class="summary-item">
                                    <div class="summary-label">多样性指数</div>
                                    <div class="summary-value">${stats.diversityIndex}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (mode === 'detailed') {
                    const sequences = dnaAnalysisData.sequencePatterns.sequences.slice(0, 10);
                    resultsContent.innerHTML = `
                        <div class="results-detailed">
                            <h4><i class="fas fa-dna"></i> DNA序列详情</h4>
                            <table class="results-table">
                                <thead>
                                    <tr>
                                        <th>期数</th>
                                        <th>DNA序列</th>
                                        <th>GC含量</th>
                                        <th>相似度</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sequences.map(s => `
                                        <tr>
                                            <td>${s.drawIndex}</td>
                                            <td>${s.sequence}</td>
                                            <td>${(s.gcContent * 100).toFixed(2)}%</td>
                                            <td>${(s.similarity * 100).toFixed(2)}%</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    `;
                } else if (mode === 'recommendations') {
                    const recommendations = [];
                    const gcContent = parseFloat(stats.avgGCContent);
                    const similarity = parseFloat(stats.avgSimilarity);
                    const fitness = parseFloat(stats.avgFitness);

                    if (gcContent > 0.45) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐GC富集号码</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于GC含量规律（${gcContent.toFixed(4)}），${gcContent > 0.5 ? 'GC含量较高' : 'GC含量适中'}，建议关注模4余${gcContent > 0.5 ? '2或3' : '1或2'}的号码组合。</p>
                            </div>
                        </div>`);
                    }

                    if (similarity > 0.4) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐相似序列号码</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于序列相似规律（${similarity.toFixed(4)}），${similarity > 0.6 ? '序列相似度较高' : '序列有一定相似性'}，建议参考历史相似序列进行选号。</p>
                            </div>
                        </div>`);
                    }

                    if (fitness > 0.5) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐高适应度号码</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于适应度进化规律（${fitness.toFixed(4)}），${fitness > 0.7 ? '适应度较高' : '适应度适中'}，建议关注高适应度号码组合。</p>
                            </div>
                        </div>`);
                    }

                    if (parseFloat(stats.diversityIndex) > 0.3) {
                        const diversity = parseFloat(stats.diversityIndex);
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐多样性号码组合</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于种群多样性规律（${diversity.toFixed(4)}），${diversity > 0.5 ? '多样性较高' : '多样性适中'}，建议选择分布较为分散的号码组合。</p>
                            </div>
                        </div>`);
                    }

                    if (stats.totalMutations > 0) {
                        const mutationRate = (stats.totalMutations / stats.totalSequences).toFixed(2);
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-check-circle" style="color: #27ae60;"></i>
                                <strong>推荐关注突变热点</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于基因突变规律（平均每期${mutationRate}次突变），建议关注近期突变频繁出现的号码位置。</p>
                            </div>
                        </div>`);
                    }

                    if (recommendations.length === 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                                <strong>基础推荐建议</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>当前分析结果特征不明显，建议采用均衡选号策略，关注各区间号码的均匀分布，并参考历史高频号码进行组合。</p>
                            </div>
                        </div>`);
                    }

                    resultsContent.innerHTML = recommendations.join('');
                }
            }

            static exportDNAReport() {
                if (!dnaAnalysisData) {
                    MessageSystem.showMessage('请先完成DNA分析', 'error');
                    return;
                }

                const stats = dnaAnalysisData.statistics;
                const mappingData = dnaAnalysisData.mappingPatterns;
                const sequencePatterns = dnaAnalysisData.sequencePatterns;

                const geneFrequency = {};
                sequencePatterns.sequences.forEach(seq => {
                    seq.redBalls.forEach(ball => {
                        const geneName = `基因${ball}`;
                        if (!geneFrequency[geneName]) {
                            geneFrequency[geneName] = 0;
                        }
                        geneFrequency[geneName]++;
                    });
                });

                const topGenes = Object.entries(geneFrequency)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);

                const avgLinkageDistance = mappingData.linkageMap.reduce((sum, link) => sum + link.distance, 0) / mappingData.linkageMap.length;
                const linkageStrength = 1 - (avgLinkageDistance / 33);
                const recombinationRate = mappingData.linkageMap.filter(link => link.distance > avgLinkageDistance).length / mappingData.linkageMap.length;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px;">
                        <div class="modal-header">
                            <h3><i class="fas fa-dna"></i> DNA分析报告</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="report-section">
                                <h4><i class="fas fa-info-circle"></i> 报告信息</h4>
                                <div class="report-info">
                                    <p><strong>生成时间：</strong>${new Date().toLocaleString()}</p>
                                    <p><strong>彩种：</strong>${currentLotteryType === 'ssq' ? '双色球' : '大乐透'}</p>
                                    <p><strong>分析期数：</strong>${dnaAnalysisData.period}期</p>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-dna"></i> DNA序列统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">序列总数</span>
                                        <span class="stat-value">${stats.totalSequences}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">平均GC含量</span>
                                        <span class="stat-value">${stats.avgGCContent}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">平均相似度</span>
                                        <span class="stat-value">${stats.avgSimilarity}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-chart-line"></i> 遗传进化统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">平均适应度</span>
                                        <span class="stat-value">${stats.avgFitness}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">最优适应度</span>
                                        <span class="stat-value">${dnaAnalysisData.evolutionPatterns.bestFitness.toFixed(4)}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-exchange-alt"></i> 基因突变统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">总突变次数</span>
                                        <span class="stat-value">${stats.totalMutations}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">突变率</span>
                                        <span class="stat-value">${(dnaAnalysisData.mutationPatterns.mutationRate * 100).toFixed(2)}%</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-globe"></i> 种群多样性统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">香农多样性指数</span>
                                        <span class="stat-value">${dnaAnalysisData.diversityPatterns.shannonIndex.toFixed(4)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">辛普森多样性指数</span>
                                        <span class="stat-value">${dnaAnalysisData.diversityPatterns.simpsonIndex.toFixed(4)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">多样性指数</span>
                                        <span class="stat-value">${stats.diversityIndex}</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-project-diagram"></i> DNA图谱统计</h4>
                                <div class="report-stats">
                                    <div class="stat-item highlight">
                                        <span class="stat-label">基因位点数</span>
                                        <span class="stat-value">${sequencePatterns.sequences.length * 6}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">连锁强度</span>
                                        <span class="stat-value">${linkageStrength.toFixed(4)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">重组率</span>
                                        <span class="stat-value">${(recombinationRate * 100).toFixed(2)}%</span>
                                    </div>
                                </div>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-star"></i> 高频基因（Top 10）</h4>
                                <table class="report-table">
                                    <thead>
                                        <tr>
                                            <th>排名</th>
                                            <th>基因名称</th>
                                            <th>基因值</th>
                                            <th>出现次数</th>
                                            <th>出现频率</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${topGenes.map(([geneName, count], index) => {
                                            const geneValue = parseInt(geneName.replace('基因', ''));
                                            const frequency = (count / sequencePatterns.sequences.length * 100).toFixed(2);
                                            return `
                                                <tr>
                                                    <td>${index + 1}</td>
                                                    <td>${geneName}</td>
                                                    <td>${geneValue}</td>
                                                    <td>${count}次</td>
                                                    <td>${frequency}%</td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>

                            <div class="report-section">
                                <h4><i class="fas fa-layer-group"></i> 染色体分布</h4>
                                <table class="report-table">
                                    <thead>
                                        <tr>
                                            <th>染色体</th>
                                            <th>基因数量</th>
                                            <th>核苷酸分布</th>
                                            <th>平均表达水平</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${Object.entries(mappingData.chromosomeMap).map(([chrom, chromData]) => {
                                            const nucDist = chromData.nucleotideDistribution;
                                            return `
                                                <tr>
                                                    <td>染色体${chrom}</td>
                                                    <td>${chromData.genes.length}</td>
                                                    <td>A:${(nucDist.A * 100).toFixed(1)}% T:${(nucDist.T * 100).toFixed(1)}% C:${(nucDist.C * 100).toFixed(1)}% G:${(nucDist.G * 100).toFixed(1)}%</td>
                                                    <td>${chromData.avgExpression.toFixed(4)}</td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                            <button class="btn btn-primary" onclick="EventDelegate.printDNAReport()">打印报告</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            static printDNAReport() {
                window.print();
            }

            static async performStatModelAnalysis() {
                const periodSelect = document.getElementById('statModelPeriodSelect');
                const analysisTypeSelect = document.getElementById('statModelAnalysisType');
                const confidenceSelect = document.getElementById('statModelConfidence');

                const period = periodSelect.value;
                const analysisType = analysisTypeSelect.value;
                const significanceLevel = parseFloat(confidenceSelect.value);

                MessageSystem.showMessage('正在加载分析数据...', 'info');

                try {
                    await dataManager.loadDataForCurrentLottery();
                    MessageSystem.showMessage('正在执行统计学模型分析...', 'info');

                    setTimeout(() => {
                        try {
                            const analysisData = this.calculateStatModelMetrics(period, analysisType, significanceLevel);
                            this.displayStatModelAnalysis(analysisData);
                            MessageSystem.showMessage('统计学模型分析完成', 'success');
                        } catch (error) {
                            console.error('统计学模型分析错误:', error);
                            MessageSystem.showMessage('统计学模型分析失败: ' + error.message, 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            static calculateStatModelMetrics(period, analysisType, significanceLevel) {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    throw new Error('没有可分析的数据，请先导入数据');
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                // 更新分析范围显示
                const statModelDataRangeInfo = document.getElementById('statModelDataRangeInfo');
                if (statModelDataRangeInfo && analysisData.length > 0) {
                    const startPeriod = analysisData[analysisData.length - 1].period;
                    const endPeriod = analysisData[0].period;
                    statModelDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;
                const totalDraws = analysisData.length;

                const results = {
                    period,
                    analysisType,
                    significanceLevel,
                    maxRedBall,
                    totalDraws,
                    hypothesis: null,
                    anova: null,
                    regression: null,
                    timeseries: null,
                    clustering: null
                };

                if (analysisType === 'all' || analysisType === 'hypothesis') {
                    results.hypothesis = this.performHypothesisTesting(redBalls, maxRedBall, totalDraws, significanceLevel);
                }

                if (analysisType === 'all' || analysisType === 'anova') {
                    results.anova = this.performANOVA(redBalls, maxRedBall, totalDraws, significanceLevel);
                }

                if (analysisType === 'all' || analysisType === 'regression') {
                    results.regression = this.performRegressionAnalysis(redBalls, maxRedBall, totalDraws);
                }

                if (analysisType === 'all' || analysisType === 'timeseries') {
                    results.timeseries = this.performTimeSeriesAnalysis(redBalls, maxRedBall, totalDraws);
                }

                if (analysisType === 'all' || analysisType === 'clustering') {
                    results.clustering = this.performClusteringAnalysis(redBalls, maxRedBall, totalDraws);
                }

                results.combinations = this.generateStatModelCombinations(results, maxRedBall);

                return results;
            }

            static performHypothesisTesting(redBalls, maxRedBall, totalDraws, significanceLevel) {
                const frequency = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    frequency[i] = 0;
                }

                redBalls.forEach(draw => {
                    draw.forEach(ball => {
                        frequency[ball]++;
                    });
                });

                const totalNumbers = totalDraws * 6;
                const expectedFrequency = totalNumbers / maxRedBall;

                let chiSquare = 0;
                const deviations = [];

                for (let i = 1; i <= maxRedBall; i++) {
                    const observed = frequency[i];
                    const deviation = observed - expectedFrequency;
                    const contribution = Math.pow(deviation, 2) / expectedFrequency;
                    chiSquare += contribution;

                    deviations.push({
                        number: i,
                        observed,
                        expected: expectedFrequency,
                        deviation,
                        contribution,
                        zScore: deviation / Math.sqrt(expectedFrequency * (1 - 1 / maxRedBall))
                    });
                }

                const degreesOfFreedom = maxRedBall - 1;
                const pValue = 1 - this.chiSquareCDF(chiSquare, degreesOfFreedom);

                const isUniform = pValue > significanceLevel;

                const abnormalNumbers = deviations.filter(d => Math.abs(d.zScore) > 1.96).sort((a, b) => Math.abs(b.zScore) - Math.abs(a.zScore));
                const hotNumbers = deviations.filter(d => d.zScore > 1.96).sort((a, b) => b.zScore - a.zScore).slice(0, 10);
                const coldNumbers = deviations.filter(d => d.zScore < -1.96).sort((a, b) => a.zScore - b.zScore).slice(0, 10);

                return {
                    chiSquare,
                    degreesOfFreedom,
                    pValue,
                    isUniform,
                    significanceLevel,
                    expectedFrequency,
                    deviations,
                    abnormalNumbers,
                    hotNumbers,
                    coldNumbers,
                    conclusion: isUniform ? '号码分布符合均匀分布假设' : '号码分布显著偏离均匀分布'
                };
            }

            static chiSquareCDF(x, df) {
                if (x <= 0) return 0;
                if (df === 1) {
                    return 2 * (1 - this.normalCDF(Math.sqrt(x)));
                }

                const a = df / 2;
                const c = x / 2;

                let sum = 0;
                let term = Math.exp(-c);
                sum = term;

                for (let i = 1; i < 100; i++) {
                    term *= c / i;
                    sum += term;
                    if (term < 1e-15) break;
                }

                return 1 - sum;
            }

            static normalCDF(x) {
                const a1 = 0.254829592;
                const a2 = -0.284496736;
                const a3 = 1.421413741;
                const a4 = -1.453152027;
                const a5 = 1.061405429;
                const p = 0.3275911;

                const sign = x < 0 ? -1 : 1;
                x = Math.abs(x) / Math.sqrt(2);

                const t = 1.0 / (1.0 + p * x);
                const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

                return 0.5 * (1.0 + sign * y);
            }

            static performANOVA(redBalls, maxRedBall, totalDraws, significanceLevel) {
                const numGroups = 5;
                const groupSize = Math.ceil(maxRedBall / numGroups);
                const groups = [];

                console.log('方差分析开始，maxRedBall:', maxRedBall, 'totalDraws:', totalDraws);

                for (let g = 0; g < numGroups; g++) {
                    const start = g * groupSize + 1;
                    const end = Math.min((g + 1) * groupSize, maxRedBall);
                    const groupNumbers = [];

                    for (let num = start; num <= end; num++) {
                        groupNumbers.push(num);
                    }

                    const groupFrequencies = [];
                    redBalls.forEach(draw => {
                        const count = draw.filter(ball => groupNumbers.includes(ball)).length;
                        groupFrequencies.push(count);
                    });

                    const numberFrequencies = {};
                    groupNumbers.forEach(num => {
                        numberFrequencies[num] = 0;
                    });

                    redBalls.forEach(draw => {
                        draw.forEach(ball => {
                            if (groupNumbers.includes(ball)) {
                                numberFrequencies[ball]++;
                            }
                        });
                    });

                    console.log(`区间${start}-${end}:`, {
                        groupNumbers,
                        numberFrequencies,
                        mean: groupFrequencies.reduce((a, b) => a + b, 0) / groupFrequencies.length
                    });

                    groups.push({
                        name: `区间${start}-${end}`,
                        numbers: groupNumbers,
                        frequencies: groupFrequencies,
                        numberFrequencies: numberFrequencies,
                        mean: groupFrequencies.reduce((a, b) => a + b, 0) / groupFrequencies.length,
                        variance: this.calculateVariance(groupFrequencies),
                        size: groupFrequencies.length
                    });
                }

                const grandMean = groups.reduce((sum, g) => sum + g.mean, 0) / groups.length;

                let ssBetween = 0;
                groups.forEach(g => {
                    ssBetween += g.size * Math.pow(g.mean - grandMean, 2);
                });

                let ssWithin = 0;
                groups.forEach(g => {
                    ssWithin += g.variance * (g.size - 1);
                });

                const dfBetween = groups.length - 1;
                const dfWithin = totalDraws - groups.length;

                const msBetween = ssBetween / dfBetween;
                const msWithin = ssWithin / dfWithin;

                const fStatistic = msWithin > 0 ? msBetween / msWithin : 0;
                const pValue = 1 - this.fCDF(fStatistic, dfBetween, dfWithin);

                const isSignificant = pValue < significanceLevel;

                return {
                    groups,
                    grandMean,
                    ssBetween,
                    ssWithin,
                    dfBetween,
                    dfWithin,
                    msBetween,
                    msWithin,
                    fStatistic,
                    pValue,
                    isSignificant,
                    significanceLevel,
                    conclusion: isSignificant ? '不同区间号码出现频率存在显著差异' : '不同区间号码出现频率无显著差异'
                };
            }

            static calculateVariance(data) {
                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                return data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (data.length - 1);
            }

            static fCDF(x, df1, df2) {
                if (x <= 0) return 0;

                const a = df1 / 2;
                const b = df2 / 2;
                const c = (df1 * x) / (df2 + df1 * x);

                let sum = 0;
                let term = Math.pow(c, a) * Math.pow(1 - c, b);
                sum = term;

                for (let i = 1; i < 100; i++) {
                    term *= (a + i - 1) * c / (b + i - 1) / (1 - c);
                    sum += term;
                    if (term < 1e-15) break;
                }

                return sum;
            }

            static performRegressionAnalysis(redBalls, maxRedBall, totalDraws) {
                const frequency = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    frequency[i] = 0;
                }

                redBalls.forEach((draw, index) => {
                    draw.forEach(ball => {
                        frequency[ball]++;
                    });
                });

                const dataPoints = [];
                for (let i = 1; i <= maxRedBall; i++) {
                    dataPoints.push({ x: i, y: frequency[i] });
                }

                const linearRegression = this.calculateLinearRegression(dataPoints);
                const polynomialRegression = this.calculatePolynomialRegression(dataPoints, 2);

                const linearR2 = this.calculateR2(dataPoints, linearRegression);
                const polynomialR2 = this.calculateR2(dataPoints, polynomialRegression);

                const trend = linearRegression.slope > 0.01 ? '上升' : (linearRegression.slope < -0.01 ? '下降' : '平稳');

                return {
                    dataPoints,
                    frequency,
                    linearRegression,
                    polynomialRegression,
                    linearR2,
                    polynomialR2,
                    trend,
                    conclusion: `号码频率趋势${trend}，线性回归R²=${linearR2.toFixed(4)}，多项式回归R²=${polynomialR2.toFixed(4)}`
                };
            }

            static calculateLinearRegression(data) {
                const n = data.length;
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

                data.forEach(point => {
                    sumX += point.x;
                    sumY += point.y;
                    sumXY += point.x * point.y;
                    sumX2 += point.x * point.x;
                });

                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                return {
                    slope,
                    intercept,
                    predict: (x) => slope * x + intercept
                };
            }

            static calculatePolynomialRegression(data, degree) {
                const n = data.length;
                const matrix = [];
                const vector = [];

                for (let i = 0; i <= degree; i++) {
                    const row = [];
                    for (let j = 0; j <= degree; j++) {
                        let sum = 0;
                        data.forEach(point => {
                            sum += Math.pow(point.x, i + j);
                        });
                        row.push(sum);
                    }
                    matrix.push(row);

                    let sum = 0;
                    data.forEach(point => {
                        sum += point.y * Math.pow(point.x, i);
                    });
                    vector.push(sum);
                }

                const coefficients = this.gaussianElimination(matrix, vector);

                return {
                    degree,
                    coefficients,
                    predict: (x) => {
                        let y = 0;
                        for (let i = 0; i <= degree; i++) {
                            y += coefficients[i] * Math.pow(x, i);
                        }
                        return y;
                    }
                };
            }

            static gaussianElimination(matrix, vector) {
                const n = matrix.length;
                const augmented = matrix.map((row, i) => [...row, vector[i]]);

                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                            maxRow = k;
                        }
                    }

                    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                    for (let k = i + 1; k < n; k++) {
                        const factor = augmented[k][i] / augmented[i][i];
                        for (let j = i; j <= n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }

                const solution = new Array(n).fill(0);
                for (let i = n - 1; i >= 0; i--) {
                    solution[i] = augmented[i][n];
                    for (let j = i + 1; j < n; j++) {
                        solution[i] -= augmented[i][j] * solution[j];
                    }
                    solution[i] /= augmented[i][i];
                }

                return solution;
            }

            static calculateR2(data, regression) {
                const yMean = data.reduce((sum, p) => sum + p.y, 0) / data.length;

                let ssTotal = 0;
                let ssResidual = 0;

                data.forEach(point => {
                    const predicted = regression.predict(point.x);
                    ssTotal += Math.pow(point.y - yMean, 2);
                    ssResidual += Math.pow(point.y - predicted, 2);
                });

                return 1 - ssResidual / ssTotal;
            }

            static performTimeSeriesAnalysis(redBalls, maxRedBall, totalDraws) {
                const frequency = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    frequency[i] = [];
                }

                redBalls.forEach((draw, index) => {
                    draw.forEach(ball => {
                        frequency[ball].push(index);
                    });
                });

                const timeSeriesData = [];
                for (let i = 1; i <= maxRedBall; i++) {
                    const appearances = frequency[i];
                    const count = appearances.length;
                    const intervals = this.calculateIntervals(appearances, totalDraws);
                    const avgInterval = intervals.length > 0 ? intervals.reduce((a, b) => a + b, 0) / intervals.length : 0;
                    const maxInterval = intervals.length > 0 ? Math.max(...intervals) : 0;
                    const minInterval = intervals.length > 0 ? Math.min(...intervals) : 0;
                    const lastAppearance = appearances.length > 0 ? appearances[appearances.length - 1] : -1;
                    const currentOmission = lastAppearance >= 0 ? totalDraws - 1 - lastAppearance : totalDraws;

                    timeSeriesData.push({
                        number: i,
                        count: count,
                        appearances: appearances,
                        intervals: intervals,
                        avgInterval: avgInterval,
                        maxInterval: maxInterval,
                        minInterval: minInterval,
                        lastAppearance: lastAppearance,
                        currentOmission: currentOmission,
                        frequency: count / totalDraws
                    });
                }

                const movingAverages = {};
                const windowSize = Math.min(10, Math.floor(totalDraws / 3));

                for (let i = 1; i <= maxRedBall; i++) {
                    movingAverages[i] = this.calculateMovingAverage(timeSeriesData[i - 1].appearances, windowSize);
                }

                const autocorrelations = this.calculateAutocorrelation(timeSeriesData);

                const trends = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    const appearances = timeSeriesData[i - 1].appearances;
                    const recent = appearances.slice(-Math.min(10, appearances.length));
                    const earlier = appearances.slice(0, Math.min(10, appearances.length));
                    const recentAvg = recent.length > 0 ? recent.reduce((a, b) => a + b, 0) / recent.length : 0;
                    const earlierAvg = earlier.length > 0 ? earlier.reduce((a, b) => a + b, 0) / earlier.length : 0;
                    trends[i] = recentAvg > earlierAvg ? '上升' : (recentAvg < earlierAvg ? '下降' : '平稳');
                }

                const periodicNumbers = timeSeriesData.filter(d => d.intervals.length > 1 && this.hasPeriodicity(d.intervals));

                const sortedByCount = [...timeSeriesData].sort((a, b) => b.count - a.count);
                const topNumbers = sortedByCount.slice(0, 10);
                const bottomNumbers = sortedByCount.slice(-10);

                const avgCount = timeSeriesData.reduce((sum, d) => sum + d.count, 0) / timeSeriesData.length;
                const avgInterval = timeSeriesData.reduce((sum, d) => sum + d.avgInterval, 0) / timeSeriesData.length;
                const avgOmission = timeSeriesData.reduce((sum, d) => sum + d.currentOmission, 0) / timeSeriesData.length;

                return {
                    timeSeriesData,
                    movingAverages,
                    windowSize,
                    autocorrelations,
                    trends,
                    periodicNumbers,
                    topNumbers,
                    bottomNumbers,
                    avgCount,
                    avgInterval,
                    avgOmission,
                    conclusion: `识别出${periodicNumbers.length}个具有周期性特征的号码，趋势分析显示${Object.values(trends).filter(t => t === '上升').length}个号码呈上升趋势，${Object.values(trends).filter(t => t === '下降').length}个号码呈下降趋势，${Object.values(trends).filter(t => t === '平稳').length}个号码呈平稳趋势。平均出现次数${avgCount.toFixed(2)}次，平均间隔${avgInterval.toFixed(2)}期，平均遗漏${avgOmission.toFixed(2)}期。`
                };
            }

            static calculateIntervals(appearances, totalDraws) {
                if (appearances.length < 2) return [];

                const intervals = [];
                for (let i = 1; i < appearances.length; i++) {
                    intervals.push(appearances[i] - appearances[i - 1]);
                }

                return intervals;
            }

            static calculateMovingAverage(data, windowSize) {
                if (data.length < windowSize) return [];

                const result = [];
                for (let i = windowSize - 1; i < data.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < windowSize; j++) {
                        sum += data[i - j];
                    }
                    result.push(sum / windowSize);
                }

                return result;
            }

            static calculateAutocorrelation(timeSeriesData) {
                const correlations = {};

                timeSeriesData.forEach(d => {
                    if (d.intervals.length < 4) {
                        correlations[d.number] = 0;
                        return;
                    }

                    const n = d.intervals.length;
                    const mean = d.intervals.reduce((a, b) => a + b, 0) / n;

                    let numerator = 0;
                    let denominator = 0;

                    for (let i = 0; i < n - 1; i++) {
                        numerator += (d.intervals[i] - mean) * (d.intervals[i + 1] - mean);
                    }

                    for (let i = 0; i < n; i++) {
                        denominator += Math.pow(d.intervals[i] - mean, 2);
                    }

                    correlations[d.number] = denominator > 0 ? numerator / denominator : 0;
                });

                return correlations;
            }

            static hasPeriodicity(intervals) {
                if (intervals.length < 3) return false;

                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / intervals.length;
                const stdDev = Math.sqrt(variance);

                const cv = stdDev / mean;

                return cv < 0.3;
            }

            static performClusteringAnalysis(redBalls, maxRedBall, totalDraws) {
                const frequency = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    frequency[i] = 0;
                }

                redBalls.forEach(draw => {
                    draw.forEach(ball => {
                        frequency[ball]++;
                    });
                });

                const features = [];
                for (let i = 1; i <= maxRedBall; i++) {
                    features.push({
                        number: i,
                        frequency: frequency[i],
                        normalizedFreq: frequency[i] / totalDraws,
                        position: i / maxRedBall
                    });
                }

                const k = 3;
                const clusters = this.kMeansClustering(features, k);

                const clusterStats = clusters.map((cluster, index) => {
                    const frequencies = cluster.map(f => f.frequency);
                    const numbers = cluster.map(f => f.number);

                    const sortedCluster = cluster.sort((a, b) => b.frequency - a.frequency);
                    const sortedNumbers = sortedCluster.map(f => f.number);

                    return {
                        clusterId: index,
                        numbers: sortedNumbers,
                        count: cluster.length,
                        avgFrequency: frequencies.reduce((a, b) => a + b, 0) / frequencies.length,
                        minFrequency: Math.min(...frequencies),
                        maxFrequency: Math.max(...frequencies),
                        stdFrequency: Math.sqrt(frequencies.reduce((sum, f) => sum + Math.pow(f - frequencies.reduce((a, b) => a + b, 0) / frequencies.length, 2), 0) / frequencies.length)
                    };
                });

                return {
                    features,
                    clusters,
                    clusterStats,
                    k,
                    conclusion: `将${maxRedBall}个号码分为${k}个簇，各簇平均频率分别为${clusterStats.map(c => c.avgFrequency.toFixed(2)).join('、')}`
                };
            }

            static kMeansClustering(features, k) {
                const n = features.length;

                let centroids = [];
                const indices = [];
                while (indices.length < k) {
                    const idx = Math.floor(Math.random() * n);
                    if (!indices.includes(idx)) {
                        indices.push(idx);
                        centroids.push([features[idx].frequency, features[idx].position]);
                    }
                }

                let assignments = new Array(n).fill(-1);
                let converged = false;
                const maxIterations = 100;
                let iteration = 0;

                while (!converged && iteration < maxIterations) {
                    const newAssignments = [];

                    features.forEach((feature, i) => {
                        let minDist = Infinity;
                        let cluster = 0;

                        for (let j = 0; j < k; j++) {
                            const dist = Math.sqrt(
                                Math.pow(feature.frequency - centroids[j][0], 2) +
                                Math.pow(feature.position - centroids[j][1], 2)
                            );

                            if (dist < minDist) {
                                minDist = dist;
                                cluster = j;
                            }
                        }

                        newAssignments.push(cluster);
                    });

                    converged = newAssignments.every((a, i) => a === assignments[i]);
                    assignments = newAssignments;

                    if (!converged) {
                        for (let j = 0; j < k; j++) {
                            const clusterFeatures = features.filter((_, i) => assignments[i] === j);

                            if (clusterFeatures.length > 0) {
                                centroids[j][0] = clusterFeatures.reduce((sum, f) => sum + f.frequency, 0) / clusterFeatures.length;
                                centroids[j][1] = clusterFeatures.reduce((sum, f) => sum + f.position, 0) / clusterFeatures.length;
                            }
                        }
                    }

                    iteration++;
                }

                const clusters = [];
                for (let j = 0; j < k; j++) {
                    clusters.push(features.filter((_, i) => assignments[i] === j));
                }

                return clusters;
            }

            static displayStatModelAnalysis(analysisData) {
                if (analysisData.hypothesis) {
                    this.displayHypothesisResults(analysisData.hypothesis);
                }

                if (analysisData.anova) {
                    this.displayAnovaResults(analysisData.anova);
                }

                if (analysisData.regression) {
                    this.displayRegressionResults(analysisData.regression);
                }

                if (analysisData.timeseries) {
                    this.displayTimeseriesResults(analysisData.timeseries);
                }

                if (analysisData.clustering) {
                    this.displayClusteringResults(analysisData.clustering);
                }

                this.displayStatModelRecommendations(analysisData);
            }

            static displayHypothesisResults(hypothesis) {
                const statsContainer = document.getElementById('statModelHypothesisStats');
                statsContainer.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">卡方统计量</div>
                        <div class="stat-value">${hypothesis.chiSquare.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">P值</div>
                        <div class="stat-value">${hypothesis.pValue.toFixed(6)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">显著性水平</div>
                        <div class="stat-value">${(hypothesis.significanceLevel * 100).toFixed(1)}%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">均匀分布</div>
                        <div class="stat-value ${hypothesis.isUniform ? 'success' : 'warning'}">${hypothesis.isUniform ? '是' : '否'}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">异常号码数</div>
                        <div class="stat-value">${hypothesis.abnormalNumbers.length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">热号数</div>
                        <div class="stat-value">${hypothesis.hotNumbers.length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">冷号数</div>
                        <div class="stat-value">${hypothesis.coldNumbers.length}</div>
                    </div>
                `;

                const conclusionContainer = document.getElementById('statModelHypothesisConclusion');
                conclusionContainer.innerHTML = `
                    <h4><i class="fas fa-check-circle"></i> 假设检验结论</h4>
                    <ul>
                        <li>${hypothesis.conclusion}</li>
                        <li>卡方检验结果：χ² = ${hypothesis.chiSquare.toFixed(4)}, df = ${hypothesis.degreesOfFreedom}, p = ${hypothesis.pValue.toFixed(6)}</li>
                        ${hypothesis.hotNumbers.length > 0 ? `<li>热号（Z > 1.96）：${hypothesis.hotNumbers.map(n => n.number).join('、')}</li>` : ''}
                        ${hypothesis.coldNumbers.length > 0 ? `<li>冷号（Z < -1.96）：${hypothesis.coldNumbers.map(n => n.number).join('、')}</li>` : ''}
                    </ul>
                `;

                const chartContainer = document.getElementById('statModelHypothesisChart');
                const deviations = hypothesis.deviations;

                const chart = echarts.init(chartContainer);
                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: '号码频率偏差分析',
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '15%'
                    },
                    xAxis: {
                        type: 'category',
                        data: deviations.map(d => d.number),
                        name: '号码',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '偏差值',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '偏差值',
                            type: 'bar',
                            data: deviations.map(d => ({
                                value: d.deviation,
                                itemStyle: {
                                    color: d.zScore > 1.96 ? '#e74c3c' : (d.zScore < -1.96 ? '#3498db' : '#95a5a6')
                                }
                            })),
                            itemStyle: {
                                borderRadius: [4, 4, 0, 0]
                            }
                        }
                    ]
                };

                chart.setOption(option);
            }

            static displayAnovaResults(anova) {
                const statsContainer = document.getElementById('statModelAnovaStats');
                statsContainer.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">F统计量</div>
                        <div class="stat-value">${anova.fStatistic.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">P值</div>
                        <div class="stat-value">${anova.pValue.toFixed(6)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">显著性水平</div>
                        <div class="stat-value">${(anova.significanceLevel * 100).toFixed(1)}%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">显著差异</div>
                        <div class="stat-value ${anova.isSignificant ? 'warning' : 'success'}">${anova.isSignificant ? '是' : '否'}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">组间均方</div>
                        <div class="stat-value">${anova.msBetween.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">组内均方</div>
                        <div class="stat-value">${anova.msWithin.toFixed(4)}</div>
                    </div>
                `;

                const conclusionContainer = document.getElementById('statModelAnovaConclusion');
                conclusionContainer.innerHTML = `
                    <h4><i class="fas fa-check-circle"></i> 方差分析结论</h4>
                    <ul>
                        <li>${anova.conclusion}</li>
                        <li>F检验结果：F = ${anova.fStatistic.toFixed(4)}, p = ${anova.pValue.toFixed(6)}</li>
                        ${anova.groups.map(g => `<li>${g.name}：均值=${g.mean.toFixed(2)}, 方差=${g.variance.toFixed(2)}</li>`).join('')}
                    </ul>
                `;

                const chartContainer = document.getElementById('statModelAnovaChart');
                const chart = echarts.init(chartContainer);
                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: '区间频率对比分析',
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: anova.groups.map(g => g.name),
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        data: Array.from({ length: anova.totalDraws }, (_, i) => i + 1),
                        name: '期数',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '出现次数',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: anova.groups.map((g, index) => ({
                        name: g.name,
                        type: 'line',
                        smooth: true,
                        data: g.frequencies,
                        itemStyle: {
                            color: ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'][index]
                        }
                    }))
                };

                chart.setOption(option);
            }

            static displayRegressionResults(regression) {
                const statsContainer = document.getElementById('statModelRegressionStats');
                statsContainer.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">线性斜率</div>
                        <div class="stat-value">${regression.linearRegression.slope.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">线性截距</div>
                        <div class="stat-value">${regression.linearRegression.intercept.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">线性R²</div>
                        <div class="stat-value">${regression.linearR2.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">多项式R²</div>
                        <div class="stat-value">${regression.polynomialR2.toFixed(4)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">趋势</div>
                        <div class="stat-value">${regression.trend}</div>
                    </div>
                `;

                const conclusionContainer = document.getElementById('statModelRegressionConclusion');
                conclusionContainer.innerHTML = `
                    <h4><i class="fas fa-check-circle"></i> 回归分析结论</h4>
                    <ul>
                        <li>${regression.conclusion}</li>
                        <li>线性回归方程：y = ${regression.linearRegression.slope.toFixed(4)}x + ${regression.linearRegression.intercept.toFixed(4)}</li>
                        <li>多项式回归方程：y = ${regression.polynomialRegression.coefficients.map((c, i) => `${c.toFixed(4)}x${i > 0 ? `^${i}` : ''}`).join(' + ')}</li>
                    </ul>
                `;

                const chartContainer = document.getElementById('statModelRegressionChart');
                const chart = echarts.init(chartContainer);
                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: '号码频率回归分析',
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        }
                    },
                    legend: {
                        data: ['实际频率', '线性回归', '多项式回归'],
                        top: '10%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        data: regression.dataPoints.map(p => p.x),
                        name: '号码',
                        nameTextStyle: {
                            fontSize: 12
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '频率',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: [
                        {
                            name: '实际频率',
                            type: 'scatter',
                            data: regression.dataPoints.map(p => [p.x, p.y]),
                            itemStyle: {
                                color: '#e74c3c'
                            }
                        },
                        {
                            name: '线性回归',
                            type: 'line',
                            smooth: true,
                            data: regression.dataPoints.map(p => [p.x, regression.linearRegression.predict(p.x)]),
                            itemStyle: {
                                color: '#3498db'
                            },
                            lineStyle: {
                                width: 2
                            }
                        },
                        {
                            name: '多项式回归',
                            type: 'line',
                            smooth: true,
                            data: regression.dataPoints.map(p => [p.x, regression.polynomialRegression.predict(p.x)]),
                            itemStyle: {
                                color: '#2ecc71'
                            },
                            lineStyle: {
                                width: 2
                            }
                        }
                    ]
                };

                chart.setOption(option);
            }

            static displayTimeseriesResults(timeseries) {
                const statsContainer = document.getElementById('statModelTimeseriesStats');
                statsContainer.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">移动平均窗口</div>
                        <div class="stat-value">${timeseries.windowSize}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">周期性号码数</div>
                        <div class="stat-value">${timeseries.periodicNumbers.length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">上升趋势号码</div>
                        <div class="stat-value">${Object.values(timeseries.trends).filter(t => t === '上升').length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">下降趋势号码</div>
                        <div class="stat-value">${Object.values(timeseries.trends).filter(t => t === '下降').length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">平稳趋势号码</div>
                        <div class="stat-value">${Object.values(timeseries.trends).filter(t => t === '平稳').length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">平均出现次数</div>
                        <div class="stat-value">${timeseries.avgCount.toFixed(2)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">平均间隔期数</div>
                        <div class="stat-value">${timeseries.avgInterval.toFixed(2)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">平均遗漏期数</div>
                        <div class="stat-value">${timeseries.avgOmission.toFixed(2)}</div>
                    </div>
                `;

                const conclusionContainer = document.getElementById('statModelTimeseriesConclusion');
                conclusionContainer.innerHTML = `
                    <h4><i class="fas fa-check-circle"></i> 时间序列分析结论</h4>
                    <ul>
                        <li><strong>整体趋势：</strong>${timeseries.conclusion}</li>
                        ${timeseries.periodicNumbers.length > 0 ? `<li><strong>周期性号码：</strong>${timeseries.periodicNumbers.map(n => n.number).join('、')}，这些号码表现出明显的周期性特征，间隔相对稳定。</li>` : ''}
                        <li><strong>高频号码（前10）：</strong>${timeseries.topNumbers.map(n => `<strong>${n.number.toString().padStart(2, '0')}</strong>(${n.count}次)`).join('、')}，出现次数明显高于平均值${timeseries.avgCount.toFixed(2)}次。</li>
                        <li><strong>低频号码（后10）：</strong>${timeseries.bottomNumbers.map(n => `<strong>${n.number.toString().padStart(2, '0')}</strong>(${n.count}次)`).join('、')}，出现次数明显低于平均值${timeseries.avgCount.toFixed(2)}次。</li>
                        <li><strong>趋势分析：</strong>上升趋势号码${Object.values(timeseries.trends).filter(t => t === '上升').length}个，下降趋势号码${Object.values(timeseries.trends).filter(t => t === '下降').length}个，平稳趋势号码${Object.values(timeseries.trends).filter(t => t === '平稳').length}个。</li>
                        <li><strong>间隔分析：</strong>号码平均间隔${timeseries.avgInterval.toFixed(2)}期，最大间隔${Math.max(...timeseries.timeSeriesData.map(d => d.maxInterval))}期，最小间隔${Math.min(...timeseries.timeSeriesData.map(d => d.minInterval))}期。</li>
                        <li><strong>遗漏分析：</strong>号码平均遗漏${timeseries.avgOmission.toFixed(2)}期，当前最大遗漏${Math.max(...timeseries.timeSeriesData.map(d => d.currentOmission))}期（号码${timeseries.timeSeriesData.find(d => d.currentOmission === Math.max(...timeseries.timeSeriesData.map(d => d.currentOmission))).number}），当前最小遗漏${Math.min(...timeseries.timeSeriesData.map(d => d.currentOmission))}期。</li>
                        <li><strong>分析说明：</strong>时间序列分析通过统计号码的出现时间、间隔、遗漏等指标，识别号码的周期性特征和趋势变化。所有结论均基于历史统计数据，反映号码在指定期数内的统计特征，不作为预测依据。</li>
                    </ul>
                `;

                const chartContainer = document.getElementById('statModelTimeseriesChart');
                const chart = echarts.init(chartContainer);
                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: '号码出现时间序列',
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        },
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const dataIndex = param.dataIndex;
                            const data = timeseries.timeSeriesData[dataIndex];
                            const trend = timeseries.trends[data.number];
                            const trendText = trend === '上升' ? '↑ 上升' : (trend === '下降' ? '↓ 下降' : '→ 平稳');
                            const trendColor = trend === '上升' ? '#e74c3c' : (trend === '下降' ? '#3498db' : '#95a5a6');
                            const isTop = timeseries.topNumbers.some(n => n.number === data.number);
                            const isBottom = timeseries.bottomNumbers.some(n => n.number === data.number);
                            const isPeriodic = timeseries.periodicNumbers.some(n => n.number === data.number);

                            let html = `<div style="font-weight:bold;margin-bottom:5px;">号码 ${data.number.toString().padStart(2, '0')}</div>`;
                            html += `<div>出现次数：<span style="color:#f39c12;font-weight:bold;">${data.count}</span>次</div>`;
                            html += `<div>平均间隔：<span style="color:#2ecc71;">${data.avgInterval.toFixed(2)}</span>期</div>`;
                            html += `<div>最大间隔：<span style="color:#e74c3c;">${data.maxInterval}</span>期</div>`;
                            html += `<div>最小间隔：<span style="color:#3498db;">${data.minInterval}</span>期</div>`;
                            html += `<div>当前遗漏：<span style="color:#9b59b6;">${data.currentOmission}</span>期</div>`;
                            html += `<div>趋势：<span style="color:${trendColor};font-weight:bold;">${trendText}</span></div>`;
                            if (isTop) html += `<div style="color:#e74c3c;font-weight:bold;">★ 高频号码</div>`;
                            if (isBottom) html += `<div style="color:#3498db;font-weight:bold;">★ 低频号码</div>`;
                            if (isPeriodic) html += `<div style="color:#2ecc71;font-weight:bold;">★ 周期性号码</div>`;
                            return html;
                        }
                    },
                    legend: {
                        data: ['出现次数', '平均间隔', '当前遗漏'],
                        top: '12%',
                        textStyle: {
                            fontSize: 12
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '20%'
                    },
                    xAxis: {
                        type: 'category',
                        data: timeseries.timeSeriesData.map(d => d.number),
                        name: '号码',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        axisLabel: {
                            rotate: 45,
                            fontSize: 10
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '出现次数',
                            nameTextStyle: {
                                fontSize: 12
                            },
                            splitLine: {
                                lineStyle: {
                                    type: 'dashed'
                                }
                            },
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '间隔/遗漏',
                            nameTextStyle: {
                                fontSize: 12
                            },
                            splitLine: {
                                show: false
                            },
                            position: 'right'
                        }
                    ],
                    series: [
                        {
                            name: '出现次数',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: timeseries.timeSeriesData.map(d => d.count),
                            itemStyle: {
                                color: (params) => {
                                    const data = timeseries.timeSeriesData[params.dataIndex];
                                    const isTop = timeseries.topNumbers.some(n => n.number === data.number);
                                    const isBottom = timeseries.bottomNumbers.some(n => n.number === data.number);
                                    const isPeriodic = timeseries.periodicNumbers.some(n => n.number === data.number);

                                    if (isPeriodic) return '#2ecc71';
                                    if (isTop) return '#e74c3c';
                                    if (isBottom) return '#3498db';

                                    const trend = timeseries.trends[data.number];
                                    if (trend === '上升') return '#f39c12';
                                    if (trend === '下降') return '#9b59b6';
                                    return '#95a5a6';
                                },
                                borderRadius: [4, 4, 0, 0]
                            },
                            markLine: {
                                data: [
                                    { type: 'average', name: '平均值' }
                                ],
                                lineStyle: {
                                    color: '#e74c3c',
                                    type: 'dashed'
                                },
                                label: {
                                    formatter: '平均值: {c}'
                                }
                            }
                        },
                        {
                            name: '平均间隔',
                            type: 'line',
                            yAxisIndex: 1,
                            data: timeseries.timeSeriesData.map(d => d.avgInterval),
                            itemStyle: {
                                color: '#2ecc71'
                            },
                            lineStyle: {
                                width: 2
                            },
                            symbol: 'circle',
                            symbolSize: 4
                        },
                        {
                            name: '当前遗漏',
                            type: 'line',
                            yAxisIndex: 1,
                            data: timeseries.timeSeriesData.map(d => d.currentOmission),
                            itemStyle: {
                                color: '#9b59b6'
                            },
                            lineStyle: {
                                width: 2
                            },
                            symbol: 'circle',
                            symbolSize: 4
                        }
                    ]
                };

                chart.setOption(option);
            }

            static displayClusteringResults(clustering) {
                const statsContainer = document.getElementById('statModelClusteringStats');
                statsContainer.innerHTML = clustering.clusterStats.map(stat => `
                    <div class="stat-card">
                        <div class="stat-label">簇${stat.clusterId + 1}</div>
                        <div class="stat-value">${stat.count}个</div>
                    </div>
                `).join('');

                const conclusionContainer = document.getElementById('statModelClusteringConclusion');
                conclusionContainer.innerHTML = `
                    <h4><i class="fas fa-check-circle"></i> 聚类分析结论</h4>
                    <ul>
                        <li>${clustering.conclusion}</li>
                        ${clustering.clusterStats.map(stat => `<li>簇${stat.clusterId + 1}：${stat.numbers.join('、')}（平均频率=${stat.avgFrequency.toFixed(2)}）</li>`).join('')}
                    </ul>
                `;

                const chartContainer = document.getElementById('statModelClusteringChart');
                const chart = echarts.init(chartContainer);
                const option = {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    title: {
                        text: '号码聚类分析',
                        left: 'center',
                        top: '5%',
                        textStyle: {
                            fontSize: 18,
                            fontWeight: 'bold',
                            color: '#2c3e50'
                        }
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(44, 62, 80, 0.95)',
                        borderColor: '#3498db',
                        borderWidth: 1,
                        textStyle: {
                            color: '#fff',
                            fontSize: 12
                        },
                        formatter: (params) => {
                            const f = params.data[2];
                            return `号码${f.number}<br/>频率：${f.frequency.toFixed(2)}<br/>位置：${f.position.toFixed(2)}`;
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true,
                        top: '15%'
                    },
                    xAxis: {
                        type: 'value',
                        name: '位置',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    yAxis: {
                        type: 'value',
                        name: '频率',
                        nameTextStyle: {
                            fontSize: 12
                        },
                        splitLine: {
                            lineStyle: {
                                type: 'dashed'
                            }
                        }
                    },
                    series: clustering.clusters.map((cluster, index) => ({
                        name: `簇${index + 1}`,
                        type: 'scatter',
                        data: cluster.map(f => [f.position, f.frequency, f]),
                        itemStyle: {
                            color: ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'][index]
                        },
                        symbolSize: (data) => Math.max(10, data[1] * 2)
                    }))
                };

                chart.setOption(option);
            }

            static displayStatModelRecommendations(analysisData) {
                const recommendationContainer = document.getElementById('statModelRecommendation');

                const recommendations = [];

                if (analysisData.combinations && analysisData.combinations.length > 0) {
                    analysisData.combinations.forEach((combo, index) => {
                        const iconMap = {
                            '热号组合': { icon: 'fa-fire', color: '#e74c3c' },
                            '周期性组合': { icon: 'fa-sync', color: '#2ecc71' },
                            '高频组合': { icon: 'fa-chart-line', color: '#9b59b6' },
                            '趋势组合': { icon: 'fa-arrow-trend-up', color: '#e67e22' },
                            '区间组合': { icon: 'fa-layer-group', color: '#f39c12' },
                            '高频簇组合': { icon: 'fa-object-group', color: '#1abc9c' },
                            '随机组合': { icon: 'fa-dice', color: '#95a5a6' }
                        };

                        const iconInfo = iconMap[combo.type] || { icon: 'fa-star', color: '#3498db' };

                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas ${iconInfo.icon}" style="color: ${iconInfo.color};"></i>
                                <strong>推荐${combo.type}</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>${combo.description}</p>
                                <div class="number-combination">
                                    ${combo.numbers.map(n => `<span class="number-ball red">${n.toString().padStart(2, '0')}</span>`).join('')}
                                </div>
                            </div>
                        </div>`);
                    });
                } else {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>基础推荐建议</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>当前统计学分析结果特征不明显，建议采用均衡选号策略，关注各区间号码的均匀分布，并参考历史高频号码进行组合。</p>
                        </div>
                    </div>`);
                }

                recommendationContainer.innerHTML = recommendations.join('');
            }

            static generateCombinationFromNumbers(numbers, maxRedBall) {
                const combination = [];
                const available = [...numbers];

                while (combination.length < 6 && available.length > 0) {
                    const index = Math.floor(Math.random() * available.length);
                    combination.push(available.splice(index, 1)[0]);
                }

                while (combination.length < 6) {
                    const num = Math.floor(Math.random() * maxRedBall) + 1;
                    if (!combination.includes(num)) {
                        combination.push(num);
                    }
                }

                combination.sort((a, b) => a - b);

                return `<div class="number-row">
                    ${combination.map(num => `<span class="number-ball red">${num.toString().padStart(2, '0')}</span>`).join('')}
                </div>`;
            }

            static generateStatModelCombinations(results, maxRedBall) {
                const combinations = [];

                if (results.hypothesis && results.hypothesis.hotNumbers.length >= 6) {
                    const hotNums = results.hypothesis.hotNumbers.slice(0, 6).map(n => n.number);
                    combinations.push({
                        type: '热号组合',
                        numbers: hotNums.sort((a, b) => a - b),
                        description: '基于假设检验的显著热号'
                    });
                }

                if (results.timeseries) {
                    if (results.timeseries.periodicNumbers && results.timeseries.periodicNumbers.length >= 6) {
                        const periodicNums = results.timeseries.periodicNumbers.slice(0, 6).map(n => n.number);
                        combinations.push({
                            type: '周期性组合',
                            numbers: periodicNums.sort((a, b) => a - b),
                            description: '基于时间序列分析的周期性号码'
                        });
                    }

                    if (results.timeseries.topNumbers && results.timeseries.topNumbers.length >= 6) {
                        const highFreqNums = results.timeseries.topNumbers.slice(0, 6).map(n => n.number);
                        combinations.push({
                            type: '高频组合',
                            numbers: highFreqNums.sort((a, b) => a - b),
                            description: '基于时间序列分析的高频号码'
                        });
                    }
                }

                if (results.regression) {
                    const trend = results.regression.trend;
                    const frequency = results.regression.frequency || {};
                    let trendNums = [];

                    console.log('回归分析趋势:', trend);
                    console.log('回归分析频率对象:', frequency);

                    const sortedByFrequency = Object.entries(frequency)
                        .sort((a, b) => b[1] - a[1])
                        .map(entry => parseInt(entry[0]));

                    console.log('按频率排序后的所有号码:', sortedByFrequency);

                    if (trend === '上升') {
                        const largeNumbers = sortedByFrequency.filter(n => n > maxRedBall / 2);
                        console.log('大号码区:', largeNumbers);
                        trendNums = largeNumbers.slice(0, 6);
                        if (trendNums.length < 6) {
                            const remaining = sortedByFrequency.filter(n => !trendNums.includes(n)).slice(0, 6 - trendNums.length);
                            trendNums = [...trendNums, ...remaining];
                        }
                    } else if (trend === '下降') {
                        const smallNumbers = sortedByFrequency.filter(n => n <= maxRedBall / 2);
                        console.log('小号码区:', smallNumbers);
                        trendNums = smallNumbers.slice(0, 6);
                        if (trendNums.length < 6) {
                            const remaining = sortedByFrequency.filter(n => !trendNums.includes(n)).slice(0, 6 - trendNums.length);
                            trendNums = [...trendNums, ...remaining];
                        }
                    } else {
                        const mid = Math.floor(maxRedBall / 2);
                        const midNumbers = sortedByFrequency.filter(n => n >= mid - 5 && n <= mid + 5);
                        console.log('中号码区:', midNumbers);
                        trendNums = midNumbers.slice(0, 6);
                        if (trendNums.length < 6) {
                            const remaining = sortedByFrequency.filter(n => !trendNums.includes(n)).slice(0, 6 - trendNums.length);
                            trendNums = [...trendNums, ...remaining];
                        }
                    }

                    console.log('回归分析最终选择的号码:', trendNums);

                    combinations.push({
                        type: '趋势组合',
                        numbers: trendNums.sort((a, b) => a - b),
                        description: `基于回归分析的${trend}趋势号码`
                    });
                }

                if (results.anova && results.anova.groups.length > 0) {
                    const bestGroup = results.anova.groups.reduce((best, group) => 
                        group.mean > best.mean ? group : best
                    );

                    console.log('方差分析最佳区间:', bestGroup.name);
                    console.log('区间号码:', bestGroup.numbers);
                    console.log('号码频率:', bestGroup.numberFrequencies);
                    console.log('区间均值:', bestGroup.mean);

                    if (bestGroup.numbers.length >= 6) {
                        const frequencyEntries = Object.entries(bestGroup.numberFrequencies || {});
                        console.log('频率条目:', frequencyEntries);

                        const sortedEntries = [...frequencyEntries].sort((a, b) => {
                            console.log(`比较 ${a[0]}(${a[1]}) 和 ${b[0]}(${b[1]}):`, b[1] - a[1]);
                            if (b[1] !== a[1]) {
                                return b[1] - a[1];
                            }
                            const randomVal = Math.random() - 0.5;
                            console.log(`频率相同，随机值: ${randomVal}`);
                            return randomVal;
                        });

                        console.log('排序后的条目:', sortedEntries);

                        let sortedNumbers = sortedEntries.map(entry => parseInt(entry[0]));
                        console.log('按频率排序后的号码:', sortedNumbers);
                        const anovaNums = sortedNumbers.slice(0, 6);
                        console.log('最终选择的号码:', anovaNums);
                        combinations.push({
                            type: '区间组合',
                            numbers: anovaNums.sort((a, b) => a - b),
                            description: `基于方差分析的高频区间${bestGroup.name}号码`
                        });
                    }
                }

                if (results.clustering && results.clustering.clusterStats.length > 0) {
                    console.log('聚类分析簇统计:', results.clustering.clusterStats);
                    const highFreqCluster = results.clustering.clusterStats.reduce((max, cluster) => 
                        cluster.avgFrequency > max.avgFrequency ? cluster : max
                    );
                    console.log('高频簇:', highFreqCluster);
                    if (highFreqCluster.numbers.length >= 6) {
                        const clusterNums = highFreqCluster.numbers.slice(0, 6);
                        console.log('聚类分析最终选择的号码:', clusterNums);
                        combinations.push({
                            type: '高频簇组合',
                            numbers: clusterNums.sort((a, b) => a - b),
                            description: '基于聚类分析的高频簇号码'
                        });
                    }
                }

                while (combinations.length < 5) {
                    const combination = [];
                    while (combination.length < 6) {
                        const num = Math.floor(Math.random() * maxRedBall) + 1;
                        if (!combination.includes(num)) {
                            combination.push(num);
                        }
                    }
                    combination.sort((a, b) => a - b);
                    combinations.push({
                        type: '随机组合',
                        numbers: combination,
                        description: '基于统计学概率的随机组合'
                    });
                }

                return combinations;
            }

            static async performRecoveryAnalysis() {
                const periodSelect = document.getElementById('recoveryPeriodSelect');
                const period = periodSelect.value;

                MessageSystem.showMessage('正在加载分析数据...', 'info');

                try {
                    await dataManager.loadDataForCurrentLottery();
                    MessageSystem.showMessage('正在分析回补数据...', 'info');

                    setTimeout(() => {
                        try {
                            const analysisData = this.calculateRecoveryMetrics(period);
                            this.displayRecoveryAnalysis(analysisData);
                            MessageSystem.showMessage('回补分析完成', 'success');
                        } catch (error) {
                            console.error('回补分析错误:', error);
                            MessageSystem.showMessage('回补分析失败: ' + error.message, 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            static calculateRecoveryMetrics(period) {
                console.log('回补分析 - 当前数据库数据:', currentDatabaseData);
                console.log('回补分析 - 彩票类型:', currentLotteryType);

                const draws = currentDatabaseData.draws || [];

                console.log('回补分析 - 抽取期数数据:', draws.length);

                if (draws.length === 0) {
                    throw new Error('没有可分析的数据，请先导入数据');
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                console.log('回补分析 - 分析数据:', analysisData.length);
                console.log('回补分析 - 第一条数据示例:', analysisData[0]);

                // 更新分析范围显示
                const recoveryDataRangeInfo = document.getElementById('recoveryDataRangeInfo');
                if (recoveryDataRangeInfo && analysisData.length > 0) {
                    const startPeriod = analysisData[0].period;
                    const endPeriod = analysisData[analysisData.length - 1].period;
                    recoveryDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;

                console.log('回补分析 - 红球数据:', redBalls.length);
                console.log('回补分析 - 最大红球:', maxRedBall);

                const advancedAnalysis = this.performAdvancedRecoveryAnalysis(redBalls, maxRedBall);

                const recoveryCycle = this.calculateRecoveryCycle(redBalls, maxRedBall);
                const recoveryIntensity = this.calculateRecoveryIntensity(redBalls, maxRedBall);
                const recoveryTiming = this.calculateRecoveryTiming(redBalls, maxRedBall);
                const recoveryPattern = this.identifyRecoveryPatterns(redBalls, maxRedBall);

                return {
                    recoveryCycle,
                    recoveryIntensity,
                    recoveryTiming,
                    recoveryPattern,
                    advancedAnalysis,
                    period: period === 'all' ? analysisData.length : period
                };
            }

            static performAdvancedRecoveryAnalysis(redBalls, maxRedBall) {
                console.log('=== 开始执行回补分析高级分析 ===');
                console.log('数据期数:', redBalls.length);

                const advancedData = {
                    recoveryTrendAnalysis: {},
                    recoveryClusterAnalysis: {},
                    recoveryPredictionAnalysis: {},
                    recoveryStabilityAnalysis: {},
                    recoveryCorrelationAnalysis: {}
                };

                const totalDraws = redBalls.length;

                advancedData.recoveryTrendAnalysis = this.analyzeRecoveryTrend(redBalls, maxRedBall);
                advancedData.recoveryClusterAnalysis = this.analyzeRecoveryClusters(redBalls, maxRedBall);
                advancedData.recoveryStabilityAnalysis = this.analyzeRecoveryStability(redBalls, maxRedBall);
                advancedData.recoveryCorrelationAnalysis = this.analyzeRecoveryCorrelation(redBalls, maxRedBall);
                advancedData.recoveryPredictionAnalysis = this.analyzeRecoveryPredictions(redBalls, maxRedBall, advancedData);

                console.log('回补分析高级分析完成');

                return advancedData;
            }

            static analyzeRecoveryTrend(redBalls, maxRedBall) {
                const trendData = {
                    shortTermTrend: {},
                    mediumTermTrend: {},
                    longTermTrend: {},
                    trendDirection: {}
                };

                const shortTerm = redBalls.slice(-10);
                const mediumTerm = redBalls.slice(-30);
                const longTerm = redBalls;

                for (let num = 1; num <= maxRedBall; num++) {
                    const numStr = num.toString().padStart(2, '0');

                    const shortTermCount = shortTerm.filter(balls => balls.includes(num)).length;
                    const mediumTermCount = mediumTerm.filter(balls => balls.includes(num)).length;
                    const longTermCount = longTerm.filter(balls => balls.includes(num)).length;

                    const shortTermAvg = shortTermCount / shortTerm.length;
                    const mediumTermAvg = mediumTermCount / mediumTerm.length;
                    const longTermAvg = longTermCount / longTerm.length;

                    trendData.shortTermTrend[numStr] = shortTermAvg;
                    trendData.mediumTermTrend[numStr] = mediumTermAvg;
                    trendData.longTermTrend[numStr] = longTermAvg;

                    if (shortTermAvg > mediumTermAvg * 1.1) {
                        trendData.trendDirection[numStr] = 'rising';
                    } else if (shortTermAvg < mediumTermAvg * 0.9) {
                        trendData.trendDirection[numStr] = 'falling';
                    } else {
                        trendData.trendDirection[numStr] = 'stable';
                    }
                }

                return trendData;
            }

            static analyzeRecoveryClusters(redBalls, maxRedBall) {
                const clusterData = {
                    hotCluster: [],
                    warmCluster: [],
                    coldCluster: [],
                    clusterTransitions: {}
                };

                const numberAppearances = {};
                for (let num = 1; num <= maxRedBall; num++) {
                    const numStr = num.toString().padStart(2, '0');
                    numberAppearances[numStr] = redBalls.filter(balls => balls.includes(num)).length;
                }

                const sortedNumbers = Object.entries(numberAppearances)
                    .map(([num, count]) => ({ num, count }))
                    .sort((a, b) => b.count - a.count);

                const avgAppearance = sortedNumbers.reduce((sum, item) => sum + item.count, 0) / sortedNumbers.length;

                sortedNumbers.forEach(item => {
                    if (item.count > avgAppearance * 1.3) {
                        clusterData.hotCluster.push(item.num);
                    } else if (item.count > avgAppearance * 0.9) {
                        clusterData.warmCluster.push(item.num);
                    } else {
                        clusterData.coldCluster.push(item.num);
                    }
                });

                for (let i = 0; i < redBalls.length - 1; i++) {
                    const currentBalls = redBalls[i];
                    const nextBalls = redBalls[i + 1];

                    const currentHot = currentBalls.filter(num => clusterData.hotCluster.includes(num.toString().padStart(2, '0'))).length;
                    const nextHot = nextBalls.filter(num => clusterData.hotCluster.includes(num.toString().padStart(2, '0'))).length;

                    const transitionKey = `${currentHot}-${nextHot}`;
                    clusterData.clusterTransitions[transitionKey] = (clusterData.clusterTransitions[transitionKey] || 0) + 1;
                }

                return clusterData;
            }

            static analyzeRecoveryStability(redBalls, maxRedBall) {
                const stabilityData = {
                    numberStability: {},
                    overallStability: 0,
                    stableNumbers: [],
                    unstableNumbers: []
                };

                for (let num = 1; num <= maxRedBall; num++) {
                    const numStr = num.toString().padStart(2, '0');
                    const appearances = [];

                    redBalls.forEach((balls, index) => {
                        if (balls.includes(num)) {
                            appearances.push(index);
                        }
                    });

                    if (appearances.length < 2) {
                        stabilityData.numberStability[numStr] = 0;
                        stabilityData.unstableNumbers.push(numStr);
                        continue;
                    }

                    const intervals = [];
                    for (let i = 1; i < appearances.length; i++) {
                        intervals.push(appearances[i] - appearances[i - 1]);
                    }

                    const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
                    const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;
                    const stdDev = Math.sqrt(variance);

                    const stabilityScore = 1 - (stdDev / avgInterval);
                    stabilityData.numberStability[numStr] = Math.max(0, Math.min(1, stabilityScore));

                    if (stabilityScore > 0.6) {
                        stabilityData.stableNumbers.push(numStr);
                    } else if (stabilityScore < 0.4) {
                        stabilityData.unstableNumbers.push(numStr);
                    }
                }

                const avgStability = Object.values(stabilityData.numberStability).reduce((sum, val) => sum + val, 0) / Object.keys(stabilityData.numberStability).length;
                stabilityData.overallStability = avgStability;

                return stabilityData;
            }

            static analyzeRecoveryCorrelation(redBalls, maxRedBall) {
                const correlationData = {
                    positionCorrelation: {},
                    intervalCorrelation: {},
                    correlationStrength: {}
                };

                for (let pos = 0; pos < 6; pos++) {
                    const positionNumbers = redBalls.map(balls => balls[pos]);
                    const positionData = {};

                    for (let num = 1; num <= maxRedBall; num++) {
                        const numStr = num.toString().padStart(2, '0');
                        const appearances = positionNumbers.filter(n => n === num).length;
                        positionData[numStr] = appearances;
                    }

                    correlationData.positionCorrelation[pos] = positionData;
                }

                for (let i = 0; i < redBalls.length - 1; i++) {
                    const currentBalls = redBalls[i];
                    const nextBalls = redBalls[i + 1];

                    for (let pos = 0; pos < 6; pos++) {
                        const currentNum = currentBalls[pos];
                        const nextNum = nextBalls[pos];

                        const intervalKey = `${currentNum}-${nextNum}`;
                        correlationData.intervalCorrelation[intervalKey] = (correlationData.intervalCorrelation[intervalKey] || 0) + 1;
                    }
                }

                Object.entries(correlationData.intervalCorrelation).forEach(([key, count]) => {
                    const strength = count / (redBalls.length - 1);
                    correlationData.correlationStrength[key] = strength;
                });

                return correlationData;
            }

            static analyzeRecoveryPredictions(redBalls, maxRedBall, advancedData) {
                const predictionData = {
                    nextRecoveryNumbers: [],
                    confidence: 0,
                    predictionReasoning: []
                };

                const recentDraws = redBalls.slice(-10);
                const trendData = advancedData.recoveryTrendAnalysis;
                const clusterData = advancedData.recoveryClusterAnalysis;
                const stabilityData = advancedData.recoveryStabilityAnalysis;

                const predictedNumbers = [];

                for (let num = 1; num <= maxRedBall; num++) {
                    const numStr = num.toString().padStart(2, '0');
                    let predictionScore = 0;

                    if (trendData.trendDirection[numStr] === 'rising') {
                        predictionScore += 30;
                        predictionData.predictionReasoning.push(`${numStr}呈上升趋势`);
                    }

                    if (clusterData.hotCluster.includes(numStr)) {
                        predictionScore += 25;
                        predictionData.predictionReasoning.push(`${numStr}属于热门集群`);
                    }

                    if (stabilityData.stableNumbers.includes(numStr)) {
                        predictionScore += 20;
                        predictionData.predictionReasoning.push(`${numStr}稳定性较高`);
                    }

                    const currentGap = this.calculateCurrentGap(redBalls, num);
                    const avgGap = this.calculateAverageGap(redBalls, num);

                    if (currentGap > avgGap * 1.5) {
                        predictionScore += 35;
                        predictionData.predictionReasoning.push(`${numStr}超期待回补`);
                    } else if (currentGap > avgGap * 1.2) {
                        predictionScore += 25;
                        predictionData.predictionReasoning.push(`${numStr}接近回补期`);
                    }

                    if (predictionScore > 50) {
                        predictedNumbers.push({ num: numStr, score: predictionScore });
                    }
                }

                predictedNumbers.sort((a, b) => b.score - a.score);
                predictionData.nextRecoveryNumbers = predictedNumbers.slice(0, 10);

                let confidence = 0;

                if (predictedNumbers.length > 0) {
                    const avgScore = predictedNumbers.reduce((sum, item) => sum + item.score, 0) / predictedNumbers.length;
                    confidence = Math.min(100, avgScore);
                }

                if (stabilityData.overallStability > 0.6) {
                    confidence += 15;
                    predictionData.predictionReasoning.push(`整体稳定性较高（${(stabilityData.overallStability * 100).toFixed(0)}%）`);
                }

                if (clusterData.hotCluster.length > 0) {
                    confidence += 10;
                    predictionData.predictionReasoning.push(`热门集群明确（${clusterData.hotCluster.length}个号码）`);
                }

                predictionData.confidence = Math.max(0, Math.min(100, confidence));

                return predictionData;
            }

            static calculateCurrentGap(redBalls, num) {
                for (let i = redBalls.length - 1; i >= 0; i--) {
                    if (redBalls[i].includes(num)) {
                        return redBalls.length - 1 - i;
                    }
                }
                return redBalls.length;
            }

            static calculateAverageGap(redBalls, num) {
                const gaps = [];
                let lastAppearance = -1;

                redBalls.forEach((balls, index) => {
                    if (balls.includes(num)) {
                        if (lastAppearance !== -1) {
                            gaps.push(index - lastAppearance);
                        }
                        lastAppearance = index;
                    }
                });

                if (gaps.length === 0) return redBalls.length;

                return gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
            }

            static calculateRecoveryCycle(redBalls, maxRedBall) {
                const cycles = {};

                for (let num = 1; num <= maxRedBall; num++) {
                    const appearances = [];
                    redBalls.forEach((balls, index) => {
                        if (balls.includes(num)) {
                            appearances.push(index);
                        }
                    });

                    if (appearances.length > 1) {
                        const intervals = [];
                        for (let i = 1; i < appearances.length; i++) {
                            intervals.push(appearances[i] - appearances[i - 1]);
                        }
                        const avgCycle = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                        cycles[num] = {
                            avgCycle,
                            minCycle: Math.min(...intervals),
                            maxCycle: Math.max(...intervals),
                            intervals,
                            lastAppearance: appearances[appearances.length - 1]
                        };
                    } else if (appearances.length === 1) {
                        cycles[num] = {
                            avgCycle: redBalls.length - appearances[0],
                            minCycle: redBalls.length - appearances[0],
                            maxCycle: redBalls.length - appearances[0],
                            intervals: [redBalls.length - appearances[0]],
                            lastAppearance: appearances[0]
                        };
                    } else {
                        cycles[num] = {
                            avgCycle: redBalls.length,
                            minCycle: redBalls.length,
                            maxCycle: redBalls.length,
                            intervals: [redBalls.length],
                            lastAppearance: -1
                        };
                    }
                }

                return cycles;
            }

            static calculateRecoveryIntensity(redBalls, maxRedBall) {
                const intensity = {};

                for (let num = 1; num <= maxRedBall; num++) {
                    const appearances = [];
                    redBalls.forEach((balls, index) => {
                        if (balls.includes(num)) {
                            appearances.push(index);
                        }
                    });

                    if (appearances.length > 0) {
                        let totalGaps = appearances[0];
                        for (let i = 1; i < appearances.length; i++) {
                            totalGaps += appearances[i] - appearances[i - 1] - 1;
                        }

                        const avgGap = totalGaps / appearances.length;
                        const maxGap = Math.max(...appearances.map((app, i) => {
                            if (i === 0) return app;
                            return app - appearances[i - 1] - 1;
                        }));

                        const intensityScore = 1 - (avgGap / redBalls.length);

                        intensity[num] = {
                            intensityScore,
                            avgGap,
                            maxGap,
                            totalAppearances: appearances.length,
                            totalGaps
                        };
                    } else {
                        intensity[num] = {
                            intensityScore: 0,
                            avgGap: redBalls.length,
                            maxGap: redBalls.length,
                            totalAppearances: 0,
                            totalGaps: redBalls.length
                        };
                    }
                }

                return intensity;
            }

            static calculateRecoveryTiming(redBalls, maxRedBall) {
                const timing = {};
                const hotNumbers = [];
                const coldNumbers = [];
                const overdueNumbers = [];

                for (let num = 1; num <= maxRedBall; num++) {
                    const appearances = [];
                    redBalls.forEach((balls, index) => {
                        if (balls.includes(num)) {
                            appearances.push(index);
                        }
                    });

                    const lastAppearance = appearances.length > 0 ? appearances[appearances.length - 1] : -1;
                    const currentGap = lastAppearance === -1 ? redBalls.length : redBalls.length - 1 - lastAppearance;
                    const frequency = appearances.length;
                    const avgInterval = frequency > 1 ? (redBalls.length - 1) / frequency : redBalls.length;

                    timing[num] = {
                        lastAppearance,
                        currentGap,
                        frequency,
                        avgInterval,
                        expectedNext: lastAppearance + avgInterval
                    };

                    if (frequency > redBalls.length / 10) {
                        hotNumbers.push(num);
                    } else if (frequency < redBalls.length / 30) {
                        coldNumbers.push(num);
                    }

                    if (currentGap > avgInterval * 2) {
                        overdueNumbers.push(num);
                    }
                }

                return {
                    timing,
                    hotNumbers,
                    coldNumbers,
                    overdueNumbers
                };
            }

            static identifyRecoveryPatterns(redBalls, maxRedBall) {
                const patterns = {
                    consecutiveRecovery: [],
                    alternatingRecovery: [],
                    clusterRecovery: [],
                    delayedRecovery: []
                };

                for (let num = 1; num <= maxRedBall; num++) {
                    const appearances = [];
                    redBalls.forEach((balls, index) => {
                        if (balls.includes(num)) {
                            appearances.push(index);
                        }
                    });

                    if (appearances.length < 2) continue;

                    const intervals = [];
                    for (let i = 1; i < appearances.length; i++) {
                        intervals.push(appearances[i] - appearances[i - 1]);
                    }

                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;
                    const stdDev = Math.sqrt(variance);

                    const consecutiveCount = intervals.filter(i => i <= 2).length;
                    const alternatingCount = intervals.filter(i => i >= 3 && i <= 8).length;
                    const clusterCount = intervals.filter(i => i > 8 && i <= 15).length;
                    const delayedCount = intervals.filter(i => i > 15).length;

                    if (consecutiveCount / intervals.length > 0.4) {
                        patterns.consecutiveRecovery.push(num);
                    }

                    if (alternatingCount / intervals.length > 0.4) {
                        patterns.alternatingRecovery.push(num);
                    }

                    if (clusterCount / intervals.length > 0.3) {
                        patterns.clusterRecovery.push(num);
                    }

                    if (delayedCount / intervals.length > 0.3) {
                        patterns.delayedRecovery.push(num);
                    }
                }

                return patterns;
            }

            static displayRecoveryAnalysis(analysisData) {
                this.displayRecoveryCycleChart(analysisData.recoveryCycle);
                this.displayRecoveryIntensityChart(analysisData.recoveryIntensity);
                this.displayRecoveryTimingChart(analysisData.recoveryTiming);
                this.displayRecoveryPatternChart(analysisData.recoveryPattern);
                this.displayRecoveryConclusion(analysisData);
                this.displayRecoveryRecommendation(analysisData);
            }

            static displayRecoveryCycleChart(recoveryCycle) {
                const chartDom = document.getElementById('recoveryCycleChart');
                if (!chartDom) return;

                const numbers = Object.keys(recoveryCycle).map(Number);
                const avgCycles = numbers.map(n => recoveryCycle[n].avgCycle);
                const minCycles = numbers.map(n => recoveryCycle[n].minCycle);
                const maxCycles = numbers.map(n => recoveryCycle[n].maxCycle);

                const chart = echarts.init(chartDom);
                chart.setOption({
                    title: {
                        text: '回补周期分布',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const param = Array.isArray(params) ? params[0] : params;
                            const num = param.name;
                            const data = recoveryCycle[num];
                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">号码 ${num} 回补周期详情</div>
                                <div style="margin-bottom: 5px;"><span style="color: #E63946;">●</span> 平均周期: ${data.avgCycle.toFixed(1)}期</div>
                                <div style="margin-bottom: 5px;"><span style="color: #457B9D;">●</span> 最短周期: ${data.minCycle}期</div>
                                <div style="margin-bottom: 5px;"><span style="color: #A8DADC;">●</span> 最长周期: ${data.maxCycle}期</div>
                                <div style="margin-bottom: 5px;">最后出现: ${data.lastAppearance >= 0 ? `第${data.lastAppearance + 1}期` : '从未出现'}</div>
                                <div style="margin-bottom: 5px;">历史间隔: ${data.intervals.slice(0, 5).join(', ')}${data.intervals.length > 5 ? '...' : ''}</div>
                            </div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['平均周期', '最短周期', '最长周期'],
                        bottom: 10
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        name: '号码',
                        nameLocation: 'middle',
                        nameGap: 25
                    },
                    yAxis: {
                        type: 'value',
                        name: '周期（期）'
                    },
                    series: [
                        {
                            name: '平均周期',
                            type: 'line',
                            data: avgCycles,
                            smooth: true,
                            itemStyle: { color: '#E63946' },
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '最短周期',
                            type: 'bar',
                            data: minCycles,
                            itemStyle: { color: '#457B9D' },
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '最长周期',
                            type: 'bar',
                            data: maxCycles,
                            itemStyle: { color: '#A8DADC' },
                            emphasis: {
                                focus: 'series'
                            }
                        }
                    ]
                });

                chart.on('click', function(params) {
                    const num = params.name;
                    const data = recoveryCycle[num];
                    console.log(`号码 ${num} 详细数据:`, data);
                });

                const statsDom = document.getElementById('recoveryCycleStats');
                const avgAll = avgCycles.reduce((a, b) => a + b, 0) / avgCycles.length;
                const minAll = Math.min(...minCycles);
                const maxAll = Math.max(...maxCycles);
                const mostFrequent = numbers.reduce((a, b) => recoveryCycle[a].avgCycle < recoveryCycle[b].avgCycle ? a : b);

                statsDom.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">平均回补周期</span>
                        <span class="stat-value">${avgAll.toFixed(1)}期</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">最短回补周期</span>
                        <span class="stat-value">${minAll}期</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">最长回补周期</span>
                        <span class="stat-value">${maxAll}期</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">最快回补号码</span>
                        <span class="stat-value">${mostFrequent}</span>
                    </div>
                `;
            }

            static displayRecoveryIntensityChart(recoveryIntensity) {
                const chartDom = document.getElementById('recoveryIntensityChart');
                if (!chartDom) return;

                const numbers = Object.keys(recoveryIntensity).map(Number);
                const intensityScores = numbers.map(n => recoveryIntensity[n].intensityScore);
                const totalAppearances = numbers.map(n => recoveryIntensity[n].totalAppearances);

                const chart = echarts.init(chartDom);
                chart.setOption({
                    title: {
                        text: '回补强度分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const num = params[0].name;
                            const data = recoveryIntensity[num];
                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">号码 ${num} 回补强度详情</div>
                                <div style="margin-bottom: 5px;"><span style="color: #E63946;">●</span> 回补强度: ${data.intensityScore.toFixed(4)}</div>
                                <div style="margin-bottom: 5px;"><span style="color: #457B9D;">●</span> 出现次数: ${data.totalAppearances}次</div>
                                <div style="margin-bottom: 5px;">平均间隔: ${data.avgGap.toFixed(1)}期</div>
                                <div style="margin-bottom: 5px;">最大间隔: ${data.maxGap}期</div>
                                <div style="margin-bottom: 5px;">总间隔期数: ${data.totalGaps}期</div>
                            </div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['回补强度', '出现次数'],
                        bottom: 10
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        name: '号码',
                        nameLocation: 'middle',
                        nameGap: 25
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '回补强度',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '出现次数',
                            position: 'right'
                        }
                    ],
                    series: [
                        {
                            name: '回补强度',
                            type: 'line',
                            data: intensityScores,
                            smooth: true,
                            itemStyle: { color: '#E63946' },
                            yAxisIndex: 0,
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '出现次数',
                            type: 'bar',
                            data: totalAppearances,
                            itemStyle: { color: '#457B9D' },
                            yAxisIndex: 1,
                            emphasis: {
                                focus: 'series'
                            }
                        }
                    ]
                });

                chart.on('click', function(params) {
                    const num = params.name;
                    const data = recoveryIntensity[num];
                    console.log(`号码 ${num} 详细数据:`, data);
                });

                const statsDom = document.getElementById('recoveryIntensityStats');
                const avgIntensity = intensityScores.reduce((a, b) => a + b, 0) / intensityScores.length;
                const maxIntensity = Math.max(...intensityScores);
                const maxIntensityNumber = numbers[intensityScores.indexOf(maxIntensity)];
                const highIntensityCount = intensityScores.filter(s => s > 0.7).length;

                statsDom.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">平均回补强度</span>
                        <span class="stat-value">${avgIntensity.toFixed(4)}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">最高回补强度</span>
                        <span class="stat-value">${maxIntensity.toFixed(4)}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">最强回补号码</span>
                        <span class="stat-value">${maxIntensityNumber}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">高强度号码数</span>
                        <span class="stat-value">${highIntensityCount}个</span>
                    </div>
                `;
            }

            static displayRecoveryTimingChart(recoveryTiming) {
                const chartDom = document.getElementById('recoveryTimingChart');
                if (!chartDom) return;

                const numbers = Object.keys(recoveryTiming.timing).map(Number);
                const currentGaps = numbers.map(n => recoveryTiming.timing[n].currentGap);
                const avgIntervals = numbers.map(n => recoveryTiming.timing[n].avgInterval);
                const frequencies = numbers.map(n => recoveryTiming.timing[n].frequency);

                const chart = echarts.init(chartDom);
                chart.setOption({
                    title: {
                        text: '回补时机分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const num = params[0].name;
                            const data = recoveryTiming.timing[num];
                            const isHot = recoveryTiming.hotNumbers.includes(num);
                            const isCold = recoveryTiming.coldNumbers.includes(num);
                            const isOverdue = recoveryTiming.overdueNumbers.includes(num);
                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">号码 ${num} 回补时机详情</div>
                                <div style="margin-bottom: 5px;"><span style="color: #E63946;">●</span> 当前间隔: ${data.currentGap}期</div>
                                <div style="margin-bottom: 5px;"><span style="color: #457B9D;">●</span> 平均间隔: ${data.avgInterval.toFixed(1)}期</div>
                                <div style="margin-bottom: 5px;"><span style="color: #A8DADC;">●</span> 出现频率: ${data.frequency}次</div>
                                <div style="margin-bottom: 5px;">最后出现: ${data.lastAppearance >= 0 ? `第${data.lastAppearance + 1}期` : '从未出现'}</div>
                                <div style="margin-bottom: 5px;">预期下次: ${data.expectedNext.toFixed(1)}期</div>
                                <div style="margin-bottom: 5px;">状态标签: ${isHot ? '<span style="color: #E63946;">热门</span>' : ''} ${isCold ? '<span style="color: #457B9D;">冷门</span>' : ''} ${isOverdue ? '<span style="color: #F4A261;">超期</span>' : ''}</div>
                            </div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['当前间隔', '平均间隔', '出现频率'],
                        bottom: 10
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        name: '号码',
                        nameLocation: 'middle',
                        nameGap: 25
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '间隔（期）',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '出现频率',
                            position: 'right'
                        }
                    ],
                    series: [
                        {
                            name: '当前间隔',
                            type: 'line',
                            data: currentGaps,
                            smooth: true,
                            itemStyle: { color: '#E63946' },
                            yAxisIndex: 0,
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '平均间隔',
                            type: 'line',
                            data: avgIntervals,
                            smooth: true,
                            itemStyle: { color: '#457B9D' },
                            yAxisIndex: 0,
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '出现频率',
                            type: 'bar',
                            data: frequencies,
                            itemStyle: { color: '#A8DADC' },
                            yAxisIndex: 1,
                            emphasis: {
                                focus: 'series'
                            }
                        }
                    ]
                });

                chart.on('click', function(params) {
                    const num = params.name;
                    const data = recoveryTiming.timing[num];
                    console.log(`号码 ${num} 详细数据:`, data);
                });

                const statsDom = document.getElementById('recoveryTimingStats');
                const overdueCount = recoveryTiming.overdueNumbers.length;
                const hotCount = recoveryTiming.hotNumbers.length;
                const coldCount = recoveryTiming.coldNumbers.length;
                const avgCurrentGap = currentGaps.reduce((a, b) => a + b, 0) / currentGaps.length;

                statsDom.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">超期待回补</span>
                        <span class="stat-value">${overdueCount}个</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">热门号码</span>
                        <span class="stat-value">${hotCount}个</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">冷门号码</span>
                        <span class="stat-value">${coldCount}个</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">平均当前间隔</span>
                        <span class="stat-value">${avgCurrentGap.toFixed(1)}期</span>
                    </div>
                `;
            }

            static displayRecoveryPatternChart(recoveryPattern) {
                const chartDom = document.getElementById('recoveryPatternChart');
                if (!chartDom) return;

                const chart = echarts.init(chartDom);
                chart.setOption({
                    title: {
                        text: '回补模式识别',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: function(params) {
                            const patternType = params.name;
                            let numbers = [];
                            let description = '';

                            switch(patternType) {
                                case '连续回补':
                                    numbers = recoveryPattern.consecutiveRecovery;
                                    description = '间隔≤2期，号码频繁出现';
                                    break;
                                case '交替回补':
                                    numbers = recoveryPattern.alternatingRecovery;
                                    description = '间隔3-8期，规律性出现';
                                    break;
                                case '集群回补':
                                    numbers = recoveryPattern.clusterRecovery;
                                    description = '间隔9-15期，集中出现';
                                    break;
                                case '延迟回补':
                                    numbers = recoveryPattern.delayedRecovery;
                                    description = '间隔>15期，长期不出现';
                                    break;
                            }

                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">${patternType} (${numbers.length}个)</div>
                                <div style="margin-bottom: 5px;">${description}</div>
                                <div style="margin-bottom: 5px;">号码列表: ${numbers.slice(0, 10).join(', ')}${numbers.length > 10 ? '...' : ''}</div>
                            </div>`;
                            return result;
                        }
                    },
                    legend: {
                        orient: 'vertical',
                        left: 'left',
                        top: 'middle'
                    },
                    series: [
                        {
                            name: '回补模式',
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#fff',
                                borderWidth: 2
                            },
                            label: {
                                show: false,
                                position: 'center'
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: 16,
                                    fontWeight: 'bold'
                                },
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            },
                            labelLine: {
                                show: false
                            },
                            data: [
                                {
                                    value: recoveryPattern.consecutiveRecovery.length,
                                    name: '连续回补',
                                    itemStyle: { color: '#E63946' }
                                },
                                {
                                    value: recoveryPattern.alternatingRecovery.length,
                                    name: '交替回补',
                                    itemStyle: { color: '#457B9D' }
                                },
                                {
                                    value: recoveryPattern.clusterRecovery.length,
                                    name: '集群回补',
                                    itemStyle: { color: '#A8DADC' }
                                },
                                {
                                    value: recoveryPattern.delayedRecovery.length,
                                    name: '延迟回补',
                                    itemStyle: { color: '#F1FAEE' }
                                }
                            ]
                        }
                    ]
                });

                chart.on('click', function(params) {
                    const patternType = params.name;
                    let numbers = [];
                    switch(patternType) {
                        case '连续回补':
                            numbers = recoveryPattern.consecutiveRecovery;
                            break;
                        case '交替回补':
                            numbers = recoveryPattern.alternatingRecovery;
                            break;
                        case '集群回补':
                            numbers = recoveryPattern.clusterRecovery;
                            break;
                        case '延迟回补':
                            numbers = recoveryPattern.delayedRecovery;
                            break;
                    }
                    console.log(`${patternType} 号码列表:`, numbers);
                });

                const statsDom = document.getElementById('recoveryPatternStats');
                const totalPatterns = recoveryPattern.consecutiveRecovery.length + 
                                     recoveryPattern.alternatingRecovery.length + 
                                     recoveryPattern.clusterRecovery.length + 
                                     recoveryPattern.delayedRecovery.length;

                statsDom.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">连续回补</span>
                        <span class="stat-value">${recoveryPattern.consecutiveRecovery.length}个</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">交替回补</span>
                        <span class="stat-value">${recoveryPattern.alternatingRecovery.length}个</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">集群回补</span>
                        <span class="stat-value">${recoveryPattern.clusterRecovery.length}个</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">延迟回补</span>
                        <span class="stat-value">${recoveryPattern.delayedRecovery.length}个</span>
                    </div>
                `;
            }

            static displayRecoveryConclusion(analysisData) {
                const conclusionDom = document.getElementById('recoveryConclusion');
                if (!conclusionDom) return;

                const { recoveryCycle, recoveryIntensity, recoveryTiming, recoveryPattern, advancedAnalysis } = analysisData;

                const avgCycle = Object.values(recoveryCycle).reduce((sum, c) => sum + c.avgCycle, 0) / Object.keys(recoveryCycle).length;
                const avgIntensity = Object.values(recoveryIntensity).reduce((sum, i) => sum + i.intensityScore, 0) / Object.keys(recoveryIntensity).length;
                const overdueCount = recoveryTiming.overdueNumbers.length;
                const hotCount = recoveryTiming.hotNumbers.length;
                const coldCount = recoveryTiming.coldNumbers.length;

                let html = '<div class="conclusion-grid">';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-chart-line" style="color: #E63946;"></i> 回补周期特征</h4>';
                html += `<p>平均周期：<strong>${avgCycle.toFixed(1)}</strong>期</p>`;
                html += `<p>周期状态：<strong>${avgCycle < 10 ? '较短，活跃度高' : '适中，表现稳定'}</strong></p>`;
                html += '</div>';

                html += '<div class="conclusion-item">';
                html += '<h4><i class="fas fa-fire" style="color: #457B9D;"></i> 回补强度特征</h4>';
                html += `<p>平均强度：<strong>${avgIntensity.toFixed(4)}</strong></p>`;
                html += `<p>强度状态：<strong>${avgIntensity > 0.5 ? '较高，表现活跃' : '一般，表现平稳'}</strong></p>`;
                html += '</div>';

                if (overdueCount > 0) {
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-clock" style="color: #F4A261;"></i> 超期待回补</h4>';
                    html += `<p>超期号码：<strong>${overdueCount}</strong>个</p>`;
                    html += `<p>状态：<strong>可能即将回补</strong></p>`;
                    html += '</div>';
                }

                if (hotCount > 0) {
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-star" style="color: #2ECC71;"></i> 热门号码</h4>';
                    html += `<p>热门号码：<strong>${hotCount}</strong>个</p>`;
                    html += `<p>状态：<strong>近期表现活跃</strong></p>`;
                    html += '</div>';
                }

                if (coldCount > 0) {
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-snowflake" style="color: #3498DB;"></i> 冷门号码</h4>';
                    html += `<p>冷门号码：<strong>${coldCount}</strong>个</p>`;
                    html += `<p>状态：<strong>可能处于休眠期</strong></p>`;
                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.recoveryStabilityAnalysis) {
                    const stabilityData = advancedAnalysis.recoveryStabilityAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-shield-alt" style="color: #9B59B6;"></i> 稳定性分析</h4>';
                    html += `<p>整体稳定性：<strong>${(stabilityData.overallStability * 100).toFixed(0)}%</strong></p>`;
                    html += `<p>稳定号码：<strong>${stabilityData.stableNumbers.length}</strong>个</p>`;
                    html += `<p>不稳定号码：<strong>${stabilityData.unstableNumbers.length}</strong>个</p>`;
                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.recoveryClusterAnalysis) {
                    const clusterData = advancedAnalysis.recoveryClusterAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-layer-group" style="color: #E74C3C;"></i> 集群分析</h4>';
                    html += `<p>热门集群：<strong>${clusterData.hotCluster.length}</strong>个</p>`;
                    html += `<p>温热集群：<strong>${clusterData.warmCluster.length}</strong>个</p>`;
                    html += `<p>冷门集群：<strong>${clusterData.coldCluster.length}</strong>个</p>`;
                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.recoveryTrendAnalysis) {
                    const trendData = advancedAnalysis.recoveryTrendAnalysis;
                    const risingCount = Object.values(trendData.trendDirection).filter(d => d === 'rising').length;
                    const fallingCount = Object.values(trendData.trendDirection).filter(d => d === 'falling').length;
                    const stableCount = Object.values(trendData.trendDirection).filter(d => d === 'stable').length;

                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-chart-area" style="color: #16A085;"></i> 趋势分析</h4>';
                    html += `<p>上升趋势：<strong>${risingCount}</strong>个</p>`;
                    html += `<p>下降趋势：<strong>${fallingCount}</strong>个</p>`;
                    html += `<p>稳定状态：<strong>${stableCount}</strong>个</p>`;
                    html += '</div>';
                }

                if (advancedAnalysis && advancedAnalysis.recoveryPredictionAnalysis) {
                    const predictionData = advancedAnalysis.recoveryPredictionAnalysis;
                    html += '<div class="conclusion-item">';
                    html += '<h4><i class="fas fa-magic" style="color: #F39C12;"></i> 预测分析</h4>';
                    html += `<p>预测号码数：<strong>${predictionData.nextRecoveryNumbers.length}</strong>个</p>`;
                    html += `<p>预测置信度：<strong>${predictionData.confidence.toFixed(0)}%</strong></p>`;
                    if (predictionData.predictionReasoning.length > 0) {
                        html += '<p>预测依据：';
                        predictionData.predictionReasoning.slice(0, 3).forEach(reason => {
                            html += `${reason}；`;
                        });
                        html += '</p>';
                    }
                    html += '</div>';
                }

                const patternCounts = {
                    consecutive: recoveryPattern.consecutiveRecovery.length,
                    alternating: recoveryPattern.alternatingRecovery.length,
                    cluster: recoveryPattern.clusterRecovery.length,
                    delayed: recoveryPattern.delayedRecovery.length
                };

                const dominantPattern = Object.entries(patternCounts).sort((a, b) => b[1] - a[1])[0];
                const patternNames = {
                    consecutive: '连续回补',
                    alternating: '交替回补',
                    cluster: '集群回补',
                    delayed: '延迟回补'
                };

                html += '<div class="conclusion-item full-width">';
                html += '<h4><i class="fas fa-th" style="color: #8E44AD;"></i> 主要回补模式</h4>';
                html += `<p><strong>${patternNames[dominantPattern[0]]}</strong>模式占主导地位，共${dominantPattern[1]}个号码采用此模式。</p>`;
                html += '</div>';

                html += '</div>';

                conclusionDom.innerHTML = html;
            }

            static displayRecoveryRecommendation(analysisData) {
                const recommendationDom = document.getElementById('recoveryRecommendation');
                if (!recommendationDom) return;

                const { recoveryCycle, recoveryIntensity, recoveryTiming, recoveryPattern, advancedAnalysis } = analysisData;

                let recommendations = [];

                if (advancedAnalysis && advancedAnalysis.recoveryPredictionAnalysis) {
                    const predictionData = advancedAnalysis.recoveryPredictionAnalysis;

                    if (predictionData.nextRecoveryNumbers.length > 0) {
                        const predictedNumbers = predictionData.nextRecoveryNumbers.map(n => n.num);
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-magic" style="color: #F39C12;"></i>
                                <strong>智能预测推荐号码</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>基于多维度分析预测的高概率回补号码（置信度：${predictionData.confidence.toFixed(0)}%）：</p>
                                <div>${predictedNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                            </div>
                        </div>`);
                    }
                }

                if (advancedAnalysis && advancedAnalysis.recoveryTrendAnalysis) {
                    const trendData = advancedAnalysis.recoveryTrendAnalysis;
                    const risingNumbers = Object.entries(trendData.trendDirection)
                        .filter(([num, direction]) => direction === 'rising')
                        .map(([num, direction]) => num)
                        .slice(0, 5);

                    if (risingNumbers.length > 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-chart-line" style="color: #2ECC71;"></i>
                                <strong>上升趋势号码推荐</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>以下号码近期呈上升趋势，建议重点关注：</p>
                                <div>${risingNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                            </div>
                        </div>`);
                    }
                }

                if (advancedAnalysis && advancedAnalysis.recoveryClusterAnalysis) {
                    const clusterData = advancedAnalysis.recoveryClusterAnalysis;
                    const hotClusterNumbers = clusterData.hotCluster.slice(0, 5);

                    if (hotClusterNumbers.length > 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-fire" style="color: #E74C3C;"></i>
                                <strong>热门集群号码推荐</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>以下号码属于热门集群，出现频率较高：</p>
                                <div>${hotClusterNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                            </div>
                        </div>`);
                    }
                }

                if (advancedAnalysis && advancedAnalysis.recoveryStabilityAnalysis) {
                    const stabilityData = advancedAnalysis.recoveryStabilityAnalysis;
                    const stableNumbers = stabilityData.stableNumbers.slice(0, 5);

                    if (stableNumbers.length > 0) {
                        recommendations.push(`<div class="recommendation-item">
                            <div class="recommendation-header">
                                <i class="fas fa-shield-alt" style="color: #9B59B6;"></i>
                                <strong>高稳定性号码推荐</strong>
                            </div>
                            <div class="recommendation-body">
                                <p>以下号码回补稳定性较高，表现规律：</p>
                                <div>${stableNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                            </div>
                        </div>`);
                    }
                }

                const highIntensityNumbers = Object.entries(recoveryIntensity)
                    .filter(([num, data]) => data.intensityScore > 0.7)
                    .map(([num, data]) => parseInt(num))
                    .sort((a, b) => recoveryIntensity[b].intensityScore - recoveryIntensity[a].intensityScore)
                    .slice(0, 5);

                if (highIntensityNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-bolt" style="color: #E63946;"></i>
                            <strong>推荐高回补强度号码</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下号码回补强度较高，建议重点关注：</p>
                            <div>${highIntensityNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                const overdueNumbers = recoveryTiming.overdueNumbers
                    .sort((a, b) => recoveryTiming.timing[b].currentGap - recoveryTiming.timing[a].currentGap)
                    .slice(0, 5);

                if (overdueNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-clock" style="color: #457B9D;"></i>
                            <strong>推荐超期待回补号码</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下号码已超过平均间隔期，建议考虑：</p>
                            <div>${overdueNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                const shortCycleNumbers = Object.entries(recoveryCycle)
                    .filter(([num, data]) => data.avgCycle < 10)
                    .map(([num, data]) => parseInt(num))
                    .sort((a, b) => recoveryCycle[a].avgCycle - recoveryCycle[b].avgCycle)
                    .slice(0, 5);

                if (shortCycleNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-bolt" style="color: #A8DADC;"></i>
                            <strong>推荐短周期回补号码</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下号码回补周期较短，表现活跃：</p>
                            <div>${shortCycleNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                const consecutiveRecoveryNumbers = recoveryPattern.consecutiveRecovery.slice(0, 5);

                if (consecutiveRecoveryNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-redo" style="color: #F1FAEE;"></i>
                            <strong>推荐连续回补模式号码</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下号码倾向于连续回补模式：</p>
                            <div>${consecutiveRecoveryNumbers.map(n => `<span class="recovery-number-tag">${n}</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                if (recommendations.length === 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>基础推荐建议</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>当前分析结果特征不明显，建议采用均衡选号策略，关注各区间号码的均匀分布，并参考历史高频号码进行组合。</p>
                        </div>
                    </div>`);
                }

                recommendationDom.innerHTML = recommendations.join('');
            }

            static async performMandelbrotAnalysis() {
                const periodSelect = document.getElementById('mandelbrotPeriodSelect');
                const period = periodSelect.value;

                MessageSystem.showMessage('正在加载分析数据...', 'info');

                try {
                    await dataManager.loadDataForCurrentLottery();
                    MessageSystem.showMessage('正在分析曼德尔定律数据...', 'info');

                    setTimeout(() => {
                        try {
                            const analysisData = this.calculateMandelbrotMetrics(period);
                            this.displayMandelbrotAnalysis(analysisData);
                            MessageSystem.showMessage('曼德尔定律分析完成', 'success');
                        } catch (error) {
                            console.error('曼德尔定律分析错误:', error);
                            MessageSystem.showMessage('曼德尔定律分析失败: ' + error.message, 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            static calculateMandelbrotMetrics(period) {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    throw new Error('没有可分析的数据，请先导入数据');
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                // 更新分析范围显示
                const mandelbrotDataRangeInfo = document.getElementById('mandelbrotDataRangeInfo');
                if (mandelbrotDataRangeInfo && analysisData.length > 0) {
                    const startPeriod = analysisData[0].period;
                    const endPeriod = analysisData[analysisData.length - 1].period;
                    mandelbrotDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;
                const totalDraws = analysisData.length;
                const expectedFrequency = totalDraws * 6 / maxRedBall;

                const frequencyStats = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    frequencyStats[i] = {
                        actualFrequency: 0,
                        expectedFrequency: expectedFrequency,
                        deviation: 0,
                        deviationPercent: 0,
                        positions: []
                    };
                }

                redBalls.forEach((draw, drawIndex) => {
                    draw.forEach(ball => {
                        frequencyStats[ball].actualFrequency++;
                        frequencyStats[ball].positions.push(drawIndex);
                    });
                });

                for (let i = 1; i <= maxRedBall; i++) {
                    const stats = frequencyStats[i];
                    stats.deviation = stats.actualFrequency - stats.expectedFrequency;
                    stats.deviationPercent = (stats.deviation / stats.expectedFrequency) * 100;
                }

                const positions = redBalls.flat();
                const mean = positions.reduce((a, b) => a + b, 0) / positions.length;
                const variance = positions.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / positions.length;
                const stdDev = Math.sqrt(variance);

                const aggregationScore = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    const stats = frequencyStats[i];
                    if (stats.positions.length > 0) {
                        const posMean = stats.positions.reduce((a, b) => a + b, 0) / stats.positions.length;
                        const posVariance = stats.positions.reduce((a, b) => a + Math.pow(b - posMean, 2), 0) / stats.positions.length;
                        const posStdDev = Math.sqrt(posVariance);
                        aggregationScore[i] = posStdDev / stdDev;
                    } else {
                        aggregationScore[i] = 0;
                    }
                }

                const regressionProbability = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    const stats = frequencyStats[i];
                    const aggScore = aggregationScore[i];
                    const devPercent = Math.abs(stats.deviationPercent);

                    let probability = 0.5;

                    if (stats.deviation < 0) {
                        probability += Math.min(devPercent / 50, 0.3);
                    }

                    if (aggScore < 0.8) {
                        probability += 0.1;
                    } else if (aggScore > 1.2) {
                        probability -= 0.1;
                    }

                    probability = Math.max(0.1, Math.min(0.9, probability));
                    regressionProbability[i] = probability;
                }

                return {
                    frequencyStats,
                    aggregationScore,
                    regressionProbability,
                    period: period === 'all' ? totalDraws : period,
                    maxRedBall,
                    expectedFrequency
                };
            }

            static displayMandelbrotAnalysis(analysisData) {
                this.displayMandelbrotStats(analysisData);
                this.displayMandelbrotDeviationChart(analysisData);
                this.displayMandelbrotAggregationChart(analysisData);
                this.displayMandelbrotRecommendation(analysisData);
            }

            static displayMandelbrotStats(analysisData) {
                const statsDom = document.getElementById('mandelbrotStats');
                if (!statsDom) return;

                const { frequencyStats, regressionProbability, maxRedBall, expectedFrequency } = analysisData;

                const avgDeviation = Object.values(frequencyStats).reduce((sum, stat) => sum + Math.abs(stat.deviationPercent), 0) / maxRedBall;
                const highDeviationNumbers = Object.entries(frequencyStats)
                    .filter(([num, stat]) => Math.abs(stat.deviationPercent) > 30)
                    .map(([num, stat]) => parseInt(num));
                const highProbabilityNumbers = Object.entries(regressionProbability)
                    .filter(([num, prob]) => prob > 0.65)
                    .map(([num, prob]) => parseInt(num))
                    .sort((a, b) => regressionProbability[b] - regressionProbability[a])
                    .slice(0, 5);

                statsDom.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">分析期数</span>
                        <span class="stat-value">${analysisData.period}期</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">理论期望频率</span>
                        <span class="stat-value">${expectedFrequency.toFixed(2)}次</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">平均偏差值</span>
                        <span class="stat-value">${avgDeviation.toFixed(2)}%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">高偏差号码数</span>
                        <span class="stat-value">${highDeviationNumbers.length}个</span>
                    </div>
                `;
            }

            static displayMandelbrotDeviationChart(analysisData) {
                const chartDom = document.getElementById('mandelbrotDeviationChart');
                if (!chartDom) return;

                const { frequencyStats, maxRedBall } = analysisData;

                const numbers = [];
                const deviationPercents = [];
                const actualFrequencies = [];
                const expectedFrequencies = [];

                for (let i = 1; i <= maxRedBall; i++) {
                    numbers.push(i);
                    deviationPercents.push(frequencyStats[i].deviationPercent.toFixed(2));
                    actualFrequencies.push(frequencyStats[i].actualFrequency);
                    expectedFrequencies.push(frequencyStats[i].expectedFrequency.toFixed(2));
                }

                const chart = echarts.init(chartDom);
                chart.setOption({
                    title: {
                        text: '号码出现频率偏差分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const num = params[0].name;
                            const stats = frequencyStats[num];
                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">号码 ${num} 频率详情</div>
                                <div style="margin-bottom: 5px;"><span style="color: #E63946;">●</span> 实际频率: ${stats.actualFrequency}次</div>
                                <div style="margin-bottom: 5px;"><span style="color: #457B9D;">●</span> 期望频率: ${stats.expectedFrequency.toFixed(2)}次</div>
                                <div style="margin-bottom: 5px;"><span style="color: #A8DADC;">●</span> 偏差值: ${stats.deviation.toFixed(2)}次</div>
                                <div style="margin-bottom: 5px;">偏差百分比: ${stats.deviationPercent.toFixed(2)}%</div>
                            </div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['实际频率', '期望频率', '偏差百分比'],
                        bottom: 10
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        name: '号码',
                        nameLocation: 'middle',
                        nameGap: 25
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '频率（次）',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '偏差百分比（%）',
                            position: 'right',
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '实际频率',
                            type: 'bar',
                            data: actualFrequencies,
                            itemStyle: { color: '#E63946' },
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '期望频率',
                            type: 'line',
                            data: expectedFrequencies,
                            smooth: true,
                            itemStyle: { color: '#457B9D' },
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '偏差百分比',
                            type: 'line',
                            yAxisIndex: 1,
                            data: deviationPercents,
                            smooth: true,
                            itemStyle: { color: '#A8DADC' },
                            emphasis: {
                                focus: 'series'
                            }
                        }
                    ]
                });
            }

            static displayMandelbrotAggregationChart(analysisData) {
                const chartDom = document.getElementById('mandelbrotAggregationChart');
                if (!chartDom) return;

                const { aggregationScore, regressionProbability, maxRedBall } = analysisData;

                const numbers = [];
                const aggregationScores = [];
                const regressionProbs = [];

                for (let i = 1; i <= maxRedBall; i++) {
                    numbers.push(i);
                    aggregationScores.push(aggregationScore[i].toFixed(4));
                    regressionProbs.push((regressionProbability[i] * 100).toFixed(2));
                }

                const chart = echarts.init(chartDom);
                chart.setOption({
                    title: {
                        text: '聚合度与回归概率分析',
                        left: 'center'
                    },
                    tooltip: {
                        trigger: 'axis',
                        formatter: function(params) {
                            const num = params[0].name;
                            const aggScore = aggregationScore[num];
                            const regProb = regressionProbability[num];
                            let result = `<div style="padding: 10px;">
                                <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">号码 ${num} 聚合度详情</div>
                                <div style="margin-bottom: 5px;"><span style="color: #E63946;">●</span> 聚合度: ${aggScore.toFixed(4)}</div>
                                <div style="margin-bottom: 5px;"><span style="color: #457B9D;">●</span> 回归概率: ${(regProb * 100).toFixed(2)}%</div>
                                <div style="margin-bottom: 5px;">聚合评价: ${aggScore < 0.8 ? '低聚合' : aggScore > 1.2 ? '高聚合' : '正常'}</div>
                                <div style="margin-bottom: 5px;">回归趋势: ${regProb > 0.65 ? '高概率回归' : regProb < 0.35 ? '低概率回归' : '正常趋势'}</div>
                            </div>`;
                            return result;
                        }
                    },
                    legend: {
                        data: ['聚合度', '回归概率'],
                        bottom: 10
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: numbers,
                        name: '号码',
                        nameLocation: 'middle',
                        nameGap: 25
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '聚合度',
                            position: 'left'
                        },
                        {
                            type: 'value',
                            name: '回归概率（%）',
                            position: 'right',
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '聚合度',
                            type: 'bar',
                            data: aggregationScores,
                            itemStyle: { color: '#E63946' },
                            emphasis: {
                                focus: 'series'
                            }
                        },
                        {
                            name: '回归概率',
                            type: 'line',
                            yAxisIndex: 1,
                            data: regressionProbs,
                            smooth: true,
                            itemStyle: { color: '#457B9D' },
                            emphasis: {
                                focus: 'series'
                            }
                        }
                    ]
                });
            }

            static displayMandelbrotRecommendation(analysisData) {
                const recommendationDom = document.getElementById('mandelbrotRecommendation');
                if (!recommendationDom) return;

                const { frequencyStats, regressionProbability, maxRedBall } = analysisData;

                let recommendations = [];

                const highRegressionNumbers = Object.entries(regressionProbability)
                    .filter(([num, prob]) => prob > 0.65)
                    .map(([num, prob]) => ({ num: parseInt(num), prob }))
                    .sort((a, b) => b.prob - a.prob)
                    .slice(0, 5);

                if (highRegressionNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-chart-line" style="color: #E63946;"></i>
                            <strong>高回归概率号码</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下号码基于曼德尔定律分析，回归概率较高：</p>
                            <div>${highRegressionNumbers.map(n => `<span class="recovery-number-tag">${n.num} (${(n.prob * 100).toFixed(1)}%)</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                const lowFrequencyNumbers = Object.entries(frequencyStats)
                    .filter(([num, stat]) => stat.deviationPercent < -20)
                    .map(([num, stat]) => ({ num: parseInt(num), dev: stat.deviationPercent }))
                    .sort((a, b) => a.dev - b.dev)
                    .slice(0, 5);

                if (lowFrequencyNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-arrow-down" style="color: #457B9D;"></i>
                            <strong>低频回归号码</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下号码出现频率低于期望，建议考虑：</p>
                            <div>${lowFrequencyNumbers.map(n => `<span class="recovery-number-tag">${n.num} (${n.dev.toFixed(1)}%)</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                const combinations = this.generateMandelbrotCombinations(regressionProbability, maxRedBall);

                if (combinations.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-star" style="color: #A8DADC;"></i>
                            <strong>参考号码组合</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>基于曼德尔定律概率分析生成的参考组合：</p>
                            <div class="combination-list">
                                ${combinations.map((combo, index) => `
                                    <div class="combination-item">
                                        <span class="combination-label">组合${index + 1}：</span>
                                        <span class="combination-numbers">${combo.numbers.sort((a, b) => a - b).map(n => `<span class="combo-ball">${n < 10 ? '0' + n : n}</span>`).join(' ')}</span>
                                        <span class="combination-prob">概率: ${combo.prob.toFixed(1)}%</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>`);
                }

                if (recommendations.length === 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>基础推荐建议</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>当前分析结果特征不明显，建议采用均衡选号策略，关注各区间号码的均匀分布，并参考历史高频号码进行组合。</p>
                        </div>
                    </div>`);
                }

                recommendationDom.innerHTML = recommendations.join('');
            }

            static generateMandelbrotCombinations(regressionProbability, maxRedBall) {
                const combinations = [];
                const sortedNumbers = Object.entries(regressionProbability)
                    .map(([num, prob]) => ({ num: parseInt(num), prob }))
                    .sort((a, b) => b.prob - a.prob);

                for (let i = 0; i < 5; i++) {
                    const combo = [];
                    const usedNumbers = new Set();

                    for (let j = 0; j < 6; j++) {
                        let selectedIndex = -1;
                        let attempts = 0;

                        while (selectedIndex === -1 && attempts < 100) {
                            const randomIndex = Math.floor(Math.random() * sortedNumbers.length);
                            const candidate = sortedNumbers[randomIndex];

                            if (!usedNumbers.has(candidate.num)) {
                                const probabilityThreshold = Math.random();
                                if (probabilityThreshold < candidate.prob) {
                                    selectedIndex = randomIndex;
                                    usedNumbers.add(candidate.num);
                                    combo.push(candidate.num);
                                }
                            }
                            attempts++;
                        }

                        if (selectedIndex === -1) {
                            for (const candidate of sortedNumbers) {
                                if (!usedNumbers.has(candidate.num)) {
                                    usedNumbers.add(candidate.num);
                                    combo.push(candidate.num);
                                    break;
                                }
                            }
                        }
                    }

                    if (combo.length === 6) {
                        const avgProb = combo.reduce((sum, num) => sum + regressionProbability[num], 0) / 6;
                        combinations.push({ numbers: combo, prob: avgProb * 100 });
                    }
                }

                return combinations;
            }

            static async performFibonacciAnalysis() {
                const periodSelect = document.getElementById('fibonacciPeriodSelect');
                const period = periodSelect.value;

                MessageSystem.showMessage('正在加载分析数据...', 'info');

                try {
                    await dataManager.loadDataForCurrentLottery();
                    MessageSystem.showMessage('正在分析斐波那契数据...', 'info');

                    setTimeout(() => {
                        try {
                            const analysisData = this.calculateFibonacciMetrics(period);
                            this.displayFibonacciAnalysis(analysisData);
                            MessageSystem.showMessage('斐波那契分析完成', 'success');
                        } catch (error) {
                            console.error('斐波那契分析错误:', error);
                            MessageSystem.showMessage('斐波那契分析失败: ' + error.message, 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            static calculateFibonacciMetrics(period) {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    throw new Error('没有可分析的数据，请先导入数据');
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                // 更新分析范围显示
                const fibonacciDataRangeInfo = document.getElementById('fibonacciDataRangeInfo');
                if (fibonacciDataRangeInfo && analysisData.length > 0) {
                    const startPeriod = analysisData[0].period;
                    const endPeriod = analysisData[analysisData.length - 1].period;
                    fibonacciDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;
                const maxBlueBall = currentLotteryType === 'ssq' ? 16 : 12;
                const totalDraws = analysisData.length;

                const fibonacciRedFeature = [1, 2, 3, 5, 8, 13, 21].filter(n => n <= maxRedBall);
                const fibonacciBlueFeature = [1, 2, 3, 5, 8, 13].filter(n => n <= maxBlueBall);

                const goldenRatio = 0.618;
                const goldenRatio2 = 0.382;
                const goldenRatio3 = 0.236;

                const redGoldenPoints = {
                    high: Math.round(maxRedBall * goldenRatio),
                    mid: Math.round(maxRedBall * goldenRatio2),
                    low: Math.round(maxRedBall * goldenRatio3)
                };

                const blueGoldenPoints = {
                    high: Math.round(maxBlueBall * goldenRatio),
                    mid: Math.round(maxBlueBall * goldenRatio2),
                    low: Math.round(maxBlueBall * goldenRatio3)
                };

                const redGoldenRanges = {
                    high: [redGoldenPoints.high - 1, redGoldenPoints.high + 1],
                    mid: [redGoldenPoints.mid - 1, redGoldenPoints.mid + 1],
                    low: [redGoldenPoints.low - 1, redGoldenPoints.low + 1]
                };

                const blueGoldenRanges = {
                    high: [blueGoldenPoints.high - 1, blueGoldenPoints.high + 1],
                    mid: [blueGoldenPoints.mid - 1, blueGoldenPoints.mid + 1],
                    low: [blueGoldenPoints.low - 1, blueGoldenPoints.low + 1]
                };

                const featureStats = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    featureStats[i] = {
                        isFibonacci: fibonacciRedFeature.includes(i),
                        isGoldenHigh: i >= redGoldenRanges.high[0] && i <= redGoldenRanges.high[1],
                        isGoldenMid: i >= redGoldenRanges.mid[0] && i <= redGoldenRanges.mid[1],
                        isGoldenLow: i >= redGoldenRanges.low[0] && i <= redGoldenRanges.low[1],
                        frequency: 0,
                        totalNumbers: 0
                    };
                }

                redBalls.forEach(draw => {
                    draw.forEach(ball => {
                        featureStats[ball].frequency++;
                        featureStats[ball].totalNumbers++;
                    });
                });

                const totalNumbers = redBalls.length * 6;
                const expectedFrequency = totalNumbers / maxRedBall;

                for (let i = 1; i <= maxRedBall; i++) {
                    const stats = featureStats[i];
                    stats.frequencyRatio = stats.frequency / totalNumbers;
                    stats.expectedRatio = 1 / maxRedBall;
                    stats.deviation = stats.frequencyRatio - stats.expectedRatio;
                    stats.deviationPercent = (stats.deviation / stats.expectedRatio) * 100;
                }

                const fibonacciNumbers = fibonacciRedFeature.map(n => ({
                    number: n,
                    frequency: featureStats[n].frequency,
                    ratio: featureStats[n].frequencyRatio,
                    deviation: featureStats[n].deviationPercent
                }));

                const goldenHighNumbers = [];
                const goldenMidNumbers = [];
                const goldenLowNumbers = [];

                for (let i = 1; i <= maxRedBall; i++) {
                    if (featureStats[i].isGoldenHigh) {
                        goldenHighNumbers.push({
                            number: i,
                            frequency: featureStats[i].frequency,
                            ratio: featureStats[i].frequencyRatio,
                            deviation: featureStats[i].deviationPercent
                        });
                    }
                    if (featureStats[i].isGoldenMid) {
                        goldenMidNumbers.push({
                            number: i,
                            frequency: featureStats[i].frequency,
                            ratio: featureStats[i].frequencyRatio,
                            deviation: featureStats[i].deviationPercent
                        });
                    }
                    if (featureStats[i].isGoldenLow) {
                        goldenLowNumbers.push({
                            number: i,
                            frequency: featureStats[i].frequency,
                            ratio: featureStats[i].frequencyRatio,
                            deviation: featureStats[i].deviationPercent
                        });
                    }
                }

                const fibonacciTotalFreq = fibonacciNumbers.reduce((sum, n) => sum + n.frequency, 0);
                const fibonacciRatio = fibonacciTotalFreq / totalNumbers;
                const fibonacciDeviation = Math.abs(fibonacciRatio - goldenRatio);

                const goldenHighTotalFreq = goldenHighNumbers.reduce((sum, n) => sum + n.frequency, 0);
                const goldenHighRatio = goldenHighTotalFreq / totalNumbers;
                const goldenHighDeviation = Math.abs(goldenHighRatio - goldenRatio);

                const goldenMidTotalFreq = goldenMidNumbers.reduce((sum, n) => sum + n.frequency, 0);
                const goldenMidRatio = goldenMidTotalFreq / totalNumbers;
                const goldenMidDeviation = Math.abs(goldenMidRatio - goldenRatio2);

                const goldenLowTotalFreq = goldenLowNumbers.reduce((sum, n) => sum + n.frequency, 0);
                const goldenLowRatio = goldenLowTotalFreq / totalNumbers;
                const goldenLowDeviation = Math.abs(goldenLowRatio - goldenRatio3);

                const regressionProbability = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    const stats = featureStats[i];
                    let probability = 0.5;

                    if (stats.isFibonacci) {
                        probability += 0.15;
                    }

                    if (stats.isGoldenHigh || stats.isGoldenMid || stats.isGoldenLow) {
                        probability += 0.15;
                    }

                    if (stats.deviation < 0) {
                        probability += Math.min(Math.abs(stats.deviationPercent) / 50, 0.2);
                    }

                    probability = Math.max(0.1, Math.min(0.9, probability));
                    regressionProbability[i] = probability;
                }

                return {
                    fibonacciNumbers,
                    goldenHighNumbers,
                    goldenMidNumbers,
                    goldenLowNumbers,
                    fibonacciRatio,
                    fibonacciDeviation,
                    goldenHighRatio,
                    goldenHighDeviation,
                    goldenMidRatio,
                    goldenMidDeviation,
                    goldenLowRatio,
                    goldenLowDeviation,
                    regressionProbability,
                    period: period === 'all' ? totalDraws : period,
                    maxRedBall,
                    fibonacciRedFeature,
                    redGoldenRanges,
                    totalDraws
                };
            }

            static displayFibonacciAnalysis(analysisData) {
                this.displayFibonacciStats(analysisData);
                this.displayFibonacciFeatureChart(analysisData);
                this.displayFibonacciGoldenChart(analysisData);
                this.displayFibonacciRecommendation(analysisData);
            }

            static displayFibonacciStats(analysisData) {
                const statsDom = document.getElementById('fibonacciStats');
                if (!statsDom) return;

                const {
                    period,
                    fibonacciRatio,
                    fibonacciDeviation,
                    goldenHighRatio,
                    goldenHighDeviation,
                    goldenMidRatio,
                    goldenMidDeviation,
                    goldenLowRatio,
                    goldenLowDeviation,
                    fibonacciRedFeature,
                    redGoldenRanges
                } = analysisData;

                const stats = [
                    { label: '分析期数', value: period + '期' },
                    { label: '斐波那契特征值', value: fibonacciRedFeature.join(', ') },
                    { label: '斐波那契占比', value: (fibonacciRatio * 100).toFixed(2) + '%' },
                    { label: '斐波那契偏差', value: (fibonacciDeviation * 100).toFixed(2) + '%' },
                    { label: '高黄金区间', value: redGoldenRanges.high.join('-') },
                    { label: '高黄金占比', value: (goldenHighRatio * 100).toFixed(2) + '%' },
                    { label: '中黄金区间', value: redGoldenRanges.mid.join('-') },
                    { label: '中黄金占比', value: (goldenMidRatio * 100).toFixed(2) + '%' },
                    { label: '低黄金区间', value: redGoldenRanges.low.join('-') },
                    { label: '低黄金占比', value: (goldenLowRatio * 100).toFixed(2) + '%' }
                ];

                statsDom.innerHTML = stats.map(stat => `
                    <div class="stat-item">
                        <span class="stat-label">${stat.label}</span>
                        <span class="stat-value">${stat.value}</span>
                    </div>
                `).join('');
            }

            static displayFibonacciFeatureChart(analysisData) {
                const chartDom = document.getElementById('fibonacciFeatureChart');
                if (!chartDom) return;

                const { fibonacciNumbers, fibonacciRedFeature } = analysisData;

                const chart = echarts.init(chartDom);

                const option = {
                    title: {
                        text: '斐波那契特征值出现频率',
                        left: 'center',
                        textStyle: {
                            fontSize: 16,
                            color: '#333'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            let result = params[0].name + '期<br>';
                            params.forEach(param => {
                                result += `${param.marker}${param.seriesName}: ${param.value}<br>`;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['实际频率', '期望频率'],
                        top: 30
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: fibonacciNumbers.map(n => n.number),
                        name: '号码',
                        nameLocation: 'middle',
                        nameGap: 30
                    },
                    yAxis: {
                        type: 'value',
                        name: '频率',
                        nameLocation: 'middle',
                        nameGap: 40
                    },
                    series: [
                        {
                            name: '实际频率',
                            type: 'bar',
                            data: fibonacciNumbers.map(n => n.frequency),
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#f093fb' },
                                    { offset: 1, color: '#f5576c' }
                                ])
                            }
                        },
                        {
                            name: '期望频率',
                            type: 'line',
                            data: fibonacciNumbers.map(n => analysisData.totalDraws * 6 / analysisData.maxRedBall),
                            itemStyle: {
                                color: '#667eea'
                            },
                            lineStyle: {
                                width: 2,
                                type: 'dashed'
                            }
                        }
                    ]
                };

                chart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    chart.resize();
                });
            }

            static displayFibonacciGoldenChart(analysisData) {
                const chartDom = document.getElementById('fibonacciGoldenChart');
                if (!chartDom) return;

                const { goldenHighNumbers, goldenMidNumbers, goldenLowNumbers } = analysisData;

                const chart = echarts.init(chartDom);

                const option = {
                    title: {
                        text: '黄金分割区间号码占比',
                        left: 'center',
                        textStyle: {
                            fontSize: 16,
                            color: '#333'
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function(params) {
                            let result = params[0].name + '期<br>';
                            params.forEach(param => {
                                result += `${param.marker}${param.seriesName}: ${param.value}<br>`;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['高黄金区间', '中黄金区间', '低黄金区间'],
                        top: 30
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ['高黄金区间', '中黄金区间', '低黄金区间'],
                        name: '区间类型',
                        nameLocation: 'middle',
                        nameGap: 30
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: '占比',
                            nameLocation: 'middle',
                            nameGap: 40,
                            position: 'left',
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        },
                        {
                            type: 'value',
                            name: '偏差',
                            nameLocation: 'middle',
                            nameGap: 40,
                            position: 'right',
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        }
                    ],
                    series: [
                        {
                            name: '高黄金区间',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: [{
                                value: (analysisData.goldenHighRatio * 100).toFixed(2),
                                itemStyle: {
                                    color: '#f093fb'
                                }
                            }, 0, 0]
                        },
                        {
                            name: '中黄金区间',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: [0, {
                                value: (analysisData.goldenMidRatio * 100).toFixed(2),
                                itemStyle: {
                                    color: '#f5576c'
                                }
                            }, 0]
                        },
                        {
                            name: '低黄金区间',
                            type: 'bar',
                            yAxisIndex: 0,
                            data: [0, 0, {
                                value: (analysisData.goldenLowRatio * 100).toFixed(2),
                                itemStyle: {
                                    color: '#667eea'
                                }
                            }]
                        },
                        {
                            name: '偏差',
                            type: 'line',
                            yAxisIndex: 1,
                            data: [
                                (analysisData.goldenHighDeviation * 100).toFixed(2),
                                (analysisData.goldenMidDeviation * 100).toFixed(2),
                                (analysisData.goldenLowDeviation * 100).toFixed(2)
                            ],
                            itemStyle: {
                                color: '#ffc107'
                            },
                            lineStyle: {
                                width: 2
                            }
                        }
                    ]
                };

                chart.setOption(option);

                eventManager.on(window, 'resize', () => {
                    chart.resize();
                });
            }

            static displayFibonacciRecommendation(analysisData) {
                const recommendationDom = document.getElementById('fibonacciRecommendation');
                if (!recommendationDom) return;

                const {
                    fibonacciNumbers,
                    goldenHighNumbers,
                    goldenMidNumbers,
                    goldenLowNumbers,
                    regressionProbability,
                    fibonacciRedFeature,
                    redGoldenRanges
                } = analysisData;

                let recommendations = [];

                const highFibonacciNumbers = fibonacciNumbers
                    .filter(n => n.deviation < -10)
                    .sort((a, b) => a.deviation - b.deviation)
                    .slice(0, 5);

                if (highFibonacciNumbers.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-infinity" style="color: #f093fb;"></i>
                            <strong>斐波那契特征值推荐</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下斐波那契特征值出现频率低于期望，建议关注：</p>
                            <div>${highFibonacciNumbers.map(n => `<span class="recovery-number-tag">${n.number} (${n.deviation.toFixed(1)}%)</span>`).join('')}</div>
                        </div>
                    </div>`);
                }

                const goldenHighRecommendations = goldenHighNumbers
                    .filter(n => n.deviation < -10)
                    .sort((a, b) => a.deviation - b.deviation)
                    .slice(0, 3);

                const goldenMidRecommendations = goldenMidNumbers
                    .filter(n => n.deviation < -10)
                    .sort((a, b) => a.deviation - b.deviation)
                    .slice(0, 3);

                const goldenLowRecommendations = goldenLowNumbers
                    .filter(n => n.deviation < -10)
                    .sort((a, b) => a.deviation - b.deviation)
                    .slice(0, 3);

                if (goldenHighRecommendations.length > 0 || goldenMidRecommendations.length > 0 || goldenLowRecommendations.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-chart-line" style="color: #f5576c;"></i>
                            <strong>黄金分割区间推荐</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>以下黄金分割区间号码出现频率低于期望，建议关注：</p>
                            ${goldenHighRecommendations.length > 0 ? `<div><strong>高黄金区间(${redGoldenRanges.high.join('-')})：</strong>${goldenHighRecommendations.map(n => `<span class="recovery-number-tag">${n.number}</span>`).join('')}</div>` : ''}
                            ${goldenMidRecommendations.length > 0 ? `<div><strong>中黄金区间(${redGoldenRanges.mid.join('-')})：</strong>${goldenMidRecommendations.map(n => `<span class="recovery-number-tag">${n.number}</span>`).join('')}</div>` : ''}
                            ${goldenLowRecommendations.length > 0 ? `<div><strong>低黄金区间(${redGoldenRanges.low.join('-')})：</strong>${goldenLowRecommendations.map(n => `<span class="recovery-number-tag">${n.number}</span>`).join('')}</div>` : ''}
                        </div>
                    </div>`);
                }

                const combinations = this.generateFibonacciCombinations(regressionProbability, fibonacciRedFeature, redGoldenRanges, analysisData.maxRedBall);

                if (combinations.length > 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-star" style="color: #A8DADC;"></i>
                            <strong>参考号码组合</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>基于斐波那契数列和黄金分割规律生成的参考组合：</p>
                            <div class="combination-list">
                                ${combinations.map((combo, index) => `
                                    <div class="combination-item">
                                        <span class="combination-label">组合${index + 1}：</span>
                                        <span class="combination-numbers">${combo.numbers.sort((a, b) => a - b).map(n => `<span class="combo-ball">${n < 10 ? '0' + n : n}</span>`).join(' ')}</span>
                                        <span class="combination-prob">概率: ${combo.prob.toFixed(1)}%</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>`);
                }

                if (recommendations.length === 0) {
                    recommendations.push(`<div class="recommendation-item">
                        <div class="recommendation-header">
                            <i class="fas fa-info-circle" style="color: #95a5a6;"></i>
                            <strong>基础推荐建议</strong>
                        </div>
                        <div class="recommendation-body">
                            <p>当前分析结果特征不明显，建议采用均衡选号策略，关注斐波那契特征值（${fibonacciRedFeature.join(', ')}）和黄金分割区间号码的均匀分布。</p>
                        </div>
                    </div>`);
                }

                recommendationDom.innerHTML = recommendations.join('');
            }

            static generateFibonacciCombinations(regressionProbability, fibonacciFeature, goldenRanges, maxRedBall) {
                const combinations = [];
                const sortedNumbers = Object.entries(regressionProbability)
                    .map(([num, prob]) => ({ num: parseInt(num), prob }))
                    .sort((a, b) => b.prob - a.prob);

                for (let i = 0; i < 5; i++) {
                    const combo = [];
                    const usedNumbers = new Set();

                    const fibonacciCount = Math.floor(Math.random() * 2) + 1;
                    const goldenCount = Math.floor(Math.random() * 2) + 1;

                    const fibonacciCandidates = sortedNumbers.filter(n => fibonacciFeature.includes(n.num));
                    const goldenCandidates = sortedNumbers.filter(n => 
                        (n.num >= goldenRanges.high[0] && n.num <= goldenRanges.high[1]) ||
                        (n.num >= goldenRanges.mid[0] && n.num <= goldenRanges.mid[1]) ||
                        (n.num >= goldenRanges.low[0] && n.num <= goldenRanges.low[1])
                    );

                    for (let j = 0; j < fibonacciCount; j++) {
                        const candidates = fibonacciCandidates.filter(n => !usedNumbers.has(n.num));
                        if (candidates.length > 0) {
                            const selected = candidates[Math.floor(Math.random() * candidates.length)];
                            usedNumbers.add(selected.num);
                            combo.push(selected.num);
                        }
                    }

                    for (let j = 0; j < goldenCount; j++) {
                        const candidates = goldenCandidates.filter(n => !usedNumbers.has(n.num));
                        if (candidates.length > 0) {
                            const selected = candidates[Math.floor(Math.random() * candidates.length)];
                            usedNumbers.add(selected.num);
                            combo.push(selected.num);
                        }
                    }

                    while (combo.length < 6) {
                        const candidates = sortedNumbers.filter(n => !usedNumbers.has(n.num));
                        if (candidates.length === 0) break;

                        let selectedIndex = -1;
                        let attempts = 0;

                        while (selectedIndex === -1 && attempts < 100) {
                            const randomIndex = Math.floor(Math.random() * candidates.length);
                            const candidate = candidates[randomIndex];

                            const probabilityThreshold = Math.random();
                            if (probabilityThreshold < candidate.prob) {
                                selectedIndex = randomIndex;
                                usedNumbers.add(candidate.num);
                                combo.push(candidate.num);
                            }
                            attempts++;
                        }

                        if (selectedIndex === -1) {
                            const selected = candidates[0];
                            usedNumbers.add(selected.num);
                            combo.push(selected.num);
                        }
                    }

                    if (combo.length === 6) {
                        const avgProb = combo.reduce((sum, num) => sum + regressionProbability[num], 0) / 6;
                        combinations.push({ numbers: combo, prob: avgProb * 100 });
                    }
                }

                return combinations;
            }

            static async performMonteCarloAnalysis() {
                const periodSelect = document.getElementById('monteCarloPeriodSelect');
                const simulationsSelect = document.getElementById('monteCarloSimulations');
                const confidenceSelect = document.getElementById('monteCarloConfidence');

                const period = periodSelect.value;
                const numSimulations = parseInt(simulationsSelect.value);
                const confidenceLevel = parseFloat(confidenceSelect.value);

                MessageSystem.showMessage('正在加载分析数据...', 'info');

                try {
                    await dataManager.loadDataForCurrentLottery();
                    MessageSystem.showMessage('正在执行蒙特卡洛模拟...', 'info');

                    setTimeout(() => {
                        try {
                            const analysisData = this.calculateMonteCarloMetrics(period, numSimulations, confidenceLevel);
                            monteCarloAnalysisData = analysisData;
                            monteCarloResults = analysisData;
                            this.displayMonteCarloAnalysis(analysisData);
                            MessageSystem.showMessage('蒙特卡洛模拟完成', 'success');
                        } catch (error) {
                            console.error('蒙特卡洛模拟错误:', error);
                            MessageSystem.showMessage('蒙特卡洛模拟失败: ' + error.message, 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            static calculateMonteCarloMetrics(period, numSimulations, confidenceLevel) {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    throw new Error('没有可分析的数据，请先导入数据');
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                // 更新分析范围显示
                const monteCarloDataRangeInfo = document.getElementById('monteCarloDataRangeInfo');
                if (monteCarloDataRangeInfo && analysisData.length > 0) {
                    const startPeriod = analysisData[0].period;
                    const endPeriod = analysisData[analysisData.length - 1].period;
                    monteCarloDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;
                const totalDraws = analysisData.length;

                const historicalFrequency = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    historicalFrequency[i] = 0;
                }

                redBalls.forEach(draw => {
                    draw.forEach(ball => {
                        historicalFrequency[ball]++;
                    });
                });

                const totalNumbers = totalDraws * 6;
                const theoreticalProbability = 6 / maxRedBall;

                const historicalProbabilities = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    historicalProbabilities[i] = historicalFrequency[i] / totalNumbers;
                }

                const simulationResults = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    simulationResults[i] = {
                        historicalCount: historicalFrequency[i],
                        simulatedCount: 0,
                        estimatedProbability: 0,
                        standardError: 0,
                        confidenceInterval: { lower: 0, upper: 0 },
                        zScore: 0
                    };
                }

                for (let sim = 0; sim < numSimulations; sim++) {
                    const simulatedDraw = this.generateRandomCombination(maxRedBall, 6);
                    simulatedDraw.forEach(ball => {
                        simulationResults[ball].simulatedCount++;
                    });
                }

                const zScoreTable = {
                    0.90: 1.645,
                    0.95: 1.96,
                    0.99: 2.576
                };

                const zScore = zScoreTable[confidenceLevel] || 1.96;

                for (let i = 1; i <= maxRedBall; i++) {
                    const result = simulationResults[i];

                    result.estimatedProbability = result.simulatedCount / numSimulations;

                    const variance = result.estimatedProbability * (1 - result.estimatedProbability) / numSimulations;
                    result.standardError = Math.sqrt(variance);

                    const marginOfError = zScore * result.standardError;
                    result.confidenceInterval.lower = Math.max(0, result.estimatedProbability - marginOfError);
                    result.confidenceInterval.upper = Math.min(1, result.estimatedProbability + marginOfError);

                    const historicalProb = result.historicalCount / totalNumbers;
                    result.zScore = (historicalProb - theoreticalProbability) / Math.sqrt(theoreticalProbability * (1 - theoreticalProbability) / totalNumbers);
                }

                const sortedByProbability = Object.entries(simulationResults)
                    .map(([num, data]) => ({ num: parseInt(num), ...data }))
                    .sort((a, b) => b.estimatedProbability - a.estimatedProbability);

                const topNumbers = sortedByProbability.slice(0, 10);
                const bottomNumbers = sortedByProbability.slice(-10);

                const meanProbability = sortedByProbability.reduce((sum, item) => sum + item.estimatedProbability, 0) / maxRedBall;
                const variance = sortedByProbability.reduce((sum, item) => sum + Math.pow(item.estimatedProbability - meanProbability, 2), 0) / maxRedBall;
                const stdDev = Math.sqrt(variance);

                const combinations = this.generateMonteCarloCombinations(simulationResults, maxRedBall);

                console.log('蒙特卡洛模拟验证信息:');
                console.log(`分析期数: ${period}, 总期数: ${totalDraws}`);
                console.log(`模拟次数: ${numSimulations}`);
                console.log(`理论概率: ${(theoreticalProbability * 100).toFixed(4)}%`);
                console.log(`平均模拟概率: ${(meanProbability * 100).toFixed(4)}%`);
                console.log(`概率偏差: ${Math.abs(meanProbability - theoreticalProbability).toFixed(6)}`);
                console.log(`标准差: ${stdDev.toFixed(6)}`);

                return {
                    period,
                    numSimulations,
                    confidenceLevel,
                    maxRedBall,
                    totalDraws,
                    simulationResults,
                    sortedByProbability,
                    topNumbers,
                    bottomNumbers,
                    meanProbability,
                    variance,
                    stdDev,
                    theoreticalProbability,
                    combinations
                };
            }

            static generateWeightedCombination(probabilities, maxRedBall, count) {
                const numbers = [];
                const used = new Set();

                const sortedNumbers = Object.entries(probabilities)
                    .map(([num, prob]) => ({ num: parseInt(num), prob }))
                    .sort((a, b) => b.prob - a.prob);

                while (numbers.length < count) {
                    let selected = null;
                    let attempts = 0;

                    while (selected === null && attempts < 100) {
                        const randomIndex = Math.floor(Math.random() * sortedNumbers.length);
                        const candidate = sortedNumbers[randomIndex];

                        if (!used.has(candidate.num)) {
                            const probabilityThreshold = Math.random();
                            if (probabilityThreshold < candidate.prob * maxRedBall / 6) {
                                selected = candidate.num;
                            }
                        }
                        attempts++;
                    }

                    if (selected === null) {
                        for (const candidate of sortedNumbers) {
                            if (!used.has(candidate.num)) {
                                selected = candidate.num;
                                break;
                            }
                        }
                    }

                    if (selected !== null) {
                        used.add(selected);
                        numbers.push(selected);
                    }
                }

                return numbers;
            }

            static generateRandomCombination(maxRedBall, count) {
                const numbers = [];
                const used = new Set();

                while (numbers.length < count) {
                    const num = Math.floor(Math.random() * maxRedBall) + 1;
                    if (!used.has(num)) {
                        used.add(num);
                        numbers.push(num);
                    }
                }

                return numbers;
            }

            static generateMonteCarloCombinations(simulationResults, maxRedBall) {
                const combinations = [];
                const sortedNumbers = Object.entries(simulationResults)
                    .map(([num, data]) => ({ num: parseInt(num), prob: data.estimatedProbability, zScore: data.zScore }))
                    .sort((a, b) => b.prob - a.prob);

                for (let i = 0; i < 5; i++) {
                    const combo = [];
                    const usedNumbers = new Set();

                    const highProbCount = Math.floor(Math.random() * 3) + 2;
                    const midProbCount = Math.floor(Math.random() * 2) + 1;
                    const lowProbCount = 6 - highProbCount - midProbCount;

                    const highProbCandidates = sortedNumbers.slice(0, 10);
                    const midProbCandidates = sortedNumbers.slice(10, 20);
                    const lowProbCandidates = sortedNumbers.slice(20);

                    for (let j = 0; j < highProbCount; j++) {
                        const candidates = highProbCandidates.filter(n => !usedNumbers.has(n.num));
                        if (candidates.length > 0) {
                            const selected = candidates[Math.floor(Math.random() * candidates.length)];
                            usedNumbers.add(selected.num);
                            combo.push(selected.num);
                        }
                    }

                    for (let j = 0; j < midProbCount; j++) {
                        const candidates = midProbCandidates.filter(n => !usedNumbers.has(n.num));
                        if (candidates.length > 0) {
                            const selected = candidates[Math.floor(Math.random() * candidates.length)];
                            usedNumbers.add(selected.num);
                            combo.push(selected.num);
                        }
                    }

                    for (let j = 0; j < lowProbCount; j++) {
                        const candidates = lowProbCandidates.filter(n => !usedNumbers.has(n.num));
                        if (candidates.length > 0) {
                            const selected = candidates[Math.floor(Math.random() * candidates.length)];
                            usedNumbers.add(selected.num);
                            combo.push(selected.num);
                        }
                    }

                    if (combo.length === 6) {
                        const avgProb = combo.reduce((sum, num) => sum + simulationResults[num].estimatedProbability, 0) / 6;
                        const avgZScore = combo.reduce((sum, num) => sum + simulationResults[num].zScore, 0) / 6;
                        combinations.push({ numbers: combo, prob: avgProb * 100, zScore: avgZScore });
                    }
                }

                return combinations;
            }

            static displayMonteCarloAnalysis(analysisData) {
                const statsContainer = document.getElementById('monteCarloStats');
                const chartContainer = document.getElementById('monteCarloChart');
                const confidenceChartContainer = document.getElementById('monteCarloConfidenceChart');
                const recommendationContainer = document.getElementById('monteCarloRecommendation');

                if (statsContainer) {
                    const probabilityDeviation = Math.abs(analysisData.meanProbability - analysisData.theoreticalProbability);
                    const deviationPercent = (probabilityDeviation / analysisData.theoreticalProbability * 100).toFixed(2);

                    statsContainer.innerHTML = `
                        <div class="stat-card">
                            <div class="stat-label">模拟次数</div>
                            <div class="stat-value">${analysisData.numSimulations.toLocaleString()}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">分析期数</div>
                            <div class="stat-value">${analysisData.period === 'all' ? '全部' : analysisData.period}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">置信度</div>
                            <div class="stat-value">${(analysisData.confidenceLevel * 100).toFixed(0)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">理论概率</div>
                            <div class="stat-value">${(analysisData.theoreticalProbability * 100).toFixed(4)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">平均模拟概率</div>
                            <div class="stat-value">${(analysisData.meanProbability * 100).toFixed(4)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">概率偏差</div>
                            <div class="stat-value" style="color: ${probabilityDeviation < 0.001 ? '#28a745' : '#dc3545'}">${deviationPercent}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">标准差</div>
                            <div class="stat-value">${analysisData.stdDev.toFixed(6)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">验证状态</div>
                            <div class="stat-value" style="color: ${probabilityDeviation < 0.001 ? '#28a745' : '#ffc107'}">${probabilityDeviation < 0.001 ? '✓ 通过' : '⚠ 接近'}</div>
                        </div>
                    `;
                }

                if (chartContainer) {
                    const probabilityChart = echarts.init(chartContainer);
                    const chartData = analysisData.sortedByProbability.map(item => ({
                        name: item.num.toString(),
                        value: item.estimatedProbability * 100,
                        historical: (item.historicalCount / (analysisData.totalDraws * 6)) * 100,
                        theoretical: analysisData.theoreticalProbability * 100
                    }));

                    const option = {
                        title: {
                            text: '号码概率分布',
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'axis',
                            axisPointer: {
                                type: 'shadow'
                            },
                            formatter: function(params) {
                                let result = `<strong>号码: ${params[0].name}</strong><br/>`;
                                params.forEach(param => {
                                    result += `${param.seriesName}: ${param.value.toFixed(3)}%<br/>`;
                                });
                                return result;
                            }
                        },
                        legend: {
                            data: ['模拟概率', '历史概率', '理论概率'],
                            top: 30
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            containLabel: true
                        },
                        xAxis: {
                            type: 'category',
                            data: chartData.map(item => item.name),
                            name: '号码'
                        },
                        yAxis: {
                            type: 'value',
                            name: '概率 (%)',
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        },
                        series: [
                            {
                                name: '模拟概率',
                                type: 'bar',
                                data: chartData.map(item => item.value),
                                itemStyle: {
                                    color: '#667eea'
                                }
                            },
                            {
                                name: '历史概率',
                                type: 'line',
                                data: chartData.map(item => item.historical),
                                itemStyle: {
                                    color: '#f093fb'
                                }
                            },
                            {
                                name: '理论概率',
                                type: 'line',
                                data: chartData.map(item => item.theoretical),
                                itemStyle: {
                                    color: '#ff6b6b'
                                },
                                lineStyle: {
                                    type: 'dashed'
                                }
                            }
                        ]
                    };

                    probabilityChart.setOption(option);
                }

                if (confidenceChartContainer) {
                    const confidenceChart = echarts.init(confidenceChartContainer);
                    const confidenceData = analysisData.sortedByProbability.map(item => ({
                        name: item.num.toString(),
                        probability: item.estimatedProbability * 100,
                        lower: item.confidenceInterval.lower * 100,
                        upper: item.confidenceInterval.upper * 100
                    }));

                    const option = {
                        title: {
                            text: `置信区间 (${(analysisData.confidenceLevel * 100).toFixed(0)}%)`,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'axis',
                            formatter: function(params) {
                                const data = confidenceData[params[0].dataIndex];
                                return `<strong>号码: ${data.name}</strong><br/>
                                        概率: ${data.probability.toFixed(3)}%<br/>
                                        下限: ${data.lower.toFixed(3)}%<br/>
                                        上限: ${data.upper.toFixed(3)}%`;
                            }
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            containLabel: true
                        },
                        xAxis: {
                            type: 'category',
                            data: confidenceData.map(item => item.name),
                            name: '号码'
                        },
                        yAxis: {
                            type: 'value',
                            name: '概率 (%)',
                            axisLabel: {
                                formatter: '{value}%'
                            }
                        },
                        series: [
                            {
                                name: '概率',
                                type: 'scatter',
                                data: confidenceData.map(item => [item.name, item.probability]),
                                itemStyle: {
                                    color: '#667eea'
                                },
                                symbolSize: 8
                            },
                            {
                                name: '置信区间',
                                type: 'custom',
                                data: confidenceData.map(item => [item.name, item.lower, item.upper]),
                                renderItem: function(params, api) {
                                    const xValue = api.value(0);
                                    const lower = api.value(1);
                                    const upper = api.value(2);
                                    const yValue = (lower + upper) / 2;
                                    const height = Math.abs(upper - lower);

                                    return {
                                        type: 'rect',
                                        shape: {
                                            x: api.coord([xValue, yValue])[0] - 10,
                                            y: api.coord([xValue, upper])[1],
                                            width: 20,
                                            height: api.size([0, height])[1]
                                        },
                                        style: {
                                            fill: 'rgba(102, 126, 234, 0.2)',
                                            stroke: '#667eea'
                                        }
                                    };
                                }
                            }
                        ]
                    };

                    confidenceChart.setOption(option);
                }

                if (recommendationContainer) {
                    let html = '<div class="recommendation-list">';

                    analysisData.combinations.forEach((combo, index) => {
                        const sortedNumbers = combo.numbers.sort((a, b) => a - b);
                        const formattedNumbers = sortedNumbers.map(n => n.toString().padStart(2, '0')).join(' ');

                        html += `
                            <div class="recommendation-item">
                                <div class="recommendation-header">
                                    <span class="recommendation-title">推荐组合 ${index + 1}</span>
                                    <span class="recommendation-prob">综合概率: ${combo.prob.toFixed(2)}%</span>
                                </div>
                                <div class="recommendation-numbers">
                                    ${sortedNumbers.map(n => `<span class="number-ball">${n.toString().padStart(2, '0')}</span>`).join('')}
                                </div>
                                <div class="recommendation-details">
                                    <span>Z分数: ${combo.zScore.toFixed(3)}</span>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                    recommendationContainer.innerHTML = html;
                }
            }

            static async performComboOptimizationAnalysis() {
                const periodSelect = document.getElementById('comboOptPeriodSelect');
                const period = periodSelect.value;

                MessageSystem.showMessage('正在加载分析数据...', 'info');

                try {
                    await dataManager.loadDataForCurrentLottery();
                    MessageSystem.showMessage('正在执行组合优化分析...', 'info');

                    setTimeout(() => {
                        try {
                            const phase1Data = this.performComboOptimizationPhase1Analysis(period);
                            const analysisData = this.calculateComboOptimizationMetrics(period, phase1Data);
                            this.displayComboOptimizationAnalysis(analysisData);
                            MessageSystem.showMessage('组合优化分析完成', 'success');
                        } catch (error) {
                            console.error('组合优化分析错误:', error);
                            MessageSystem.showMessage('组合优化分析失败: ' + error.message, 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('加载数据失败:', error);
                    MessageSystem.showMessage('加载数据失败: ' + error.message, 'error');
                }
            }

            static performComboOptimizationPhase1Analysis(period) {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    return {
                        consecutivePatterns: [],
                        patternTransitions: {},
                        avgPatternSimilarity: 0
                    };
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                // 更新分析范围显示
                const comboOptDataRangeInfo = document.getElementById('comboOptDataRangeInfo');
                if (comboOptDataRangeInfo && analysisData.length > 0) {
                    const startPeriod = analysisData[0].period;
                    const endPeriod = analysisData[analysisData.length - 1].period;
                    comboOptDataRangeInfo.textContent = `分析范围：${startPeriod} - ${endPeriod}（共${analysisData.length}期）`;
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;

                const consecutivePatterns = [];
                const patternTransitions = {};
                let totalSimilarity = 0;

                for (let i = 0; i < redBalls.length - 1; i++) {
                    const currentDraw = redBalls[i].sort((a, b) => a - b);
                    const nextDraw = redBalls[i + 1].sort((a, b) => a - b);

                    const currentPattern = this.extractPatternFeatures(currentDraw, maxRedBall);
                    const nextPattern = this.extractPatternFeatures(nextDraw, maxRedBall);

                    const similarity = this.calculatePatternSimilarity(currentPattern, nextPattern);
                    totalSimilarity += similarity;

                    const transitionKey = `${currentPattern.oddEvenRatio}-${currentPattern.bigSmallRatio}-${currentPattern.zoneCounts.join(':')}`;
                    const nextTransitionKey = `${nextPattern.oddEvenRatio}-${nextPattern.bigSmallRatio}-${nextPattern.zoneCounts.join(':')}`;

                    if (!patternTransitions[transitionKey]) {
                        patternTransitions[transitionKey] = {};
                    }
                    if (!patternTransitions[transitionKey][nextTransitionKey]) {
                        patternTransitions[transitionKey][nextTransitionKey] = 0;
                    }
                    patternTransitions[transitionKey][nextTransitionKey]++;

                    consecutivePatterns.push({
                        currentPattern,
                        nextPattern,
                        similarity,
                        overlap: currentDraw.filter(n => nextDraw.includes(n)).length
                    });
                }

                const avgPatternSimilarity = consecutivePatterns.length > 0 ? totalSimilarity / consecutivePatterns.length : 0;

                return {
                    consecutivePatterns,
                    patternTransitions,
                    avgPatternSimilarity
                };
            }

            static extractPatternFeatures(draw, maxRedBall) {
                const oddCount = draw.filter(n => n % 2 === 1).length;
                const evenCount = 6 - oddCount;

                const bigCount = draw.filter(n => n > maxRedBall / 2).length;
                const smallCount = 6 - bigCount;

                const sum = draw.reduce((a, b) => a + b, 0);
                const span = draw[5] - draw[0];

                const zoneCounts = this.getThreeZoneCounts(draw, maxRedBall);

                return {
                    oddEvenRatio: `${oddCount}:${evenCount}`,
                    bigSmallRatio: `${bigCount}:${smallCount}`,
                    sum,
                    span,
                    zoneCounts
                };
            }

            static calculatePatternSimilarity(pattern1, pattern2) {
                let similarity = 0;

                if (pattern1.oddEvenRatio === pattern2.oddEvenRatio) similarity += 0.3;
                if (pattern1.bigSmallRatio === pattern2.bigSmallRatio) similarity += 0.3;
                if (pattern1.zoneCounts.join(':') === pattern2.zoneCounts.join(':')) similarity += 0.2;
                if (Math.abs(pattern1.sum - pattern2.sum) <= 10) similarity += 0.1;
                if (Math.abs(pattern1.span - pattern2.span) <= 5) similarity += 0.1;

                return similarity;
            }

            static calculateComboOptimizationMetrics(period, phase1Data) {
                const draws = currentDatabaseData.draws || [];

                if (draws.length === 0) {
                    throw new Error('没有可分析的数据，请先导入数据');
                }

                let analysisData = draws;

                if (period !== 'all') {
                    const periodNum = parseInt(period);
                    analysisData = draws.slice(-periodNum);
                }

                const redBalls = analysisData.map(d => d.redBalls.map(n => parseInt(n, 10)));
                const maxRedBall = currentLotteryType === 'ssq' ? 33 : 35;
                const totalDraws = analysisData.length;

                const historicalFrequency = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    historicalFrequency[i] = 0;
                }

                redBalls.forEach(draw => {
                    draw.forEach(ball => {
                        historicalFrequency[ball]++;
                    });
                });

                const totalNumbers = totalDraws * 6;
                const theoreticalProbability = 1 / maxRedBall;

                const numberStats = {};
                for (let i = 1; i <= maxRedBall; i++) {
                    numberStats[i] = {
                        frequency: historicalFrequency[i],
                        probability: historicalFrequency[i] / totalNumbers,
                        expectedProbability: theoreticalProbability,
                        deviation: (historicalFrequency[i] / totalNumbers) - theoreticalProbability,
                        deviationPercent: ((historicalFrequency[i] / totalNumbers - theoreticalProbability) / theoreticalProbability) * 100
                    };
                }

                const historicalPatterns = this.extractHistoricalPatterns(redBalls, maxRedBall);

                const patternWeights = this.calculatePatternWeights(historicalPatterns, totalDraws);

                const candidateCombinations = this.generateCandidateCombinations(maxRedBall, 100);

                const evaluatedCombinations = candidateCombinations.map(combo => {
                    const probabilityScore = this.calculateCombinationProbability(combo, numberStats, patternWeights);
                    const balanceScore = this.calculateCombinationBalance(combo, maxRedBall);
                    const coverageScore = this.calculateCombinationCoverage(combo, redBalls);

                    const lambda1 = 0.5;
                    const lambda2 = 0.3;
                    const lambda3 = 0.2;

                    const totalScore = lambda1 * probabilityScore + lambda2 * balanceScore + lambda3 * coverageScore;

                    return {
                        numbers: combo,
                        probabilityScore,
                        balanceScore,
                        coverageScore,
                        totalScore
                    };
                });

                const sortedCombinations = evaluatedCombinations.sort((a, b) => b.totalScore - a.totalScore);
                const topCombinations = sortedCombinations.slice(0, 5);

                const overallStats = {
                    totalPatterns: historicalPatterns.length,
                    avgPatternWeight: patternWeights.reduce((sum, w) => sum + w.weight, 0) / patternWeights.length,
                    avgProbability: Object.values(numberStats).reduce((sum, s) => sum + s.probability, 0) / maxRedBall,
                    avgDeviation: Object.values(numberStats).reduce((sum, s) => sum + Math.abs(s.deviationPercent), 0) / maxRedBall
                };

                return {
                    period,
                    maxRedBall,
                    totalDraws,
                    numberStats,
                    historicalPatterns,
                    patternWeights,
                    topCombinations,
                    overallStats,
                    phase1Data
                };
            }

            static extractHistoricalPatterns(redBalls, maxRedBall) {
                const patterns = [];

                redBalls.forEach(draw => {
                    const sortedDraw = [...draw].sort((a, b) => a - b);

                    const oddCount = sortedDraw.filter(n => n % 2 === 1).length;
                    const evenCount = 6 - oddCount;

                    const bigCount = sortedDraw.filter(n => n > maxRedBall / 2).length;
                    const smallCount = 6 - bigCount;

                    const sum = sortedDraw.reduce((a, b) => a + b, 0);
                    const span = sortedDraw[5] - sortedDraw[0];

                    const acValue = this.calculateACValue(sortedDraw);

                    const zoneCounts = this.getThreeZoneCounts(sortedDraw, maxRedBall);

                    patterns.push({
                        numbers: sortedDraw,
                        oddEvenRatio: `${oddCount}:${evenCount}`,
                        bigSmallRatio: `${bigCount}:${smallCount}`,
                        sum,
                        span,
                        acValue,
                        zoneCounts
                    });
                });

                return patterns;
            }

            static calculatePatternWeights(patterns, totalDraws) {
                const patternCounts = {};

                patterns.forEach(pattern => {
                    const key = `${pattern.oddEvenRatio}-${pattern.bigSmallRatio}-${pattern.zoneCounts.join(':')}`;
                    if (!patternCounts[key]) {
                        patternCounts[key] = {
                            count: 0,
                            pattern
                        };
                    }
                    patternCounts[key].count++;
                });

                const weightedPatterns = Object.entries(patternCounts).map(([key, data]) => {
                    const frequency = data.count / totalDraws;
                    const recencyBonus = this.calculateRecencyBonus(patterns, data.pattern);
                    const weight = frequency * (1 + recencyBonus);

                    return {
                        key,
                        pattern: data.pattern,
                        count: data.count,
                        frequency,
                        recencyBonus,
                        weight
                    };
                });

                return weightedPatterns.sort((a, b) => b.weight - a.weight);
            }

            static calculateRecencyBonus(patterns, targetPattern) {
                let recencyScore = 0;
                const recentPatterns = patterns.slice(-10);

                recentPatterns.forEach((pattern, index) => {
                    const matchScore = this.calculatePatternMatch(pattern, targetPattern);
                    recencyScore += matchScore * (1 - index / 10);
                });

                return recencyScore / recentPatterns.length;
            }

            static calculatePatternMatch(pattern1, pattern2) {
                let matchScore = 0;

                if (pattern1.oddEvenRatio === pattern2.oddEvenRatio) matchScore += 0.3;
                if (pattern1.bigSmallRatio === pattern2.bigSmallRatio) matchScore += 0.3;
                if (pattern1.zoneCounts.join(':') === pattern2.zoneCounts.join(':')) matchScore += 0.2;
                if (Math.abs(pattern1.sum - pattern2.sum) <= 10) matchScore += 0.1;
                if (Math.abs(pattern1.span - pattern2.span) <= 5) matchScore += 0.1;

                return matchScore;
            }

            static generateCandidateCombinations(maxRedBall, count) {
                const combinations = [];
                const usedCombinations = new Set();

                while (combinations.length < count) {
                    const combo = [];
                    const used = new Set();

                    while (combo.length < 6) {
                        const num = Math.floor(Math.random() * maxRedBall) + 1;
                        if (!used.has(num)) {
                            used.add(num);
                            combo.push(num);
                        }
                    }

                    combo.sort((a, b) => a - b);
                    const comboKey = combo.join(',');

                    if (!usedCombinations.has(comboKey)) {
                        usedCombinations.add(comboKey);
                        combinations.push(combo);
                    }
                }

                return combinations;
            }

            static calculateCombinationProbability(combo, numberStats, patternWeights) {
                let probability = 0;

                combo.forEach(num => {
                    probability += numberStats[num].probability;
                });

                const avgProbability = probability / 6;

                const comboPattern = {
                    oddEvenRatio: `${combo.filter(n => n % 2 === 1).length}:${combo.filter(n => n % 2 === 0).length}`,
                    bigSmallRatio: `${combo.filter(n => n > numberStats.length / 2).length}:${combo.filter(n => n <= numberStats.length / 2).length}`,
                    zoneCounts: this.getThreeZoneCounts(combo, numberStats.length)
                };

                let patternMatchScore = 0;
                const topPatterns = patternWeights.slice(0, 5);

                topPatterns.forEach(pw => {
                    patternMatchScore += this.calculatePatternMatch(comboPattern, pw.pattern) * pw.weight;
                });

                return avgProbability + patternMatchScore * 0.1;
            }

            static calculateCombinationBalance(combo, maxRedBall) {
                const oddCount = combo.filter(n => n % 2 === 1).length;
                const evenCount = 6 - oddCount;
                const oddEvenBalance = 1 - Math.abs(oddCount - evenCount) / 6;

                const bigCount = combo.filter(n => n > maxRedBall / 2).length;
                const smallCount = 6 - bigCount;
                const bigSmallBalance = 1 - Math.abs(bigCount - smallCount) / 6;

                const zoneCounts = this.getThreeZoneCounts(combo, maxRedBall);
                const expectedPerZone = 6 / 3;
                const zoneBalance = 1 - zoneCounts.reduce((sum, count) => sum + Math.abs(count - expectedPerZone), 0) / 6;

                const sum = combo.reduce((a, b) => a + b, 0);
                const expectedSum = (1 + maxRedBall) * 6 / 2;
                const sumBalance = 1 - Math.abs(sum - expectedSum) / expectedSum;

                return (oddEvenBalance + bigSmallBalance + zoneBalance + sumBalance) / 4;
            }

            static calculateCombinationCoverage(combo, historicalDraws) {
                let coverageCount = 0;
                const minMatch = 3;

                historicalDraws.forEach(draw => {
                    const matchCount = combo.filter(num => draw.includes(num)).length;
                    if (matchCount >= minMatch) {
                        coverageCount++;
                    }
                });

                return coverageCount / historicalDraws.length;
            }

            static displayComboOptimizationAnalysis(analysisData) {
                const statsContainer = document.getElementById('comboOptStats');
                const conclusionContainer = document.getElementById('comboOptConclusion');
                const chartContainer = document.getElementById('comboOptChart');
                const recommendationContainer = document.getElementById('comboOptRecommendation');

                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="stat-card">
                            <div class="stat-label">分析期数</div>
                            <div class="stat-value">${analysisData.period === 'all' ? '全部' : analysisData.period}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">历史模式数</div>
                            <div class="stat-value">${analysisData.overallStats.totalPatterns}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">平均模式权重</div>
                            <div class="stat-value">${(analysisData.overallStats.avgPatternWeight * 100).toFixed(2)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">平均号码概率</div>
                            <div class="stat-value">${(analysisData.overallStats.avgProbability * 100).toFixed(2)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">平均偏差</div>
                            <div class="stat-value">${analysisData.overallStats.avgDeviation.toFixed(2)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">逐期模式相似度</div>
                            <div class="stat-value">${(analysisData.phase1Data.avgPatternSimilarity * 100).toFixed(2)}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">推荐组合数</div>
                            <div class="stat-value">${analysisData.topCombinations.length}</div>
                        </div>
                    `;
                }

                if (conclusionContainer) {
                    const topPatterns = analysisData.patternWeights.slice(0, 5);
                    let patternHtml = '';
                    topPatterns.forEach((pw, index) => {
                        patternHtml += `<li><strong>模式${index + 1}</strong>：奇偶${pw.pattern.oddEvenRatio}，大小${pw.pattern.bigSmallRatio}，区间${pw.pattern.zoneCounts.join(':')}，权重${(pw.weight * 100).toFixed(2)}%</li>`;
                    });

                    const phase1Data = analysisData.phase1Data;
                    const highSimilarityPatterns = phase1Data.consecutivePatterns.filter(p => p.similarity > 0.7);
                    const avgOverlap = phase1Data.consecutivePatterns.length > 0 ? 
                        phase1Data.consecutivePatterns.reduce((sum, p) => sum + p.overlap, 0) / phase1Data.consecutivePatterns.length : 0;

                    let phase1Html = '';
                    if (highSimilarityPatterns.length > 0) {
                        phase1Html = `
                            <li><strong>逐期关联分析（阶段1）：</strong>相邻期号之间模式相似度较高，平均相似度为${(phase1Data.avgPatternSimilarity * 100).toFixed(2)}%，其中${highSimilarityPatterns.length}组相邻期号相似度超过70%</li>
                            <li><strong>号码重叠特征：</strong>相邻期号平均重叠${avgOverlap.toFixed(1)}个号码，${avgOverlap >= 2 ? '表明号码连续性较强，近期重复号码较多' : '表明号码连续性一般，重复号码较少'}</li>
                        `;
                    } else {
                        phase1Html = `
                            <li><strong>逐期关联分析（阶段1）：</strong>相邻期号之间模式相似度一般，平均相似度为${(phase1Data.avgPatternSimilarity * 100).toFixed(2)}%，无明显连续规律</li>
                            <li><strong>号码重叠特征：</strong>相邻期号平均重叠${avgOverlap.toFixed(1)}个号码，${avgOverlap >= 2 ? '表明号码连续性较强，近期重复号码较多' : '表明号码连续性一般，重复号码较少'}</li>
                        `;
                    }

                    conclusionContainer.innerHTML = `
                        <h4><i class="fas fa-chart-line"></i> 组合优化分析结论</h4>
                        <ul>
                            <li><strong>数据概况：</strong>基于最近${analysisData.period}期历史数据，共提取${analysisData.overallStats.totalPatterns}种号码组合模式</li>
                            ${phase1Html}
                            <li><strong>模式分析（阶段2）：</strong>历史数据显示，以下模式出现频率较高：</li>
                            ${patternHtml}
                            <li><strong>号码特征（阶段2）：</strong>平均号码概率为${(analysisData.overallStats.avgProbability * 100).toFixed(2)}%，平均偏差为${analysisData.overallStats.avgDeviation.toFixed(2)}%</li>
                            <li><strong>优化策略：</strong>基于组合概率、平衡度和覆盖度三个维度进行综合评分，同时考虑逐期关联规律，推荐以下5组最优号码组合</li>
                            <li><strong>风险提示：</strong>本算法基于历史数据统计分析，仅供娱乐参考，不保证中奖结果。彩票具有随机性，请理性投注。</li>
                        </ul>
                    `;
                }

                if (chartContainer) {
                    const chart = echarts.init(chartContainer);
                    const chartData = Object.entries(analysisData.numberStats).map(([num, stats]) => ({
                        name: num,
                        value: stats.frequency,
                        probability: stats.probability * 100,
                        deviation: stats.deviationPercent
                    }));

                    const option = {
                        title: {
                            text: '号码频率分布',
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'axis',
                            axisPointer: {
                                type: 'shadow'
                            },
                            formatter: function(params) {
                                const data = chartData[params[0].dataIndex];
                                return `<strong>号码: ${data.name}</strong><br/>
                                        出现次数: ${data.value}<br/>
                                        概率: ${data.probability.toFixed(2)}%<br/>
                                        偏差: ${data.deviation.toFixed(2)}%`;
                            }
                        },
                        legend: {
                            data: ['出现次数', '概率', '偏差'],
                            top: 30
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            containLabel: true
                        },
                        xAxis: {
                            type: 'category',
                            data: chartData.map(item => item.name),
                            name: '号码'
                        },
                        yAxis: [
                            {
                                type: 'value',
                                name: '出现次数',
                                position: 'left'
                            },
                            {
                                type: 'value',
                                name: '概率/偏差 (%)',
                                position: 'right',
                                axisLabel: {
                                    formatter: '{value}%'
                                }
                            }
                        ],
                        series: [
                            {
                                name: '出现次数',
                                type: 'bar',
                                data: chartData.map(item => item.value),
                                itemStyle: {
                                    color: '#667eea'
                                }
                            },
                            {
                                name: '概率',
                                type: 'line',
                                yAxisIndex: 1,
                                data: chartData.map(item => item.probability),
                                itemStyle: {
                                    color: '#f093fb'
                                }
                            },
                            {
                                name: '偏差',
                                type: 'line',
                                yAxisIndex: 1,
                                data: chartData.map(item => item.deviation),
                                itemStyle: {
                                    color: '#ff6b6b'
                                }
                            }
                        ]
                    };

                    chart.setOption(option);
                }

                if (recommendationContainer) {
                    let html = '<div class="recommendation-list">';

                    analysisData.topCombinations.forEach((combo, index) => {
                        const sortedNumbers = combo.numbers.sort((a, b) => a - b);

                        html += `
                            <div class="recommendation-item">
                                <div class="recommendation-header">
                                    <span class="recommendation-title">推荐组合 ${index + 1}</span>
                                    <span class="recommendation-prob">综合得分: ${combo.totalScore.toFixed(3)}</span>
                                </div>
                                <div class="recommendation-numbers">
                                    ${sortedNumbers.map(n => `<span class="number-ball">${n.toString().padStart(2, '0')}</span>`).join('')}
                                </div>
                                <div class="recommendation-details">
                                    <span>概率得分: ${combo.probabilityScore.toFixed(3)}</span>
                                    <span>平衡度得分: ${combo.balanceScore.toFixed(3)}</span>
                                    <span>覆盖度得分: ${combo.coverageScore.toFixed(3)}</span>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                    recommendationContainer.innerHTML = html;
                }
            }

            // 九转连环图相关函数
            static initJiuzhuanChart(instanceId = 'data-management-jiuzhuan') {
                // 创建或获取实例数据
                if (!this.nineRingInstances[instanceId]) {
                    this.nineRingInstances[instanceId] = {
                        selectedNumbers: []
                    };
                }

                // 每次初始化时重置selectedNumbers，确保号码不会从其他区域带入
                this.nineRingInstances[instanceId].selectedNumbers = [];

                // 第一组数据：衡十七
                const data1 = {
                    title: "衡十七",
                    numbers: [
                        ["17"],
                        ["01", "06", "07", "22", "23", "18", "27", "32"],
                        ["33", "29", "19", "12", "03", "15", "05", "20"],
                        ["21", "24", "31", "04", "16", "10", "28", "02"],
                        ["13", "09", "11", "30", "26", "25", "08", "14"]
                    ]
                };

                // 第二组数据：九为尊
                const data2 = {
                    title: "九为尊",
                    numbers: [
                        ["09"],
                        ["10", "22", "07", "30", "02", "18", "25", "24"],
                        ["23", "13", "19", "14", "29", "26", "11", "03"],
                        ["16", "01", "31", "21", "32", "17", "05", "15"],
                        ["20", "33", "12", "04", "06", "08", "28", "27"]
                    ]
                };

                // 第三组数据：三十三
                const data3 = {
                    title: "三十三",
                    numbers: [
                        ["33"],
                        ["01", "31", "13", "21", "11", "27", "07", "17"],
                        ["32", "02", "20", "12", "22", "06", "26", "16"],
                        ["15", "19", "03", "29", "05", "23", "09", "25"],
                        ["18", "14", "30", "04", "28", "10", "24", "08"]
                    ]
                };

                // 绘制九转连环图，使用实例特定的selectedNumbers
                const selectedNumbers = this.nineRingInstances[instanceId].selectedNumbers;
                this.drawNineRingCircle('circles-svg-1', data1, selectedNumbers, 1);
                this.drawNineRingCircle('circles-svg-2', data2, selectedNumbers, 1);
                this.drawNineRingCircle('circles-svg-3', data3, selectedNumbers, 1);
            }

            static refreshJiuzhuan() {
                this.initJiuzhuanChart('data-management-jiuzhuan');
                MessageSystem.showMessage('九转连环图已刷新', 'success');
            }





            // 选号系统相关函数
            static async initSelectionSystem() {
                // 初始化选号系统数据
                if (!window.selectionSystemData) {
                    window.selectionSystemData = {
                        selectedRedBalls: [],
                        selectedBlueBalls: [],
                        ssqNumberLibrary: JSON.parse(localStorage.getItem('ssqNumberLibrary')) || [],
                        dltNumberLibrary: JSON.parse(localStorage.getItem('dltNumberLibrary')) || []
                    };
                }

                // 绑定按钮事件
                const randomSelectBtn = document.getElementById('randomSelectBtn');
                if (randomSelectBtn) {
                    randomSelectBtn.removeEventListener('click', EventDelegate.handleRandomSelect);
                    randomSelectBtn.addEventListener('click', EventDelegate.handleRandomSelect);
                }

                const clearSelectionBtn = document.getElementById('clearSelectionBtn');
                if (clearSelectionBtn) {
                    clearSelectionBtn.removeEventListener('click', EventDelegate.handleClearSelection);
                    clearSelectionBtn.addEventListener('click', EventDelegate.handleClearSelection);
                }

                const saveSelectionBtn = document.getElementById('saveSelectionBtn');
                if (saveSelectionBtn) {
                    saveSelectionBtn.removeEventListener('click', EventDelegate.handleSaveSelection);
                    saveSelectionBtn.addEventListener('click', EventDelegate.handleSaveSelection);
                }

                const resetConditionBtn = document.getElementById('resetConditionBtn');
                if (resetConditionBtn) {
                    resetConditionBtn.removeEventListener('click', EventDelegate.handleResetCondition);
                    resetConditionBtn.addEventListener('click', EventDelegate.handleResetCondition);
                }

                const luckyDrawBtn = document.getElementById('luckyDrawBtn');
                if (luckyDrawBtn) {
                    luckyDrawBtn.removeEventListener('click', EventDelegate.handleLuckyDraw);
                    luckyDrawBtn.addEventListener('click', EventDelegate.handleLuckyDraw);
                }

                // 生成幻方网格
                EventDelegate.generateMagicSquareGrid();

                // 渲染号码库
                await EventDelegate.renderNumberLibrary();

                // 更新选号显示
                await EventDelegate.updateSelectionDisplay();

                // 更新幻方高亮
                EventDelegate.updateMagicSquareHighlight();

                // 初始化九转连环图
                EventDelegate.initNineRingDiagram('selection-system-jiuzhuan');
            }

            static async handleRandomSelect() {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxRed = rules.redBallCount;
                const maxBlue = rules.blueBallCount;
                const redRange = rules.redBallRange[1];
                const blueRange = rules.blueBallRange[1];

                const conditions = EventDelegate.getConditionSettings();

                let attempts = 0;
                const maxAttempts = 10000;
                let foundValidNumber = false;

                while (attempts < maxAttempts && !foundValidNumber) {
                    window.selectionSystemData.selectedRedBalls = [];
                    window.selectionSystemData.selectedBlueBalls = [];

                    while (window.selectionSystemData.selectedRedBalls.length < maxRed) {
                        const num = Math.floor(Math.random() * redRange) + 1;
                        if (!window.selectionSystemData.selectedRedBalls.includes(num)) {
                            window.selectionSystemData.selectedRedBalls.push(num);
                        }
                    }
                    window.selectionSystemData.selectedRedBalls.sort((a, b) => a - b);

                    while (window.selectionSystemData.selectedBlueBalls.length < maxBlue) {
                        const num = Math.floor(Math.random() * blueRange) + 1;
                        if (!window.selectionSystemData.selectedBlueBalls.includes(num)) {
                            window.selectionSystemData.selectedBlueBalls.push(num);
                        }
                    }
                    window.selectionSystemData.selectedBlueBalls.sort((a, b) => a - b);

                    if (EventDelegate.validateConditions(window.selectionSystemData.selectedRedBalls, conditions)) {
                        foundValidNumber = true;
                    }

                    attempts++;
                }

                if (!foundValidNumber) {
                    MessageSystem.showMessage('未找到符合条件的号码，请调整条件后重试', 'warning');
                    return;
                }

                await EventDelegate.updateSelectionDisplay();
                EventDelegate.updateMagicSquareHighlight();
                EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');
                MessageSystem.showMessage(`已随机选择号码（尝试${attempts}次）`, 'success');
            }

            static async randomSelectRedBalls() {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxRed = rules.redBallCount;
                const redRange = rules.redBallRange[1];

                window.selectionSystemData.selectedRedBalls = [];

                while (window.selectionSystemData.selectedRedBalls.length < maxRed) {
                    const num = Math.floor(Math.random() * redRange) + 1;
                    if (!window.selectionSystemData.selectedRedBalls.includes(num)) {
                        window.selectionSystemData.selectedRedBalls.push(num);
                    }
                }
                window.selectionSystemData.selectedRedBalls.sort((a, b) => a - b);

                await EventDelegate.updateSelectionDisplay();
                EventDelegate.updateMagicSquareHighlight();
                EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');
                MessageSystem.showMessage(`已机选红球: ${window.selectionSystemData.selectedRedBalls.join(', ')}`, 'success');
            }

            static async randomSelectBlueBalls() {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxBlue = rules.blueBallCount;
                const blueRange = rules.blueBallRange[1];

                window.selectionSystemData.selectedBlueBalls = [];

                while (window.selectionSystemData.selectedBlueBalls.length < maxBlue) {
                    const num = Math.floor(Math.random() * blueRange) + 1;
                    if (!window.selectionSystemData.selectedBlueBalls.includes(num)) {
                        window.selectionSystemData.selectedBlueBalls.push(num);
                    }
                }
                window.selectionSystemData.selectedBlueBalls.sort((a, b) => a - b);

                await EventDelegate.updateSelectionDisplay();
                EventDelegate.updateMagicSquareHighlight();
                EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');
                MessageSystem.showMessage(`已机选蓝球: ${window.selectionSystemData.selectedBlueBalls.join(', ')}`, 'success');
            }

            static getConditionSettings() {
                return {
                    sumMin: parseInt(document.getElementById('conditionSumMin').value) || null,
                    sumMax: parseInt(document.getElementById('conditionSumMax').value) || null,
                    spanMin: parseInt(document.getElementById('conditionSpanMin').value) || null,
                    spanMax: parseInt(document.getElementById('conditionSpanMax').value) || null,
                    consecutive: document.getElementById('conditionConsecutive').value || null,
                    threeZone: document.getElementById('conditionThreeZone').value || null,
                    oddEven: document.getElementById('conditionOddEven').value || null,
                    acMin: parseInt(document.getElementById('conditionACMin').value) || null,
                    acMax: parseInt(document.getElementById('conditionACMax').value) || null,
                    bigSmall: document.getElementById('conditionBigSmall').value || null,
                    primeComposite: document.getElementById('conditionPrimeComposite').value || null
                };
            }

            static validateConditions(numbers, conditions) {
                if (!conditions) return true;

                const sum = numbers.reduce((a, b) => a + b, 0);
                const span = Math.max(...numbers) - Math.min(...numbers);

                if (conditions.sumMin !== null && sum < conditions.sumMin) return false;
                if (conditions.sumMax !== null && sum > conditions.sumMax) return false;

                if (conditions.spanMin !== null && span < conditions.spanMin) return false;
                if (conditions.spanMax !== null && span > conditions.spanMax) return false;

                if (conditions.consecutive !== null) {
                    if (conditions.consecutive === '0') {
                        const hasConsecutive = EventDelegate.checkConsecutive(numbers, currentLotteryType);
                        if (hasConsecutive) return false;
                    } else {
                        const consecutiveDetails = EventDelegate.getConsecutiveDetails(numbers, currentLotteryType);
                        const conditionsList = conditions.consecutive.split(',');

                        for (const condition of conditionsList) {
                            const [count, length] = condition.split('-').map(Number);

                            if (length === 2) {
                                if (consecutiveDetails.twoConsecutive !== count) return false;
                            } else if (length === 3) {
                                if (consecutiveDetails.threeConsecutive !== count) return false;
                            } else if (length === 4) {
                                if (consecutiveDetails.fourConsecutive !== count) return false;
                            } else if (length === 5) {
                                if (consecutiveDetails.fiveConsecutive !== count) return false;
                            } else if (length === 6) {
                                if (consecutiveDetails.sixConsecutive !== count) return false;
                            }
                        }
                    }
                }

                if (conditions.threeZone) {
                    const zoneCounts = EventDelegate.getThreeZoneCounts(numbers, currentLotteryType);
                    const expectedZone = conditions.threeZone.split(':').map(Number);
                    if (zoneCounts[0] !== expectedZone[0] || zoneCounts[1] !== expectedZone[1] || zoneCounts[2] !== expectedZone[2]) {
                        return false;
                    }
                }

                if (conditions.oddEven) {
                    const oddEvenCount = EventDelegate.getOddEvenCount(numbers);
                    const expectedOddEven = conditions.oddEven.split(':').map(Number);
                    if (oddEvenCount[0] !== expectedOddEven[0] || oddEvenCount[1] !== expectedOddEven[1]) {
                        return false;
                    }
                }

                const acValue = EventDelegate.calculateACValue(numbers);
                if (conditions.acMin !== null && acValue < conditions.acMin) return false;
                if (conditions.acMax !== null && acValue > conditions.acMax) return false;

                if (conditions.bigSmall) {
                    const bigSmallCount = EventDelegate.getBigSmallCount(numbers, currentLotteryType);
                    const expectedBigSmall = conditions.bigSmall.split(':').map(Number);
                    if (bigSmallCount[0] !== expectedBigSmall[0] || bigSmallCount[1] !== expectedBigSmall[1]) {
                        return false;
                    }
                }

                if (conditions.primeComposite) {
                    const primeCompositeCount = EventDelegate.getPrimeCompositeCount(numbers);
                    const expectedPrimeComposite = conditions.primeComposite.split(':').map(Number);
                    if (primeCompositeCount[0] !== expectedPrimeComposite[0] || primeCompositeCount[1] !== expectedPrimeComposite[1]) {
                        return false;
                    }
                }

                return true;
            }

            static checkConsecutive(numbers, lotteryType = 'ssq') {
                const sortedNums = [...numbers].sort((a, b) => a - b);
                for (let i = 0; i < sortedNums.length - 1; i++) {
                    if (sortedNums[i + 1] - sortedNums[i] === 1) {
                        return true;
                    }
                }
                return false;
            }

            static getConsecutiveDetails(numbers, lotteryType = 'ssq') {
                const sortedNums = [...numbers].sort((a, b) => a - b);
                let consecutiveGroups = [];
                let currentGroup = [sortedNums[0]];

                for (let i = 0; i < sortedNums.length - 1; i++) {
                    if (sortedNums[i + 1] - sortedNums[i] === 1) {
                        currentGroup.push(sortedNums[i + 1]);
                    } else {
                        if (currentGroup.length > 1) {
                            consecutiveGroups.push([...currentGroup]);
                        }
                        currentGroup = [sortedNums[i + 1]];
                    }
                }
                if (currentGroup.length > 1) {
                    consecutiveGroups.push([...currentGroup]);
                }

                const details = {
                    hasConsecutive: consecutiveGroups.length > 0,
                    groups: consecutiveGroups,
                    twoConsecutive: 0,
                    threeConsecutive: 0,
                    fourConsecutive: 0,
                    fiveConsecutive: 0,
                    sixConsecutive: 0
                };

                consecutiveGroups.forEach(group => {
                    if (group.length === 2) details.twoConsecutive++;
                    else if (group.length === 3) details.threeConsecutive++;
                    else if (group.length === 4) details.fourConsecutive++;
                    else if (group.length === 5) details.fiveConsecutive++;
                    else if (group.length === 6) details.sixConsecutive++;
                });

                return details;
            }

            static getThreeZoneCounts(numbers, param) {
                let zone1 = 0, zone2 = 0, zone3 = 0;
                let lotteryType = 'ssq';
                
                if (typeof param === 'string') {
                    lotteryType = param;
                } else if (typeof param === 'number') {
                    lotteryType = param === 33 ? 'ssq' : 'dlt';
                }
                
                if (lotteryType === 'ssq') {
                    zone1 = numbers.filter(n => n >= 1 && n <= 11).length;
                    zone2 = numbers.filter(n => n >= 12 && n <= 22).length;
                    zone3 = numbers.filter(n => n >= 23 && n <= 33).length;
                } else if (lotteryType === 'dlt') {
                    zone1 = numbers.filter(n => n >= 1 && n <= 12).length;
                    zone2 = numbers.filter(n => n >= 13 && n <= 24).length;
                    zone3 = numbers.filter(n => n >= 25 && n <= 35).length;
                }
                return [zone3, zone2, zone1];
            }

            static getOddEvenCount(numbers) {
                const odd = numbers.filter(n => n % 2 === 1).length;
                const even = numbers.filter(n => n % 2 === 0).length;
                return [odd, even];
            }

            static calculateACValue(numbers) {
                let differences = new Set();
                for (let i = 0; i < numbers.length; i++) {
                    for (let j = i + 1; j < numbers.length; j++) {
                        differences.add(Math.abs(numbers[i] - numbers[j]));
                    }
                }
                return differences.size - (numbers.length - 1);
            }

            static calculateDiversityScore(numbers) {
                let score = 0;
                const sorted = [...numbers].sort((a, b) => a - b);

                const span = sorted[sorted.length - 1] - sorted[0];
                if (span >= 25) {
                    score += 0.3;
                } else if (span >= 20) {
                    score += 0.25;
                } else if (span >= 15) {
                    score += 0.2;
                } else if (span >= 10) {
                    score += 0.15;
                }

                const intervals = [0, 0, 0, 0, 0];
                sorted.forEach(num => {
                    if (num >= 1 && num <= 6) intervals[0]++;
                    else if (num >= 7 && num <= 12) intervals[1]++;
                    else if (num >= 13 && num <= 18) intervals[2]++;
                    else if (num >= 19 && num <= 24) intervals[3]++;
                    else if (num >= 25 && num <= 33) intervals[4]++;
                });
                const nonEmptyIntervals = intervals.filter(count => count > 0).length;
                if (nonEmptyIntervals >= 5) {
                    score += 0.3;
                } else if (nonEmptyIntervals >= 4) {
                    score += 0.25;
                } else if (nonEmptyIntervals >= 3) {
                    score += 0.2;
                } else if (nonEmptyIntervals >= 2) {
                    score += 0.1;
                }

                const tails = new Set();
                sorted.forEach(num => tails.add(num % 10));
                if (tails.size >= 6) {
                    score += 0.2;
                } else if (tails.size >= 5) {
                    score += 0.15;
                } else if (tails.size >= 4) {
                    score += 0.1;
                }

                let consecutiveCount = 0;
                for (let i = 0; i < sorted.length - 1; i++) {
                    if (sorted[i + 1] - sorted[i] === 1) {
                        consecutiveCount++;
                    }
                }
                if (consecutiveCount === 1) {
                    score += 0.1;
                } else if (consecutiveCount >= 2) {
                    score += 0.05;
                }

                const distances = [];
                for (let i = 0; i < sorted.length - 1; i++) {
                    distances.push(sorted[i + 1] - sorted[i]);
                }
                const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
                const distanceVariance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
                if (distanceVariance > 4) {
                    score += 0.1;
                } else if (distanceVariance > 2) {
                    score += 0.05;
                }

                return Math.min(score, 1);
            }

            static getBigSmallCount(numbers, lotteryType = 'ssq') {
                let big = 0, small = 0;
                if (lotteryType === 'ssq') {
                    big = numbers.filter(n => n >= 17).length;
                    small = numbers.filter(n => n <= 16).length;
                } else if (lotteryType === 'dlt') {
                    big = numbers.filter(n => n >= 18).length;
                    small = numbers.filter(n => n <= 17).length;
                }
                return [big, small];
            }

            static getPrimeCompositeCount(numbers) {
                const primes = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
                const prime = numbers.filter(n => primes.includes(n)).length;
                const composite = numbers.filter(n => !primes.includes(n) && n > 1).length;
                return [prime, composite];
            }

            static async handleClearSelection() {
                window.selectionSystemData.selectedRedBalls = [];
                window.selectionSystemData.selectedBlueBalls = [];
                await EventDelegate.updateSelectionDisplay();
                EventDelegate.updateMagicSquareHighlight();
                EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');
                MessageSystem.showMessage('已清除选号', 'info');
            }

            static async handleSaveSelection() {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxRed = rules.redBallCount;
                const maxBlue = rules.blueBallCount;

                if (window.selectionSystemData.selectedRedBalls.length !== maxRed) {
                    MessageSystem.showMessage(`请选择${maxRed}个${rules.redBallName}`, 'warning');
                    return;
                }

                if (window.selectionSystemData.selectedBlueBalls.length !== maxBlue) {
                    MessageSystem.showMessage(`请选择${maxBlue}个${rules.blueBallName}`, 'warning');
                    return;
                }

                const redStr = window.selectionSystemData.selectedRedBalls.map(n => String(n).padStart(2, '0')).join(',');
                const blueStr = window.selectionSystemData.selectedBlueBalls.map(n => String(n).padStart(2, '0')).join(',');
                const fullNumber = `${redStr}+${blueStr}`;

                const currentLibrary = lotteryType === 'ssq' ? 
                    window.selectionSystemData.ssqNumberLibrary : 
                    window.selectionSystemData.dltNumberLibrary;

                if (currentLibrary.some(item => item.numbers === fullNumber)) {
                    MessageSystem.showMessage('该号码组合已存在于号码库中', 'warning');
                    return;
                }

                currentLibrary.unshift({
                    id: Date.now(),
                    numbers: fullNumber,
                    reds: [...window.selectionSystemData.selectedRedBalls],
                    blues: [...window.selectionSystemData.selectedBlueBalls],
                    timestamp: new Date().toLocaleString(),
                    selected: false
                });

                localStorage.setItem(
                    lotteryType === 'ssq' ? 'ssqNumberLibrary' : 'dltNumberLibrary', 
                    JSON.stringify(currentLibrary)
                );

                await EventDelegate.renderNumberLibrary();
                MessageSystem.showMessage('号码已保存到号码库', 'success');
                EventDelegate.handleClearSelection();
            }

            static handleResetCondition() {
                document.getElementById('conditionSumMin').value = '';
                document.getElementById('conditionSumMax').value = '';
                document.getElementById('conditionSpanMin').value = '';
                document.getElementById('conditionSpanMax').value = '';
                document.getElementById('conditionConsecutive').value = '';
                document.getElementById('conditionThreeZone').value = '';
                document.getElementById('conditionOddEven').value = '';
                document.getElementById('conditionACMin').value = '';
                document.getElementById('conditionACMax').value = '';
                document.getElementById('conditionBigSmall').value = '';
                document.getElementById('conditionPrimeComposite').value = '';
                MessageSystem.showMessage('条件已重置', 'info');
            }

            static handleLuckyDraw() {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxRed = rules.redBallCount;
                const maxBlue = rules.blueBallCount;
                const redRange = rules.redBallRange[1];
                const blueRange = rules.blueBallRange[1];

                const luckyDrawBtn = document.getElementById('luckyDrawBtn');
                luckyDrawBtn.disabled = true;
                luckyDrawBtn.textContent = '🍀 幸运出号中...';

                let duration = 8000;
                let intervalTime = 50;
                let elapsed = 0;

                const interval = setInterval(() => {
                    elapsed += intervalTime;

                    window.selectionSystemData.selectedRedBalls = [];
                    window.selectionSystemData.selectedBlueBalls = [];

                    while (window.selectionSystemData.selectedRedBalls.length < maxRed) {
                        const num = Math.floor(Math.random() * redRange) + 1;
                        if (!window.selectionSystemData.selectedRedBalls.includes(num)) {
                            window.selectionSystemData.selectedRedBalls.push(num);
                        }
                    }
                    window.selectionSystemData.selectedRedBalls.sort((a, b) => a - b);

                    while (window.selectionSystemData.selectedBlueBalls.length < maxBlue) {
                        const num = Math.floor(Math.random() * blueRange) + 1;
                        if (!window.selectionSystemData.selectedBlueBalls.includes(num)) {
                            window.selectionSystemData.selectedBlueBalls.push(num);
                        }
                    }
                    window.selectionSystemData.selectedBlueBalls.sort((a, b) => a - b);

                    EventDelegate.updateSelectionDisplay();
                    EventDelegate.updateMagicSquareHighlight();
                    EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');

                    if (elapsed >= duration) {
                        clearInterval(interval);
                        luckyDrawBtn.disabled = false;
                        luckyDrawBtn.textContent = '🍀 幸运出号';
                        MessageSystem.showMessage('幸运出号完成！', 'success');
                    }
                }, intervalTime);
            }

            static updateMagicSquareGridByLotteryType() {
                // 更新红球格子状态
                const redCells = document.querySelectorAll('#redMagicSquare .magic-square-cell[data-type="red"]');
                redCells.forEach(cell => {
                    const number = parseInt(cell.getAttribute('data-number'));

                    // 移除之前的禁用样式
                    cell.classList.remove('disabled');
                    cell.style.opacity = '';
                    cell.style.cursor = '';

                    // 根据彩票类型设置禁用状态
                    if (currentLotteryType === 'ssq') {
                        // 双色球时34,35,36禁用
                        if (number >= 34 && number <= 36) {
                            cell.classList.add('disabled');
                            cell.style.opacity = '0.5';
                            cell.style.cursor = 'not-allowed';
                        }
                    } else if (currentLotteryType === 'dlt') {
                        // 大乐透时36禁用
                        if (number === 36) {
                            cell.classList.add('disabled');
                            cell.style.opacity = '0.5';
                            cell.style.cursor = 'not-allowed';
                        }
                    }
                });

                // 更新蓝球格子状态
                const blueCells = document.querySelectorAll('#blueMagicSquare .magic-square-cell[data-type="blue"]');
                blueCells.forEach(cell => {
                    const number = parseInt(cell.getAttribute('data-number'));

                    // 移除之前的禁用样式
                    cell.classList.remove('disabled');
                    cell.style.opacity = '';
                    cell.style.cursor = '';

                    // 根据彩票类型设置禁用状态
                    if (currentLotteryType === 'dlt') {
                        // 大乐透时13-16号蓝球禁用
                        if (number >= 13 && number <= 16) {
                            cell.classList.add('disabled');
                            cell.style.opacity = '0.5';
                            cell.style.cursor = 'not-allowed';
                        }
                    }
                });
            }

            static generateMagicSquareGrid() {
                const redSquare = document.getElementById('redMagicSquare');
                const blueSquare = document.getElementById('blueMagicSquare');

                if (redSquare) {
                    redSquare.innerHTML = '';

                    // 生成六阶幻方（6x6=36个位置，使用指定顺序）
                    const redNumbers = [28, 4, 3, 31, 35, 10, 36, 18, 21, 24, 11, 1, 7, 23, 12, 17, 22, 30, 8, 13, 26, 19, 16, 29, 5, 20, 15, 14, 25, 32, 27, 33, 34, 6, 2, 9];

                    for (let i = 0; i < redNumbers.length; i++) {
                        const number = redNumbers[i];
                        const cell = document.createElement('div');
                        cell.className = 'magic-square-cell';
                        cell.textContent = String(number).padStart(2, '0');
                        cell.setAttribute('data-number', number);
                        cell.setAttribute('data-type', 'red');

                        // 根据彩票类型设置禁用状态
                        if (currentLotteryType === 'ssq') {
                            // 双色球时34,35,36禁用
                            if (number >= 34 && number <= 36) {
                                cell.classList.add('disabled');
                                cell.style.opacity = '0.5';
                                cell.style.cursor = 'not-allowed';
                            }
                        } else if (currentLotteryType === 'dlt') {
                            // 大乐透时36禁用
                            if (number === 36) {
                                cell.classList.add('disabled');
                                cell.style.opacity = '0.5';
                                cell.style.cursor = 'not-allowed';
                            }
                        }

                        cell.addEventListener('click', () => {
                            if (!cell.classList.contains('disabled')) {
                                EventDelegate.toggleRedBall(number);
                            }
                        });
                        redSquare.appendChild(cell);
                    }
                }

                if (blueSquare) {
                    blueSquare.innerHTML = '';

                    // 生成四幻图（4x4=16个位置，使用指定顺序）
                    const blueNumbers = [4, 9, 5, 16, 14, 7, 11, 2, 15, 6, 10, 3, 1, 12, 8, 13];

                    for (let i = 0; i < blueNumbers.length; i++) {
                        const number = blueNumbers[i];
                        const cell = document.createElement('div');
                        cell.className = 'magic-square-cell';
                        cell.textContent = String(number).padStart(2, '0');
                        cell.setAttribute('data-number', number);
                        cell.setAttribute('data-type', 'blue');

                        // 根据彩票类型设置禁用状态
                        if (currentLotteryType === 'dlt' && (number === 13 || number === 14 || number === 15 || number === 16)) {
                            // 大乐透时13-16号蓝球禁用
                            cell.classList.add('disabled');
                            cell.style.opacity = '0.5';
                            cell.style.cursor = 'not-allowed';
                        }

                        cell.addEventListener('click', () => {
                            if (!cell.classList.contains('disabled')) {
                                EventDelegate.toggleBlueBall(number);
                            }
                        });
                        blueSquare.appendChild(cell);
                    }
                }
            }

            static async toggleRedBall(number) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxRed = rules.redBallCount;

                const index = window.selectionSystemData.selectedRedBalls.indexOf(number);
                if (index > -1) {
                    window.selectionSystemData.selectedRedBalls.splice(index, 1);
                } else {
                    if (window.selectionSystemData.selectedRedBalls.length < maxRed) {
                        window.selectionSystemData.selectedRedBalls.push(number);
                        window.selectionSystemData.selectedRedBalls.sort((a, b) => a - b);
                    } else {
                        MessageSystem.showMessage(`最多只能选择${maxRed}个${rules.redBallName}`, 'warning');
                        return;
                    }
                }

                await EventDelegate.updateSelectionDisplay();
                EventDelegate.updateMagicSquareHighlight();
                EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');
            }

            static async toggleBlueBall(number) {
                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxBlue = rules.blueBallCount;

                const index = window.selectionSystemData.selectedBlueBalls.indexOf(number);
                if (index > -1) {
                    window.selectionSystemData.selectedBlueBalls.splice(index, 1);
                } else {
                    if (window.selectionSystemData.selectedBlueBalls.length < maxBlue) {
                        window.selectionSystemData.selectedBlueBalls.push(number);
                        window.selectionSystemData.selectedBlueBalls.sort((a, b) => a - b);
                    } else {
                        MessageSystem.showMessage(`最多只能选择${maxBlue}个${rules.blueBallName}`, 'warning');
                        return;
                    }
                }

                await EventDelegate.updateSelectionDisplay();
                EventDelegate.updateMagicSquareHighlight();
                EventDelegate.updateNineRingHighlight('selection-system-jiuzhuan');
            }

            static async updateSelectionDisplay() {
                const display = document.getElementById('selectedNumbersDisplay');
                const countDisplay = document.getElementById('selectionCount');
                const metricsDisplay = document.getElementById('selectionMetrics');

                if (!display || !countDisplay) return;

                const lotteryType = currentLotteryType;
                const rules = LOTTERY_RULES[lotteryType];
                const maxRed = rules.redBallCount;
                const maxBlue = rules.blueBallCount;

                countDisplay.textContent = `${rules.redBallName}: ${window.selectionSystemData.selectedRedBalls.length}/${maxRed} | ${rules.blueBallName}: ${window.selectionSystemData.selectedBlueBalls.length}/${maxBlue}`;

                display.innerHTML = '';

                if (window.selectionSystemData.selectedRedBalls.length === 0 && 
                    window.selectionSystemData.selectedBlueBalls.length === 0) {
                    display.innerHTML = '<div style="color: #6c757d;">尚未选择号码</div>';
                    if (metricsDisplay) metricsDisplay.innerHTML = '<div style="color: #6c757d;">暂无数据</div>';
                } else {
                    const libraryRow = document.createElement('div');
                    libraryRow.className = 'library-row';
                    libraryRow.style.padding = '12px 15px';
                    libraryRow.style.marginBottom = '10px';
                    libraryRow.style.backgroundColor = '#f8f9fa';
                    libraryRow.style.borderRadius = '8px';
                    libraryRow.style.fontSize = '0.9rem';
                    libraryRow.style.gap = '15px';
                    libraryRow.style.display = 'flex';
                    libraryRow.style.alignItems = 'center';

                    const rowNumbers = document.createElement('div');
                    rowNumbers.className = 'row-numbers';
                    rowNumbers.style.display = 'flex';
                    rowNumbers.style.alignItems = 'center';
                    rowNumbers.style.flex = '1';
                    rowNumbers.style.padding = '5px 0';
                    rowNumbers.style.minHeight = '40px';
                    rowNumbers.style.gap = '8px';

                    if (window.selectionSystemData.selectedRedBalls.length > 0) {
                        const redsSpan = document.createElement('span');
                        redsSpan.className = 'red-numbers';
                        redsSpan.style.display = 'flex';
                        redsSpan.style.gap = '5px';
                        
                        window.selectionSystemData.selectedRedBalls.forEach(num => {
                            const redBall = document.createElement('span');
                            redBall.style.display = 'inline-flex';
                            redBall.style.alignItems = 'center';
                            redBall.style.justifyContent = 'center';
                            redBall.style.width = '32px';
                            redBall.style.height = '32px';
                            redBall.style.borderRadius = '50%';
                            redBall.style.backgroundColor = '#E63946';
                            redBall.style.color = 'white';
                            redBall.style.fontWeight = 'bold';
                            redBall.style.fontSize = '14px';
                            redBall.textContent = String(num).padStart(2, '0');
                            redsSpan.appendChild(redBall);
                        });
                        
                        rowNumbers.appendChild(redsSpan);
                    }

                    if (window.selectionSystemData.selectedRedBalls.length > 0 && 
                        window.selectionSystemData.selectedBlueBalls.length > 0) {
                        const plusSpan = document.createElement('span');
                        plusSpan.className = 'row-plus';
                        plusSpan.textContent = '+';
                        plusSpan.style.margin = '0 8px';
                        plusSpan.style.fontWeight = 'bold';
                        plusSpan.style.color = '#6c757d';
                        plusSpan.style.fontSize = '16px';
                        rowNumbers.appendChild(plusSpan);
                    }

                    if (window.selectionSystemData.selectedBlueBalls.length > 0) {
                        const blueSpan = document.createElement('span');
                        blueSpan.className = 'blue-number';
                        blueSpan.style.display = 'flex';
                        blueSpan.style.gap = '5px';
                        
                        window.selectionSystemData.selectedBlueBalls.forEach(num => {
                            const blueBall = document.createElement('span');
                            blueBall.style.display = 'inline-flex';
                            blueBall.style.alignItems = 'center';
                            blueBall.style.justifyContent = 'center';
                            blueBall.style.width = '32px';
                            blueBall.style.height = '32px';
                            blueBall.style.borderRadius = '50%';
                            blueBall.style.backgroundColor = '#457B9D';
                            blueBall.style.color = 'white';
                            blueBall.style.fontWeight = 'bold';
                            blueBall.style.fontSize = '14px';
                            blueBall.textContent = String(num).padStart(2, '0');
                            blueSpan.appendChild(blueBall);
                        });
                        
                        rowNumbers.appendChild(blueSpan);
                    }

                    libraryRow.appendChild(rowNumbers);
                    display.appendChild(libraryRow);

                    if (metricsDisplay) {
                        const metrics = EventDelegate.calculateAnalysisMetrics(window.selectionSystemData.selectedRedBalls, currentLotteryType);
                        const historicalPrize = await EventDelegate.queryHistoricalHighestPrize(window.selectionSystemData.selectedRedBalls, window.selectionSystemData.selectedBlueBalls);

                        let historicalPrizeText = '';
                        let historicalPrizeColor = '#000000';
                        if (historicalPrize.prizeLevel === '暂无数据') {
                            historicalPrizeText = '历史最高：暂无数据';
                            historicalPrizeColor = '#6c757d';
                        } else if (historicalPrize.prizeLevel === '未中奖') {
                            historicalPrizeText = '历史最高：未中奖';
                            historicalPrizeColor = '#6c757d';
                        } else {
                            historicalPrizeColor = historicalPrize.prizeLevel.includes('一等奖') ? '#dc3545' :
                                                  historicalPrize.prizeLevel.includes('二等奖') ? '#fd7e14' :
                                                  historicalPrize.prizeLevel.includes('三等奖') ? '#ffc107' :
                                                  historicalPrize.prizeLevel.includes('四等奖') ? '#20c997' :
                                                  historicalPrize.prizeLevel.includes('五等奖') ? '#0dcaf0' :
                                                  historicalPrize.prizeLevel.includes('六等奖') ? '#6f42c1' :
                                                  historicalPrize.prizeLevel.includes('福运奖') ? '#17a2b8' :
                                                  historicalPrize.prizeLevel.includes('好运奖') ? '#e83e8c' :
                                                  '#adb5bd';
                            historicalPrizeText = `<span style="color: #000000;">历史最高：</span><span style="color: ${historicalPrizeColor}; font-weight: bold;">${historicalPrize.prizeLevel}</span><span style="color: #000000;">(${historicalPrize.prizeCount}次)</span>`;
                        }

                        metricsDisplay.innerHTML = `
                            <div class="metric-item"><span class="metric-label">和值:</span><span class="metric-value">${metrics.sum || 0}</span></div>
                            <div class="metric-item"><span class="metric-label">跨度:</span><span class="metric-value">${metrics.span || 0}</span></div>
                            <div class="metric-item"><span class="metric-label">连号:</span><span class="metric-value">${metrics.consecutive || 0}</span></div>
                            <div class="metric-item"><span class="metric-label">大中小:</span><span class="metric-value">${metrics.zoneDistribution || '0-0-0'}</span></div>
                            <div class="metric-item"><span class="metric-label">奇偶:</span><span class="metric-value">${metrics.oddEvenRatio || '0:0'}</span></div>
                            <div class="metric-item"><span class="metric-label">AC值:</span><span class="metric-value">${metrics.acValue || 0}</span></div>
                            <div class="metric-item"><span class="metric-label">大小比:</span><span class="metric-value">${metrics.bigSmallRatio || '0:0'}</span></div>
                            <div class="metric-item"><span class="metric-label">质合比:</span><span class="metric-value">${metrics.primeCompositeRatio || '0:0'}</span></div>
                            <div class="metric-item"><span class="metric-label">${historicalPrizeText}</span></div>
                        `;
                    }
                }

                EventDelegate.updateNineRingDisplay();
            }

            static async queryHistoricalHighestPrize(selectedRedBalls, selectedBlueBalls) {
                const lotteryType = currentLotteryType;
                const data = await dataManager.currentDb.getData();
                const allData = data.draws || [];

                if (!allData || allData.length === 0) {
                    return {
                        prizeLevel: '暂无数据',
                        prizeCount: 0
                    };
                }

                const prizeCounts = {};
                const prizeOrder = {
                    '一等奖': 1,
                    '二等奖': 2,
                    '三等奖': 3,
                    '四等奖': 4,
                    '五等奖': 5,
                    '六等奖': 6,
                    '福运奖': 7,
                    '好运奖': 7,
                    '未中奖': 999
                };

                allData.forEach(draw => {
                    const drawRedBalls = draw.redBalls || [];
                    const drawBlueBalls = draw.blueBalls || [];

                    let redMatch = 0;
                    let blueMatch = 0;
                    let frontMatch = 0;
                    let backMatch = 0;

                    if (lotteryType === 'ssq') {
                        const selectedRedStr = selectedRedBalls.map(num => num.toString().padStart(2, '0'));
                        const selectedBlueStr = selectedBlueBalls.map(num => num.toString().padStart(2, '0'));
                        redMatch = selectedRedStr.filter(num => drawRedBalls.includes(num)).length;
                        blueMatch = selectedBlueStr.filter(num => drawBlueBalls.includes(num)).length;
                    } else if (lotteryType === 'dlt') {
                        const selectedRedStr = selectedRedBalls.map(num => num.toString().padStart(2, '0'));
                        const selectedBlueStr = selectedBlueBalls.map(num => num.toString().padStart(2, '0'));
                        frontMatch = selectedRedStr.filter(num => drawRedBalls.includes(num)).length;
                        backMatch = selectedBlueStr.filter(num => drawBlueBalls.includes(num)).length;
                    }

                    const result = {
                        redMatch: redMatch,
                        blueMatch: blueMatch,
                        frontMatch: frontMatch,
                        backMatch: backMatch
                    };

                    const prizeInfo = EventDelegate.getPrizeInfo(result, lotteryType);

                    if (prizeInfo.prizeLevel !== '未中奖') {
                        if (!prizeCounts[prizeInfo.prizeLevel]) {
                            prizeCounts[prizeInfo.prizeLevel] = 0;
                        }
                        prizeCounts[prizeInfo.prizeLevel]++;
                    }
                });

                if (Object.keys(prizeCounts).length === 0) {
                    return {
                        prizeLevel: '未中奖',
                        prizeCount: 0
                    };
                }

                let highestPrizeLevel = null;
                let highestPrizeOrder = 999;

                for (const [prizeLevel, count] of Object.entries(prizeCounts)) {
                    const order = prizeOrder[prizeLevel] || 999;
                    if (order < highestPrizeOrder) {
                        highestPrizeOrder = order;
                        highestPrizeLevel = prizeLevel;
                    }
                }

                return {
                    prizeLevel: highestPrizeLevel,
                    prizeCount: prizeCounts[highestPrizeLevel]
                };
            }

            static updateNineRingDisplay() {
                // 九转连环图数据
                const data1 = {
                    title: "衡十七",
                    numbers: [
                        ["17"],
                        ["01", "06", "07", "22", "23", "18", "27", "32"],
                        ["33", "29", "19", "12", "03", "15", "05", "20"],
                        ["21", "24", "31", "04", "16", "10", "28", "02"],
                        ["13", "09", "11", "30", "26", "25", "08", "14"]
                    ]
                };

                const data2 = {
                    title: "九为尊",
                    numbers: [
                        ["09"],
                        ["10", "22", "07", "30", "02", "18", "25", "24"],
                        ["23", "13", "19", "14", "29", "26", "11", "03"],
                        ["16", "01", "31", "21", "32", "17", "05", "15"],
                        ["20", "33", "12", "04", "06", "08", "28", "27"]
                    ]
                };

                const data3 = {
                    title: "三十三",
                    numbers: [
                        ["33"],
                        ["01", "31", "13", "21", "11", "27", "07", "17"],
                        ["32", "02", "20", "12", "22", "06", "26", "16"],
                        ["15", "19", "03", "29", "05", "23", "09", "25"],
                        ["18", "14", "30", "04", "28", "10", "24", "08"]
                    ]
                };

                setTimeout(() => {

                }, 100);
            }

            static updateMagicSquareHighlight() {
                document.querySelectorAll('.magic-square-cell').forEach(cell => {
                    cell.classList.remove('selected', 'red', 'blue');
                });

                window.selectionSystemData.selectedRedBalls.forEach(num => {
                    const cell = document.querySelector(`.magic-square-cell[data-number="${num}"][data-type="red"]`);
                    if (cell) {
                        cell.classList.add('selected', 'red');
                    }
                });

                window.selectionSystemData.selectedBlueBalls.forEach(num => {
                    const cell = document.querySelector(`.magic-square-cell[data-number="${num}"][data-type="blue"]`);
                    if (cell) {
                        cell.classList.add('selected', 'blue');
                    }
                });
            }

            static async renderNumberLibrary() {
                const container = document.getElementById('numberLibraryContainer');
                const countDisplay = document.getElementById('libraryCountDisplay');

                if (!container || !countDisplay) return;

                const lotteryType = currentLotteryType;
                const currentLibrary = lotteryType === 'ssq' ? 
                    window.selectionSystemData.ssqNumberLibrary : 
                    window.selectionSystemData.dltNumberLibrary;

                if (currentLibrary.length === 0) {
                    container.innerHTML = `
                        <div class="empty-library">
                            <i class="fas fa-inbox"></i>
                            <p>号码库为空，请先保存选号</p>
                        </div>
                    `;
                } else {
                    let html = '';
                    const data = await dataManager.currentDb.getData();
                    const allData = data.draws || [];

                    for (const item of currentLibrary) {
                        const metrics = EventDelegate.calculateAnalysisMetrics(item.reds, currentLotteryType);
                        const numbersString = `${item.reds.map(n => String(n).padStart(2, '0')).join(',')}+${item.blues.map(n => String(n).padStart(2, '0')).join(',')}`;

                        const historicalPrize = await EventDelegate.queryHistoricalHighestPrize(item.reds, item.blues);

                        let historicalPrizeText = '';
                        let historicalPrizeColor = '#000000';
                        if (historicalPrize.prizeLevel === '暂无数据') {
                            historicalPrizeText = '历史最高：暂无数据';
                            historicalPrizeColor = '#6c757d';
                        } else if (historicalPrize.prizeLevel === '未中奖') {
                            historicalPrizeText = '历史最高：未中奖';
                            historicalPrizeColor = '#6c757d';
                        } else {
                            historicalPrizeColor = historicalPrize.prizeLevel.includes('一等奖') ? '#dc3545' :
                                                  historicalPrize.prizeLevel.includes('二等奖') ? '#fd7e14' :
                                                  historicalPrize.prizeLevel.includes('三等奖') ? '#ffc107' :
                                                  historicalPrize.prizeLevel.includes('四等奖') ? '#20c997' :
                                                  historicalPrize.prizeLevel.includes('五等奖') ? '#0dcaf0' :
                                                  historicalPrize.prizeLevel.includes('六等奖') ? '#6f42c1' :
                                                  historicalPrize.prizeLevel.includes('福运奖') ? '#17a2b8' :
                                                  historicalPrize.prizeLevel.includes('好运奖') ? '#e83e8c' :
                                                  '#adb5bd';
                            historicalPrizeText = `<span style="color: #000000;">历史最高：</span><span style="color: ${historicalPrizeColor}; font-weight: bold;">${historicalPrize.prizeLevel}</span><span style="color: #000000;">(${historicalPrize.prizeCount}次)</span>`;
                        }

                        const rules = LOTTERY_RULES[lotteryType];
                        const redBallsDisplay = item.reds.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: ${rules.themeColor}; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                        const blueBallsDisplay = item.blues.map(num => `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: ${lotteryType === 'ssq' ? '#457B9D' : '#F4A261'}; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`).join('');
                        const numbersDisplay = `${redBallsDisplay}+${blueBallsDisplay}`;

                        const metricsDisplay = `<span class="library-metrics" style="font-size: 12px; margin-left: 10px; color: #6c757d; white-space: nowrap;">
                            和值:<span style="color: #E63946; font-weight: bold;">${metrics.sum || 0}</span>|
                            跨度:<span style="color: #457B9D; font-weight: bold;">${metrics.span || 0}</span>|
                            连号:<span style="color: #2A9D8F; font-weight: bold;">${metrics.consecutive || 0}</span>|
                            大中小:<span style="color: #F4A261; font-weight: bold;">${metrics.zoneDistribution || '0-0-0'}</span>|
                            奇偶:<span style="color: #9B5DE5; font-weight: bold;">${metrics.oddEvenRatio || '0:0'}</span>|
                            AC值:<span style="color: #FF7700; font-weight: bold;">${metrics.acValue || 0}</span>|
                            大小比:<span style="color: #00BBBB; font-weight: bold;">${metrics.bigSmallRatio || '0:0'}</span>|
                            质合比:<span style="color: #0077FF; font-weight: bold;">${metrics.primeCompositeRatio || '0:0'}</span>|
                            ${historicalPrizeText}
                        </span>`;

                        html += `
                            <div class="library-item" data-id="${item.id}" style="display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #e0e0e0; background-color: white;">
                                <input type="checkbox" class="library-checkbox" data-id="${item.id}" style="margin-right: 10px; cursor: pointer;">
                                <div class="library-numbers" style="display: inline-flex; align-items: center; margin-right: 10px;">
                                    ${numbersDisplay}
                                </div>
                                ${metricsDisplay}
                                <div class="library-actions" style="margin-left: auto; display: flex; gap: 4px;">
                                    <button class="btn btn-info" onclick="dataManager.showNineChart('${item.id}', '${numbersString.replace(/'/g, '&quot;')}', 'library-jiuzhuan-${item.id}')" style="padding: 4px 8px; font-size: 12px; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;" title="九转图">
                                        <i class="fas fa-circle-notch"></i> 九转图
                                    </button>
                                    <button class="btn btn-success" onclick="dataManager.showDNAAnalysis('${item.id}', '${numbersString.replace(/'/g, '&quot;')}')" style="padding: 4px 8px; font-size: 12px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DNA分析">
                                        <i class="fas fa-dna"></i> DNA
                                    </button>
                                    <button class="btn btn-sm btn-danger" onclick="EventDelegate.deleteLibraryItem(${item.id})" style="padding: 4px 8px; font-size: 12px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        <i class="fas fa-trash"></i> 删除
                                    </button>
                                </div>
                            </div>
                        `;
                    }
                    container.innerHTML = html;
                }

                countDisplay.textContent = currentLibrary.length;
            }

            static async deleteLibraryItem(id) {
                const lotteryType = currentLotteryType;
                const currentLibrary = lotteryType === 'ssq' ? 
                    window.selectionSystemData.ssqNumberLibrary : 
                    window.selectionSystemData.dltNumberLibrary;

                const index = currentLibrary.findIndex(item => item.id === id);
                if (index > -1) {
                    currentLibrary.splice(index, 1);
                    localStorage.setItem(
                        lotteryType === 'ssq' ? 'ssqNumberLibrary' : 'dltNumberLibrary', 
                        JSON.stringify(currentLibrary)
                    );
                    await EventDelegate.renderNumberLibrary();
                    MessageSystem.showMessage('号码已从号码库中删除', 'info');
                }
            }

            static calculateAnalysisMetrics(numbers, lotteryType = 'ssq') {
                if (!numbers || numbers.length === 0) return {};

                let redBalls = [];
                if (typeof numbers === 'string') {
                    const parts = numbers.split('+');
                    redBalls = parts[0].split(',').map(n => parseInt(n.trim(), 10)).filter(n => !isNaN(n));
                } else {
                    redBalls = numbers;
                }

                if (redBalls.length === 0) return {};

                const sum = redBalls.reduce((acc, num) => acc + num, 0);
                const span = Math.max(...redBalls) - Math.min(...redBalls);

                const consecutiveDetails = this.getConsecutiveDetails(redBalls, lotteryType);
                let consecutiveType = '无连号';
                
                if (consecutiveDetails.hasConsecutive) {
                    const parts = [];
                    if (consecutiveDetails.twoConsecutive > 0) {
                        parts.push(`${consecutiveDetails.twoConsecutive}个2连`);
                    }
                    if (consecutiveDetails.threeConsecutive > 0) {
                        parts.push(`${consecutiveDetails.threeConsecutive}个3连`);
                    }
                    if (consecutiveDetails.fourConsecutive > 0) {
                        parts.push(`${consecutiveDetails.fourConsecutive}个4连`);
                    }
                    if (consecutiveDetails.fiveConsecutive > 0) {
                        parts.push(`${consecutiveDetails.fiveConsecutive}个5连`);
                    }
                    if (consecutiveDetails.sixConsecutive > 0) {
                        parts.push(`${consecutiveDetails.sixConsecutive}个6连`);
                    }
                    consecutiveType = parts.join('+');
                }

                let zone1 = 0, zone2 = 0, zone3 = 0;
                if (lotteryType === 'ssq') {
                    redBalls.forEach(num => {
                        if (num >= 1 && num <= 11) zone1++;
                        else if (num >= 12 && num <= 22) zone2++;
                        else if (num >= 23 && num <= 33) zone3++;
                    });
                } else if (lotteryType === 'dlt') {
                    redBalls.forEach(num => {
                        if (num >= 1 && num <= 12) zone1++;
                        else if (num >= 13 && num <= 24) zone2++;
                        else if (num >= 25 && num <= 35) zone3++;
                    });
                }
                const zoneDistribution = `${zone3}:${zone2}:${zone1}`;

                let oddCount = 0, evenCount = 0;
                redBalls.forEach(num => {
                    if (num % 2 === 0) evenCount++;
                    else oddCount++;
                });
                const oddEvenRatio = `${oddCount}:${evenCount}`;

                let differences = new Set();
                for (let i = 0; i < redBalls.length; i++) {
                    for (let j = i + 1; j < redBalls.length; j++) {
                        differences.add(Math.abs(redBalls[i] - redBalls[j]));
                    }
                }
                const acValue = differences.size - (redBalls.length - 1);

                let bigCount = 0, smallCount = 0;
                if (lotteryType === 'ssq') {
                    redBalls.forEach(num => {
                        if (num >= 17) bigCount++;
                        else smallCount++;
                    });
                } else if (lotteryType === 'dlt') {
                    redBalls.forEach(num => {
                        if (num >= 18) bigCount++;
                        else smallCount++;
                    });
                }
                const bigSmallRatio = `${bigCount}:${smallCount}`;

                const isPrime = (n) => {
                    if (n < 2) return false;
                    if (n === 2) return true;
                    if (n % 2 === 0) return false;
                    for (let i = 3; i <= Math.sqrt(n); i += 2) {
                        if (n % i === 0) return false;
                    }
                    return true;
                };

                let primeCount = 0, compositeCount = 0;
                redBalls.forEach(num => {
                    if (isPrime(num)) primeCount++;
                    else if (num > 1) compositeCount++;
                });
                const primeCompositeRatio = `${primeCount}:${compositeCount}`;

                return {
                    sum: sum,
                    span: span,
                    consecutive: consecutiveType,
                    zoneDistribution: zoneDistribution,
                    oddEvenRatio: oddEvenRatio,
                    acValue: acValue,
                    bigSmallRatio: bigSmallRatio,
                    primeCompositeRatio: primeCompositeRatio
                };
            }

            static drawNineRingCircle(canvasId, data, selectedNumbers, scale = 1) {
                console.log('drawNineRingCircle - canvasId:', canvasId);
                console.log('drawNineRingCircle - data:', data);
                console.log('drawNineRingCircle - selectedNumbers:', selectedNumbers);
                console.log('drawNineRingCircle - scale:', scale);

                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    console.error('drawNineRingCircle - Canvas not found:', canvasId);
                    return;
                }

                console.log('drawNineRingCircle - canvas found:', canvas);

                const ctx = canvas.getContext('2d');

                const dpr = window.devicePixelRatio || 1;
                
                // 使用固定尺寸560x560，确保每次绘制一致
                const FIXED_SIZE = 560;
                const displayWidth = FIXED_SIZE;
                const displayHeight = FIXED_SIZE;

                // 只在首次绘制或尺寸变化时设置Canvas内部尺寸
                const expectedInternalWidth = Math.floor(displayWidth * dpr);
                const expectedInternalHeight = Math.floor(displayHeight * dpr);
                
                if (canvas.width !== expectedInternalWidth || canvas.height !== expectedInternalHeight) {
                    canvas.width = expectedInternalWidth;
                    canvas.height = expectedInternalHeight;
                    canvas.style.width = displayWidth + 'px';
                    canvas.style.height = displayHeight + 'px';
                }

                // 重置变换矩阵并应用DPR缩放
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);

                console.log('drawNineRingCircle - displayWidth:', displayWidth, 'displayHeight:', displayHeight);
                console.log('drawNineRingCircle - dpr:', dpr);
                console.log('drawNineRingCircle - canvas.width:', canvas.width, 'canvas.height:', canvas.height);

                // 使用clearRect清除整个Canvas（考虑DPR）
                ctx.clearRect(0, 0, displayWidth, displayHeight);

                const centerX = displayWidth / 2;
                const centerY = displayHeight / 2;

                const baseSize = Math.min(displayWidth, displayHeight);

                const padding = baseSize * 0.08;
                const availableSize = baseSize - padding * 2;

                // 使用固定像素值，确保每次绘制完全一致
                const numberCircleRadius = 24.5;
                const fontSize = 30 * scale;

                // 使用固定像素值，确保每次绘制完全一致
                const circleDistances = [
                    0,
                    73.5,
                    126.5,
                    179.5,
                    232.5
                ];

                const lineWidth = baseSize * 0.003 * scale;
                const dashLineWidth = baseSize * 0.0025 * scale;

                function draw() {
                    drawBackgroundRings();
                    drawCenterConnections();
                    drawCircleConnections();
                    drawDirectionalConnections();
                    drawNumberLabels();
                }

                function drawBackgroundRings() {
                    for (let i = 1; i < circleDistances.length; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, circleDistances[i], 0, Math.PI * 2);
                        ctx.strokeStyle = "rgba(241, 245, 249, 0.8)";
                        ctx.lineWidth = lineWidth;
                        ctx.stroke();
                    }
                }

                function drawCenterConnections() {
                    ctx.strokeStyle = "#cbd5e1";
                    ctx.lineWidth = dashLineWidth;
                    ctx.setLineDash([4, 3]);

                    const numCount = data.numbers[1].length;
                    const angleStep = (2 * Math.PI) / numCount;
                    let startAngle = -Math.PI / 2;

                    for (let j = 0; j < numCount; j++) {
                        const angle = startAngle + j * angleStep;
                        const adjustedRadius = circleDistances[1];
                        const x = centerX + adjustedRadius * Math.cos(angle);
                        const y = centerY + adjustedRadius * Math.sin(angle);

                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }

                    ctx.setLineDash([]);
                }

                function drawCircleConnections() {
                    ctx.strokeStyle = "#e2e8f0";
                    ctx.lineWidth = lineWidth;

                    for (let i = 1; i < data.numbers.length; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, circleDistances[i], 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                function drawDirectionalConnections() {
                    ctx.strokeStyle = "#cbd5e1";
                    ctx.lineWidth = dashLineWidth;
                    ctx.setLineDash([4, 3]);

                    const directions = [
                        -Math.PI / 2,
                        Math.PI / 2,
                        Math.PI,
                        0,
                        -Math.PI * 3 / 4,
                        -Math.PI / 4,
                        Math.PI * 3 / 4,
                        Math.PI / 4
                    ];

                    const outerCircleRadius = circleDistances[circleDistances.length - 1];

                    for (let i = 0; i < directions.length; i++) {
                        const angle = directions[i];
                        const x = centerX + outerCircleRadius * Math.cos(angle);
                        const y = centerY + outerCircleRadius * Math.sin(angle);

                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }

                    ctx.setLineDash([]);
                }

                function drawNumberLabels() {
                    drawNumberWithCircle(centerX, centerY, data.numbers[0][0], true);

                    for (let i = 1; i < data.numbers.length; i++) {
                        const numCount = data.numbers[i].length;
                        const angleStep = (2 * Math.PI) / numCount;
                        let startAngle = -Math.PI / 2;
                        const circleRadius = circleDistances[i];

                        for (let j = 0; j < numCount; j++) {
                            const angle = startAngle + j * angleStep;
                            const x = centerX + circleRadius * Math.cos(angle);
                            const y = centerY + circleRadius * Math.sin(angle);

                            drawNumberWithCircle(x, y, data.numbers[i][j]);
                        }
                    }
                }

                const drawNumberWithCircle = (x, y, number, isCenter = false) => {
                    const isSelected = selectedNumbers.includes(parseInt(number));

                    ctx.beginPath();
                    ctx.arc(x, y, numberCircleRadius, 0, Math.PI * 2);

                    if (isSelected) {
                        ctx.fillStyle = "#E63946";
                    } else {
                        ctx.fillStyle = "white";
                    }
                    ctx.fill();

                    ctx.strokeStyle = isCenter ? "#94a3b8" : (isSelected ? "#C1121F" : "#cbd5e1");
                    ctx.lineWidth = isCenter ? lineWidth * 1.5 : lineWidth * 1.2;
                    ctx.stroke();

                    ctx.font = `bold ${fontSize}px Arial, sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = isSelected ? "white" : "#1e293b";
                    ctx.fillText(number.toString(), x, y);
                };

                draw();
            }

            static initNineRingDiagram(instanceId = 'selection-system-jiuzhuan') {
                // 创建或获取实例数据
                if (!this.nineRingInstances[instanceId]) {
                    this.nineRingInstances[instanceId] = {
                        selectedNumbers: []
                    };
                }

                // 九转连环图数据 - 统一使用numbers格式
                const cardData = {
                  'selected-circles-svg-1': { title: "衡十七", numbers: [["17"], ["01", "06", "07", "22", "23", "18", "27", "32"], ["33", "29", "19", "12", "03", "15", "05", "20"], ["21", "24", "31", "04", "16", "10", "28", "02"], ["13", "09", "11", "30", "26", "25", "08", "14"]] },
                  'selected-circles-svg-2': { title: "九为尊", numbers: [["09"], ["10", "22", "07", "30", "02", "18", "25", "24"], ["23", "13", "19", "14", "29", "26", "11", "03"], ["16", "01", "31", "21", "32", "17", "05", "15"], ["20", "33", "12", "04", "06", "08", "28", "27"]] },
                  'selected-circles-svg-3': { title: "三十三", numbers: [["33"], ["01", "31", "13", "21", "11", "27", "07", "17"], ["32", "02", "20", "12", "22", "06", "26", "16"], ["15", "19", "03", "29", "05", "23", "09", "25"], ["18", "14", "30", "04", "28", "10", "24", "08"]] }
                };

                const selectedNumbers = window.selectionSystemData.selectedRedBalls || [];

                // 使用canvas绘制九转连环图
                ['selected-circles-svg-1', 'selected-circles-svg-2', 'selected-circles-svg-3'].forEach((canvasId, index) => {
                    const data = cardData[canvasId];
                    if (!data) return;

                    this.drawNineRingCircle(canvasId, data, selectedNumbers, 1);
                });

                // 更新高亮，传入instanceId
                EventDelegate.updateNineRingHighlight(instanceId);
            }

            static updateNineRingHighlight(instanceId = 'selection-system-jiuzhuan') {
                const instance = this.nineRingInstances[instanceId];
                if (!instance) return;

                const selectedNumbers = window.selectionSystemData.selectedRedBalls || [];

                // 根据instanceId确定canvas ID前缀和scale
                let canvasPrefix = 'selected-circles-svg-';
                let scale = 1;

                if (instanceId === 'data-management-jiuzhuan') {
                    canvasPrefix = 'circles-svg-';
                    scale = 1;
                } else if (instanceId.startsWith('database-jiuzhuan-')) {
                    canvasPrefix = 'circles-svg-';
                    scale = 1;
                } else if (instanceId.startsWith('library-jiuzhuan-')) {
                    canvasPrefix = 'circles-svg-';
                    scale = 1;
                }

                // 获取对应的数据
                let cardData;
                if (instanceId === 'data-management-jiuzhuan') {
                    cardData = {
                        'circles-svg-1': { title: "衡十七", numbers: [["17"], ["01", "06", "07", "22", "23", "18", "27", "32"], ["33", "29", "19", "12", "03", "15", "05", "20"], ["21", "24", "31", "04", "16", "10", "28", "02"], ["13", "09", "11", "30", "26", "25", "08", "14"]] },
                        'circles-svg-2': { title: "九为尊", numbers: [["09"], ["10", "22", "07", "30", "02", "18", "25", "24"], ["23", "13", "19", "14", "29", "26", "11", "03"], ["16", "01", "31", "21", "32", "17", "05", "15"], ["20", "33", "12", "04", "06", "08", "28", "27"]] },
                        'circles-svg-3': { title: "三十三", numbers: [["33"], ["01", "31", "13", "21", "11", "27", "07", "17"], ["32", "02", "20", "12", "22", "06", "26", "16"], ["15", "19", "03", "29", "05", "23", "09", "25"], ["18", "14", "30", "04", "28", "10", "24", "08"]] }
                    };
                } else if (instanceId === 'selection-system-jiuzhuan') {
                    cardData = {
                        'selected-circles-svg-1': { title: "衡十七", numbers: [["17"], ["01", "06", "07", "22", "23", "18", "27", "32"], ["33", "29", "19", "12", "03", "15", "05", "20"], ["21", "24", "31", "04", "16", "10", "28", "02"], ["13", "09", "11", "30", "26", "25", "08", "14"]] },
                        'selected-circles-svg-2': { title: "九为尊", numbers: [["09"], ["10", "22", "07", "30", "02", "18", "25", "24"], ["23", "13", "19", "14", "29", "26", "11", "03"], ["16", "01", "31", "21", "32", "17", "05", "15"], ["20", "33", "12", "04", "06", "08", "28", "27"]] },
                        'selected-circles-svg-3': { title: "三十三", numbers: [["33"], ["01", "31", "13", "21", "11", "27", "07", "17"], ["32", "02", "20", "12", "22", "06", "26", "16"], ["15", "19", "03", "29", "05", "23", "09", "25"], ["18", "14", "30", "04", "28", "10", "24", "08"]] }
                    };
                } else {
                    cardData = {
                        'circles-svg-1': { title: "衡十七", numbers: [["17"], ["01", "06", "07", "22", "23", "18", "27", "32"], ["33", "29", "19", "12", "03", "15", "05", "20"], ["21", "24", "31", "04", "16", "10", "28", "02"], ["13", "09", "11", "30", "26", "25", "08", "14"]] },
                        'circles-svg-2': { title: "九为尊", numbers: [["09"], ["10", "22", "07", "30", "02", "18", "25", "24"], ["23", "13", "19", "14", "29", "26", "11", "03"], ["16", "01", "31", "21", "32", "17", "05", "15"], ["20", "33", "12", "04", "06", "08", "28", "27"]] },
                        'circles-svg-3': { title: "三十三", numbers: [["33"], ["01", "31", "13", "21", "11", "27", "07", "17"], ["32", "02", "20", "12", "22", "06", "26", "16"], ["15", "19", "03", "29", "05", "23", "09", "25"], ["18", "14", "30", "04", "28", "10", "24", "08"]] }
                    };
                }

                // 重新绘制canvas以更新高亮
                [1, 2, 3].forEach(index => {
                    const canvasId = `${canvasPrefix}${index}`;
                    const canvas = document.getElementById(canvasId);
                    if (!canvas) return;

                    const data = cardData[canvasId];
                    if (!data) return;

                    // 所有数据现在都使用统一的numbers格式
                    this.drawNineRingCircle(canvasId, data, selectedNumbers, scale);
                });
            }

            static initDNAQuery() {
                const dnaQueryBtn = document.getElementById('dnaQueryBtn');
                if (dnaQueryBtn && !dnaQueryBtn.hasAttribute('data-listener-added')) {
                    dnaQueryBtn.addEventListener('click', () => {
                        this.handleDNAQuery();
                    });
                    dnaQueryBtn.setAttribute('data-listener-added', 'true');
                }

                const dnaLotteryTypeSelect = document.getElementById('dnaLotteryType');
                if (dnaLotteryTypeSelect && !dnaLotteryTypeSelect.hasAttribute('data-listener-added')) {
                    dnaLotteryTypeSelect.addEventListener('change', (e) => {
                        this.handleDNALotteryTypeChange(e.target.value);
                    });
                    dnaLotteryTypeSelect.setAttribute('data-listener-added', 'true');
                }

                const dnaRandomBtn = document.getElementById('dnaRandomBtn');
                if (dnaRandomBtn && !dnaRandomBtn.hasAttribute('data-listener-added')) {
                    dnaRandomBtn.addEventListener('click', () => {
                        this.generateRandomNumbers();
                    });
                    dnaRandomBtn.setAttribute('data-listener-added', 'true');
                }

                const dnaHistoryBtn = document.getElementById('dnaHistoryBtn');
                if (dnaHistoryBtn && !dnaHistoryBtn.hasAttribute('data-listener-added')) {
                    dnaHistoryBtn.addEventListener('click', () => {
                        this.showQueryHistory();
                    });
                    dnaHistoryBtn.setAttribute('data-listener-added', 'true');
                }

                const dnaQueryInput = document.getElementById('dnaQueryInput');
                if (dnaQueryInput && dnaLotteryTypeSelect) {
                    const defaultLotteryType = dnaLotteryTypeSelect.value;
                    if (defaultLotteryType === 'ssq') {
                        dnaQueryInput.value = '05,07,14,20,23,27+16';
                    } else if (defaultLotteryType === 'dlt') {
                        dnaQueryInput.value = '01,13,15,21,27+11,12';
                    }
                }

                const dnaQueryTabs = document.querySelectorAll('.dna-query-tab');
                dnaQueryTabs.forEach(tab => {
                    if (!tab.hasAttribute('data-listener-added')) {
                        tab.addEventListener('click', (e) => {
                            dnaQueryTabs.forEach(t => t.classList.remove('active'));
                            e.target.classList.add('active');
                            const tabType = e.target.getAttribute('data-tab');
                            this.switchDNAQueryTab(tabType);
                        });
                        tab.setAttribute('data-listener-added', 'true');
                    }
                });

                const samePeriodQueryBtn = document.getElementById('samePeriodQueryBtn');
                if (samePeriodQueryBtn && !samePeriodQueryBtn.hasAttribute('data-listener-added')) {
                    samePeriodQueryBtn.addEventListener('click', () => {
                        this.handleSamePeriodQuery();
                    });
                    samePeriodQueryBtn.setAttribute('data-listener-added', 'true');
                }

                const historySamePeriodQueryBtn = document.getElementById('historySamePeriodQueryBtn');
                if (historySamePeriodQueryBtn && !historySamePeriodQueryBtn.hasAttribute('data-listener-added')) {
                    historySamePeriodQueryBtn.addEventListener('click', () => {
                        this.handleHistorySamePeriodQuery();
                    });
                    historySamePeriodQueryBtn.setAttribute('data-listener-added', 'true');
                }
            }

            static handleDNALotteryTypeChange(lotteryType) {
                const dnaQueryInput = document.getElementById('dnaQueryInput');
                if (dnaQueryInput) {
                    if (lotteryType === 'ssq') {
                        dnaQueryInput.value = '05,07,14,20,23,27+16';
                    } else if (lotteryType === 'dlt') {
                        dnaQueryInput.value = '01,13,15,21,27+11,12';
                    }
                }
                MessageSystem.showMessage(`DNA查询彩票类型已切换为: ${lotteryType === 'ssq' ? '双色球DNA' : '大乐透DNA'}`, 'info');
            }

            static switchDNAQueryTab(tabType) {
                const dnaQueryPanel = document.getElementById('dnaQueryPanel');
                const samePeriodQueryPanel = document.getElementById('samePeriodQueryPanel');
                const historySamePeriodQueryPanel = document.getElementById('historySamePeriodQueryPanel');
                
                if (tabType === 'dna') {
                    dnaQueryPanel.style.display = 'block';
                    samePeriodQueryPanel.style.display = 'none';
                    historySamePeriodQueryPanel.style.display = 'none';
                } else if (tabType === 'same-period') {
                    dnaQueryPanel.style.display = 'none';
                    samePeriodQueryPanel.style.display = 'block';
                    historySamePeriodQueryPanel.style.display = 'none';
                } else if (tabType === 'history-same-period') {
                    dnaQueryPanel.style.display = 'none';
                    samePeriodQueryPanel.style.display = 'none';
                    historySamePeriodQueryPanel.style.display = 'block';
                }
            }

            static async handleSamePeriodQuery() {
                const lotteryType = document.getElementById('samePeriodLotteryType').value;
                const periodInput = document.getElementById('samePeriodInput').value.trim();

                if (!periodInput) {
                    MessageSystem.showMessage('请输入期号', 'error');
                    return;
                }

                const periodMatch = periodInput.match(/(\d{4})[-_]?(\d{3})/);
                if (!periodMatch) {
                    MessageSystem.showMessage('期号格式不正确，请使用格式：年份+期号，例如：2024001 或 2024-001', 'error');
                    return;
                }

                const year = parseInt(periodMatch[1]);
                const periodNum = parseInt(periodMatch[2]);
                const targetPeriod = `${year}${periodNum.toString().padStart(3, '0')}`;

                MessageSystem.showMessage('开始查询同期开奖数据...', 'info');

                try {
                    await dataManager.switchLotteryType(lotteryType);
                    
                    const draws = currentDatabaseData.draws || [];
                    if (draws.length === 0) {
                        document.getElementById('samePeriodQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">暂无历史数据</p>`;
                        return;
                    }

                    const targetDraw = draws.find(draw => {
                        const drawPeriod = draw.issue || draw.period || '';
                        return drawPeriod === targetPeriod;
                    });

                    if (!targetDraw) {
                        document.getElementById('samePeriodQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">未找到期号 ${targetPeriod} 的开奖数据</p>`;
                        return;
                    }

                    const samePeriodDraws = draws.filter(draw => {
                        const drawPeriod = draw.issue || draw.period || '';
                        const periodMatch = drawPeriod.match(/(\d{4})(\d{3})/);
                        if (!periodMatch) return false;
                        
                        const drawYear = parseInt(periodMatch[1]);
                        const drawPeriodNum = parseInt(periodMatch[2]);
                        
                        return drawYear === year && drawPeriodNum === periodNum;
                    });

                    this.displaySamePeriodResult(targetDraw, samePeriodDraws, lotteryType, targetPeriod);
                } catch (error) {
                    console.error('同期查询错误:', error);
                    MessageSystem.showMessage('查询出错: ' + error.message, 'error');
                }
            }

            static displaySamePeriodResult(targetDraw, samePeriodDraws, lotteryType, targetPeriod) {
                const resultDiv = document.getElementById('samePeriodQueryResult');
                if (!resultDiv) return;

                const isRed = lotteryType === 'ssq';
                const redBalls = targetDraw.redBalls || [];
                const blueBalls = targetDraw.blueBalls || [];
                const frontBalls = targetDraw.redBalls || [];
                const backBalls = targetDraw.blueBalls || [];

                let targetNumbersHTML = '';
                let targetNumbersString = '';
                if (isRed) {
                    const redBallsHTML = redBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #E63946; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`
                    ).join('');
                    const blueBallsHTML = blueBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #457B9D; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`
                    ).join('');
                    targetNumbersHTML = `${redBallsHTML} <span style="font-size: 24px; font-weight: bold; margin: 0 10px;">+</span> ${blueBallsHTML}`;
                    targetNumbersString = `${redBalls.join(',')}+${blueBalls.join(',')}`;
                } else {
                    const frontBallsHTML = frontBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #2A9D8F; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`
                    ).join('');
                    const backBallsHTML = backBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #F4A261; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num.toString().padStart(2, '0')}</span>`
                    ).join('');
                    targetNumbersHTML = `${frontBallsHTML} <span style="font-size: 24px; font-weight: bold; margin: 0 10px;">+</span> ${backBallsHTML}`;
                    targetNumbersString = `${frontBalls.join(',')}+${backBalls.join(',')}`;
                }

                const targetMetrics = EventDelegate.calculateAnalysisMetrics(targetNumbersString, lotteryType);
                const targetMetricsDisplay = `和值:<span style="color: #E63946; font-weight: bold;">${targetMetrics.sum || 0}</span>|跨度:<span style="color: #457B9D; font-weight: bold;">${targetMetrics.span || 0}</span>|连号:<span style="color: #2A9D8F; font-weight: bold;">${targetMetrics.consecutive || 0}</span>|大中小:<span style="color: #F4A261; font-weight: bold;">${targetMetrics.zoneDistribution || '0-0-0'}</span>|奇偶:<span style="color: #9B5DE5; font-weight: bold;">${targetMetrics.oddEvenRatio || '0:0'}</span>|AC值:<span style="color: #FF7700; font-weight: bold;">${targetMetrics.acValue || 0}</span>|大小比:<span style="color: #00BBBB; font-weight: bold;">${targetMetrics.bigSmallRatio || '0:0'}</span>|质合比:<span style="color: #0077FF; font-weight: bold;">${targetMetrics.primeCompositeRatio || '0:0'}</span>`;

                let html = `
                    <div class="query-result-container">
                        <div style="margin-bottom: 30px;">
                            <h3 style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">查询期号: ${targetPeriod}</h3>
                            <div style="background: #f0f2f5; color: #333; padding: 30px 20px; border-radius: 10px; text-align: center; border: 2px solid #e9ecef;">
                                <h4 style="margin: 0 0 20px 0; font-size: 20px; color: #495057;">当期开奖号码</h4>
                                <div style="font-size: 0; margin-bottom: 20px;">${targetNumbersHTML}</div>
                                <div style="font-size: 13px; padding: 10px; background: white; border-radius: 6px;">
                                    <strong>分析指标:</strong> ${targetMetricsDisplay}
                                </div>
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">历史同期开奖记录（共 ${samePeriodDraws.length} 期）</h4>
                        </div>

                        <table class="result-table" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">期号</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">开奖号码</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5; min-width: 400px;">分析指标</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">操作</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                samePeriodDraws.forEach(draw => {
                    const period = draw.issue || draw.period || '未知';
                    const drawRedBalls = draw.redBalls || [];
                    const drawBlueBalls = draw.blueBalls || [];
                    const drawNumbersString = `${drawRedBalls.join(',')}+${drawBlueBalls.join(',')}`;
                    const drawMetrics = EventDelegate.calculateAnalysisMetrics(drawNumbersString, lotteryType);
                    const drawMetricsDisplay = `和值:<span style="color: #E63946; font-weight: bold;">${drawMetrics.sum || 0}</span>|跨度:<span style="color: #457B9D; font-weight: bold;">${drawMetrics.span || 0}</span>|连号:<span style="color: #2A9D8F; font-weight: bold;">${drawMetrics.consecutive || 0}</span>|大中小:<span style="color: #F4A261; font-weight: bold;">${drawMetrics.zoneDistribution || '0-0-0'}</span>|奇偶:<span style="color: #9B5DE5; font-weight: bold;">${drawMetrics.oddEvenRatio || '0:0'}</span>|AC值:<span style="color: #FF7700; font-weight: bold;">${drawMetrics.acValue || 0}</span>|大小比:<span style="color: #00BBBB; font-weight: bold;">${drawMetrics.bigSmallRatio || '0:0'}</span>|质合比:<span style="color: #0077FF; font-weight: bold;">${drawMetrics.primeCompositeRatio || '0:0'}</span>`;

                    let numbersHTML = '';
                    if (isRed) {
                        const redBallsHTML = drawRedBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #E63946; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        const blueBallsHTML = drawBlueBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #457B9D; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        numbersHTML = `${redBallsHTML}+${blueBallsHTML}`;
                    } else {
                        const frontBallsHTML = drawRedBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #2A9D8F; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        const backBallsHTML = drawBlueBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #F4A261; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        numbersHTML = `${frontBallsHTML}+${backBallsHTML}`;
                    }

                    html += `
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;">${period}</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">${numbersHTML}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; font-size: 13px;">${drawMetricsDisplay}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                                <button class="btn btn-info" onclick="dataManager.showNineChart('${period}', '${drawNumbersString.replace(/'/g, '&quot;')}', 'sameperiod-jiuzhuan-${period}')" style="padding: 4px 8px; margin-right: 4px; font-size: 12px; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;" title="九转图">
                                    <i class="fas fa-circle-notch"></i> 九转图
                                </button>
                                <button class="btn btn-success" onclick="dataManager.showDNAAnalysis('${period}', '${drawNumbersString.replace(/'/g, '&quot;')}')" style="padding: 4px 8px; font-size: 12px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DNA分析">
                                    <i class="fas fa-dna"></i> DNA
                                </button>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;

                resultDiv.innerHTML = html;
            }

            static async handleHistorySamePeriodQuery() {
                const lotteryType = document.getElementById('historySamePeriodLotteryType').value;
                const periodInput = document.getElementById('historySamePeriodInput').value.trim();

                if (!periodInput) {
                    MessageSystem.showMessage('请输入期号', 'error');
                    return;
                }

                const periodMatch = periodInput.match(/^(\d{3})$|^(\d{4})[-_]?(\d{3})$/);
                if (!periodMatch) {
                    MessageSystem.showMessage('期号格式不正确，请使用格式：期号（如：001）或 年份+期号（如：2024-001）', 'error');
                    return;
                }

                let targetPeriod;
                let filterYear = null;

                if (periodMatch[1] && periodMatch[2]) {
                    const year = parseInt(periodMatch[1]);
                    const periodNum = parseInt(periodMatch[2]);
                    targetPeriod = `${year}${periodNum.toString().padStart(3, '0')}`;
                    filterYear = year;
                } else if (periodMatch[1]) {
                    targetPeriod = periodMatch[1];
                } else {
                    return;
                }

                MessageSystem.showMessage('开始查询历史同期开奖数据...', 'info');

                try {
                    await dataManager.switchLotteryType(lotteryType);
                    
                    const draws = currentDatabaseData.draws || [];
                    if (draws.length === 0) {
                        document.getElementById('historySamePeriodQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">暂无历史数据</p>`;
                        return;
                    }

                    const historySamePeriodDraws = draws.filter(draw => {
                        const drawPeriod = draw.issue || draw.period || '';
                        const periodMatch = drawPeriod.match(/^(\d{4})(\d{3})$/);
                        if (!periodMatch) return false;
                        
                        const drawYear = parseInt(periodMatch[1]);
                        const drawPeriodNum = parseInt(periodMatch[2]);
                        const drawPeriodStr = periodMatch[2];
                        
                        if (filterYear !== null) {
                            return drawYear === filterYear && drawPeriodStr === targetPeriod;
                        } else {
                            return drawPeriodStr === targetPeriod;
                        }
                    });

                    if (historySamePeriodDraws.length === 0) {
                        document.getElementById('historySamePeriodQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">未找到期号 ${targetPeriod} 的历史开奖数据</p>`;
                        return;
                    }

                    this.displayHistorySamePeriodResult(historySamePeriodDraws, lotteryType, targetPeriod, filterYear);
                } catch (error) {
                    console.error('历史同期查询错误:', error);
                    MessageSystem.showMessage('查询出错: ' + error.message, 'error');
                }
            }

            static displayHistorySamePeriodResult(historySamePeriodDraws, lotteryType, targetPeriod, filterYear) {
                const resultDiv = document.getElementById('historySamePeriodQueryResult');
                if (!resultDiv) return;

                const isRed = lotteryType === 'ssq';
                const periodDesc = filterYear !== null ? `${filterYear}年第${targetPeriod}期` : `第${targetPeriod}期`;

                let html = `
                    <div class="query-result-container">
                        <div style="margin-bottom: 30px; display: flex; align-items: center; justify-content: space-between;">
                            <button onclick="dataManager.switchHistorySamePeriod('prev', '${lotteryType}', '${targetPeriod}', ${filterYear})" style="padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;" title="上一期">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <div style="flex: 1; text-align: center;">
                                <h3 style="margin: 0; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px; display: inline-block;">历史同期开奖记录（${periodDesc}）</h3>
                            </div>
                            <button onclick="dataManager.switchHistorySamePeriod('next', '${lotteryType}', '${targetPeriod}', ${filterYear})" style="padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;" title="下一期">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                            <p style="color: #6c757d; margin-bottom: 15px;">共找到 <strong style="color: #E63946; font-size: 18px;">${historySamePeriodDraws.length}</strong> 期历史开奖数据</p>
                        </div>

                        <table class="result-table" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">期号</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">开奖号码</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5; min-width: 400px;">分析指标</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">操作</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                let allRedBalls = [];
                let allBlueBalls = [];

                historySamePeriodDraws.forEach(draw => {
                    const period = draw.issue || draw.period || '未知';
                    const drawRedBalls = draw.redBalls || [];
                    const drawBlueBalls = draw.blueBalls || [];
                    const drawNumbersString = `${drawRedBalls.join(',')}+${drawBlueBalls.join(',')}`;
                    const drawMetrics = EventDelegate.calculateAnalysisMetrics(drawNumbersString, lotteryType);
                    const drawMetricsDisplay = `和值:<span style="color: #E63946; font-weight: bold;">${drawMetrics.sum || 0}</span>|跨度:<span style="color: #457B9D; font-weight: bold;">${drawMetrics.span || 0}</span>|连号:<span style="color: #2A9D8F; font-weight: bold;">${drawMetrics.consecutive || 0}</span>|大中小:<span style="color: #F4A261; font-weight: bold;">${drawMetrics.zoneDistribution || '0-0-0'}</span>|奇偶:<span style="color: #9B5DE5; font-weight: bold;">${drawMetrics.oddEvenRatio || '0:0'}</span>|AC值:<span style="color: #FF7700; font-weight: bold;">${drawMetrics.acValue || 0}</span>|大小比:<span style="color: #00BBBB; font-weight: bold;">${drawMetrics.bigSmallRatio || '0:0'}</span>|质合比:<span style="color: #0077FF; font-weight: bold;">${drawMetrics.primeCompositeRatio || '0:0'}</span>`;

                    allRedBalls.push(...drawRedBalls);
                    allBlueBalls.push(...drawBlueBalls);

                    let numbersHTML = '';
                    if (isRed) {
                        const redBallsHTML = drawRedBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #E63946; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        const blueBallsHTML = drawBlueBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #457B9D; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        numbersHTML = `${redBallsHTML}+${blueBallsHTML}`;
                    } else {
                        const frontBallsHTML = drawRedBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #2A9D8F; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        const backBallsHTML = drawBlueBalls.map(num => 
                            `<span style="display: inline-block; width: 28px; height: 28px; line-height: 28px; text-align: center; background-color: #F4A261; color: white; border-radius: 50%; font-size: 14px; font-weight: bold; margin: 2px;">${num.toString().padStart(2, '0')}</span>`
                        ).join('');
                        numbersHTML = `${frontBallsHTML}+${backBallsHTML}`;
                    }

                    html += `
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;">${period}</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">${numbersHTML}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; font-size: 13px;">${drawMetricsDisplay}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                                <button class="btn btn-info" onclick="dataManager.showNineChart('${period}', '${drawNumbersString.replace(/'/g, '&quot;')}', 'historysameperiod-jiuzhuan-${period}')" style="padding: 4px 8px; margin-right:4px; font-size: 12px; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer;" title="九转图">
                                    <i class="fas fa-circle-notch"></i> 九转图
                                </button>
                                <button class="btn btn-success" onclick="dataManager.showDNAAnalysis('${period}', '${drawNumbersString.replace(/'/g, '&quot;')}')" style="padding: 4px 8px; font-size: 12px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DNA分析">
                                    <i class="fas fa-dna"></i> DNA
                                </button>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;

                const redBallRange = isRed ? 33 : 35;
                const blueBallRange = isRed ? 16 : 12;

                const redBallCounts = {};
                const blueBallCounts = {};

                allRedBalls.forEach(num => {
                    redBallCounts[num] = (redBallCounts[num] || 0) + 1;
                });

                allBlueBalls.forEach(num => {
                    blueBallCounts[num] = (blueBallCounts[num] || 0) + 1;
                });

                const unopenedRedBalls = [];
                const unopenedBlueBalls = [];

                for (let i = 1; i <= redBallRange; i++) {
                    const iStr = i.toString().padStart(2, '0');
                    if (!redBallCounts[iStr]) {
                        unopenedRedBalls.push(i);
                    }
                }

                for (let i = 1; i <= blueBallRange; i++) {
                    const iStr = i.toString().padStart(2, '0');
                    if (!blueBallCounts[iStr]) {
                        unopenedBlueBalls.push(i);
                    }
                }

                const maxRedCount = Math.max(...Object.values(redBallCounts), 0);
                const minRedCount = Math.min(...Object.values(redBallCounts), Infinity);
                const maxBlueCount = Math.max(...Object.values(blueBallCounts), 0);
                const minBlueCount = Math.min(...Object.values(blueBallCounts), Infinity);

                const mostFrequentRedBalls = Object.keys(redBallCounts).filter(num => redBallCounts[num] === maxRedCount).map(Number);
                const leastFrequentRedBalls = Object.keys(redBallCounts).filter(num => redBallCounts[num] === minRedCount).map(Number);
                const mostFrequentBlueBalls = Object.keys(blueBallCounts).filter(num => blueBallCounts[num] === maxBlueCount).map(Number);
                const leastFrequentBlueBalls = Object.keys(blueBallCounts).filter(num => blueBallCounts[num] === minBlueCount).map(Number);

                const totalPeriods = historySamePeriodDraws.length;
                const totalRedBalls = allRedBalls.length;
                const totalBlueBalls = allBlueBalls.length;

                const oddRedBalls = allRedBalls.filter(num => num % 2 !== 0);
                const evenRedBalls = allRedBalls.filter(num => num % 2 === 0);
                const oddBlueBalls = allBlueBalls.filter(num => num % 2 !== 0);
                const evenBlueBalls = allBlueBalls.filter(num => num % 2 === 0);

                const redMidValue = isRed ? 17 : 18;
                const bigRedBalls = allRedBalls.filter(num => num > redMidValue);
                const smallRedBalls = allRedBalls.filter(num => num <= redMidValue);
                const blueMidValue = isRed ? 8 : 6;
                const bigBlueBalls = allBlueBalls.filter(num => num > blueMidValue);
                const smallBlueBalls = allBlueBalls.filter(num => num <= blueMidValue);

                let consecutiveCount = 0;
                let repeatCount = 0;
                const redBallOccurrences = {};

                allRedBalls.forEach(num => {
                    redBallOccurrences[num] = (redBallOccurrences[num] || 0) + 1;
                });

                Object.values(redBallOccurrences).forEach(count => {
                    if (count > 1) {
                        repeatCount += count - 1;
                    }
                });

                historySamePeriodDraws.forEach(draw => {
                    const drawRedBalls = draw.redBalls || [];
                    const sortedBalls = [...drawRedBalls].sort((a, b) => a - b);
                    for (let i = 0; i < sortedBalls.length - 1; i++) {
                        if (sortedBalls[i + 1] - sortedBalls[i] === 1) {
                            consecutiveCount++;
                        }
                    }
                });

                const redBallTheoretical = totalPeriods * (isRed ? 6 : 5) / redBallRange;
                const blueBallTheoretical = totalPeriods * (isRed ? 1 : 2) / blueBallRange;

                const redBallDetails = [];
                for (let i = 1; i <= redBallRange; i++) {
                    const iStr = i.toString().padStart(2, '0');
                    const actualCount = redBallCounts[iStr] || 0;
                    const absoluteDeviation = actualCount - redBallTheoretical;
                    const relativeDeviation = redBallTheoretical > 0 ? ((actualCount - redBallTheoretical) / redBallTheoretical * 100) : 0;
                    
                    let omissionValue = 0;
                    let found = false;
                    for (let j = historySamePeriodDraws.length - 1; j >= 0; j--) {
                        if (historySamePeriodDraws[j].redBalls && historySamePeriodDraws[j].redBalls.includes(i)) {
                            omissionValue = historySamePeriodDraws.length - 1 - j;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        omissionValue = historySamePeriodDraws.length;
                    }

                    redBallDetails.push({
                        number: i,
                        count: actualCount,
                        absoluteDeviation: absoluteDeviation.toFixed(2),
                        relativeDeviation: relativeDeviation.toFixed(2),
                        omission: omissionValue
                    });
                }

                const blueBallDetails = [];
                for (let i = 1; i <= blueBallRange; i++) {
                    const iStr = i.toString().padStart(2, '0');
                    const actualCount = blueBallCounts[iStr] || 0;
                    const absoluteDeviation = actualCount - blueBallTheoretical;
                    const relativeDeviation = blueBallTheoretical > 0 ? ((actualCount - blueBallTheoretical) / blueBallTheoretical * 100) : 0;
                    
                    let omissionValue = 0;
                    let found = false;
                    for (let j = historySamePeriodDraws.length - 1; j >= 0; j--) {
                        if (historySamePeriodDraws[j].blueBalls && historySamePeriodDraws[j].blueBalls.includes(i)) {
                            omissionValue = historySamePeriodDraws.length - 1 - j;
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        omissionValue = historySamePeriodDraws.length;
                    }

                    blueBallDetails.push({
                        number: i,
                        count: actualCount,
                        absoluteDeviation: absoluteDeviation.toFixed(2),
                        relativeDeviation: relativeDeviation.toFixed(2),
                        omission: omissionValue
                    });
                }

                html += `
                    <div style="margin-top: 40px;">
                        <h3 style="margin-bottom: 20px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">统计分析</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 30px;">
                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                                <h4 style="margin: 0 0 15px 0; color: #E63946; font-size: 18px;">未开出的红球</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    ${unopenedRedBalls.length > 0 ? unopenedRedBalls.map(num => 
                                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #E63946; color: white; font-weight: bold; font-size: 14px;">${num.toString().padStart(2, '0')}</span>`
                                    ).join('') : '<span style="color: #6c757d;">全部已开出</span>'}
                                </div>
                            </div>

                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                                <h4 style="margin: 0 0 15px 0; color: #457B9D; font-size: 18px;">未开出的蓝球</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    ${unopenedBlueBalls.length > 0 ? unopenedBlueBalls.map(num => 
                                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #457B9D; color: white; font-weight: bold; font-size: 14px;">${num.toString().padStart(2, '0')}</span>`
                                    ).join('') : '<span style="color: #6c757d;">全部已开出</span>'}
                                </div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 30px;">
                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                                <h4 style="margin: 0 0 15px 0; color: #28a745; font-size: 18px;">开出最多的红球</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                                    ${mostFrequentRedBalls.length > 0 ? mostFrequentRedBalls.map(num => 
                                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #28a745; color: white; font-weight: bold; font-size: 14px;">${num.toString().padStart(2, '0')}</span>`
                                    ).join('') : '<span style="color: #6c757d;">暂无数据</span>'}
                                    ${maxRedCount > 0 ? `<span style="margin-left: 10px; color: #6c757d; font-size: 14px;">共开出 <strong style="color: #28a745;">${maxRedCount}</strong> 次</span>` : ''}
                                </div>
                            </div>

                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                                <h4 style="margin: 0 0 15px 0; color: #dc3545; font-size: 18px;">开出最少的红球</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                                    ${leastFrequentRedBalls.length > 0 ? leastFrequentRedBalls.map(num => 
                                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #dc3545; color: white; font-weight: bold; font-size: 14px;">${num.toString().padStart(2, '0')}</span>`
                                    ).join('') : '<span style="color: #6c757d;">暂无数据</span>'}
                                    ${minRedCount !== Infinity ? `<span style="margin-left: 10px; color: #6c757d; font-size: 14px;">共开出 <strong style="color: #dc3545;">${minRedCount}</strong> 次</span>` : ''}
                                </div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 30px;">
                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                                <h4 style="margin: 0 0 15px 0; color: #17a2b8; font-size: 18px;">开出最多的蓝球</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                                    ${mostFrequentBlueBalls.length > 0 ? mostFrequentBlueBalls.map(num => 
                                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #17a2b8; color: white; font-weight: bold; font-size: 14px;">${num.toString().padStart(2, '0')}</span>`
                                    ).join('') : '<span style="color: #6c757d;">暂无数据</span>'}
                                    ${maxBlueCount > 0 ? `<span style="margin-left: 10px; color: #6c757d; font-size: 14px;">共开出 <strong style="color: #17a2b8;">${maxBlueCount}</strong> 次</span>` : ''}
                                </div>
                            </div>

                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                                <h4 style="margin: 0 0 15px 0; color: #fd7e14; font-size: 18px;">开出最少的蓝球</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                                    ${leastFrequentBlueBalls.length > 0 ? leastFrequentBlueBalls.map(num => 
                                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #fd7e14; color: white; font-weight: bold; font-size: 14px;">${num.toString().padStart(2, '0')}</span>`
                                    ).join('') : '<span style="color: #6c757d;">暂无数据</span>'}
                                    ${minBlueCount !== Infinity ? `<span style="margin-left: 10px; color: #6c757d; font-size: 14px;">共开出 <strong style="color: #fd7e14;">${minBlueCount}</strong> 次</span>` : ''}
                                </div>
                            </div>
                        </div>

                        <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; margin-bottom: 30px;">
                            <h4 style="margin: 0 0 20px 0; color: #667eea; font-size: 18px;">数据概览</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">总期数</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #E63946;">${totalPeriods}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">总红球数</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #457B9D;">${totalRedBalls}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">总蓝球数</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #2A9D8F;">${totalBlueBalls}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">红球奇偶</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #9B5DE5;">${oddRedBalls.length}：${evenRedBalls.length}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">蓝球奇偶</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #9B5DE5;">${oddBlueBalls.length}：${evenBlueBalls.length}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">红球大小</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #00BBBB;">${bigRedBalls.length}：${smallRedBalls.length}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">蓝球大小</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #00BBBB;">${bigBlueBalls.length}：${smallBlueBalls.length}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">连号次数</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #2A9D8F;">${consecutiveCount}</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                                    <div style="font-size: 14px; color: #6c757d; margin-bottom: 8px;">重号次数</div>
                                    <div style="font-size: 32px; font-weight: bold; color: #FF7700;">${repeatCount}</div>
                                </div>
                            </div>
                        </div>

                        <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; margin-bottom: 30px;">
                            <h4 style="margin: 0 0 20px 0; color: #667eea; font-size: 18px;">红球频次详情（按出现次数排序）</h4>
                            <div style="overflow-x: auto;">
                                <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                    <thead>
                                        <tr>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">号码</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">出现次数</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">理论次数</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">绝对偏差</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">相对偏差(%)</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">遗漏值</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${redBallDetails.sort((a, b) => b.count - a.count).map(detail => `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: #E63946;">${detail.number.toString().padStart(2, '0')}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${detail.count}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${redBallTheoretical.toFixed(2)}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${detail.absoluteDeviation > 0 ? '#dc3545' : detail.absoluteDeviation < 0 ? '#28a745' : '#6c757d'};">${detail.absoluteDeviation}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${detail.relativeDeviation > 0 ? '#dc3545' : detail.relativeDeviation < 0 ? '#28a745' : '#6c757d'};">${detail.relativeDeviation}%</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${detail.omission > 0 ? '#E63946' : '#6c757d'};">${detail.omission}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;">
                            <h4 style="margin: 0 0 20px 0; color: #667eea; font-size: 18px;">蓝球频次详情（按出现次数排序）</h4>
                            <div style="overflow-x: auto;">
                                <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                    <thead>
                                        <tr>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">号码</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">出现次数</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">理论次数</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">绝对偏差</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">相对偏差(%)</th>
                                            <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; text-align: center;">遗漏值</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${blueBallDetails.sort((a, b) => b.count - a.count).map(detail => `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold; color: #457B9D;">${detail.number.toString().padStart(2, '0')}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${detail.count}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${blueBallTheoretical.toFixed(2)}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${detail.absoluteDeviation > 0 ? '#dc3545' : detail.absoluteDeviation < 0 ? '#28a745' : '#6c757d'};">${detail.absoluteDeviation}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${detail.relativeDeviation > 0 ? '#dc3545' : detail.relativeDeviation < 0 ? '#28a745' : '#6c757d'};">${detail.relativeDeviation}%</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${detail.omission > 0 ? '#457B9D' : '#6c757d'};">${detail.omission}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                resultDiv.innerHTML = html;
            }

            static showSampleData() {
                const existingModal = document.getElementById('sampleDataModal');
                if (existingModal) {
                    existingModal.remove();
                }

                let html = `
                    <div id="sampleDataModal" class="modal active">
                        <div class="modal-content" style="max-width: 1100px;">
                            <div class="modal-header">
                                <div class="modal-title">奖级对照表</div>
                                <span class="modal-close" onclick="document.getElementById('sampleDataModal').remove()">&times;</span>
                            </div>
                            <div class="modal-body">
                                <div style="margin-bottom: 30px;">
                                    <h3 style="color: #E63946; border-bottom: 2px solid #E63946; padding-bottom: 10px; margin-bottom: 15px;">双色球奖级</h3>
                                    <table class="result-table" style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖级</th>
                                                <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 60%;">中奖条件</th>
                                                <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖金</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #dc3545; font-weight: bold;">一等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">6红+1蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">500万</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #fd7e14; font-weight: bold;">二等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">6红+0蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">50万</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #ffc107; font-weight: bold;">三等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5红+1蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">3000元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #20c997; font-weight: bold;">四等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5红+0蓝 或 4红+1蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">200元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #0dcaf0; font-weight: bold;">五等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">4红+0蓝 或 3红+1蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">10元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">六等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">2红+1蓝 或 1红+1蓝 或 0红+1蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">福运奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">3红+0蓝</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5元</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>

                                <div>
                                    <h3 style="color: #2A9D8F; border-bottom: 2px solid #2A9D8F; padding-bottom: 10px; margin-bottom: 15px;">大乐透奖级</h3>
                                    <table class="result-table" style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖级</th>
                                                <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 60%;">中奖条件</th>
                                                <th style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; width: 20%;">奖金</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #dc3545; font-weight: bold;">一等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5前+2后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">500万</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #fd7e14; font-weight: bold;">二等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5前+1后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">50万</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #ffc107; font-weight: bold;">三等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5前+0后 或 4前+2后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5000元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #20c997; font-weight: bold;">四等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">4前+1后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">300元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #0dcaf0; font-weight: bold;">五等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">4前+0后 或 3前+2后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">150元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">六等奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">3前+1后 或 2前+2后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">15元</td>
                                            </tr>
                                            <tr>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: #6c757d; font-weight: bold;">好运奖</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; font-size: 13px; line-height: 1.8;">3前+0后<br>2前+1后<br>1前+2后<br>0前+2后</td>
                                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">5元</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-primary" onclick="document.getElementById('sampleDataModal').remove()">关闭</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML('beforeend', html);
            }

            static refreshDNAQuery() {
                const dnaQueryInput = document.getElementById('dnaQueryInput');
                if (dnaQueryInput) {
                    dnaQueryInput.value = '';
                }
                const dnaQueryResult = document.getElementById('dnaQueryResult');
                if (dnaQueryResult) {
                    dnaQueryResult.innerHTML = '';
                }
                MessageSystem.showMessage('DNA查询已刷新', 'info');
            }

            static validateQueryNumbers(queryInput, lotteryType) {
                const queryNumbers = queryInput.split(/[+,，\s]+/).map(n => n.trim()).filter(n => n);

                if (queryNumbers.length === 0) {
                    return { valid: false, message: '请输入要查询的号码' };
                }

                const numbers = queryNumbers.map(n => parseInt(n, 10));

                for (const num of numbers) {
                    if (isNaN(num) || num < 1) {
                        return { valid: false, message: '号码必须是正整数' };
                    }
                }

                if (lotteryType === 'ssq') {
                    if (numbers.length !== 7) {
                        return { valid: false, message: '双色球需要输入7个号码（6个红球 + 1个蓝球）' };
                    }

                    const redBalls = numbers.slice(0, 6);
                    const blueBall = numbers[6];

                    for (const num of redBalls) {
                        if (num > 33) {
                            return { valid: false, message: '红球号码必须在1-33之间' };
                        }
                    }

                    if (blueBall > 16) {
                        return { valid: false, message: '蓝球号码必须在1-16之间' };
                    }

                    const uniqueRedBalls = new Set(redBalls);
                    if (uniqueRedBalls.size !== 6) {
                        return { valid: false, message: '红球号码不能重复' };
                    }
                } else if (lotteryType === 'dlt') {
                    if (numbers.length !== 7) {
                        return { valid: false, message: '大乐透需要输入7个号码（5个前区 + 2个后区）' };
                    }

                    const frontBalls = numbers.slice(0, 5);
                    const backBalls = numbers.slice(5);

                    for (const num of frontBalls) {
                        if (num > 35) {
                            return { valid: false, message: '前区号码必须在1-35之间' };
                        }
                    }

                    for (const num of backBalls) {
                        if (num > 12) {
                            return { valid: false, message: '后区号码必须在1-12之间' };
                        }
                    }

                    const uniqueFrontBalls = new Set(frontBalls);
                    if (uniqueFrontBalls.size !== 5) {
                        return { valid: false, message: '前区号码不能重复' };
                    }

                    const uniqueBackBalls = new Set(backBalls);
                    if (uniqueBackBalls.size !== 2) {
                        return { valid: false, message: '后区号码不能重复' };
                    }
                }

                return { valid: true, message: '' };
            }

            static handleDNAQuery() {
                const lotteryType = document.getElementById('dnaLotteryType').value;
                const queryInput = document.getElementById('dnaQueryInput').value;

                console.log('DNA查询 - 彩票类型:', lotteryType);
                console.log('DNA查询 - 输入号码:', queryInput);
                console.log('DNA查询 - 当前数据:', currentDatabaseData);

                if (!queryInput || queryInput.trim() === '') {
                    MessageSystem.showMessage('请输入要查询的号码', 'error');
                    return;
                }

                const validation = this.validateQueryNumbers(queryInput, lotteryType);
                if (!validation.valid) {
                    MessageSystem.showMessage(validation.message, 'error');
                    return;
                }

                MessageSystem.showMessage('开始执行DNA查询...', 'info');

                setTimeout(async () => {
                    try {
                        const queryNumbers = queryInput.split(/[+,，\s]+/).map(n => n.trim()).filter(n => n);
                        const formattedQueryNumbers = queryNumbers.map(n => n.padStart(2, '0'));
                        const queryResult = await this.executeQuery(lotteryType, queryInput);
                        console.log('DNA查询结果:', queryResult);
                        
                        if (queryResult.message) {
                            document.getElementById('dnaQueryResult').innerHTML = `<p style="color: #666; text-align: center; padding: 20px;">${queryResult.message}</p>`;
                            return;
                        }
                        
                        this.saveQueryHistory(lotteryType, queryInput);
                        this.showQueryResult(queryResult.results, formattedQueryNumbers, lotteryType, queryResult.totalDraws);
                    } catch (error) {
                        console.error('DNA查询错误:', error);
                        MessageSystem.showMessage('查询出错: ' + error.message, 'error');
                    }
                }, 300);
            }

            static generateRandomNumbers() {
                const lotteryType = document.getElementById('dnaLotteryType').value;
                let randomNumbers = '';

                if (lotteryType === 'ssq') {
                    const redBalls = this.generateRandomSet(1, 33, 6);
                    const blueBall = Math.floor(Math.random() * 16) + 1;
                    randomNumbers = `${redBalls.map(n => n.toString().padStart(2, '0')).join(',')}+${blueBall.toString().padStart(2, '0')}`;
                } else if (lotteryType === 'dlt') {
                    const frontBalls = this.generateRandomSet(1, 35, 5);
                    const backBalls = this.generateRandomSet(1, 12, 2);
                    randomNumbers = `${frontBalls.map(n => n.toString().padStart(2, '0')).join(',')}+${backBalls.map(n => n.toString().padStart(2, '0')).join(',')}`;
                }

                document.getElementById('dnaQueryInput').value = randomNumbers;
                MessageSystem.showMessage('已生成随机号码，点击查询按钮开始查询', 'info');
            }

            static generateRandomSet(min, max, count) {
                const numbers = [];
                while (numbers.length < count) {
                    const num = Math.floor(Math.random() * (max - min + 1)) + min;
                    if (!numbers.includes(num)) {
                        numbers.push(num);
                    }
                }
                return numbers.sort((a, b) => a - b);
            }

            static async saveQueryHistory(lotteryType, queryInput) {
                try {
                    const request = indexedDB.open('LotteryDNAQueryHistory', 1);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('history')) {
                            const objectStore = db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
                            objectStore.createIndex('lotteryType', 'lotteryType', { unique: false });
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };

                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['history'], 'readwrite');
                        const objectStore = transaction.objectStore('history');
                        
                        const record = {
                            lotteryType: lotteryType,
                            queryInput: queryInput,
                            timestamp: new Date().getTime()
                        };
                        
                        objectStore.add(record);
                        
                        transaction.oncomplete = () => {
                            console.log('查询历史已保存');
                        };
                        
                        transaction.onerror = (event) => {
                            console.error('保存查询历史失败:', event.target.error);
                        };
                    };

                    request.onerror = (event) => {
                        console.error('打开IndexedDB失败:', event.target.error);
                    };
                } catch (error) {
                    console.error('保存查询历史出错:', error);
                }
            }

            static async showQueryHistory() {
                try {
                    const request = indexedDB.open('LotteryDNAQueryHistory', 1);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('history')) {
                            const objectStore = db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
                            objectStore.createIndex('lotteryType', 'lotteryType', { unique: false });
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };

                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['history'], 'readonly');
                        const objectStore = transaction.objectStore('history');
                        const index = objectStore.index('timestamp');
                        
                        const query = index.openCursor(null, 'prev');
                        const historyRecords = [];
                        
                        query.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                historyRecords.push(cursor.value);
                                cursor.continue();
                            } else {
                                this.displayHistoryModal(historyRecords);
                            }
                        };

                        query.onerror = (event) => {
                            console.error('加载查询历史失败:', event.target.error);
                            MessageSystem.showMessage('加载查询历史失败', 'error');
                        };
                    };

                    request.onerror = (event) => {
                        console.error('打开IndexedDB失败:', event.target.error);
                        MessageSystem.showMessage('加载查询历史失败', 'error');
                    };
                } catch (error) {
                    console.error('显示查询历史出错:', error);
                    MessageSystem.showMessage('显示查询历史失败', 'error');
                }
            }

            static displayHistoryModal(historyRecords) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                const content = document.createElement('div');
                content.style.cssText = `
                    background: white;
                    padding: 20px;
                    border-radius: 8px;
                    max-width: 90%;
                    max-height: 80%;
                    overflow: auto;
                    position: relative;
                    min-width: 600px;
                `;

                let html = `
                    <h3 style="margin-bottom: 15px;">查询历史</h3>
                    <div style="margin-bottom: 15px;">
                        <button id="clearHistoryBtn" class="btn btn-danger" style="padding: 5px 10px; font-size: 12px;">
                            <i class="fas fa-trash"></i> 清空历史
                        </button>
                    </div>
                `;

                if (historyRecords.length === 0) {
                    html += `<p style="color: #666; text-align: center; padding: 20px;">暂无查询历史</p>`;
                } else {
                    html += `
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">时间</th>
                                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">类型</th>
                                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">号码</th>
                                    <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">操作</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    historyRecords.forEach((record, index) => {
                        const date = new Date(record.timestamp);
                        const timeStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
                        const typeStr = record.lotteryType === 'ssq' ? '双色球DNA' : '大乐透DNA';
                        
                        html += `
                            <tr>
                                <td style="padding: 10px; border: 1px solid #ddd;">${timeStr}</td>
                                <td style="padding: 10px; border: 1px solid #ddd;">${typeStr}</td>
                                <td style="padding: 10px; border: 1px solid #ddd;">${record.queryInput}</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">
                                    <button class="btn btn-primary btn-use-history" data-id="${record.id}" data-type="${record.lotteryType}" data-input="${record.queryInput}" style="padding: 5px 10px; font-size: 12px;">
                                        使用
                                    </button>
                                    <button class="btn btn-danger btn-delete-history" data-id="${record.id}" style="padding: 5px 10px; font-size: 12px;">
                                        删除
                                    </button>
                                </td>
                            </tr>
                        `;
                    });

                    html += `
                            </tbody>
                        </table>
                    `;
                }

                html += `<button id="closeHistoryModal" style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">关闭</button>`;

                content.innerHTML = html;
                modal.appendChild(content);
                document.body.appendChild(modal);

                const closeModal = () => {
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                };

                const closeBtn = content.querySelector('#closeHistoryModal');
                if (closeBtn) {
                    closeBtn.addEventListener('click', closeModal);
                }

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal();
                    }
                });

                const useButtons = content.querySelectorAll('.btn-use-history');
                useButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const type = btn.getAttribute('data-type');
                        const input = btn.getAttribute('data-input');
                        
                        document.getElementById('dnaLotteryType').value = type;
                        document.getElementById('dnaQueryInput').value = input;
                        
                        closeModal();
                        MessageSystem.showMessage('已加载历史查询记录', 'info');
                    });
                });

                const deleteButtons = content.querySelectorAll('.btn-delete-history');
                deleteButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = parseInt(btn.getAttribute('data-id'));
                        this.deleteHistoryRecord(id, btn);
                    });
                });

                const clearHistoryBtn = content.querySelector('#clearHistoryBtn');
                if (clearHistoryBtn) {
                    clearHistoryBtn.addEventListener('click', () => {
                        if (confirm('确定要清空所有查询历史吗？')) {
                            this.clearAllHistory();
                            closeModal();
                        }
                    });
                }
            }

            static deleteHistoryRecord(id, btnElement) {
                try {
                    const request = indexedDB.open('LotteryDNAQueryHistory', 1);
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['history'], 'readwrite');
                        const objectStore = transaction.objectStore('history');
                        
                        const deleteRequest = objectStore.delete(id);
                        
                        deleteRequest.onsuccess = () => {
                            const row = btnElement.closest('tr');
                            row.remove();
                            MessageSystem.showMessage('查询记录已删除', 'info');
                        };

                        deleteRequest.onerror = (event) => {
                            console.error('删除查询记录失败:', event.target.error);
                            MessageSystem.showMessage('删除查询记录失败', 'error');
                        };
                    };

                    request.onerror = (event) => {
                        console.error('打开IndexedDB失败:', event.target.error);
                        MessageSystem.showMessage('删除查询记录失败', 'error');
                    };
                } catch (error) {
                    console.error('删除查询记录出错:', error);
                    MessageSystem.showMessage('删除查询记录失败', 'error');
                }
            }

            static clearAllHistory() {
                try {
                    const request = indexedDB.open('LotteryDNAQueryHistory', 1);
                    
                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        const transaction = db.transaction(['history'], 'readwrite');
                        const objectStore = transaction.objectStore('history');
                        
                        const clearRequest = objectStore.clear();
                        
                        clearRequest.onsuccess = () => {
                            MessageSystem.showMessage('所有查询历史已清空', 'info');
                        };

                        clearRequest.onerror = (event) => {
                            console.error('清空查询历史失败:', event.target.error);
                            MessageSystem.showMessage('清空查询历史失败', 'error');
                        };
                    };

                    request.onerror = (event) => {
                        console.error('打开IndexedDB失败:', event.target.error);
                        MessageSystem.showMessage('清空查询历史失败', 'error');
                    };
                } catch (error) {
                    console.error('清空查询历史出错:', error);
                    MessageSystem.showMessage('清空查询历史失败', 'error');
                }
            }

            static async executeQuery(lotteryType, queryInput) {
                let queryDatabaseData = null;
                
                if (!dataManager.databases[lotteryType]) {
                    dataManager.databases[lotteryType] = new LotteryDatabase(lotteryType);
                    await dataManager.databases[lotteryType].init();
                }
                
                if (dataManager.databases[lotteryType]) {
                    queryDatabaseData = await dataManager.databases[lotteryType].getData();
                }
                
                if (!queryDatabaseData || !queryDatabaseData.draws || queryDatabaseData.draws.length === 0) {
                    return {
                        results: [],
                        message: '暂无历史数据'
                    };
                }
                
                const data = queryDatabaseData.draws || [];
                console.log('数据库中的记录数:', data.length);
                console.log('数据库前3条记录:', data.slice(0, 3));

                const queryNumbers = queryInput.split(/[+,，\s]+/).map(n => n.trim()).filter(n => n);
                console.log('解析后的查询号码:', queryNumbers);

                const formattedQueryNumbers = queryNumbers.map(n => n.padStart(2, '0'));
                console.log('格式化后的查询号码:', formattedQueryNumbers);
                console.log('查询号码字符串:', formattedQueryNumbers.join(','));

                const results = data.map(item => {
                    const numbers = [];
                    if (item.redBalls) {
                        numbers.push(...item.redBalls);
                    }
                    if (item.blueBalls) {
                        numbers.push(...item.blueBalls);
                    }

                    const indicators = this.calculateNumberIndicators({ numbers: item.redBalls || [] }, lotteryType);

                    let redMatch = 0, blueMatch = 0, frontMatch = 0, backMatch = 0;

                    if (lotteryType === 'ssq') {
                        const queryRed = formattedQueryNumbers.slice(0, 6);
                        const queryBlue = formattedQueryNumbers.slice(6);

                        if (item.redBalls) {
                            const redBallsStr = item.redBalls.map(n => n.toString().padStart(2, '0'));
                            redMatch = queryRed.filter(n => redBallsStr.includes(n)).length;
                        }
                        if (item.blueBalls) {
                            const blueBallsStr = item.blueBalls.map(n => n.toString().padStart(2, '0'));
                            blueMatch = queryBlue.filter(n => blueBallsStr.includes(n)).length;
                        }
                    } else if (lotteryType === 'dlt') {
                        const queryFront = formattedQueryNumbers.slice(0, 5);
                        const queryBack = formattedQueryNumbers.slice(5);

                        if (item.redBalls) {
                            const redBallsStr = item.redBalls.map(n => n.toString().padStart(2, '0'));
                            frontMatch = queryFront.filter(n => redBallsStr.includes(n)).length;
                        }
                        if (item.blueBalls) {
                            const blueBallsStr = item.blueBalls.map(n => n.toString().padStart(2, '0'));
                            backMatch = queryBack.filter(n => blueBallsStr.includes(n)).length;
                        }
                    }

                    return {
                        issue: item.issue || item.period,
                        period: item.period || item.issue,
                        redBalls: item.redBalls || [],
                        blueBalls: item.blueBalls || [],
                        numbers: numbers,
                        indicators: indicators,
                        redMatch: redMatch,
                        blueMatch: blueMatch,
                        frontMatch: frontMatch,
                        backMatch: backMatch
                    };
                });

                const prizeLevelOrder = lotteryType === 'ssq' ? {
                    '一等奖': 1,
                    '二等奖': 2,
                    '三等奖': 3,
                    '四等奖': 4,
                    '五等奖': 5,
                    '六等奖': 6,
                    '福运奖': 7,
                    '未中奖': 10
                } : {
                    '一等奖': 1,
                    '二等奖': 2,
                    '三等奖': 3,
                    '四等奖': 4,
                    '五等奖': 5,
                    '六等奖': 6,
                    '好运奖': 7,
                    '未中奖': 10
                };

                results.sort((a, b) => {
                    const prizeInfoA = this.getPrizeInfo(a, lotteryType);
                    const prizeInfoB = this.getPrizeInfo(b, lotteryType);
                    const orderA = prizeLevelOrder[prizeInfoA.prizeLevel] || 10;
                    const orderB = prizeLevelOrder[prizeInfoB.prizeLevel] || 10;
                    return orderA - orderB;
                });

                console.log('查询结果数量:', results.length);
                
                return {
                    results: results,
                    totalDraws: data.length
                };
            }

            static showQueryResult(results, queryNumbers, lotteryType, totalDraws) {
                const dnaQueryResult = document.getElementById('dnaQueryResult');
                if (!dnaQueryResult) {
                    MessageSystem.showMessage('查询结果容器不存在', 'error');
                    return;
                }

                const queryNumbersStr = queryNumbers.join(' ');
                const winningResults = results.filter(result => {
                    const prizeInfo = this.getPrizeInfo(result, lotteryType);
                    return prizeInfo.prizeLevel !== '未中奖';
                });
                const winCount = winningResults.length;
                const winRate = totalDraws > 0 ? ((winCount / totalDraws) * 100).toFixed(2) : '0.00';

                const prizeStats = this.calculatePrizeStatistics(results, lotteryType);
                const queryRedBalls = lotteryType === 'ssq' ? queryNumbers.slice(0, 6) : queryNumbers.slice(0, 5);
                const indicators = this.calculateNumberIndicators({ numbers: queryRedBalls }, lotteryType);

                let formattedQueryNumbers = '';
                if (lotteryType === 'ssq') {
                    const redBalls = queryNumbers.slice(0, 6).map(n => n.padStart(2, '0'));
                    const blueBalls = queryNumbers.slice(6).map(n => n.padStart(2, '0'));
                    const redBallsHTML = redBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #dc3545; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num}</span>`
                    ).join('');
                    const blueBallsHTML = blueBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #007bff; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num}</span>`
                    ).join('');
                    formattedQueryNumbers = `${redBallsHTML} <span style="font-size: 24px; font-weight: bold; margin: 0 10px;">+</span> ${blueBallsHTML}`;
                } else if (lotteryType === 'dlt') {
                    const frontBalls = queryNumbers.slice(0, 5).map(n => n.padStart(2, '0'));
                    const backBalls = queryNumbers.slice(5).map(n => n.padStart(2, '0'));
                    const frontBallsHTML = frontBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #dc3545; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num}</span>`
                    ).join('');
                    const backBallsHTML = backBalls.map(num => 
                        `<span style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: #007bff; color: white; font-weight: bold; font-size: 16px; margin: 0 3px;">${num}</span>`
                    ).join('');
                    formattedQueryNumbers = `${frontBallsHTML} <span style="font-size: 24px; font-weight: bold; margin: 0 10px;">+</span> ${backBallsHTML}`;
                }

                const indicatorText = `和值: <span style="color: #007bff; font-weight: bold;">${indicators.sum}</span> | 跨度: <span style="color: #28a745; font-weight: bold;">${indicators.span}</span> | 连号: <span style="color: #fd7e14; font-weight: bold;">${indicators.consecutive}</span> | 大中小: <span style="color: #6f42c1; font-weight: bold;">${indicators.threeZone}</span> | 奇偶: <span style="color: #17a2b8; font-weight: bold;">${indicators.oddEven}</span> | AC值: <span style="color: #dc3545; font-weight: bold;">${indicators.acValue}</span> | 大小比: <span style="color: #e83e8c; font-weight: bold;">${indicators.bigSmall}</span> | 质合比: <span style="color: #6610f2; font-weight: bold;">${indicators.primeComposite}</span>`;

                let html = `
                    <div class="query-result-container">
                        <div style="margin-bottom: 30px;">
                            <div style="background: #f0f2f5; color: #333; padding: 30px 20px; border-radius: 10px; text-align: center; border: 2px solid #e9ecef;">
                                <h3 style="margin: 0 0 20px 0; font-size: 24px; color: #495057;">查询号码</h3>
                                <div style="font-size: 0; margin-bottom: 20px;">${formattedQueryNumbers}</div>
                                <div style="font-size: 14px; color: #495057; line-height: 1.6;">${indicatorText}</div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 30px;">
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #28a745;">
                                <div style="color: #6c757d; font-size: 14px; margin-bottom: 10px;">中奖次数</div>
                                <div style="font-size: 28px; font-weight: bold; color: #28a745;">${winCount}</div>
                            </div>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #007bff;">
                                <div style="color: #6c757d; font-size: 14px; margin-bottom: 10px;">胜率</div>
                                <div style="font-size: 28px; font-weight: bold; color: #007bff;">${winRate}%</div>
                            </div>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #ffc107;">
                                <div style="color: #6c757d; font-size: 14px; margin-bottom: 10px;">总奖金</div>
                                <div style="font-size: 28px; font-weight: bold; color: #ffc107;">${prizeStats.totalPrize}</div>
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">中奖统计</h4>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                                ${this.generatePrizeStatsHTML(prizeStats)}
                            </div>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">详细中奖记录</h4>
                `;

                html += `
                        <table class="result-table" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">期号</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">中奖号码</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">奖项</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">中奖条件</th>
                                    <th style="padding: 12px; border: 1px solid #ddd; background: #f5f5f5;">奖金</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                const prizeOrder = {
                    '一等奖': 1,
                    '二等奖': 2,
                    '三等奖': 3,
                    '四等奖': 4,
                    '五等奖': 5,
                    '六等奖': 6,
                    '福运奖': 7,
                    '好运奖': 7,
                    '未中奖': 999
                };

                const sortedWinningResults = [...winningResults];

                sortedWinningResults.sort((a, b) => {
                    const prizeInfoA = this.getPrizeInfo(a, lotteryType);
                    const prizeInfoB = this.getPrizeInfo(b, lotteryType);
                    const orderA = prizeOrder[prizeInfoA.prizeLevel] || 999;
                    const orderB = prizeOrder[prizeInfoB.prizeLevel] || 999;

                    if (orderA !== orderB) {
                        return orderA - orderB;
                    }

                    const periodA = parseInt(a.issue || a.period || '0');
                    const periodB = parseInt(b.issue || b.period || '0');
                    return periodB - periodA;
                });

                sortedWinningResults.forEach(result => {
                    const prizeInfo = this.getPrizeInfo(result, lotteryType);

                    let winningNumbersHTML = '';

                    if (lotteryType === 'ssq') {
                        const redBalls = result.redBalls || [];
                        const blueBalls = result.blueBalls || [];
                        const queryRed = queryNumbers.slice(0, 6).map(n => n.padStart(2, '0'));
                        const queryBlue = queryNumbers.slice(6).map(n => n.padStart(2, '0'));

                        const redNumbersHTML = redBalls.map(num => {
                            if (queryRed.includes(num)) {
                                return `<span style="color: #dc3545; font-weight: bold;">${num}</span>`;
                            } else {
                                return `<span style="color: #000000;">${num}</span>`;
                            }
                        }).join(' ');

                        const blueNumbersHTML = blueBalls.map(num => {
                            if (queryBlue.includes(num)) {
                                return `<span style="color: #007bff; font-weight: bold;">${num}</span>`;
                            } else {
                                return `<span style="color: #000000;">${num}</span>`;
                            }
                        }).join(' ');

                        winningNumbersHTML = `${redNumbersHTML} | ${blueNumbersHTML}`;
                    } else if (lotteryType === 'dlt') {
                        const frontBalls = result.redBalls || [];
                        const backBalls = result.blueBalls || [];
                        const queryFront = queryNumbers.slice(0, 5).map(n => n.padStart(2, '0'));
                        const queryBack = queryNumbers.slice(5).map(n => n.padStart(2, '0'));

                        const frontNumbersHTML = frontBalls.map(num => {
                            if (queryFront.includes(num)) {
                                return `<span style="color: #dc3545; font-weight: bold;">${num}</span>`;
                            } else {
                                return `<span style="color: #000000;">${num}</span>`;
                            }
                        }).join(' ');

                        const backNumbersHTML = backBalls.map(num => {
                            if (queryBack.includes(num)) {
                                return `<span style="color: #007bff; font-weight: bold;">${num}</span>`;
                            } else {
                                return `<span style="color: #000000;">${num}</span>`;
                            }
                        }).join(' ');

                        winningNumbersHTML = `${frontNumbersHTML} | ${backNumbersHTML}`;
                    }

                    const period = result.issue || result.period || '未知';

                    const prizeColor = prizeInfo.prizeLevel === '一等奖' ? '#dc3545' :
                                     prizeInfo.prizeLevel === '二等奖' ? '#fd7e14' :
                                     prizeInfo.prizeLevel === '三等奖' ? '#ffc107' :
                                     prizeInfo.prizeLevel === '四等奖' ? '#20c997' :
                                     prizeInfo.prizeLevel === '五等奖' ? '#0dcaf0' :
                                     prizeInfo.prizeLevel === '六等奖' ? '#6f42c1' :
                                     prizeInfo.prizeLevel === '福运奖' ? '#17a2b8' :
                                     prizeInfo.prizeLevel === '好运奖' ? '#e83e8c' :
                                     '#6c757d';

                    const prizeCondition = prizeInfo.prizeCondition || '-';

                    html += `
                        <tr>
                            <td style="padding: 12px; border: 1px solid #ddd;">${period}</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">${winningNumbersHTML}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; color: ${prizeColor}; font-weight: bold;">${prizeInfo.prizeLevel}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; color: ${prizeCondition !== '-' ? '#2A9D8F' : '#6c757d'}; font-weight: ${prizeCondition !== '-' ? 'bold' : 'normal'};">${prizeCondition}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; color: #ffc107; font-weight: bold;">${prizeInfo.prizeAmount}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                `;

                html += `
                        </div>
                    </div>
                `;

                dnaQueryResult.innerHTML = html;
            }

            static calculateNumberIndicators(item, lotteryType) {
                const numbers = item.numbers.map(n => parseInt(n, 10)).sort((a, b) => a - b);
                const indicators = {
                    sum: numbers.reduce((a, b) => a + b, 0),
                    average: (numbers.reduce((a, b) => a + b, 0) / numbers.length).toFixed(2),
                    max: Math.max(...numbers),
                    min: Math.min(...numbers),
                    span: Math.max(...numbers) - Math.min(...numbers),
                    oddCount: numbers.filter(n => n % 2 !== 0).length,
                    evenCount: numbers.filter(n => n % 2 === 0).length,
                    oddEven: `${numbers.filter(n => n % 2 !== 0).length}:${numbers.filter(n => n % 2 === 0).length}`,
                    consecutive: this.calculateConsecutive(numbers),
                    threeZone: this.calculateThreeZone(numbers, lotteryType),
                    acValue: this.calculateACValue(numbers),
                    bigSmall: this.calculateBigSmall(numbers, lotteryType),
                    primeComposite: this.calculatePrimeComposite(numbers)
                };

                return indicators;
            }

            static calculateConsecutive(numbers) {
                let consecutiveCount = 0;
                for (let i = 0; i < numbers.length - 1; i++) {
                    if (numbers[i + 1] - numbers[i] === 1) {
                        consecutiveCount++;
                    }
                }
                if (numbers.includes(1) && numbers.includes(33)) {
                    consecutiveCount++;
                }
                return consecutiveCount;
            }

            static calculateThreeZone(numbers, lotteryType) {
                let zone1 = 0, zone2 = 0, zone3 = 0;

                if (lotteryType === 'ssq') {
                    numbers.forEach(n => {
                        if (n >= 1 && n <= 11) zone1++;
                        else if (n >= 12 && n <= 22) zone2++;
                        else if (n >= 23 && n <= 33) zone3++;
                    });
                } else if (lotteryType === 'dlt') {
                    numbers.forEach(n => {
                        if (n >= 1 && n <= 12) zone1++;
                        else if (n >= 13 && n <= 24) zone2++;
                        else if (n >= 25 && n <= 35) zone3++;
                    });
                }

                return `${zone3}:${zone2}:${zone1}`;
            }

            static calculateACValue(numbers) {
                const differences = new Set();
                for (let i = 0; i < numbers.length; i++) {
                    for (let j = i + 1; j < numbers.length; j++) {
                        differences.add(Math.abs(numbers[j] - numbers[i]));
                    }
                }
                return differences.size - numbers.length + 1;
            }

            static calculateBigSmall(numbers, lotteryType) {
                let bigCount = 0, smallCount = 0;
                let midValue;

                if (lotteryType === 'ssq') {
                    midValue = 17;
                } else if (lotteryType === 'dlt') {
                    midValue = 18;
                }

                numbers.forEach(n => {
                    if (n <= midValue) smallCount++;
                    else bigCount++;
                });

                return `${bigCount}:${smallCount}`;
            }

            static calculatePrimeComposite(numbers) {
                const primes = new Set([1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]);
                let primeCount = 0, compositeCount = 0;

                numbers.forEach(n => {
                    if (primes.has(n)) {
                        primeCount++;
                    } else if (n > 1) {
                        compositeCount++;
                    }
                });

                return `${primeCount}:${compositeCount}`;
            }

            static generateIndicatorsHTML(indicators) {
                return `
                    <div class="indicators">
                        <div class="indicator-item">
                            <span class="indicator-label">和值:</span>
                            <span class="indicator-value">${indicators.sum}</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">均值:</span>
                            <span class="indicator-value">${indicators.average}</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">跨度:</span>
                            <span class="indicator-value">${indicators.span}</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">奇数:</span>
                            <span class="indicator-value">${indicators.oddCount}</span>
                        </div>
                        <div class="indicator-item">
                            <span class="indicator-label">偶数:</span>
                            <span class="indicator-value">${indicators.evenCount}</span>
                        </div>
                    </div>
                `;
            }

            static calculatePrizeStatistics(results, lotteryType) {
                const prizeStats = {
                    totalPrize: 0,
                    prizeCounts: {}
                };

                if (lotteryType === 'ssq') {
                    prizeStats.prizeCounts = {
                        '一等奖': 0,
                        '二等奖': 0,
                        '三等奖': 0,
                        '四等奖': 0,
                        '五等奖': 0,
                        '六等奖': 0,
                        '福运奖': 0,
                        '未中奖': 0
                    };

                    results.forEach(result => {
                        const prizeInfo = this.getPrizeInfo(result, lotteryType);
                        prizeStats.prizeCounts[prizeInfo.prizeLevel]++;
                        prizeStats.totalPrize += prizeInfo.prizeAmountNum;
                    });
                } else if (lotteryType === 'dlt') {
                    prizeStats.prizeCounts = {
                        '一等奖': 0,
                        '二等奖': 0,
                        '三等奖': 0,
                        '四等奖': 0,
                        '五等奖': 0,
                        '六等奖': 0,
                        '好运奖': 0,
                        '未中奖': 0
                    };

                    results.forEach(result => {
                        const prizeInfo = this.getPrizeInfo(result, lotteryType);
                        prizeStats.prizeCounts[prizeInfo.prizeLevel]++;
                        prizeStats.totalPrize += prizeInfo.prizeAmountNum;
                    });
                }

                prizeStats.totalPrize = prizeStats.totalPrize.toLocaleString();
                return prizeStats;
            }

            static getPrizeInfo(result, lotteryType) {
                let prizeLevel = '';
                let prizeAmount = 0;
                let prizeAmountNum = 0;
                let prizeCondition = '';

                if (lotteryType === 'ssq') {
                    const redMatch = result.redMatch || 0;
                    const blueMatch = result.blueMatch || 0;

                    if (redMatch === 6 && blueMatch === 1) {
                        prizeLevel = '一等奖';
                        prizeAmount = 5000000;
                        prizeCondition = '6红+1蓝';
                    } else if (redMatch === 6 && blueMatch === 0) {
                        prizeLevel = '二等奖';
                        prizeAmount = 500000;
                        prizeCondition = '6红+0蓝';
                    } else if (redMatch === 5 && blueMatch === 1) {
                        prizeLevel = '三等奖';
                        prizeAmount = 3000;
                        prizeCondition = '5红+1蓝';
                    } else if (redMatch === 5 && blueMatch === 0) {
                        prizeLevel = '四等奖';
                        prizeAmount = 200;
                        prizeCondition = '5红+0蓝';
                    } else if (redMatch === 4 && blueMatch === 1) {
                        prizeLevel = '四等奖';
                        prizeAmount = 200;
                        prizeCondition = '4红+1蓝';
                    } else if (redMatch === 4 && blueMatch === 0) {
                        prizeLevel = '五等奖';
                        prizeAmount = 10;
                        prizeCondition = '4红+0蓝';
                    } else if (redMatch === 3 && blueMatch === 1) {
                        prizeLevel = '五等奖';
                        prizeAmount = 10;
                        prizeCondition = '3红+1蓝';
                    } else if (redMatch === 3 && blueMatch === 0) {
                        prizeLevel = '福运奖';
                        prizeAmount = 5;
                        prizeCondition = '3红+0蓝';
                    } else if (redMatch === 2 && blueMatch === 1) {
                        prizeLevel = '六等奖';
                        prizeAmount = 5;
                        prizeCondition = '2红+1蓝';
                    } else if (redMatch === 1 && blueMatch === 1) {
                        prizeLevel = '六等奖';
                        prizeAmount = 5;
                        prizeCondition = '1红+1蓝';
                    } else if (redMatch === 0 && blueMatch === 1) {
                        prizeLevel = '六等奖';
                        prizeAmount = 5;
                        prizeCondition = '0红+1蓝';
                    } else {
                        prizeLevel = '未中奖';
                        prizeAmount = 0;
                        prizeCondition = '-';
                    }
                } else if (lotteryType === 'dlt') {
                    const frontMatch = result.frontMatch || 0;
                    const backMatch = result.backMatch || 0;

                    if (frontMatch === 5 && backMatch === 2) {
                        prizeLevel = '一等奖';
                        prizeAmount = 5000000;
                        prizeCondition = '5前+2后';
                    } else if (frontMatch === 5 && backMatch === 1) {
                        prizeLevel = '二等奖';
                        prizeAmount = 500000;
                        prizeCondition = '5前+1后';
                    } else if (frontMatch === 5 && backMatch === 0) {
                        prizeLevel = '三等奖';
                        prizeAmount = 5000;
                        prizeCondition = '5前+0后';
                    } else if (frontMatch === 4 && backMatch === 2) {
                        prizeLevel = '三等奖';
                        prizeAmount = 5000;
                        prizeCondition = '4前+2后';
                    } else if (frontMatch === 4 && backMatch === 1) {
                        prizeLevel = '四等奖';
                        prizeAmount = 300;
                        prizeCondition = '4前+1后';
                    } else if (frontMatch === 4 && backMatch === 0) {
                        prizeLevel = '五等奖';
                        prizeAmount = 150;
                        prizeCondition = '4前+0后';
                    } else if (frontMatch === 3 && backMatch === 2) {
                        prizeLevel = '五等奖';
                        prizeAmount = 150;
                        prizeCondition = '3前+2后';
                    } else if (frontMatch === 3 && backMatch === 1) {
                        prizeLevel = '六等奖';
                        prizeAmount = 15;
                        prizeCondition = '3前+1后';
                    } else if (frontMatch === 2 && backMatch === 2) {
                        prizeLevel = '六等奖';
                        prizeAmount = 15;
                        prizeCondition = '2前+2后';
                    } else if (frontMatch === 3 && backMatch === 0) {
                        prizeLevel = '好运奖';
                        prizeAmount = 5;
                        prizeCondition = '3前+0后';
                    } else if (frontMatch === 2 && backMatch === 1) {
                        prizeLevel = '好运奖';
                        prizeAmount = 5;
                        prizeCondition = '2前+1后';
                    } else if (frontMatch === 1 && backMatch === 2) {
                        prizeLevel = '好运奖';
                        prizeAmount = 5;
                        prizeCondition = '1前+2后';
                    } else if (frontMatch === 0 && backMatch === 2) {
                        prizeLevel = '好运奖';
                        prizeAmount = 5;
                        prizeCondition = '0前+2后';
                    } else {
                        prizeLevel = '未中奖';
                        prizeAmount = 0;
                        prizeCondition = '-';
                    }
                }

                prizeAmountNum = prizeAmount;
                if (prizeAmount >= 10000) {
                    prizeAmount = (prizeAmount / 10000).toFixed(2) + '万';
                }

                return {
                    prizeLevel: prizeLevel,
                    prizeAmount: prizeAmount,
                    prizeAmountNum: prizeAmountNum,
                    prizeCondition: prizeCondition
                };
            }

            static generatePrizeStatsHTML(prizeStats) {
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">';

                for (const [prizeLevel, count] of Object.entries(prizeStats.prizeCounts)) {
                    const bgColor = prizeLevel.includes('一等奖') ? '#dc3545' :
                                   prizeLevel.includes('二等奖') ? '#fd7e14' :
                                   prizeLevel.includes('三等奖') ? '#ffc107' :
                                   prizeLevel.includes('四等奖') ? '#20c997' :
                                   prizeLevel.includes('五等奖') ? '#0dcaf0' :
                                   prizeLevel.includes('六等奖') ? '#6f42c1' :
                                   prizeLevel.includes('福运奖') ? '#17a2b8' :
                                   prizeLevel.includes('好运奖') ? '#e83e8c' :
                                   '#adb5bd';

                    html += `
                        <div style="background: ${bgColor}; color: white; padding: 12px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 12px; margin-bottom: 5px;">${prizeLevel}</div>
                            <div style="font-size: 20px; font-weight: bold;">${count}次</div>
                        </div>
                    `;
                }

                html += '</div>';
                return html;
            }

            // 处理分页按钮点击
            static handlePagination(button) {
                const buttonId = button.id;

                // 确定当前显示的数据库类型
                let displayLotteryType = 'ssq';
                const databaseCard = document.getElementById('databaseCard');
                if (databaseCard && databaseCard.style.display !== 'none') {
                    const breadcrumbContainer = document.querySelector('.breadcrumb');
                    if (breadcrumbContainer) {
                        const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                        if (breadcrumbItems.length >= 3) {
                            const breadcrumbText = breadcrumbItems[2].textContent;
                            if (breadcrumbText.includes('大乐透')) {
                                displayLotteryType = 'dlt';
                            }
                        }
                    }
                }

                switch(buttonId) {
                    case 'firstPageBtn':
                        currentPage = 1;
                        break;
                    case 'prevPageBtn':
                        if (currentPage > 1) {
                            currentPage--;
                        }
                        break;
                    case 'nextPageBtn':
                        if (currentPage < totalPages) {
                            currentPage++;
                        }
                        break;
                    case 'lastPageBtn':
                        currentPage = totalPages;
                        break;
                    case 'goPageBtn':
                        const currentPageInput = document.getElementById('currentPageInput');
                        const targetPage = parseInt(currentPageInput.value);
                        if (targetPage >= 1 && targetPage <= totalPages) {
                            currentPage = targetPage;
                        } else {
                            MessageSystem.showMessage('请输入有效的页码', 'warning');
                            return;
                        }
                        break;
                }

                // 保存当前彩票类型的页码状态
                pageStates[displayLotteryType] = currentPage;

                dataManager.updateDatabaseTable();
            }

            // 处理每页显示条数变化
            static handlePageSizeChange(select) {
                const newPageSize = parseInt(select.value);
                if (newPageSize && newPageSize > 0) {
                    pageSize = newPageSize;
                    currentPage = 1;

                    // 确定当前显示的数据库类型
                    let displayLotteryType = 'ssq';
                    const databaseCard = document.getElementById('databaseCard');
                    if (databaseCard && databaseCard.style.display !== 'none') {
                        const breadcrumbContainer = document.querySelector('.breadcrumb');
                        if (breadcrumbContainer) {
                            const breadcrumbItems = breadcrumbContainer.querySelectorAll('.breadcrumb-item');
                            if (breadcrumbItems.length >= 3) {
                                const breadcrumbText = breadcrumbItems[2].textContent;
                                if (breadcrumbText.includes('大乐透')) {
                                    displayLotteryType = 'dlt';
                                }
                            }
                        }
                    }

                    // 保存当前彩票类型的页码状态
                    pageStates[displayLotteryType] = currentPage;

                    dataManager.updateDatabaseTable();
                    MessageSystem.showMessage(`每页显示${newPageSize}条数据`, 'success');
                }
            }

            static copyToClipboard(text) {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => {
                        MessageSystem.showMessage('号码已复制到剪贴板', 'success');
                    }).catch(err => {
                        MessageSystem.showMessage('复制失败: ' + err.message, 'error');
                    });
                } else {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        MessageSystem.showMessage('号码已复制到剪贴板', 'success');
                    } catch (err) {
                        MessageSystem.showMessage('复制失败: ' + err.message, 'error');
                    }
                    document.body.removeChild(textArea);
                }
            }
        }

        // 主题管理器
        class ThemeManager {
            static init() {
                // 为所有主题选项添加点击事件
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        const parent = e.target.parentElement;

                        // 根据父元素的类名判断是主题还是存储方式
                        if (parent.classList.contains('theme-options')) {
                            if (e.target.hasAttribute('data-storage')) {
                                // 存储方式选项
                                parent.querySelectorAll('.theme-option[data-storage]').forEach(opt => {
                                    opt.classList.remove('active');
                                });
                                e.target.classList.add('active');
                            } else if (e.target.hasAttribute('data-theme')) {
                                // 主题选项
                                parent.querySelectorAll('.theme-option[data-theme]').forEach(opt => {
                                    opt.classList.remove('active');
                                });
                                e.target.classList.add('active');

                                // 应用主题
                                this.applyTheme(e.target.getAttribute('data-theme'));
                            }
                        }
                    });
                });
            }

            static applyTheme(themeName) {
                const root = document.documentElement;

                // 移除所有现有的主题类
                root.className = root.className.replace(/\btheme-\w+\b/g, '');

                // 根据主题名称应用相应的CSS类
                switch(themeName) {
                    case 'ssq':
                        // 双色球主题 - 默认主题，无需额外类
                        root.style.setProperty('--primary-color', 'var(--ssq-primary)');
                        root.style.setProperty('--secondary-color', 'var(--ssq-secondary)');
                        root.style.setProperty('--bg-color', 'var(--ssq-bg)');
                        root.style.setProperty('--text-primary', 'var(--ssq-text)');
                        root.style.setProperty('--text-secondary', 'var(--ssq-secondary-text)');
                        root.style.setProperty('--border-color', 'var(--ssq-border)');
                        root.style.setProperty('--highlight-color', 'var(--ssq-highlight)');
                        break;
                    case 'dlt':
                        root.style.setProperty('--primary-color', 'var(--dlt-primary)');
                        root.style.setProperty('--secondary-color', 'var(--dlt-secondary)');
                        root.style.setProperty('--bg-color', 'var(--dlt-bg)');
                        root.style.setProperty('--text-primary', 'var(--dlt-text)');
                        root.style.setProperty('--text-secondary', 'var(--dlt-secondary-text)');
                        root.style.setProperty('--border-color', 'var(--dlt-border)');
                        root.style.setProperty('--highlight-color', 'var(--dlt-highlight)');
                        break;
                    case 'viz-light':
                        root.classList.add('theme-viz-light');
                        break;
                    case 'viz-dark':
                        root.classList.add('theme-viz-dark');
                        break;
                    case 'business':
                        root.classList.add('theme-business');
                        break;
                    case 'tech':
                        root.classList.add('theme-tech');
                        break;
                    case 'accessible':
                        root.classList.add('theme-accessible');
                        break;
                    case 'dark-comfort':
                        root.classList.add('theme-dark-comfort');
                        break;
                    default:
                        // 默认使用双色球主题
                        root.style.setProperty('--primary-color', 'var(--ssq-primary)');
                        root.style.setProperty('--secondary-color', 'var(--ssq-secondary)');
                        root.style.setProperty('--bg-color', 'var(--ssq-bg)');
                        root.style.setProperty('--text-primary', 'var(--ssq-text)');
                        root.style.setProperty('--text-secondary', 'var(--ssq-secondary-text)');
                        root.style.setProperty('--border-color', 'var(--ssq-border)');
                        root.style.setProperty('--highlight-color', 'var(--ssq-highlight)');
                        break;
                }

                MessageSystem.showMessage(`主题已切换为${this.getThemeDisplayName(themeName)}`, 'success');
            }

            static getThemeDisplayName(themeName) {
                const themeNames = {
                    'ssq': '双色球主题',
                    'dlt': '大乐透主题',
                    'viz-light': '数据可视化-光明模式',
                    'viz-dark': '数据可视化-暗黑模式',
                    'business': '简约商务主题',
                    'tech': '现代科技主题',
                    'accessible': '无障碍友好主题',
                    'dark-comfort': '暗黑护眼主题'
                };
                return themeNames[themeName] || '默认主题';
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async function() {
            // 确保ECharts库加载后再初始化图表
            const waitForECharts = () => {
                return new Promise((resolve) => {
                    if (typeof echarts !== 'undefined') {
                        resolve();
                    } else {
                        let attempts = 0;
                        const maxAttempts = 20; // 最多等待2秒 (20 * 100ms)
                        const checkECharts = () => {
                            if (typeof echarts !== 'undefined') {
                                resolve();
                            } else if (attempts < maxAttempts) {
                                attempts++;
                                setTimeout(checkECharts, 100);
                            } else {
                                console.error('ECharts库加载超时');
                                resolve(); // 即使超时也继续执行，但图表可能无法正常显示
                            }
                        };
                        checkECharts();
                    }
                });
            };

            await waitForECharts();

            // 初始化时隐藏分析卡片，只显示欢迎卡片
            const analysisCards = ['frequencyCard', 'omissionCard', 'numberDistributionCard'];
            analysisCards.forEach(cardId => {
                const card = document.getElementById(cardId);
                if (card) {
                    card.style.display = 'none';
                }
            });

            // 确保双色球选项卡默认选中
            const ssqTab = document.getElementById('ssqBtn');
            const dltTab = document.getElementById('dltBtn');
            if (ssqTab && dltTab) {
                ssqTab.classList.add('active');
                dltTab.classList.remove('active');
            }

            // 初始化图表
            await dataManager.switchLotteryType('ssq'); // 默认加载双色球数据

            // 初始化条件选号选项
            dataManager.updateConditionOptions('ssq');

            // 初始化事件委托
            EventDelegate.init();

            // 初始化选号系统
            EventDelegate.initSelectionSystem();

            // 初始化DNA查询功能
            EventDelegate.initDNAQuery();

            // 初始化主题管理
            ThemeManager.init();

            // 初始化后调整图表大小，确保图表正确显示
            setTimeout(() => {
                if (typeof echarts !== 'undefined') {
                    const allCharts = [
                        'frequencyChart', 'distributionChart', 'trendChart', 
                        'radarChart', 'scatterChart', 'heatmapChart',
                        'omissionChart', 'numberDistributionChart'
                    ];
                    allCharts.forEach(chartId => {
                        const chartDom = document.getElementById(chartId);
                        if (chartDom) {
                            const chartInstance = echarts.getInstanceByDom(chartDom);
                            if (chartInstance) {
                                chartInstance.resize();
                            }
                        }
                    });
                }
            }, 200);

            // 为文件输入元素添加change事件监听器
            const fileInput = document.getElementById('excelFileInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    EventDelegate.handleFileInput(this);
                });
            }

            // 为频率分析按钮添加事件监听器
            const analyzeBtn = document.getElementById('analyzeBtn');
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', EventDelegate.handleFrequencyAnalysis);
            }

            // 为趋势分析按钮添加事件监听器
            const analyzeTrendBtn = document.getElementById('analyzeTrendBtn');
            if (analyzeTrendBtn) {
                analyzeTrendBtn.addEventListener('click', EventDelegate.handleTrendAnalysis);
            }

            // 为趋势分析期数选择添加事件监听器
            const trendPeriodSelect = document.getElementById('trendPeriodSelect');
            if (trendPeriodSelect) {
                trendPeriodSelect.addEventListener('change', EventDelegate.handleTrendAnalysis);
            }

            // 为频率分析标签页切换添加事件监听器
            const frequencyTabs = document.querySelectorAll('.frequency-tab');
            frequencyTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    frequencyTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    const type = this.dataset.type;
                    currentFrequencyTab = type;
                    if (globalRedBallFrequency && globalBlueBallFrequency) {
                        const sortOption = document.getElementById('sortOption')?.value || 'number';
                        const sortOrder = document.getElementById('sortOrder')?.value || 'asc';
                        EventDelegate.updateFrequencyChart(globalRedBallFrequency, globalBlueBallFrequency, sortOption, sortOrder);
                        EventDelegate.updateFrequencyTable(globalRedBallFrequency, globalBlueBallFrequency);
                    }
                });
            });

            // 为频率分析排序按钮添加事件监听器
            const sortButtons = document.querySelectorAll('.sort-btn');
            sortButtons.forEach(btn => {
                btn.addEventListener('click', function(e) {
                    sortButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const sortType = this.dataset.sort;
                    currentFrequencySort = sortType;
                    
                    // 同步到下拉选择框
                    const sortOptionSelect = document.getElementById('sortOption');
                    const sortOrderSelect = document.getElementById('sortOrder');
                    
                    if (sortType === 'number') {
                        if (sortOptionSelect) sortOptionSelect.value = 'number';
                    } else if (sortType === 'desc') {
                        if (sortOptionSelect) sortOptionSelect.value = 'count';
                        if (sortOrderSelect) sortOrderSelect.value = 'desc';
                    } else if (sortType === 'asc') {
                        if (sortOptionSelect) sortOptionSelect.value = 'count';
                        if (sortOrderSelect) sortOrderSelect.value = 'asc';
                    }
                    
                    if (globalRedBallFrequency && globalBlueBallFrequency) {
                        const sortOption = document.getElementById('sortOption')?.value || 'number';
                        const sortOrder = document.getElementById('sortOrder')?.value || 'asc';
                        EventDelegate.updateFrequencyChart(globalRedBallFrequency, globalBlueBallFrequency, sortOption, sortOrder);
                        EventDelegate.updateFrequencyTable(globalRedBallFrequency, globalBlueBallFrequency);
                    }
                });
            });

            // 为运行预测按钮添加事件监听器
            const runPredictionBtn = document.getElementById('runPredictionBtn');
            if (runPredictionBtn) {
                runPredictionBtn.addEventListener('click', EventDelegate.handlePrediction);
            }

            // 为标签页切换添加事件监听器
            const tabButtons = document.querySelectorAll('.tab-btn');
            tabButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    tabButtons.forEach(b => {
                        b.classList.remove('active');
                        b.style.color = 'var(--text-secondary)';
                        b.style.borderBottom = 'none';
                    });
                    e.target.classList.add('active');
                    const tab = e.target.dataset.tab;
                    e.target.style.color = tab === 'red' ? '#E63946' : '#457B9D';
                    e.target.style.borderBottom = `3px solid ${tab === 'red' ? '#E63946' : '#457B9D'}`;
                    e.target.style.fontWeight = 'bold';

                    if (globalRedBallFrequency && globalBlueBallFrequency) {
                        EventDelegate.updateFrequencyTable(globalRedBallFrequency, globalBlueBallFrequency);
                    }
                });
            });

            // 为排序选项添加事件监听器
            const sortOption = document.getElementById('sortOption');
            const sortOrder = document.getElementById('sortOrder');
            if (sortOption && sortOrder) {
                sortOption.addEventListener('change', () => {
                    if (globalRedBallFrequency && globalBlueBallFrequency) {
                        EventDelegate.updateFrequencyTable(globalRedBallFrequency, globalBlueBallFrequency);
                    }
                });
                sortOrder.addEventListener('change', () => {
                    if (globalRedBallFrequency && globalBlueBallFrequency) {
                        EventDelegate.updateFrequencyTable(globalRedBallFrequency, globalBlueBallFrequency);
                    }
                });
            }

            // 为遗漏分析标签页切换添加事件监听器
            const omissionTabs = document.querySelectorAll('.omission-tab');
            omissionTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    omissionTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    currentOmissionTab = e.target.dataset.type;
                    EventDelegate.updateOmissionChart();
                    EventDelegate.updateOmissionTable();
                    EventDelegate.generateOmissionPrediction();
                });
            });

            // 为遗漏分析图表标签页切换添加事件监听器
            const patternChartTabs = document.querySelectorAll('.pattern-tab-btn');
            patternChartTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    patternChartTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    currentPatternChartType = e.target.dataset.type;
                    EventDelegate.generatePatternAnalysis();
                });
            });

            // 为遗漏分析科学规律分析标签页切换添加事件监听器
            const omissionPatternTabs = document.querySelectorAll('.omission-pattern-tab-btn');
            omissionPatternTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    omissionPatternTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    currentPatternChartType = e.target.dataset.type;
                    EventDelegate.generatePatternAnalysis();
                });
            });

            // 为遗漏分析排序按钮添加事件监听器
            const omissionSortButtons = document.querySelectorAll('#omissionCard .sort-btn');
            omissionSortButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    omissionSortButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const sortType = this.dataset.sort;
                    currentOmissionSort = sortType;
                    EventDelegate.updateOmissionChart();
                    EventDelegate.updateOmissionTable();
                });
            });

            // 为遗漏分析期数选择器添加事件监听器
            const omissionPeriodSelect = document.getElementById('omissionPeriodSelect');
            if (omissionPeriodSelect) {
                // 初始化时同步 currentOmissionPeriod 的值与下拉菜单的默认选中值
                currentOmissionPeriod = omissionPeriodSelect.value === 'all' ? 'all' : parseInt(omissionPeriodSelect.value);
                
                omissionPeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentOmissionPeriod = value === 'all' ? 'all' : parseInt(value);
                    EventDelegate.performOmissionAnalysis();
                });
            }

            // 为遗漏分析开始按钮添加事件监听器
            const startOmissionAnalysisBtn = document.getElementById('startOmissionAnalysis');
            if (startOmissionAnalysisBtn) {
                startOmissionAnalysisBtn.addEventListener('click', () => {
                    EventDelegate.performOmissionAnalysis();
                });
            }

            // 为冷热分析期数选择器添加事件监听器
            const hotColdPeriodSelect = document.getElementById('hotColdPeriodSelect');
            if (hotColdPeriodSelect) {
                hotColdPeriodSelect.addEventListener('change', (e) => {
                    const activeTab = document.querySelector('.hotcold-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'single';
                    EventDelegate.performHotColdAnalysisByTab(tabType);
                });
            }

            // 为冷热分析开始按钮添加事件监听器
            const startHotColdAnalysisBtn = document.getElementById('startHotColdAnalysis');
            if (startHotColdAnalysisBtn) {
                startHotColdAnalysisBtn.addEventListener('click', () => {
                    const activeTab = document.querySelector('.hotcold-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'single';
                    EventDelegate.performHotColdAnalysisByTab(tabType);
                });
            }

            // 为奇偶分析标签页切换添加事件监听器
            const oddEvenTabs = document.querySelectorAll('.odd-even-tab');
            oddEvenTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    oddEvenTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    const tabType = this.dataset.tab;
                    EventDelegate.handleOddEvenTab(tabType);
                });
            });

            // 为奇偶分析刷新按钮添加事件监听器
            // 为奇偶分析开始按钮添加事件监听器
            const startOddEvenAnalysisBtn = document.getElementById('startOddEvenAnalysis');
            if (startOddEvenAnalysisBtn) {
                startOddEvenAnalysisBtn.addEventListener('click', () => {
                    const activeTab = document.querySelector('.odd-even-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'single';
                    EventDelegate.performOddEvenAnalysisByTab(tabType);
                });
            }

            // 为奇偶分析刷新按钮添加事件监听器
            const refreshOddEvenAnalysis = document.getElementById('refreshOddEvenAnalysis');
            if (refreshOddEvenAnalysis) {
                refreshOddEvenAnalysis.addEventListener('click', function() {
                    const activeTab = document.querySelector('.odd-even-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'single';
                    EventDelegate.performOddEvenAnalysisByTab(tabType);
                });
            }

            // 为奇偶分析期数选择器添加事件监听器
            const oddEvenPeriodSelect = document.getElementById('oddEvenPeriodSelect');
            if (oddEvenPeriodSelect) {
                oddEvenPeriodSelect.addEventListener('change', (e) => {
                    const activeTab = document.querySelector('.odd-even-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'single';
                    EventDelegate.performOddEvenAnalysisByTab(tabType);
                });
            }

            // 为大小分析标签页切换添加事件监听器
            const bigSmallTabs = document.querySelectorAll('.big-small-tab');
            bigSmallTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    const tabType = this.dataset.tab;
                    EventDelegate.handleBigSmallTab(tabType);
                });
            });

            // 为大小分析开始按钮添加事件监听器
            const startBigSmallAnalysisBtn = document.getElementById('startBigSmallAnalysis');
            if (startBigSmallAnalysisBtn) {
                startBigSmallAnalysisBtn.addEventListener('click', () => {
                    const activeTab = document.querySelector('.big-small-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'overview';
                    EventDelegate.performBigSmallAnalysisByTab(tabType);
                });
            }

            // 为大小分析期数选择器添加事件监听器
            const bigSmallPeriodSelect = document.getElementById('bigSmallPeriodSelect');
            if (bigSmallPeriodSelect) {
                bigSmallPeriodSelect.addEventListener('change', (e) => {
                    const activeTab = document.querySelector('.big-small-tab.active');
                    const tabType = activeTab ? activeTab.getAttribute('data-tab') : 'overview';
                    EventDelegate.performBigSmallAnalysisByTab(tabType);
                });
            }

            // 为质合分析开始按钮添加事件监听器
            const startPrimeCompositeAnalysisBtn = document.getElementById('startPrimeCompositeAnalysisV1');
            if (startPrimeCompositeAnalysisBtn) {
                startPrimeCompositeAnalysisBtn.addEventListener('click', () => {
                    EventDelegate.performPrimeCompositeAnalysisByPeriod();
                });
            }

            // 为质合分析期数选择器添加事件监听器
            const primeCompositePeriodSelect = document.getElementById('primeCompositePeriodSelectV1');
            if (primeCompositePeriodSelect) {
                primeCompositePeriodSelect.addEventListener('change', (e) => {
                    EventDelegate.performPrimeCompositeAnalysisByPeriod();
                });
            }

            // 为质合分析标签页切换添加事件监听器
            const primeCompositeTabs = document.querySelectorAll('.prime-composite-tab');
            const primeCompositeContents = document.querySelectorAll('.prime-composite-tab-content');
            primeCompositeTabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    primeCompositeTabs.forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');

                    const tabType = e.target.dataset.tab;
                    primeCompositeContents.forEach(content => content.classList.remove('active'));
                    const targetContent = document.getElementById(`prime-composite-${tabType}`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }

                    setTimeout(() => {
                        EventDelegate.performPrimeCompositeAnalysisByTab(tabType);
                    }, 100);
                });
            });

            // 为AC值分析开始按钮添加事件监听器
            const startAcValueAnalysisBtn = document.getElementById('startAcValueAnalysis');
            if (startAcValueAnalysisBtn) {
                startAcValueAnalysisBtn.addEventListener('click', () => {
                    const draws = currentDatabaseData.draws || [];
                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }
                    EventDelegate.performAcValueAnalysis(draws);
                });
            }

            // 为AC值分析导出数据按钮添加事件监听器
            const exportAcValueDataBtn = document.getElementById('exportAcValueData');
            if (exportAcValueDataBtn) {
                exportAcValueDataBtn.addEventListener('click', () => {
                    EventDelegate.exportAcValueData();
                });
            }

            // 为AC值分析图表类型切换标签添加事件监听器
            const acValueChartTabs = document.querySelectorAll('#acValueChartTabs .chart-tab-btn');
            acValueChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    acValueChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentAcValueChartType = this.dataset.type;
                    if (acValueChartData) {
                        EventDelegate.updateAcValueChart(acValueChartData);
                    }
                });
            });

            // 为AC值分析生成推荐按钮添加事件监听器
            const generateAcValueRecommendationBtn = document.getElementById('generateAcValueRecommendation');
            if (generateAcValueRecommendationBtn) {
                generateAcValueRecommendationBtn.addEventListener('click', () => {
                    EventDelegate.generateAcValueRecommendation();
                });
            }

            // 为AC值分析期数选择器添加事件监听器
            const acValuePeriodSelect = document.getElementById('acValuePeriodSelect');
            if (acValuePeriodSelect) {
                acValuePeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentAcValuePeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为大中小分析开始按钮添加事件监听器
            const startThreeZoneAnalysisBtn = document.getElementById('startThreeZoneAnalysis');
            if (startThreeZoneAnalysisBtn) {
                startThreeZoneAnalysisBtn.addEventListener('click', () => {
                    const draws = currentDatabaseData.draws || [];
                    if (draws.length === 0) {
                        MessageSystem.showMessage('没有可分析的数据，请先导入数据', 'error');
                        return;
                    }
                    EventDelegate.performThreeZoneAnalysis(draws);
                });
            }

            // 为大中小分析期数选择器添加事件监听器
            const threeZonePeriodSelect = document.getElementById('threeZonePeriodSelect');
            if (threeZonePeriodSelect) {
                threeZonePeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentThreeZonePeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为大中小分析图表类型切换标签添加事件监听器
            const threeZoneChartTabs = document.querySelectorAll('#threeZoneChartTabs .chart-tab');
            threeZoneChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    threeZoneChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentThreeZoneChartType = this.dataset.chartType;
                    if (threeZoneChartData) {
                        EventDelegate.updateThreeZoneChart(threeZoneChartData);
                    }
                });
            });

            // 为大中小分析生成推荐按钮添加事件监听器
            const generateThreeZoneRecommendationBtn = document.getElementById('generateThreeZoneRecommendation');
            if (generateThreeZoneRecommendationBtn) {
                generateThreeZoneRecommendationBtn.addEventListener('click', () => {
                    EventDelegate.handleGenerateThreeZoneRecommendation();
                });
            }

            // 为跟随分析开始按钮添加事件监听器
            const startFollowUpAnalysisBtn = document.getElementById('startFollowUpAnalysis');
            if (startFollowUpAnalysisBtn) {
                startFollowUpAnalysisBtn.addEventListener('click', () => {
                    EventDelegate.performFollowUpAnalysis();
                });
            }

            // 为跟随分析期数选择器添加事件监听器
            const followUpPeriodSelect = document.getElementById('followUpPeriodSelect');
            if (followUpPeriodSelect) {
                followUpPeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentFollowUpPeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为跟随分析图表类型切换标签添加事件监听器
            const followUpChartTabs = document.querySelectorAll('#followUpChartTabs .chart-tab');
            followUpChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    followUpChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentFollowUpChartType = this.dataset.chartType;
                    if (followUpChartData) {
                        EventDelegate.updateFollowUpChart(followUpChartData);
                    }
                });
            });

            // 为启用图表联动按钮添加事件监听器
            const enableChartLinkageBtn = document.getElementById('enableChartLinkage');
            if (enableChartLinkageBtn) {
                enableChartLinkageBtn.addEventListener('click', () => {
                    EventDelegate.setupChartLinkage();
                });
            }

            // 为生成联动报告按钮添加事件监听器
            const generateLinkageReportBtn = document.getElementById('generateLinkageReport');
            if (generateLinkageReportBtn) {
                generateLinkageReportBtn.addEventListener('click', () => {
                    EventDelegate.generateLinkageReport();
                });
            }

            // 为相关性分析开始按钮添加事件监听器
            const startCorrelationAnalysisBtn = document.getElementById('startCorrelationAnalysis');
            if (startCorrelationAnalysisBtn) {
                startCorrelationAnalysisBtn.addEventListener('click', () => {
                    EventDelegate.performCorrelationAnalysis();
                });
            }

            // 为相关性分析导出报告按钮添加事件监听器
            const exportCorrelationReportBtn = document.getElementById('exportCorrelationReport');
            if (exportCorrelationReportBtn) {
                exportCorrelationReportBtn.addEventListener('click', () => {
                    EventDelegate.exportCorrelationReport();
                });
            }

            // 为相关性分析生成推荐按钮添加事件监听器
            const generateCorrelationRecommendationBtn = document.getElementById('generateCorrelationRecommendation');
            if (generateCorrelationRecommendationBtn) {
                generateCorrelationRecommendationBtn.addEventListener('click', () => {
                    EventDelegate.generateCorrelationRecommendation();
                });
            }

            // 为相关性分析期数选择器添加事件监听器
            const correlationPeriodSelect = document.getElementById('correlationPeriodSelect');
            if (correlationPeriodSelect) {
                correlationPeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentCorrelationPeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为相关性分析图表类型切换标签添加事件监听器
            const correlationChartTabs = document.querySelectorAll('#correlationChartTabs .chart-tab');
            correlationChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    correlationChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentCorrelationChartType = this.dataset.chartType;
                    if (correlationAnalysisData) {
                        EventDelegate.updateCorrelationChart(correlationAnalysisData);
                    }
                });
            });

            // 为统计分析开始按钮添加事件监听器
            const startStatisticsAnalysisBtn = document.getElementById('startStatisticsAnalysis');
            if (startStatisticsAnalysisBtn) {
                startStatisticsAnalysisBtn.addEventListener('click', () => {
                    EventDelegate.performStatisticsAnalysis();
                });
            }

            // 为统计分析导出报告按钮添加事件监听器
            const exportStatisticsReportBtn = document.getElementById('exportStatisticsReport');
            if (exportStatisticsReportBtn) {
                exportStatisticsReportBtn.addEventListener('click', () => {
                    EventDelegate.exportStatisticsReport();
                });
            }

            // 为统计分析生成结果按钮添加事件监听器
            const generateStatisticsResultsBtn = document.getElementById('generateStatisticsResults');
            if (generateStatisticsResultsBtn) {
                generateStatisticsResultsBtn.addEventListener('click', () => {
                    EventDelegate.generateStatisticsResults();
                });
            }

            // 为统计分析期数选择器添加事件监听器
            const statisticsPeriodSelect = document.getElementById('statisticsPeriodSelect');
            if (statisticsPeriodSelect) {
                statisticsPeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentStatisticalPeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为统计分析图表类型切换标签添加事件监听器
            const statisticsChartTabs = document.querySelectorAll('#statisticsChartTabs .chart-tab');
            statisticsChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    statisticsChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentStatisticalChartType = this.dataset.chartType;
                    if (statisticalAnalysisData) {
                        EventDelegate.updateStatisticsChart(statisticalAnalysisData);
                    }
                });
            });

            // 为模式识别开始分析按钮添加事件监听器
            const startPatternRecognitionBtn = document.getElementById('startPatternRecognition');
            if (startPatternRecognitionBtn) {
                startPatternRecognitionBtn.addEventListener('click', () => {
                    EventDelegate.performPatternRecognition();
                });
            }

            // 为模式识别导出报告按钮添加事件监听器
            const exportPatternReportBtn = document.getElementById('exportPatternReport');
            if (exportPatternReportBtn) {
                exportPatternReportBtn.addEventListener('click', () => {
                    EventDelegate.exportPatternReport();
                });
            }

            // 为模式识别生成结果按钮添加事件监听器
            const generatePatternRecognitionResultsBtn = document.getElementById('generatePatternRecognitionResults');
            if (generatePatternRecognitionResultsBtn) {
                generatePatternRecognitionResultsBtn.addEventListener('click', () => {
                    EventDelegate.generatePatternRecognitionResults();
                });
            }

            // 为模式识别期数选择器添加事件监听器
            const patternRecognitionPeriodSelect = document.getElementById('patternRecognitionPeriodSelect');
            if (patternRecognitionPeriodSelect) {
                patternRecognitionPeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentPatternRecognitionPeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为模式识别图表类型切换标签添加事件监听器
            const patternRecognitionChartTabs = document.querySelectorAll('#patternRecognitionChartTabs .chart-tab');
            patternRecognitionChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    patternRecognitionChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentPatternRecognitionChartType = this.dataset.chartType;
                    if (patternRecognitionData) {
                        EventDelegate.updatePatternRecognitionChart(patternRecognitionData);
                    }
                });
            });

            // 为DNA分析开始按钮添加事件监听器
            const startDNAAnalysisBtn = document.getElementById('startDNAAnalysis');
            if (startDNAAnalysisBtn) {
                startDNAAnalysisBtn.addEventListener('click', () => {
                    EventDelegate.performDNAAnalysis();
                });
            }

            // 为DNA分析导出报告按钮添加事件监听器
            const exportDNAReportBtn = document.getElementById('exportDNAReport');
            if (exportDNAReportBtn) {
                exportDNAReportBtn.addEventListener('click', () => {
                    EventDelegate.exportDNAReport();
                });
            }

            // 为DNA分析期数选择器添加事件监听器
            const dnaAnalysisPeriodSelect = document.getElementById('dnaAnalysisPeriodSelect');
            if (dnaAnalysisPeriodSelect) {
                dnaAnalysisPeriodSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    currentDNAAnalysisPeriod = value === 'all' ? 'all' : parseInt(value);
                });
            }

            // 为DNA分析图表类型切换标签添加事件监听器
            const dnaAnalysisChartTabs = document.querySelectorAll('#dnaAnalysisChartTabs .chart-tab');
            dnaAnalysisChartTabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    dnaAnalysisChartTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    currentDNAAnalysisChartType = this.dataset.chartType;
                    if (dnaAnalysisData) {
                        EventDelegate.updateDNAAnalysisChart(dnaAnalysisData);
                    }
                });
            });

            // 为DNA分析生成结果按钮添加事件监听器
            const generateDNAAnalysisResultsBtn = document.getElementById('generateDNAAnalysisResults');
            if (generateDNAAnalysisResultsBtn) {
                generateDNAAnalysisResultsBtn.addEventListener('click', () => {
                    EventDelegate.generateDNAAnalysisResults();
                });
            }

            // 初始化页面显示：只显示首页内容，隐藏所有其他内容卡片
            const allCards = document.querySelectorAll('.content-card');
            allCards.forEach(card => {
                if (card.id === 'welcomeCard') {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });

            // 测试数据校验功能
            dataManager.testValidation();

            // 显示欢迎消息
            MessageSystem.showMessage('智能彩票分析选号系统已启动', 'success');
        });
    </script>
</body>
</html>